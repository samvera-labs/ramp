import QA, { createContext as to, useReducer as TT, useContext as pt, useState as $e, useMemo as Je, Component as ZA, isValidElement as JA, createElement as Yu, useEffect as et, useRef as He, useCallback as $t, createRef as Zn, Fragment as Qu, memo as jm } from "react";
var At = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function Qt(n) {
  return n && n.__esModule && Object.prototype.hasOwnProperty.call(n, "default") ? n.default : n;
}
function kc(n) {
  if (Object.prototype.hasOwnProperty.call(n, "__esModule")) return n;
  var e = n.default;
  if (typeof e == "function") {
    var t = function i() {
      var r = !1;
      try {
        r = this instanceof i;
      } catch {
      }
      return r ? Reflect.construct(e, arguments, this.constructor) : e.apply(this, arguments);
    };
    t.prototype = e.prototype;
  } else t = {};
  return Object.defineProperty(t, "__esModule", { value: !0 }), Object.keys(n).forEach(function(i) {
    var r = Object.getOwnPropertyDescriptor(n, i);
    Object.defineProperty(t, i, r.get ? r : {
      enumerable: !0,
      get: function() {
        return n[i];
      }
    });
  }), t;
}
var Hl = { exports: {} }, rs = {};
/**
 * @license React
 * react-jsx-runtime.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var xb;
function e8() {
  if (xb) return rs;
  xb = 1;
  var n = Symbol.for("react.transitional.element"), e = Symbol.for("react.fragment");
  function t(i, r, a) {
    var s = null;
    if (a !== void 0 && (s = "" + a), r.key !== void 0 && (s = "" + r.key), "key" in r) {
      a = {};
      for (var o in r)
        o !== "key" && (a[o] = r[o]);
    } else a = r;
    return r = a.ref, {
      $$typeof: n,
      type: i,
      key: s,
      ref: r !== void 0 ? r : null,
      props: a
    };
  }
  return rs.Fragment = e, rs.jsx = t, rs.jsxs = t, rs;
}
var _b;
function t8() {
  return _b || (_b = 1, Hl.exports = e8()), Hl.exports;
}
var se = t8(), zl = { exports: {} }, $l = {};
/**
 * @license React
 * react-compiler-runtime.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var Tb;
function n8() {
  if (Tb) return $l;
  Tb = 1;
  var n = QA.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE;
  return $l.c = function(e) {
    return n.H.useMemoCache(e);
  }, $l;
}
var wb;
function i8() {
  return wb || (wb = 1, zl.exports = n8()), zl.exports;
}
var Et = i8(), wT = (
  /** @class */
  (function() {
    function n(e) {
      this.__jsonld = e, this.context = this.getProperty("context"), this.id = this.getProperty("id");
    }
    return n.prototype.getProperty = function(e) {
      var t = null;
      return this.__jsonld && (t = this.__jsonld[e], t || (t = this.__jsonld["@" + e])), t;
    }, n;
  })()
), Gl = {}, Eb;
function r8() {
  return Eb || (Eb = 1, (function(n) {
    Object.defineProperty(n, "__esModule", { value: !0 }), (function(e) {
      e.BOOKMARKING = "oa:bookmarking", e.CLASSIFYING = "oa:classifying", e.COMMENTING = "oa:commenting", e.DESCRIBING = "oa:describing", e.EDITING = "oa:editing", e.HIGHLIGHTING = "oa:highlighting", e.IDENTIFYING = "oa:identifying", e.LINKING = "oa:linking", e.MODERATING = "oa:moderating", e.PAINTING = "sc:painting", e.QUESTIONING = "oa:questioning", e.REPLYING = "oa:replying", e.TAGGING = "oa:tagging", e.TRANSCRIBING = "oad:transcribing";
    })(n.AnnotationMotivation || (n.AnnotationMotivation = {})), (function(e) {
      e.AUTO_ADVANCE = "auto-advance", e.CONTINUOUS = "continuous", e.FACING_PAGES = "facing-pages", e.HIDDEN = "hidden", e.INDIVIDUALS = "individuals", e.MULTI_PART = "multi-part", e.NO_NAV = "no-nav", e.NON_PAGED = "non-paged", e.PAGED = "paged", e.REPEAT = "repeat", e.SEQUENCE = "sequence", e.THUMBNAIL_NAV = "thumbnail-nav", e.TOGETHER = "together", e.UNORDERED = "unordered";
    })(n.Behavior || (n.Behavior = {})), (function(e) {
      e.CANVAS = "canvas", e.CHOICE = "choice", e.OA_CHOICE = "oa:choice", e.CONTENT_AS_TEXT = "contentastext", e.DATASET = "dataset", e.DOCUMENT = "document", e.IMAGE = "image", e.MODEL = "model", e.MOVING_IMAGE = "movingimage", e.PDF = "pdf", e.PHYSICAL_OBJECT = "physicalobject", e.SOUND = "sound", e.TEXT = "text", e.TEXTUALBODY = "textualbody", e.VIDEO = "video";
    })(n.ExternalResourceType || (n.ExternalResourceType = {})), (function(e) {
      e.ANNOTATION = "annotation", e.CANVAS = "canvas", e.COLLECTION = "collection", e.MANIFEST = "manifest", e.RANGE = "range", e.SEQUENCE = "sequence";
    })(n.IIIFResourceType || (n.IIIFResourceType = {})), (function(e) {
      e.AUDIO_MP4 = "audio/mp4", e.CORTO = "application/corto", e.DICOM = "application/dicom", e.DRACO = "application/draco", e.EPUB = "application/epub+zip", e.GIRDER = "image/vnd.kitware.girder", e.GLB = "model/gltf-binary", e.GLTF = "model/gltf+json", e.IIIF_PRESENTATION_2 = 'application/ld+json;profile="http://iiif.io/api/presentation/2/context.json"', e.IIIF_PRESENTATION_3 = 'application/ld+json;profile="http://iiif.io/api/presentation/3/context.json"', e.JPG = "image/jpeg", e.M3U8 = "application/vnd.apple.mpegurl", e.MP3 = "audio/mp3", e.MPEG_DASH = "application/dash+xml", e.OBJ = "text/plain", e.OPF = "application/oebps-package+xml", e.PDF = "application/pdf", e.PLY = "application/ply", e.THREEJS = "application/vnd.threejs+json", e.USDZ = "model/vnd.usd+zip", e.VIDEO_MP4 = "video/mp4", e.WAV = "audio/wav", e.WEBM = "video/webm";
    })(n.MediaType || (n.MediaType = {})), (function(e) {
      e.DOC = "application/msword", e.DOCX = "application/vnd.openxmlformats-officedocument.wordprocessingml.document", e.PDF = "application/pdf";
    })(n.RenderingFormat || (n.RenderingFormat = {})), (function(e) {
      e.IMAGE_0_COMPLIANCE_LEVEL_0 = "http://library.stanford.edu/iiif/image-api/compliance.html#level0", e.IMAGE_0_COMPLIANCE_LEVEL_1 = "http://library.stanford.edu/iiif/image-api/compliance.html#level1", e.IMAGE_0_COMPLIANCE_LEVEL_2 = "http://library.stanford.edu/iiif/image-api/compliance.html#level2", e.IMAGE_0_CONFORMANCE_LEVEL_0 = "http://library.stanford.edu/iiif/image-api/conformance.html#level0", e.IMAGE_0_CONFORMANCE_LEVEL_1 = "http://library.stanford.edu/iiif/image-api/conformance.html#level1", e.IMAGE_0_CONFORMANCE_LEVEL_2 = "http://library.stanford.edu/iiif/image-api/conformance.html#level2", e.IMAGE_1_COMPLIANCE_LEVEL_0 = "http://library.stanford.edu/iiif/image-api/1.1/compliance.html#level0", e.IMAGE_1_COMPLIANCE_LEVEL_1 = "http://library.stanford.edu/iiif/image-api/1.1/compliance.html#level1", e.IMAGE_1_COMPLIANCE_LEVEL_2 = "http://library.stanford.edu/iiif/image-api/1.1/compliance.html#level2", e.IMAGE_1_CONFORMANCE_LEVEL_0 = "http://library.stanford.edu/iiif/image-api/1.1/conformance.html#level0", e.IMAGE_1_CONFORMANCE_LEVEL_1 = "http://library.stanford.edu/iiif/image-api/1.1/conformance.html#level1", e.IMAGE_1_CONFORMANCE_LEVEL_2 = "http://library.stanford.edu/iiif/image-api/1.1/conformance.html#level2", e.IMAGE_1_LEVEL_0 = "http://iiif.io/api/image/1/level0.json", e.IMAGE_1_PROFILE_LEVEL_0 = "http://iiif.io/api/image/1/profiles/level0.json", e.IMAGE_1_LEVEL_1 = "http://iiif.io/api/image/1/level1.json", e.IMAGE_1_PROFILE_LEVEL_1 = "http://iiif.io/api/image/1/profiles/level1.json", e.IMAGE_1_LEVEL_2 = "http://iiif.io/api/image/1/level2.json", e.IMAGE_1_PROFILE_LEVEL_2 = "http://iiif.io/api/image/1/profiles/level2.json", e.IMAGE_2_LEVEL_0 = "http://iiif.io/api/image/2/level0.json", e.IMAGE_2_PROFILE_LEVEL_0 = "http://iiif.io/api/image/2/profiles/level0.json", e.IMAGE_2_LEVEL_1 = "http://iiif.io/api/image/2/level1.json", e.IMAGE_2_PROFILE_LEVEL_1 = "http://iiif.io/api/image/2/profiles/level1.json", e.IMAGE_2_LEVEL_2 = "http://iiif.io/api/image/2/level2.json", e.IMAGE_2_PROFILE_LEVEL_2 = "http://iiif.io/api/image/2/profiles/level2.json", e.AUTH_0_CLICK_THROUGH = "http://iiif.io/api/auth/0/login/clickthrough", e.AUTH_0_LOGIN = "http://iiif.io/api/auth/0/login", e.AUTH_0_LOGOUT = "http://iiif.io/api/auth/0/logout", e.AUTH_0_RESTRICTED = "http://iiif.io/api/auth/0/login/restricted", e.AUTH_0_TOKEN = "http://iiif.io/api/auth/0/token", e.AUTH_1_CLICK_THROUGH = "http://iiif.io/api/auth/1/clickthrough", e.AUTH_1_EXTERNAL = "http://iiif.io/api/auth/1/external", e.AUTH_1_KIOSK = "http://iiif.io/api/auth/1/kiosk", e.AUTH_1_LOGIN = "http://iiif.io/api/auth/1/login", e.AUTH_1_LOGOUT = "http://iiif.io/api/auth/1/logout", e.AUTH_1_PROBE = "http://iiif.io/api/auth/1/probe", e.AUTH_1_TOKEN = "http://iiif.io/api/auth/1/token", e.SEARCH_0 = "http://iiif.io/api/search/0/search", e.SEARCH_0_AUTO_COMPLETE = "http://iiif.io/api/search/0/autocomplete", e.SEARCH_1 = "http://iiif.io/api/search/1/search", e.SEARCH_1_AUTO_COMPLETE = "http://iiif.io/api/search/1/autocomplete", e.TRACKING_EXTENSIONS = "http://universalviewer.io/tracking-extensions-profile", e.UI_EXTENSIONS = "http://universalviewer.io/ui-extensions-profile", e.PRINT_EXTENSIONS = "http://universalviewer.io/print-extensions-profile", e.SHARE_EXTENSIONS = "http://universalviewer.io/share-extensions-profile", e.DOWNLOAD_EXTENSIONS = "http://universalviewer.io/download-extensions-profile", e.OTHER_MANIFESTATIONS = "http://iiif.io/api/otherManifestations.json", e.IXIF = "http://wellcomelibrary.org/ld/ixif/0/alpha.json";
    })(n.ServiceProfile || (n.ServiceProfile = {})), (function(e) {
      e.IMAGE_SERVICE_2 = "ImageService2", e.IMAGE_SERVICE_3 = "ImageService3";
    })(n.ServiceType || (n.ServiceType = {})), (function(e) {
      e.BOTTOM_TO_TOP = "bottom-to-top", e.LEFT_TO_RIGHT = "left-to-right", e.RIGHT_TO_LEFT = "right-to-left", e.TOP_TO_BOTTOM = "top-to-bottom";
    })(n.ViewingDirection || (n.ViewingDirection = {})), (function(e) {
      e.CONTINUOUS = "continuous", e.INDIVIDUALS = "individuals", e.NON_PAGED = "non-paged", e.PAGED = "paged", e.TOP = "top";
    })(n.ViewingHint || (n.ViewingHint = {}));
  })(Gl)), Gl;
}
var qe = r8(), a8 = /* @__PURE__ */ (function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var a in r) r.hasOwnProperty(a) && (i[a] = r[a]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
})(), Ni = (
  /** @class */
  (function(n) {
    a8(e, n);
    function e(t, i) {
      var r = n.call(this, t) || this;
      return r.options = i, r;
    }
    return e.prototype.getIIIFResourceType = function() {
      return st.normaliseType(this.getProperty("type"));
    }, e.prototype.getLabel = function() {
      var t = this.getProperty("label");
      return t ? Jn.parse(t, this.options.locale) : new Jn([], this.options.locale);
    }, e.prototype.getDefaultLabel = function() {
      return this.getLabel().getValue(this.options.locale);
    }, e.prototype.getMetadata = function() {
      var t = this.getProperty("metadata"), i = [];
      if (!t)
        return i;
      for (var r = 0; r < t.length; r++) {
        var a = t[r], s = new Ju(this.options.locale);
        s.parse(a), i.push(s);
      }
      return i;
    }, e.prototype.getRendering = function(t) {
      for (var i = this.getRenderings(), r = 0; r < i.length; r++) {
        var a = i[r];
        if (a.getFormat() === t)
          return a;
      }
      return null;
    }, e.prototype.getRenderings = function() {
      var t;
      this.__jsonld ? t = this.__jsonld.rendering : t = this.rendering;
      var i = [];
      if (!t)
        return i;
      Array.isArray(t) || (t = [t]);
      for (var r = 0; r < t.length; r++) {
        var a = t[r];
        i.push(new M8(a, this.options));
      }
      return i;
    }, e.prototype.getRequiredStatement = function() {
      var t = null, i = this.getProperty("requiredStatement");
      return i && (t = new Ju(this.options.locale), t.parse(i)), t;
    }, e.prototype.getService = function(t) {
      return st.getService(this, t);
    }, e.prototype.getServices = function() {
      return st.getServices(this);
    }, e.prototype.getThumbnail = function() {
      var t = this.getProperty("thumbnail");
      return Array.isArray(t) && (t = t[0]), t ? new H8(t, this.options) : null;
    }, e.prototype.isAnnotation = function() {
      return this.getIIIFResourceType() === qe.IIIFResourceType.ANNOTATION;
    }, e.prototype.isCanvas = function() {
      return this.getIIIFResourceType() === qe.IIIFResourceType.CANVAS;
    }, e.prototype.isCollection = function() {
      return this.getIIIFResourceType() === qe.IIIFResourceType.COLLECTION;
    }, e.prototype.isManifest = function() {
      return this.getIIIFResourceType() === qe.IIIFResourceType.MANIFEST;
    }, e.prototype.isRange = function() {
      return this.getIIIFResourceType() === qe.IIIFResourceType.RANGE;
    }, e.prototype.isSequence = function() {
      return this.getIIIFResourceType() === qe.IIIFResourceType.SEQUENCE;
    }, e;
  })(wT)
), s8 = /* @__PURE__ */ (function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var a in r) r.hasOwnProperty(a) && (i[a] = r[a]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
})(), qm = (
  /** @class */
  (function(n) {
    s8(e, n);
    function e(t, i) {
      return n.call(this, t, i) || this;
    }
    return e.prototype.getFormat = function() {
      var t = this.getProperty("format");
      return t ? t.toLowerCase() : null;
    }, e.prototype.getResources = function() {
      var t = [];
      if (!this.__jsonld.resources)
        return t;
      for (var i = 0; i < this.__jsonld.resources.length; i++) {
        var r = this.__jsonld.resources[i], a = new Ws(r, this.options);
        t.push(a);
      }
      return t;
    }, e.prototype.getType = function() {
      var t = this.getProperty("type");
      return t ? st.normaliseType(t) : null;
    }, e.prototype.getWidth = function() {
      return this.getProperty("width");
    }, e.prototype.getHeight = function() {
      return this.getProperty("height");
    }, e.prototype.getMaxWidth = function() {
      return this.getProperty("maxWidth");
    }, e.prototype.getMaxHeight = function() {
      var t = this.getProperty("maxHeight");
      return t ? null : this.getMaxWidth();
    }, e;
  })(Ni)
), o8 = /* @__PURE__ */ (function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var a in r) r.hasOwnProperty(a) && (i[a] = r[a]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
})(), ET = (
  /** @class */
  (function(n) {
    o8(e, n);
    function e(t, i) {
      var r = n.call(this, t, i) || this;
      r.index = -1, r.isLoaded = !1;
      var a = {
        defaultLabel: "-",
        locale: "en-GB",
        resource: r,
        pessimisticAccessControl: !1
      };
      return r.options = Object.assign(a, i), r;
    }
    return e.prototype.getAttribution = function() {
      var t = this.getProperty("attribution");
      return t ? Jn.parse(t, this.options.locale) : new Jn([], this.options.locale);
    }, e.prototype.getDescription = function() {
      var t = this.getProperty("description");
      return t ? Jn.parse(t, this.options.locale) : new Jn([], this.options.locale);
    }, e.prototype.getHomepage = function() {
      var t = this.getProperty("homepage");
      return t ? typeof t == "string" ? t : (Array.isArray(t) && t.length && (t = t[0]), t["@id"] || t.id) : null;
    }, e.prototype.getIIIFResourceType = function() {
      return st.normaliseType(this.getProperty("type"));
    }, e.prototype.getLogo = function() {
      var t = this.getProperty("logo");
      if (!t) {
        var i = this.getProperty("provider");
        if (!i)
          return null;
        t = i.logo;
      }
      return t ? typeof t == "string" ? t : (Array.isArray(t) && t.length && (t = t[0]), t["@id"] || t.id) : null;
    }, e.prototype.getLicense = function() {
      return st.getLocalisedValue(this.getProperty("license"), this.options.locale);
    }, e.prototype.getNavDate = function() {
      return new Date(this.getProperty("navDate"));
    }, e.prototype.getRelated = function() {
      return this.getProperty("related");
    }, e.prototype.getSeeAlso = function() {
      return this.getProperty("seeAlso");
    }, e.prototype.getTrackingLabel = function() {
      var t = this.getService(qe.ServiceProfile.TRACKING_EXTENSIONS);
      return t ? t.getProperty("trackingLabel") : "";
    }, e.prototype.getDefaultTree = function() {
      return this.defaultTree = new Kp("root"), this.defaultTree.data = this, this.defaultTree;
    }, e.prototype.getRequiredStatement = function() {
      var t = null, i = this.getProperty("requiredStatement");
      if (i)
        t = new Ju(this.options.locale), t.parse(i);
      else {
        var r = this.getAttribution();
        r && (t = new Ju(this.options.locale), t.value = r);
      }
      return t;
    }, e.prototype.isCollection = function() {
      return this.getIIIFResourceType() === qe.IIIFResourceType.COLLECTION;
    }, e.prototype.isManifest = function() {
      return this.getIIIFResourceType() === qe.IIIFResourceType.MANIFEST;
    }, e.prototype.load = function() {
      var t = this;
      return new Promise(function(i) {
        if (t.isLoaded)
          i(t);
        else {
          var r = t.options;
          r.navDate = t.getNavDate();
          var a = t.__jsonld.id;
          a || (a = t.__jsonld["@id"]), st.loadManifest(a).then(function(s) {
            t.parentLabel = t.getLabel().getValue(r.locale);
            var o = kT.parse(s, r);
            t = Object.assign(t, o), t.index = r.index, i(t);
          });
        }
      });
    }, e;
  })(Ni)
), u8 = /* @__PURE__ */ (function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var a in r) r.hasOwnProperty(a) && (i[a] = r[a]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
})(), Ws = (
  /** @class */
  (function(n) {
    u8(e, n);
    function e(t, i) {
      return n.call(this, t, i) || this;
    }
    return e.prototype.getBody = function() {
      var t = [], i = this.getProperty("body");
      if (i)
        if (Array.isArray(i))
          for (var r = 0; r < i.length; r++) {
            var a = i[r];
            if (a.items)
              for (var s = 0; s < a.items.length; s++) {
                var o = a.items[s];
                t.push(new zo(o, this.options));
              }
            else
              t.push(new zo(a, this.options));
          }
        else if (i.items)
          for (var r = 0; r < i.items.length; r++) {
            var a = i.items[r];
            t.push(new zo(a, this.options));
          }
        else
          t.push(new zo(i, this.options));
      return t;
    }, e.prototype.getMotivation = function() {
      var t = this.getProperty("motivation");
      return t || null;
    }, e.prototype.getOn = function() {
      return this.getProperty("on");
    }, e.prototype.getTarget = function() {
      return this.getProperty("target");
    }, e.prototype.getResource = function() {
      return new qm(this.getProperty("resource"), this.options);
    }, e;
  })(Ni)
), c8 = /* @__PURE__ */ (function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var a in r) r.hasOwnProperty(a) && (i[a] = r[a]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
})(), zo = (
  /** @class */
  (function(n) {
    c8(e, n);
    function e(t, i) {
      return n.call(this, t, i) || this;
    }
    return e.prototype.getFormat = function() {
      var t = this.getProperty("format");
      return t ? st.getMediaType(t) : null;
    }, e.prototype.getType = function() {
      var t = this.getProperty("type");
      return t ? st.normaliseType(this.getProperty("type")) : null;
    }, e.prototype.getWidth = function() {
      return this.getProperty("width");
    }, e.prototype.getHeight = function() {
      return this.getProperty("height");
    }, e;
  })(Ni)
), l8 = /* @__PURE__ */ (function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var a in r) r.hasOwnProperty(a) && (i[a] = r[a]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
})(), d8 = (
  /** @class */
  (function(n) {
    l8(e, n);
    function e(t, i, r) {
      var a = n.call(this, i) || this;
      return a.label = t, a.options = r, a;
    }
    return e.prototype.getIIIFResourceType = function() {
      return st.normaliseType(this.getProperty("type"));
    }, e.prototype.getLabel = function() {
      return this.label;
    }, e.prototype.getResources = function() {
      var t = this, i = this.getProperty("resources");
      return i.map(function(r) {
        return new Ws(r, t.options);
      });
    }, e.prototype.load = function() {
      var t = this;
      return new Promise(function(i, r) {
        if (t.isLoaded)
          i(t);
        else {
          var a = t.__jsonld.id;
          a || (a = t.__jsonld["@id"]), st.loadManifest(a).then(function(s) {
            t.__jsonld = s, t.context = t.getProperty("context"), t.id = t.getProperty("id"), t.isLoaded = !0, i(t);
          }).catch(r);
        }
      });
    }, e;
  })(wT)
), f8 = /* @__PURE__ */ (function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var a in r) r.hasOwnProperty(a) && (i[a] = r[a]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
})(), h8 = (
  /** @class */
  (function(n) {
    f8(e, n);
    function e(t, i) {
      return n.call(this, t, i) || this;
    }
    return e.prototype.getItems = function() {
      return this.getProperty("items");
    }, e;
  })(Ni)
), Xl, Db;
function p8() {
  if (Db) return Xl;
  Db = 1;
  function n(e, t) {
    for (var i = -1, r = t.length, a = e.length; ++i < r; )
      e[a + i] = t[i];
    return e;
  }
  return Xl = n, Xl;
}
var Kl, Sb;
function DT() {
  if (Sb) return Kl;
  Sb = 1;
  var n = typeof At == "object" && At && At.Object === Object && At;
  return Kl = n, Kl;
}
var Yl, Cb;
function Mi() {
  if (Cb) return Yl;
  Cb = 1;
  var n = DT(), e = typeof self == "object" && self && self.Object === Object && self, t = n || e || Function("return this")();
  return Yl = t, Yl;
}
var Ql, Ab;
function Wm() {
  if (Ab) return Ql;
  Ab = 1;
  var n = Mi(), e = n.Symbol;
  return Ql = e, Ql;
}
var Zl, kb;
function m8() {
  if (kb) return Zl;
  kb = 1;
  var n = Wm(), e = Object.prototype, t = e.hasOwnProperty, i = e.toString, r = n ? n.toStringTag : void 0;
  function a(s) {
    var o = t.call(s, r), u = s[r];
    try {
      s[r] = void 0;
      var c = !0;
    } catch {
    }
    var l = i.call(s);
    return c && (o ? s[r] = u : delete s[r]), l;
  }
  return Zl = a, Zl;
}
var Jl, Ib;
function g8() {
  if (Ib) return Jl;
  Ib = 1;
  var n = Object.prototype, e = n.toString;
  function t(i) {
    return e.call(i);
  }
  return Jl = t, Jl;
}
var ed, Ub;
function no() {
  if (Ub) return ed;
  Ub = 1;
  var n = Wm(), e = m8(), t = g8(), i = "[object Null]", r = "[object Undefined]", a = n ? n.toStringTag : void 0;
  function s(o) {
    return o == null ? o === void 0 ? r : i : a && a in Object(o) ? e(o) : t(o);
  }
  return ed = s, ed;
}
var td, Rb;
function Ic() {
  if (Rb) return td;
  Rb = 1;
  function n(e) {
    return e != null && typeof e == "object";
  }
  return td = n, td;
}
var nd, Ob;
function b8() {
  if (Ob) return nd;
  Ob = 1;
  var n = no(), e = Ic(), t = "[object Arguments]";
  function i(r) {
    return e(r) && n(r) == t;
  }
  return nd = i, nd;
}
var id, Lb;
function ST() {
  if (Lb) return id;
  Lb = 1;
  var n = b8(), e = Ic(), t = Object.prototype, i = t.hasOwnProperty, r = t.propertyIsEnumerable, a = n(/* @__PURE__ */ (function() {
    return arguments;
  })()) ? n : function(s) {
    return e(s) && i.call(s, "callee") && !r.call(s, "callee");
  };
  return id = a, id;
}
var rd, Pb;
function CT() {
  if (Pb) return rd;
  Pb = 1;
  var n = Array.isArray;
  return rd = n, rd;
}
var ad, Fb;
function y8() {
  if (Fb) return ad;
  Fb = 1;
  var n = Wm(), e = ST(), t = CT(), i = n ? n.isConcatSpreadable : void 0;
  function r(a) {
    return t(a) || e(a) || !!(i && a && a[i]);
  }
  return ad = r, ad;
}
var sd, Nb;
function AT() {
  if (Nb) return sd;
  Nb = 1;
  var n = p8(), e = y8();
  function t(i, r, a, s, o) {
    var u = -1, c = i.length;
    for (a || (a = e), o || (o = []); ++u < c; ) {
      var l = i[u];
      r > 0 && a(l) ? r > 1 ? t(l, r - 1, a, s, o) : n(o, l) : s || (o[o.length] = l);
    }
    return o;
  }
  return sd = t, sd;
}
var od, Mb;
function v8() {
  if (Mb) return od;
  Mb = 1;
  var n = AT();
  function e(t) {
    var i = t == null ? 0 : t.length;
    return i ? n(t, 1) : [];
  }
  return od = e, od;
}
var x8 = v8();
const ud = /* @__PURE__ */ Qt(x8);
var cd, Bb;
function _8() {
  if (Bb) return cd;
  Bb = 1;
  var n = AT(), e = 1 / 0;
  function t(i) {
    var r = i == null ? 0 : i.length;
    return r ? n(i, e) : [];
  }
  return cd = t, cd;
}
var T8 = _8();
const jb = /* @__PURE__ */ Qt(T8);
var w8 = /* @__PURE__ */ (function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var a in r) r.hasOwnProperty(a) && (i[a] = r[a]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
})(), Zu = (
  /** @class */
  (function(n) {
    w8(e, n);
    function e(t, i) {
      return n.call(this, t, i) || this;
    }
    return e.prototype.getCanonicalImageUri = function(t) {
      var i = null, r = "full", a = 0, s = "default", o = t, u;
      if (this.externalResource && this.externalResource.data && this.externalResource.data["@id"])
        i = this.externalResource.data["@id"], o || (o = this.externalResource.data.width), this.externalResource.data["@context"] && (this.externalResource.data["@context"].indexOf("/1.0/context.json") > -1 || this.externalResource.data["@context"].indexOf("/1.1/context.json") > -1 || this.externalResource.data["@context"].indexOf("/1/context.json") > -1) && (s = "native");
      else {
        var c = void 0;
        if (c = this.getImages(), c && c.length) {
          var l = c[0], h = l.getResource(), f = h.getServices();
          o || (o = h.getWidth());
          var d = f ? f.find(function(g) {
            return st.isImageProfile(g.getProfile()) || st.isImageServiceType(g.getIIIFResourceType());
          }) : null;
          if (d)
            i = d.id, s = st.getImageQuality(d.getProfile());
          else if (o === h.getWidth())
            return h.id;
        }
        if (c = this.getContent(), c && c.length) {
          var l = c[0], y = l.getBody(), m = y[0], f = m.getServices();
          o || (o = m.getWidth());
          var d = f ? f.find(function(x) {
            return st.isImageServiceType(x.getIIIFResourceType());
          }) : null;
          if (d)
            i = d.id, s = st.getImageQuality(d.getProfile());
          else if (o === m.getWidth())
            return m.id;
        }
        if (!i) {
          var b = this.getProperty("thumbnail");
          if (b) {
            if (typeof b == "string")
              return b;
            if (b["@id"])
              return b["@id"];
            if (b.length)
              return b[0].id;
          }
        }
      }
      u = o + ",", i && i.endsWith("/") && (i = i.substr(0, i.length - 1));
      var p = [i, r, u, a, s + ".jpg"].join("/");
      return p;
    }, e.prototype.getMaxDimensions = function() {
      var t = null, i;
      return this.externalResource && this.externalResource.data && this.externalResource.data.profile && (i = this.externalResource.data.profile, Array.isArray(i) && (i = i.filter(function(r) {
        return r.maxWidth;
      })[0], i && (t = new q8(i.maxWidth, i.maxHeight ? i.maxHeight : i.maxWidth)))), t;
    }, e.prototype.getContent = function() {
      var t = [], i = this.__jsonld.items || this.__jsonld.content;
      if (!i)
        return t;
      var r = null;
      if (i.length && (r = new h8(i[0], this.options)), !r)
        return t;
      for (var a = r.getItems(), s = 0; s < a.length; s++) {
        var o = a[s], u = new Ws(o, this.options);
        t.push(u);
      }
      return t;
    }, e.prototype.getDuration = function() {
      return this.getProperty("duration");
    }, e.prototype.getImages = function() {
      var t = [];
      if (!this.__jsonld.images)
        return t;
      for (var i = 0; i < this.__jsonld.images.length; i++) {
        var r = this.__jsonld.images[i], a = new Ws(r, this.options);
        t.push(a);
      }
      return t;
    }, e.prototype.getIndex = function() {
      return this.getProperty("index");
    }, e.prototype.getOtherContent = function() {
      var t = this, i = Array.isArray(this.getProperty("otherContent")) ? this.getProperty("otherContent") : [this.getProperty("otherContent")], r = function(s, o) {
        return typeof s != "string" ? !1 : s.toLowerCase() === s.toLowerCase();
      }, a = i.filter(function(s) {
        return s && r(s["@type"]);
      }).map(function(s, o) {
        return new d8(s.label || "Annotation list " + o, s, t.options);
      }).map(function(s) {
        return s.load();
      });
      return Promise.all(a);
    }, e.prototype.getWidth = function() {
      return this.getProperty("width");
    }, e.prototype.getHeight = function() {
      return this.getProperty("height");
    }, e.prototype.getViewingHint = function() {
      return this.getProperty("viewingHint");
    }, Object.defineProperty(e.prototype, "imageResources", {
      get: function() {
        var t = this, i = jb([
          this.getImages().map(function(r) {
            return r.getResource();
          }),
          this.getContent().map(function(r) {
            return r.getBody();
          })
        ]);
        return ud(i.map(function(r) {
          switch (r.getProperty("type").toLowerCase()) {
            case qe.ExternalResourceType.CHOICE:
            case qe.ExternalResourceType.OA_CHOICE:
              return new e({
                images: ud([
                  r.getProperty("default"),
                  r.getProperty("item")
                ]).map(function(a) {
                  return { resource: a };
                })
              }, t.options).getImages().map(function(a) {
                return a.getResource();
              });
            default:
              return r;
          }
        }));
      },
      enumerable: !0,
      configurable: !0
    }), Object.defineProperty(e.prototype, "resourceAnnotations", {
      get: function() {
        return jb([this.getImages(), this.getContent()]);
      },
      enumerable: !0,
      configurable: !0
    }), e.prototype.resourceAnnotation = function(t) {
      return this.resourceAnnotations.find(function(i) {
        return i.getResource().id === t || ud(new Array(i.getBody())).some(function(r) {
          return r.id === t;
        });
      });
    }, e.prototype.onFragment = function(t) {
      var i = this.resourceAnnotation(t);
      if (i) {
        var r = i.getProperty("on"), a = i.getProperty("target");
        if (!(!r || !a)) {
          var s = (r || a).match(/xywh=(.*)$/);
          if (s)
            return s[1].split(",").map(function(o) {
              return parseInt(o, 10);
            });
        }
      }
    }, Object.defineProperty(e.prototype, "iiifImageResources", {
      get: function() {
        return this.imageResources.filter(function(t) {
          return t && t.getServices()[0] && t.getServices()[0].id;
        });
      },
      enumerable: !0,
      configurable: !0
    }), Object.defineProperty(e.prototype, "imageServiceIds", {
      get: function() {
        return this.iiifImageResources.map(function(t) {
          return t.getServices()[0].id;
        });
      },
      enumerable: !0,
      configurable: !0
    }), Object.defineProperty(e.prototype, "aspectRatio", {
      get: function() {
        return this.getWidth() / this.getHeight();
      },
      enumerable: !0,
      configurable: !0
    }), e;
  })(qm)
), E8 = /* @__PURE__ */ (function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var a in r) r.hasOwnProperty(a) && (i[a] = r[a]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
})(), D8 = (
  /** @class */
  (function(n) {
    E8(e, n);
    function e(t, i) {
      var r = n.call(this, t, i) || this;
      return r.items = [], r._collections = null, r._manifests = null, t.__collection = r, r;
    }
    return e.prototype.getCollections = function() {
      return this._collections ? this._collections : this._collections = this.items.filter(function(t) {
        return t.isCollection();
      });
    }, e.prototype.getManifests = function() {
      return this._manifests ? this._manifests : this._manifests = this.items.filter(function(t) {
        return t.isManifest();
      });
    }, e.prototype.getCollectionByIndex = function(t) {
      for (var i = this.getCollections(), r, a = 0; a < i.length; a++) {
        var s = i[a];
        s.index === t && (r = s);
      }
      if (r)
        return r.options.index = t, r.load();
      throw new Error("Collection index not found");
    }, e.prototype.getManifestByIndex = function(t) {
      for (var i = this.getManifests(), r, a = 0; a < i.length; a++) {
        var s = i[a];
        s.index === t && (r = s);
      }
      if (r)
        return r.options.index = t, r.load();
      throw new Error("Manifest index not found");
    }, e.prototype.getTotalCollections = function() {
      return this.getCollections().length;
    }, e.prototype.getTotalManifests = function() {
      return this.getManifests().length;
    }, e.prototype.getTotalItems = function() {
      return this.items.length;
    }, e.prototype.getViewingDirection = function() {
      return this.getProperty("viewingDirection") ? this.getProperty("viewingDirection") : qe.ViewingDirection.LEFT_TO_RIGHT;
    }, e.prototype.getBehavior = function() {
      var t = this.getProperty("behavior");
      return Array.isArray(t) && (t = t[0]), t || null;
    }, e.prototype.getViewingHint = function() {
      return this.getProperty("viewingHint");
    }, e.prototype.getDefaultTree = function() {
      return n.prototype.getDefaultTree.call(this), this.defaultTree.data.type = st.normaliseType(vi.COLLECTION), this._parseManifests(this), this._parseCollections(this), st.generateTreeNodeIds(this.defaultTree), this.defaultTree;
    }, e.prototype._parseManifests = function(t) {
      if (t.getManifests() && t.getManifests().length)
        for (var i = 0; i < t.getManifests().length; i++) {
          var r = t.getManifests()[i], a = r.getDefaultTree();
          a.label = r.parentLabel || r.getLabel().getValue(this.options.locale) || "manifest " + (i + 1), a.navDate = r.getNavDate(), a.data.id = r.id, a.data.type = st.normaliseType(vi.MANIFEST), t.defaultTree.addNode(a);
        }
    }, e.prototype._parseCollections = function(t) {
      if (t.getCollections() && t.getCollections().length)
        for (var i = 0; i < t.getCollections().length; i++) {
          var r = t.getCollections()[i], a = r.getDefaultTree();
          a.label = r.parentLabel || r.getLabel().getValue(this.options.locale) || "collection " + (i + 1), a.navDate = r.getNavDate(), a.data.id = r.id, a.data.type = st.normaliseType(vi.COLLECTION), t.defaultTree.addNode(a);
        }
    }, e;
  })(ET)
), ld = (
  /** @class */
  (function() {
    function n(e, t) {
      this.start = e, this.end = t;
    }
    return n.prototype.getLength = function() {
      return this.end - this.start;
    }, n;
  })()
), Ju = (
  /** @class */
  (function() {
    function n(e) {
      this.defaultLocale = e;
    }
    return n.prototype.parse = function(e) {
      this.resource = e, this.label = Jn.parse(this.resource.label, this.defaultLocale), this.value = Jn.parse(this.resource.value, this.defaultLocale);
    }, n.prototype.getLabel = function(e) {
      return this.label === null ? null : (Array.isArray(e) && !e.length && (e = void 0), this.label.getValue(e || this.defaultLocale));
    }, n.prototype.setLabel = function(e) {
      this.label === null && (this.label = new Jn([])), this.label.setValue(e, this.defaultLocale);
    }, n.prototype.getValue = function(e, t) {
      return t === void 0 && (t = "<br/>"), this.value === null ? null : (Array.isArray(e) && !e.length && (e = void 0), this.value.getValue(e || this.defaultLocale, t));
    }, n.prototype.getValues = function(e) {
      return this.value === null ? [] : (Array.isArray(e) && !e.length && (e = void 0), this.value.getValues(e || this.defaultLocale));
    }, n.prototype.setValue = function(e) {
      this.value === null && (this.value = new Jn([])), this.value.setValue(e, this.defaultLocale);
    }, n;
  })()
), S8 = /* @__PURE__ */ (function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var a in r) r.hasOwnProperty(a) && (i[a] = r[a]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
})();
(function(n) {
  S8(e, n);
  function e() {
    return n !== null && n.apply(this, arguments) || this;
  }
  return e.getValue = function(t, i) {
    return t.getValue(i, "<br/>");
  }, e.getValues = function(t, i) {
    return t.getValues(i);
  }, e;
})(Array);
var Ge = {}, qb;
function C8() {
  return qb || (qb = 1, Object.defineProperty(Ge, "__esModule", { value: !0 }), Ge.CONTINUE = 100, Ge.SWITCHING_PROTOCOLS = 101, Ge.PROCESSING = 102, Ge.OK = 200, Ge.CREATED = 201, Ge.ACCEPTED = 202, Ge.NON_AUTHORITATIVE_INFORMATION = 203, Ge.NO_CONTENT = 204, Ge.RESET_CONTENT = 205, Ge.PARTIAL_CONTENT = 206, Ge.MULTI_STATUS = 207, Ge.MULTIPLE_CHOICES = 300, Ge.MOVED_PERMANENTLY = 301, Ge.MOVED_TEMPORARILY = 302, Ge.SEE_OTHER = 303, Ge.NOT_MODIFIED = 304, Ge.USE_PROXY = 305, Ge.TEMPORARY_REDIRECT = 307, Ge.BAD_REQUEST = 400, Ge.UNAUTHORIZED = 401, Ge.PAYMENT_REQUIRED = 402, Ge.FORBIDDEN = 403, Ge.NOT_FOUND = 404, Ge.METHOD_NOT_ALLOWED = 405, Ge.NOT_ACCEPTABLE = 406, Ge.PROXY_AUTHENTICATION_REQUIRED = 407, Ge.REQUEST_TIME_OUT = 408, Ge.CONFLICT = 409, Ge.GONE = 410, Ge.LENGTH_REQUIRED = 411, Ge.PRECONDITION_FAILED = 412, Ge.REQUEST_ENTITY_TOO_LARGE = 413, Ge.REQUEST_URI_TOO_LARGE = 414, Ge.UNSUPPORTED_MEDIA_TYPE = 415, Ge.REQUESTED_RANGE_NOT_SATISFIABLE = 416, Ge.EXPECTATION_FAILED = 417, Ge.IM_A_TEAPOT = 418, Ge.UNPROCESSABLE_ENTITY = 422, Ge.LOCKED = 423, Ge.FAILED_DEPENDENCY = 424, Ge.UNORDERED_COLLECTION = 425, Ge.UPGRADE_REQUIRED = 426, Ge.PRECONDITION_REQUIRED = 428, Ge.TOO_MANY_REQUESTS = 429, Ge.REQUEST_HEADER_FIELDS_TOO_LARGE = 431, Ge.INTERNAL_SERVER_ERROR = 500, Ge.NOT_IMPLEMENTED = 501, Ge.BAD_GATEWAY = 502, Ge.SERVICE_UNAVAILABLE = 503, Ge.GATEWAY_TIME_OUT = 504, Ge.HTTP_VERSION_NOT_SUPPORTED = 505, Ge.VARIANT_ALSO_NEGOTIATES = 506, Ge.INSUFFICIENT_STORAGE = 507, Ge.BANDWIDTH_LIMIT_EXCEEDED = 509, Ge.NOT_EXTENDED = 510, Ge.NETWORK_AUTHENTICATION_REQUIRED = 511), Ge;
}
var Un = C8();
function A8(n, e) {
  return e = e || {}, new Promise(function(t, i) {
    var r = new XMLHttpRequest(), a = [], s = [], o = {}, u = function() {
      return { ok: (r.status / 100 | 0) == 2, statusText: r.statusText, status: r.status, url: r.responseURL, text: function() {
        return Promise.resolve(r.responseText);
      }, json: function() {
        return Promise.resolve(r.responseText).then(JSON.parse);
      }, blob: function() {
        return Promise.resolve(new Blob([r.response]));
      }, clone: u, headers: { keys: function() {
        return a;
      }, entries: function() {
        return s;
      }, get: function(l) {
        return o[l.toLowerCase()];
      }, has: function(l) {
        return l.toLowerCase() in o;
      } } };
    };
    for (var c in r.open(e.method || "get", n, !0), r.onload = function() {
      r.getAllResponseHeaders().replace(/^(.*?):[^\S\n]*([\s\S]*?)$/gm, function(l, h, f) {
        a.push(h = h.toLowerCase()), s.push([h, f]), o[h] = o[h] ? o[h] + "," + f : f;
      }), t(u());
    }, r.onerror = i, r.withCredentials = e.credentials == "include", e.headers) r.setRequestHeader(c, e.headers[c]);
    r.send(e.body || null);
  });
}
const k8 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: A8
}, Symbol.toStringTag, { value: "Module" })), Wb = /* @__PURE__ */ kc(k8);
var dd, Vb;
function I8() {
  return Vb || (Vb = 1, dd = self.fetch || (self.fetch = Wb.default || Wb)), dd;
}
I8();
var fd = function(n, e, t, i) {
  function r(a) {
    return a instanceof t ? a : new t(function(s) {
      s(a);
    });
  }
  return new (t || (t = Promise))(function(a, s) {
    function o(l) {
      try {
        c(i.next(l));
      } catch (h) {
        s(h);
      }
    }
    function u(l) {
      try {
        c(i.throw(l));
      } catch (h) {
        s(h);
      }
    }
    function c(l) {
      l.done ? a(l.value) : r(l.value).then(o, u);
    }
    c((i = i.apply(n, e || [])).next());
  });
}, hd = function(n, e) {
  var t = { label: 0, sent: function() {
    if (a[0] & 1) throw a[1];
    return a[1];
  }, trys: [], ops: [] }, i, r, a, s;
  return s = { next: o(0), throw: o(1), return: o(2) }, typeof Symbol == "function" && (s[Symbol.iterator] = function() {
    return this;
  }), s;
  function o(c) {
    return function(l) {
      return u([c, l]);
    };
  }
  function u(c) {
    if (i) throw new TypeError("Generator is already executing.");
    for (; t; ) try {
      if (i = 1, r && (a = c[0] & 2 ? r.return : c[0] ? r.throw || ((a = r.return) && a.call(r), 0) : r.next) && !(a = a.call(r, c[1])).done) return a;
      switch (r = 0, a && (c = [c[0] & 2, a.value]), c[0]) {
        case 0:
        case 1:
          a = c;
          break;
        case 4:
          return t.label++, { value: c[1], done: !1 };
        case 5:
          t.label++, r = c[1], c = [0];
          continue;
        case 7:
          c = t.ops.pop(), t.trys.pop();
          continue;
        default:
          if (a = t.trys, !(a = a.length > 0 && a[a.length - 1]) && (c[0] === 6 || c[0] === 2)) {
            t = 0;
            continue;
          }
          if (c[0] === 3 && (!a || c[1] > a[0] && c[1] < a[3])) {
            t.label = c[1];
            break;
          }
          if (c[0] === 6 && t.label < a[1]) {
            t.label = a[1], a = c;
            break;
          }
          if (a && t.label < a[2]) {
            t.label = a[2], t.ops.push(c);
            break;
          }
          a[2] && t.ops.pop(), t.trys.pop();
          continue;
      }
      c = e.call(n, t);
    } catch (l) {
      c = [6, l], r = 0;
    } finally {
      i = a = 0;
    }
    if (c[0] & 5) throw c[1];
    return { value: c[0] ? c[1] : void 0, done: !0 };
  }
}, st = (
  /** @class */
  (function() {
    function n() {
    }
    return n.getMediaType = function(e) {
      return e = e.toLowerCase(), e = e.split(";")[0], e.trim();
    }, n.getImageQuality = function(e) {
      return e === qe.ServiceProfile.IMAGE_0_COMPLIANCE_LEVEL_1 || e === qe.ServiceProfile.IMAGE_0_COMPLIANCE_LEVEL_2 || e === qe.ServiceProfile.IMAGE_1_COMPLIANCE_LEVEL_1 || e === qe.ServiceProfile.IMAGE_1_COMPLIANCE_LEVEL_2 || e === qe.ServiceProfile.IMAGE_0_CONFORMANCE_LEVEL_1 || e === qe.ServiceProfile.IMAGE_0_CONFORMANCE_LEVEL_2 || e === qe.ServiceProfile.IMAGE_1_CONFORMANCE_LEVEL_1 || e === qe.ServiceProfile.IMAGE_1_CONFORMANCE_LEVEL_2 || e === qe.ServiceProfile.IMAGE_1_LEVEL_1 || e === qe.ServiceProfile.IMAGE_1_PROFILE_LEVEL_1 || e === qe.ServiceProfile.IMAGE_1_LEVEL_2 || e === qe.ServiceProfile.IMAGE_1_PROFILE_LEVEL_2 ? "native" : "default";
    }, n.getInexactLocale = function(e) {
      return e.indexOf("-") !== -1 ? e.substr(0, e.indexOf("-")) : e;
    }, n.getLocalisedValue = function(e, t) {
      if (!Array.isArray(e))
        return e;
      for (var i = 0; i < e.length; i++) {
        var r = e[i], a = r["@language"];
        if (t === a)
          return r["@value"];
      }
      for (var s = t.substr(0, t.indexOf("-")), i = 0; i < e.length; i++) {
        var o = e[i], u = o["@language"];
        if (u === s)
          return o["@value"];
      }
      return null;
    }, n.generateTreeNodeIds = function(e, t) {
      t === void 0 && (t = 0);
      var i;
      e.parentNode ? i = e.parentNode.id + "-" + t : i = "0", e.id = i;
      for (var r = 0; r < e.nodes.length; r++) {
        var a = e.nodes[r];
        n.generateTreeNodeIds(a, r);
      }
    }, n.normaliseType = function(e) {
      if (e = (e || "").toLowerCase(), e.indexOf(":") !== -1) {
        var t = e.split(":");
        return t[1];
      }
      return e;
    }, n.normaliseUrl = function(e) {
      return e = e.substr(e.indexOf("://")), e.indexOf("#") !== -1 && (e = e.split("#")[0]), e;
    }, n.normalisedUrlsMatch = function(e, t) {
      return n.normaliseUrl(e) === n.normaliseUrl(t);
    }, n.isImageProfile = function(e) {
      return !!(n.normalisedUrlsMatch(e, qe.ServiceProfile.IMAGE_0_COMPLIANCE_LEVEL_0) || n.normalisedUrlsMatch(e, qe.ServiceProfile.IMAGE_0_COMPLIANCE_LEVEL_1) || n.normalisedUrlsMatch(e, qe.ServiceProfile.IMAGE_0_COMPLIANCE_LEVEL_2) || n.normalisedUrlsMatch(e, qe.ServiceProfile.IMAGE_1_COMPLIANCE_LEVEL_0) || n.normalisedUrlsMatch(e, qe.ServiceProfile.IMAGE_1_COMPLIANCE_LEVEL_2) || n.normalisedUrlsMatch(e, qe.ServiceProfile.IMAGE_0_CONFORMANCE_LEVEL_0) || n.normalisedUrlsMatch(e, qe.ServiceProfile.IMAGE_0_CONFORMANCE_LEVEL_1) || n.normalisedUrlsMatch(e, qe.ServiceProfile.IMAGE_0_CONFORMANCE_LEVEL_2) || n.normalisedUrlsMatch(e, qe.ServiceProfile.IMAGE_1_CONFORMANCE_LEVEL_1) || n.normalisedUrlsMatch(e, qe.ServiceProfile.IMAGE_1_CONFORMANCE_LEVEL_2) || n.normalisedUrlsMatch(e, qe.ServiceProfile.IMAGE_1_LEVEL_0) || n.normalisedUrlsMatch(e, qe.ServiceProfile.IMAGE_1_PROFILE_LEVEL_0) || n.normalisedUrlsMatch(e, qe.ServiceProfile.IMAGE_1_LEVEL_1) || n.normalisedUrlsMatch(e, qe.ServiceProfile.IMAGE_1_PROFILE_LEVEL_1) || n.normalisedUrlsMatch(e, qe.ServiceProfile.IMAGE_1_LEVEL_2) || n.normalisedUrlsMatch(e, qe.ServiceProfile.IMAGE_1_PROFILE_LEVEL_2) || n.normalisedUrlsMatch(e, qe.ServiceProfile.IMAGE_2_LEVEL_0) || n.normalisedUrlsMatch(e, qe.ServiceProfile.IMAGE_2_PROFILE_LEVEL_0) || n.normalisedUrlsMatch(e, qe.ServiceProfile.IMAGE_2_LEVEL_1) || n.normalisedUrlsMatch(e, qe.ServiceProfile.IMAGE_2_PROFILE_LEVEL_1) || n.normalisedUrlsMatch(e, qe.ServiceProfile.IMAGE_2_LEVEL_2) || n.normalisedUrlsMatch(e, qe.ServiceProfile.IMAGE_2_PROFILE_LEVEL_2));
    }, n.isImageServiceType = function(e) {
      return e !== null && e.toLowerCase() === qe.ServiceType.IMAGE_SERVICE_2.toLowerCase() || e === qe.ServiceType.IMAGE_SERVICE_3.toLowerCase();
    }, n.isLevel0ImageProfile = function(e) {
      return !!(n.normalisedUrlsMatch(e, qe.ServiceProfile.IMAGE_0_COMPLIANCE_LEVEL_0) || n.normalisedUrlsMatch(e, qe.ServiceProfile.IMAGE_1_COMPLIANCE_LEVEL_0) || n.normalisedUrlsMatch(e, qe.ServiceProfile.IMAGE_0_CONFORMANCE_LEVEL_0) || n.normalisedUrlsMatch(e, qe.ServiceProfile.IMAGE_1_CONFORMANCE_LEVEL_0) || n.normalisedUrlsMatch(e, qe.ServiceProfile.IMAGE_1_LEVEL_0) || n.normalisedUrlsMatch(e, qe.ServiceProfile.IMAGE_1_PROFILE_LEVEL_0) || n.normalisedUrlsMatch(e, qe.ServiceProfile.IMAGE_2_LEVEL_0) || n.normalisedUrlsMatch(e, qe.ServiceProfile.IMAGE_2_PROFILE_LEVEL_0));
    }, n.isLevel1ImageProfile = function(e) {
      return !!(n.normalisedUrlsMatch(e, qe.ServiceProfile.IMAGE_0_COMPLIANCE_LEVEL_1) || n.normalisedUrlsMatch(e, qe.ServiceProfile.IMAGE_1_COMPLIANCE_LEVEL_1) || n.normalisedUrlsMatch(e, qe.ServiceProfile.IMAGE_0_CONFORMANCE_LEVEL_1) || n.normalisedUrlsMatch(e, qe.ServiceProfile.IMAGE_1_CONFORMANCE_LEVEL_1) || n.normalisedUrlsMatch(e, qe.ServiceProfile.IMAGE_1_LEVEL_1) || n.normalisedUrlsMatch(e, qe.ServiceProfile.IMAGE_1_PROFILE_LEVEL_1) || n.normalisedUrlsMatch(e, qe.ServiceProfile.IMAGE_2_LEVEL_1) || n.normalisedUrlsMatch(e, qe.ServiceProfile.IMAGE_2_PROFILE_LEVEL_1));
    }, n.isLevel2ImageProfile = function(e) {
      return !!(n.normalisedUrlsMatch(e, qe.ServiceProfile.IMAGE_0_COMPLIANCE_LEVEL_2) || n.normalisedUrlsMatch(e, qe.ServiceProfile.IMAGE_1_COMPLIANCE_LEVEL_2) || n.normalisedUrlsMatch(e, qe.ServiceProfile.IMAGE_0_CONFORMANCE_LEVEL_2) || n.normalisedUrlsMatch(e, qe.ServiceProfile.IMAGE_1_CONFORMANCE_LEVEL_2) || n.normalisedUrlsMatch(e, qe.ServiceProfile.IMAGE_1_LEVEL_2) || n.normalisedUrlsMatch(e, qe.ServiceProfile.IMAGE_1_PROFILE_LEVEL_2) || n.normalisedUrlsMatch(e, qe.ServiceProfile.IMAGE_2_LEVEL_2) || n.normalisedUrlsMatch(e, qe.ServiceProfile.IMAGE_2_PROFILE_LEVEL_2));
    }, n.parseManifest = function(e, t) {
      return kT.parse(e, t);
    }, n.checkStatus = function(e) {
      if (e.ok)
        return e;
      var t = new Error(e.statusText);
      return t.response = e, Promise.reject(t);
    }, n.loadManifest = function(e) {
      return new Promise(function(t, i) {
        fetch(e).then(n.checkStatus).then(function(r) {
          return r.json();
        }).then(function(r) {
          t(r);
        }).catch(function(r) {
          i();
        });
      });
    }, n.loadExternalResourcesAuth1 = function(e, t, i, r, a, s, o, u) {
      return new Promise(function(c, l) {
        var h = e.map(function(f) {
          return n.loadExternalResourceAuth1(f, t, i, r, a, s, o, u);
        });
        Promise.all(h).then(function() {
          c(e);
        }).catch(function(f) {
          l(f);
        });
      });
    }, n.loadExternalResourceAuth1 = function(e, t, i, r, a, s, o, u) {
      return fd(this, void 0, void 0, function() {
        var c;
        return hd(this, function(l) {
          switch (l.label) {
            case 0:
              return [4, r(e)];
            case 1:
              return c = l.sent(), c ? [4, e.getData(c)] : [3, 6];
            case 2:
              return l.sent(), e.status !== Un.OK ? [3, 3] : [2, e];
            case 3:
              return [4, n.doAuthChain(e, t, i, a, s, o, u)];
            case 4:
              l.sent(), l.label = 5;
            case 5:
              if (e.status === Un.OK || e.status === Un.MOVED_TEMPORARILY)
                return [2, e];
              throw n.createAuthorizationFailedError();
            case 6:
              return [4, e.getData()];
            case 7:
              return l.sent(), e.status === Un.MOVED_TEMPORARILY || e.status === Un.UNAUTHORIZED ? [4, n.doAuthChain(e, t, i, a, s, o, u)] : [3, 9];
            case 8:
              l.sent(), l.label = 9;
            case 9:
              if (e.status === Un.OK || e.status === Un.MOVED_TEMPORARILY)
                return [2, e];
              throw n.createAuthorizationFailedError();
          }
        });
      });
    }, n.doAuthChain = function(e, t, i, r, a, s, o) {
      return fd(this, void 0, void 0, function() {
        var u, c, l, h, f, d, y, m, m;
        return hd(this, function(b) {
          switch (b.label) {
            case 0:
              return e.isAccessControlled() ? (u = e.externalService, u && (u.options = e.options), c = e.kioskService, c && (c.options = e.options), l = e.clickThroughService, l && (l.options = e.options), h = e.loginService, h && (h.options = e.options), !e.isResponseHandled && e.status === Un.MOVED_TEMPORARILY ? [4, s(e)] : [3, 2]) : [2, e];
            case 1:
              return b.sent(), [2, e];
            case 2:
              return f = null, d = null, f = u, f ? (d = f, [4, n.attemptResourceWithToken(e, i, f)]) : [3, 4];
            case 3:
              return b.sent(), [2, e];
            case 4:
              return f = c, f ? (d = f, y = t(f), y ? [4, r(y)] : [3, 7]) : [3, 7];
            case 5:
              return b.sent(), [4, n.attemptResourceWithToken(e, i, f)];
            case 6:
              return b.sent(), [2, e];
            case 7:
              return f = l, f ? (d = f, [4, a(e, f)]) : [3, 11];
            case 8:
              return m = b.sent(), m ? [4, r(m)] : [3, 11];
            case 9:
              return b.sent(), [4, n.attemptResourceWithToken(e, i, f)];
            case 10:
              return b.sent(), [2, e];
            case 11:
              return f = h, f ? (d = f, [4, a(e, f)]) : [3, 15];
            case 12:
              return m = b.sent(), m ? [4, r(m)] : [3, 15];
            case 13:
              return b.sent(), [4, n.attemptResourceWithToken(e, i, f)];
            case 14:
              return b.sent(), [2, e];
            case 15:
              return d && o(e, d), [
                2
                /*return*/
              ];
          }
        });
      });
    }, n.attemptResourceWithToken = function(e, t, i) {
      return fd(this, void 0, void 0, function() {
        var r, a;
        return hd(this, function(s) {
          switch (s.label) {
            case 0:
              return r = i.getService(qe.ServiceProfile.AUTH_1_TOKEN), r ? [4, t(e, r)] : [3, 3];
            case 1:
              return a = s.sent(), a && a.accessToken ? [4, e.getData(a)] : [3, 3];
            case 2:
              return s.sent(), [2, e];
            case 3:
              return [
                2
                /*return*/
              ];
          }
        });
      });
    }, n.loadExternalResourcesAuth09 = function(e, t, i, r, a, s, o, u, c, l) {
      return new Promise(function(h, f) {
        var d = e.map(function(y) {
          return n.loadExternalResourceAuth09(y, t, i, r, a, s, o, u, c, l);
        });
        Promise.all(d).then(function() {
          h(e);
        }).catch(function(y) {
          f(y);
        });
      });
    }, n.loadExternalResourceAuth09 = function(e, t, i, r, a, s, o, u, c, l) {
      return new Promise(function(h, f) {
        l && l.pessimisticAccessControl ? e.getData().then(function() {
          e.isAccessControlled() ? e.clickThroughService ? (h(i(e)), h(r(e))) : a(e).then(function() {
            s(e, !0).then(function(d) {
              e.getData(d).then(function() {
                h(c(e));
              }).catch(function(y) {
                f(n.createInternalServerError(y));
              });
            }).catch(function(d) {
              f(n.createInternalServerError(d));
            });
          }).catch(function(d) {
            f(n.createInternalServerError(d));
          }) : h(e);
        }).catch(function(d) {
          f(n.createInternalServerError(d));
        }) : u(e, t).then(function(d) {
          d ? e.getData(d).then(function() {
            e.status === Un.OK ? h(c(e)) : n.authorize(e, t, i, r, a, s, o, u).then(function() {
              h(c(e));
            }).catch(function(y) {
              f(n.createAuthorizationFailedError());
            });
          }).catch(function(y) {
            f(n.createAuthorizationFailedError());
          }) : n.authorize(e, t, i, r, a, s, o, u).then(function() {
            h(c(e));
          }).catch(function(y) {
            f(n.createAuthorizationFailedError());
          });
        }).catch(function(d) {
          f(n.createAuthorizationFailedError());
        });
      });
    }, n.createError = function(e, t) {
      var i = new Error();
      return i.message = t, i.name = String(e), i;
    }, n.createAuthorizationFailedError = function() {
      return n.createError(ks.AUTHORIZATION_FAILED, "Authorization failed");
    }, n.createRestrictedError = function() {
      return n.createError(ks.RESTRICTED, "Restricted");
    }, n.createInternalServerError = function(e) {
      return n.createError(ks.INTERNAL_SERVER_ERROR, e);
    }, n.authorize = function(e, t, i, r, a, s, o, u) {
      return new Promise(function(c, l) {
        e.getData().then(function() {
          e.isAccessControlled() ? u(e, t).then(function(h) {
            h ? e.getData(h).then(function() {
              e.status === Un.OK ? c(e) : n.showAuthInteraction(e, t, i, r, a, s, o, c, l);
            }).catch(function(f) {
              l(n.createInternalServerError(f));
            }) : s(e, !1).then(function(f) {
              f ? o(e, f, t).then(function() {
                e.getData(f).then(function() {
                  e.status === Un.OK ? c(e) : n.showAuthInteraction(e, t, i, r, a, s, o, c, l);
                }).catch(function(d) {
                  l(n.createInternalServerError(d));
                });
              }).catch(function(d) {
                l(n.createInternalServerError(d));
              }) : n.showAuthInteraction(e, t, i, r, a, s, o, c, l);
            });
          }).catch(function(h) {
            l(n.createInternalServerError(h));
          }) : c(e);
        });
      });
    }, n.showAuthInteraction = function(e, t, i, r, a, s, o, u, c) {
      e.status === Un.MOVED_TEMPORARILY && !e.isResponseHandled ? u(e) : e.clickThroughService && !e.isResponseHandled ? i(e).then(function() {
        s(e, !0).then(function(l) {
          o(e, l, t).then(function() {
            e.getData(l).then(function() {
              u(e);
            }).catch(function(h) {
              c(n.createInternalServerError(h));
            });
          }).catch(function(h) {
            c(n.createInternalServerError(h));
          });
        }).catch(function(l) {
          c(n.createInternalServerError(l));
        });
      }) : a(e).then(function() {
        s(e, !0).then(function(l) {
          o(e, l, t).then(function() {
            e.getData(l).then(function() {
              u(e);
            }).catch(function(h) {
              c(n.createInternalServerError(h));
            });
          }).catch(function(h) {
            c(n.createInternalServerError(h));
          });
        }).catch(function(l) {
          c(n.createInternalServerError(l));
        });
      });
    }, n.getService = function(e, t) {
      for (var i = this.getServices(e), r = 0; r < i.length; r++) {
        var a = i[r];
        if (a.getProfile() === t)
          return a;
      }
      return null;
    }, n.getResourceById = function(e, t) {
      return n.traverseAndFind(e.__jsonld, "@id", t);
    }, n.traverseAndFind = function(e, t, i) {
      if (e.hasOwnProperty(t) && e[t] === i)
        return e;
      for (var r = 0; r < Object.keys(e).length; r++)
        if (typeof e[Object.keys(e)[r]] == "object") {
          var a = n.traverseAndFind(e[Object.keys(e)[r]], t, i);
          if (a != null)
            return a;
        }
    }, n.getServices = function(e, t) {
      var i = t === void 0 ? {} : t, r = i.onlyService, a = r === void 0 ? !1 : r, s = i.onlyServices, o = s === void 0 ? !1 : s, u = i.skipParentResources, c = u === void 0 ? !1 : u, l = [];
      !c && e && e.options && e.options.resource && e.options.resource !== e && l.push.apply(l, n.getServices(e.options.resource, { onlyServices: !0 }));
      var h = o ? [] : (e.__jsonld || e).service || [];
      if (Array.isArray(h) || (h = [h]), a || h.push.apply(h, (e.__jsonld || e).services || []), h.length === 0)
        return l;
      for (var f = 0; f < h.length; f++) {
        var d = h[f];
        if (typeof d == "string") {
          var y = this.getResourceById(e.options.resource, d);
          y && l.push(new zb(y.__jsonld || y, e.options));
        } else
          l.push(new zb(d, e.options));
      }
      return l;
    }, n.getTemporalComponent = function(e) {
      var t = /t=([^&]+)/g.exec(e), i = null;
      return t && t[1] && (i = t[1].split(",")), i;
    }, n;
  })()
), U8 = /* @__PURE__ */ (function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var a in r) r.hasOwnProperty(a) && (i[a] = r[a]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
})(), R8 = function() {
  for (var n = 0, e = 0, t = arguments.length; e < t; e++) n += arguments[e].length;
  for (var i = Array(n), r = 0, e = 0; e < t; e++)
    for (var a = arguments[e], s = 0, o = a.length; s < o; s++, r++)
      i[r] = a[s];
  return i;
}, Yr = (
  /** @class */
  (function() {
    function n(e, t, i) {
      i === void 0 && (i = "none"), Array.isArray(e) && e.length === 1 ? this._value = e[0] : this._value = e, (t === "none" || t === "@none") && (t = void 0), this._locale = t, this._defaultLocale = i;
    }
    return n.parseV2Value = function(e, t) {
      return typeof e == "string" ? new n(e, void 0, t) : e["@value"] ? new n(e["@value"], e["@language"], t) : null;
    }, Object.defineProperty(n.prototype, "value", {
      /*** @deprecated Use PropertyValue#getValue instead */
      get: function() {
        return Array.isArray(this._value) ? this._value.join("<br/>") : this._value;
      },
      enumerable: !0,
      configurable: !0
    }), Object.defineProperty(n.prototype, "locale", {
      /*** @deprecated Don't use, only used for backwards compatibility reasons */
      get: function() {
        return this._locale === void 0 ? this._defaultLocale : this._locale;
      },
      enumerable: !0,
      configurable: !0
    }), n.prototype.addValue = function(e) {
      Array.isArray(this._value) || (this._value = [this._value]), Array.isArray(e) ? this._value = this._value.concat(e) : this._value.push(e);
    }, n;
  })()
), Jn = (
  /** @class */
  (function(n) {
    U8(e, n);
    function e(t, i) {
      t === void 0 && (t = []);
      var r = n.apply(this, t) || this;
      return r.__proto__ = e.prototype, r._defaultLocale = i, r;
    }
    return e.parse = function(t, i) {
      if (!t)
        return new e([], i);
      if (Array.isArray(t)) {
        var r = t.map(function(s) {
          return Yr.parseV2Value(s, i);
        }).filter(function(s) {
          return s !== null;
        }), a = r.reduce(function(s, o) {
          var u = o._locale;
          return u || (u = "none"), s[u] ? s[u].addValue(o._value) : s[u] = o, s;
        }, {});
        return new e(Object.values(a), i);
      } else {
        if (typeof t == "string")
          return new e([new Yr(t, void 0, i)], i);
        if (t["@language"]) {
          var r = Yr.parseV2Value(t);
          return new e(r !== null ? [r] : [], i);
        } else if (t["@value"]) {
          var r = Yr.parseV2Value(t);
          return new e(r !== null ? [r] : [], i);
        } else
          return new e(Object.keys(t).map(function(s) {
            var o = t[s];
            if (!Array.isArray(o))
              throw new Error("A IIIF v3 localized property value must have an array as the value for a given language.");
            return new Yr(o, s, i);
          }), i);
      }
    }, e.prototype.getSuitableLocale = function(t) {
      for (var i = R8(this).map(function(d) {
        return d._locale;
      }).filter(function(d) {
        return d !== void 0;
      }), r = function(d) {
        var y = i.find(function(m) {
          return m === d;
        });
        if (y)
          return { value: y };
      }, a = 0, s = t; a < s.length; a++) {
        var o = s[a], u = r(o);
        if (typeof u == "object")
          return u.value;
      }
      for (var c = function(d) {
        var y = i.find(function(m) {
          return st.getInexactLocale(m) === st.getInexactLocale(d);
        });
        if (y)
          return { value: y };
      }, l = 0, h = t; l < h.length; l++) {
        var o = h[l], f = c(o);
        if (typeof f == "object")
          return f.value;
      }
    }, e.prototype.setValue = function(t, i) {
      var r = void 0;
      if (!i)
        r = this.find(function(s) {
          return s._locale === void 0;
        });
      else {
        var a = this.getSuitableLocale([i]);
        a && (r = this.find(function(s) {
          return s._locale === a;
        }));
      }
      r ? r._value = t : this.push(new Yr(t, i, this._defaultLocale));
    }, e.prototype.getValue = function(t, i) {
      var r = this.getValues(t);
      return r.length === 0 ? null : i ? r.join(i) : r[0];
    }, e.prototype.getValues = function(t) {
      if (!this.length)
        return [];
      var i;
      if (t ? Array.isArray(t) ? i = t : i = [t] : i = [], this.length === 1 && this[0]._locale === void 0) {
        var r = this[0]._value;
        return Array.isArray(r) ? r : [r];
      }
      var a = this.getSuitableLocale(i);
      if (a) {
        var r = this.find(function(c) {
          return c._locale === a;
        })._value;
        return Array.isArray(r) ? r : [r];
      }
      var s = !this.find(function(u) {
        return u._locale === void 0;
      });
      if (s) {
        var r = this[0]._value;
        return Array.isArray(r) ? r : [r];
      }
      var o = this.find(function(u) {
        return u._locale === void 0;
      });
      return o ? Array.isArray(o._value) ? o._value : [o._value] : [];
    }, e;
  })(Array)
), O8 = /* @__PURE__ */ (function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var a in r) r.hasOwnProperty(a) && (i[a] = r[a]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
})(), L8 = (
  /** @class */
  (function(n) {
    O8(e, n);
    function e(t, i) {
      var r = n.call(this, t, i) || this;
      if (r.index = 0, r._allRanges = null, r.items = [], r._topRanges = [], r.__jsonld.structures && r.__jsonld.structures.length)
        for (var a = r._getTopRanges(), s = 0; s < a.length; s++) {
          var o = a[s];
          r._parseRanges(o, String(s));
        }
      return r;
    }
    return e.prototype.getPosterCanvas = function() {
      var t = this.getProperty("posterCanvas");
      return t && (t = new Zu(t, this.options)), t;
    }, e.prototype.getAccompanyingCanvas = function() {
      var t = this.getProperty("accompanyingCanvas");
      return t && (t = new Zu(t, this.options)), t;
    }, e.prototype.getBehavior = function() {
      var t = this.getProperty("behavior");
      return Array.isArray(t) && (t = t[0]), t || null;
    }, e.prototype.getDefaultTree = function() {
      if (n.prototype.getDefaultTree.call(this), this.defaultTree.data.type = st.normaliseType(vi.MANIFEST), !this.isLoaded)
        return this.defaultTree;
      var t = this.getTopRanges();
      return t.length && t[0].getTree(this.defaultTree), st.generateTreeNodeIds(this.defaultTree), this.defaultTree;
    }, e.prototype._getTopRanges = function() {
      var t = [];
      if (this.__jsonld.structures && this.__jsonld.structures.length) {
        for (var i = 0; i < this.__jsonld.structures.length; i++) {
          var r = this.__jsonld.structures[i];
          r.viewingHint === qe.ViewingHint.TOP && t.push(r);
        }
        if (!t.length) {
          var a = {};
          a.ranges = this.__jsonld.structures, t.push(a);
        }
      }
      return t;
    }, e.prototype.getTopRanges = function() {
      return this._topRanges;
    }, e.prototype._getRangeById = function(t) {
      if (this.__jsonld.structures && this.__jsonld.structures.length)
        for (var i = 0; i < this.__jsonld.structures.length; i++) {
          var r = this.__jsonld.structures[i];
          if (r["@id"] === t || r.id === t)
            return r;
        }
      return null;
    }, e.prototype._parseRanges = function(t, i, r) {
      var a, s = null;
      if (typeof t == "string" && (s = t, t = this._getRangeById(s)), !t) {
        console.warn("Range:", s, "does not exist");
        return;
      }
      a = new F8(t, this.options), a.parentRange = r, a.path = i, r ? r.items.push(a) : this._topRanges.push(a);
      var o = t.items || t.members;
      if (o)
        for (var u = 0; u < o.length; u++) {
          var c = o[u];
          if (c["@type"] && c["@type"].toLowerCase() === "sc:range" || c.type && c.type.toLowerCase() === "range")
            this._parseRanges(c, i + "/" + u, a);
          else if (c["@type"] && c["@type"].toLowerCase() === "sc:canvas" || c.type && c.type.toLowerCase() === "canvas") {
            a.canvases || (a.canvases = []);
            var l = c.id || c["@id"];
            a.canvases.push(l);
          }
        }
      else if (t.ranges)
        for (var u = 0; u < t.ranges.length; u++)
          this._parseRanges(t.ranges[u], i + "/" + u, a);
    }, e.prototype.getAllRanges = function() {
      if (this._allRanges != null)
        return this._allRanges;
      this._allRanges = [];
      for (var t = this.getTopRanges(), i = function(s) {
        var o = t[s];
        o.id && r._allRanges.push(o);
        var u = function(l, h) {
          l.add(h);
          var f = h.getRanges();
          return f.length ? f.reduce(u, l) : l;
        }, c = Array.from(o.getRanges().reduce(u, /* @__PURE__ */ new Set()));
        r._allRanges = r._allRanges.concat(c);
      }, r = this, a = 0; a < t.length; a++)
        i(a);
      return this._allRanges;
    }, e.prototype.getRangeById = function(t) {
      for (var i = this.getAllRanges(), r = 0; r < i.length; r++) {
        var a = i[r];
        if (a.id === t)
          return a;
      }
      return null;
    }, e.prototype.getRangeByPath = function(t) {
      for (var i = this.getAllRanges(), r = 0; r < i.length; r++) {
        var a = i[r];
        if (a.path === t)
          return a;
      }
      return null;
    }, e.prototype.getSequences = function() {
      if (this.items.length)
        return this.items;
      var t = this.__jsonld.mediaSequences || this.__jsonld.sequences;
      if (t)
        for (var i = 0; i < t.length; i++) {
          var r = t[i], a = new Hb(r, this.options);
          this.items.push(a);
        }
      else if (this.__jsonld.items) {
        var a = new Hb(this.__jsonld.items, this.options);
        this.items.push(a);
      }
      return this.items;
    }, e.prototype.getSequenceByIndex = function(t) {
      return this.getSequences()[t];
    }, e.prototype.getTotalSequences = function() {
      return this.getSequences().length;
    }, e.prototype.getManifestType = function() {
      var t = this.getService(qe.ServiceProfile.UI_EXTENSIONS);
      return t ? t.getProperty("manifestType") : Xp.EMPTY;
    }, e.prototype.isMultiSequence = function() {
      return this.getTotalSequences() > 1;
    }, e.prototype.isPagingEnabled = function() {
      var t = this.getViewingHint();
      if (t)
        return t === qe.ViewingHint.PAGED;
      var i = this.getBehavior();
      return i ? i === qe.Behavior.PAGED : !1;
    }, e.prototype.getViewingDirection = function() {
      return this.getProperty("viewingDirection");
    }, e.prototype.getViewingHint = function() {
      return this.getProperty("viewingHint");
    }, e;
  })(ET)
), Xp;
(function(n) {
  n.EMPTY = "", n.MANUSCRIPT = "manuscript", n.MONOGRAPH = "monograph";
})(Xp || (Xp = {}));
var P8 = /* @__PURE__ */ (function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var a in r) r.hasOwnProperty(a) && (i[a] = r[a]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
})(), F8 = (
  /** @class */
  (function(n) {
    P8(e, n);
    function e(t, i) {
      var r = n.call(this, t, i) || this;
      return r._ranges = null, r.canvases = null, r.items = [], r;
    }
    return e.prototype.getCanvasIds = function() {
      return this.__jsonld.canvases ? this.__jsonld.canvases : this.canvases ? this.canvases : [];
    }, e.prototype.getDuration = function() {
      if (this.canvases && this.canvases.length) {
        for (var t = [], i = [], r = 0, a = this.canvases; r < a.length; r++) {
          var s = a[r];
          if (s) {
            var o = s.match(/(.*)#t=([0-9.]+),?([0-9.]+)?/) || [void 0, s], u = o[1], c = o[2], l = o[3];
            u && (t.push(parseFloat(c)), i.push(parseFloat(l)));
          }
        }
        if (t.length && i.length)
          return new ld(Math.min.apply(Math, t), Math.max.apply(Math, i));
      } else {
        for (var h = this.getRanges(), t = [], i = [], f = 0, d = h; f < d.length; f++) {
          var y = d[f], m = y.getDuration();
          m && (t.push(m.start), i.push(m.end));
        }
        if (t.length && i.length)
          return new ld(Math.min.apply(Math, t), Math.max.apply(Math, i));
      }
      var b, p;
      if (this.canvases && this.canvases.length)
        for (var g = 0; g < this.canvases.length; g++) {
          var s = this.canvases[g], v = st.getTemporalComponent(s);
          v && v.length > 1 && (g === 0 && (b = Number(v[0])), g === this.canvases.length - 1 && (p = Number(v[1])));
        }
      else
        for (var h = this.getRanges(), g = 0; g < h.length; g++) {
          var y = h[g], m = y.getDuration();
          m && (g === 0 && (b = m.start), g === h.length - 1 && (p = m.end));
        }
      if (b !== void 0 && p !== void 0)
        return new ld(b, p);
    }, e.prototype.getRanges = function() {
      return this._ranges ? this._ranges : this._ranges = this.items.filter(function(t) {
        return t.isRange();
      });
    }, e.prototype.getBehavior = function() {
      var t = this.getProperty("behavior");
      return Array.isArray(t) && (t = t[0]), t || null;
    }, e.prototype.getViewingDirection = function() {
      return this.getProperty("viewingDirection");
    }, e.prototype.getViewingHint = function() {
      return this.getProperty("viewingHint");
    }, e.prototype.getTree = function(t) {
      t.data = this, this.treeNode = t;
      var i = this.getRanges();
      if (i && i.length)
        for (var r = 0; r < i.length; r++) {
          var a = i[r], s = new Kp();
          t.addNode(s), this._parseTreeNode(s, a);
        }
      return st.generateTreeNodeIds(t), t;
    }, e.prototype.spansTime = function(t) {
      var i = this.getDuration();
      return !!(i && t >= i.start && t <= i.end);
    }, e.prototype._parseTreeNode = function(t, i) {
      t.label = i.getLabel().getValue(this.options.locale), t.data = i, t.data.type = st.normaliseType(vi.RANGE), i.treeNode = t;
      var r = i.getRanges();
      if (r && r.length)
        for (var a = 0; a < r.length; a++) {
          var s = r[a], o = s.getBehavior();
          if (o !== qe.Behavior.NO_NAV) {
            var u = new Kp();
            t.addNode(u), this._parseTreeNode(u, s);
          }
        }
    }, e;
  })(Ni)
), N8 = /* @__PURE__ */ (function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var a in r) r.hasOwnProperty(a) && (i[a] = r[a]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
})(), M8 = (
  /** @class */
  (function(n) {
    N8(e, n);
    function e(t, i) {
      return n.call(this, t, i) || this;
    }
    return e.prototype.getFormat = function() {
      return this.getProperty("format");
    }, e;
  })(Ni)
), B8 = /* @__PURE__ */ (function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var a in r) r.hasOwnProperty(a) && (i[a] = r[a]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
})(), Hb = (
  /** @class */
  (function(n) {
    B8(e, n);
    function e(t, i) {
      var r = n.call(this, t, i) || this;
      return r.items = [], r._thumbnails = null, r;
    }
    return e.prototype.getCanvases = function() {
      if (this.items.length)
        return this.items;
      var t = this.__jsonld.canvases || this.__jsonld.elements;
      if (t)
        for (var i = 0; i < t.length; i++) {
          var r = t[i], a = new Zu(r, this.options);
          a.index = i, this.items.push(a);
        }
      else if (this.__jsonld)
        for (var i = 0; i < this.__jsonld.length; i++) {
          var r = this.__jsonld[i], a = new Zu(r, this.options);
          a.index = i, this.items.push(a);
        }
      return this.items;
    }, e.prototype.getCanvasById = function(t) {
      for (var i = 0; i < this.getTotalCanvases(); i++) {
        var r = this.getCanvasByIndex(i), a = st.normaliseUrl(r.id);
        if (st.normaliseUrl(t) === a)
          return r;
      }
      return null;
    }, e.prototype.getCanvasByIndex = function(t) {
      return this.getCanvases()[t];
    }, e.prototype.getCanvasIndexById = function(t) {
      for (var i = 0; i < this.getTotalCanvases(); i++) {
        var r = this.getCanvasByIndex(i);
        if (r.id === t)
          return i;
      }
      return null;
    }, e.prototype.getCanvasIndexByLabel = function(t, i) {
      t = t.trim(), isNaN(t) || (t = parseInt(t, 10).toString(), i && (t += "r"));
      for (var r = /(\d*)\D+(\d*)/, a, s, o, u, c, l = 0; l < this.getTotalCanvases(); l++) {
        var h = this.getCanvasByIndex(l);
        if (h.getLabel().getValue(this.options.locale) === t)
          return l;
        if (a = r.exec(t), !!a && (u = a[1], c = a[2], !!c && (o = "^" + u + "\\D+" + c + "$", s = new RegExp(o), s.test(h.getLabel().toString()))))
          return l;
      }
      return -1;
    }, e.prototype.getLastCanvasLabel = function(t) {
      for (var i = this.getTotalCanvases() - 1; i >= 0; i--) {
        var r = this.getCanvasByIndex(i), a = r.getLabel().getValue(this.options.locale);
        if (t) {
          var s = /^[a-zA-Z0-9]*$/;
          if (s.test(a))
            return a;
        } else if (a)
          return a;
      }
      return this.options.defaultLabel;
    }, e.prototype.getLastPageIndex = function() {
      return this.getTotalCanvases() - 1;
    }, e.prototype.getNextPageIndex = function(t, i) {
      var r;
      if (i) {
        var a = this.getPagedIndices(t), s = this.getViewingDirection();
        s && s === qe.ViewingDirection.RIGHT_TO_LEFT ? r = a[0] + 1 : r = a[a.length - 1] + 1;
      } else
        r = t + 1;
      return r > this.getLastPageIndex() ? -1 : r;
    }, e.prototype.getPagedIndices = function(t, i) {
      var r = [];
      if (!i)
        r.push(t);
      else {
        this.isFirstCanvas(t) || this.isLastCanvas(t) ? r = [t] : t % 2 ? r = [t, t + 1] : r = [t - 1, t];
        var a = this.getViewingDirection();
        a && a === qe.ViewingDirection.RIGHT_TO_LEFT && (r = r.reverse());
      }
      return r;
    }, e.prototype.getPrevPageIndex = function(t, i) {
      var r;
      if (i) {
        var a = this.getPagedIndices(t), s = this.getViewingDirection();
        s && s === qe.ViewingDirection.RIGHT_TO_LEFT ? r = a[a.length - 1] - 1 : r = a[0] - 1;
      } else
        r = t - 1;
      return r;
    }, e.prototype.getStartCanvasIndex = function() {
      var t = this.getStartCanvas();
      if (t)
        for (var i = 0; i < this.getTotalCanvases(); i++) {
          var r = this.getCanvasByIndex(i);
          if (r.id === t)
            return i;
        }
      return 0;
    }, e.prototype.getThumbs = function(t, i) {
      for (var r = [], a = this.getTotalCanvases(), s = 0; s < a; s++) {
        var o = this.getCanvasByIndex(s), u = new W8(t, o);
        r.push(u);
      }
      return r;
    }, e.prototype.getThumbnails = function() {
      if (this._thumbnails != null)
        return this._thumbnails;
      this._thumbnails = [];
      for (var t = this.getCanvases(), i = 0; i < t.length; i++) {
        var r = t[i].getThumbnail();
        r && this._thumbnails.push(r);
      }
      return this._thumbnails;
    }, e.prototype.getStartCanvas = function() {
      return this.getProperty("startCanvas");
    }, e.prototype.getTotalCanvases = function() {
      return this.getCanvases().length;
    }, e.prototype.getViewingDirection = function() {
      return this.getProperty("viewingDirection") ? this.getProperty("viewingDirection") : this.options.resource.getViewingDirection ? this.options.resource.getViewingDirection() : null;
    }, e.prototype.getViewingHint = function() {
      return this.getProperty("viewingHint");
    }, e.prototype.isCanvasIndexOutOfRange = function(t) {
      return t > this.getTotalCanvases() - 1;
    }, e.prototype.isFirstCanvas = function(t) {
      return t === 0;
    }, e.prototype.isLastCanvas = function(t) {
      return t === this.getTotalCanvases() - 1;
    }, e.prototype.isMultiCanvas = function() {
      return this.getTotalCanvases() > 1;
    }, e.prototype.isPagingEnabled = function() {
      var t = this.getViewingHint();
      return t ? t === qe.ViewingHint.PAGED : !1;
    }, e.prototype.isTotalCanvasesEven = function() {
      return this.getTotalCanvases() % 2 === 0;
    }, e;
  })(Ni)
), kT = (
  /** @class */
  (function() {
    function n() {
    }
    return n.parse = function(e, t) {
      return typeof e == "string" && (e = JSON.parse(e)), this.parseJson(e, t);
    }, n.parseJson = function(e, t) {
      var i;
      if (t && t.navDate && !isNaN(t.navDate.getTime()) && (e.navDate = t.navDate.toString()), e["@type"])
        switch (e["@type"]) {
          case "sc:Collection":
            i = this.parseCollection(e, t);
            break;
          case "sc:Manifest":
            i = this.parseManifest(e, t);
            break;
          default:
            return null;
        }
      else
        switch (e.type) {
          case "Collection":
            i = this.parseCollection(e, t);
            break;
          case "Manifest":
            i = this.parseManifest(e, t);
            break;
          default:
            return null;
        }
      return i.isLoaded = !0, i;
    }, n.parseCollection = function(e, t) {
      var i = new D8(e, t);
      return t ? (i.index = t.index || 0, t.resource && (i.parentCollection = t.resource.parentCollection)) : i.index = 0, this.parseCollections(i, t), this.parseManifests(i, t), this.parseItems(i, t), i;
    }, n.parseCollections = function(e, t) {
      var i;
      if (e.__jsonld.collections ? i = e.__jsonld.collections : e.__jsonld.items && (i = e.__jsonld.items.filter(function(s) {
        return s.type.toLowerCase() === "collection";
      })), i)
        for (var r = 0; r < i.length; r++) {
          t && (t.index = r);
          var a = this.parseCollection(i[r], t);
          a.index = r, a.parentCollection = e, e.items.push(a);
        }
    }, n.parseManifest = function(e, t) {
      var i = new L8(e, t);
      return i;
    }, n.parseManifests = function(e, t) {
      var i;
      if (e.__jsonld.manifests ? i = e.__jsonld.manifests : e.__jsonld.items && (i = e.__jsonld.items.filter(function(s) {
        return s.type.toLowerCase() === "manifest";
      })), i)
        for (var r = 0; r < i.length; r++) {
          var a = this.parseManifest(i[r], t);
          a.index = r, a.parentCollection = e, e.items.push(a);
        }
    }, n.parseItem = function(e, t) {
      if (e["@type"]) {
        if (e["@type"].toLowerCase() === "sc:manifest")
          return this.parseManifest(e, t);
        if (e["@type"].toLowerCase() === "sc:collection")
          return this.parseCollection(e, t);
      } else if (e.type) {
        if (e.type.toLowerCase() === "manifest")
          return this.parseManifest(e, t);
        if (e.type.toLowerCase() === "collection")
          return this.parseCollection(e, t);
      }
      return null;
    }, n.parseItems = function(e, t) {
      var i = e.__jsonld.members || e.__jsonld.items;
      if (i)
        for (var r = function(u) {
          t && (t.index = u);
          var c = a.parseItem(i[u], t);
          if (!c)
            return { value: void 0 };
          if (e.items.filter(function(l) {
            return l.id === c.id;
          })[0])
            return "continue";
          c.index = u, c.parentCollection = e, e.items.push(c);
        }, a = this, s = 0; s < i.length; s++) {
          var o = r(s);
          if (typeof o == "object")
            return o.value;
        }
    }, n;
  })()
), j8 = /* @__PURE__ */ (function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var a in r) r.hasOwnProperty(a) && (i[a] = r[a]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
})(), zb = (
  /** @class */
  (function(n) {
    j8(e, n);
    function e(t, i) {
      return n.call(this, t, i) || this;
    }
    return e.prototype.getProfile = function() {
      var t = this.getProperty("profile");
      return t || (t = this.getProperty("dcterms:conformsTo")), Array.isArray(t) ? t[0] : t;
    }, e.prototype.getConfirmLabel = function() {
      return st.getLocalisedValue(this.getProperty("confirmLabel"), this.options.locale);
    }, e.prototype.getDescription = function() {
      return st.getLocalisedValue(this.getProperty("description"), this.options.locale);
    }, e.prototype.getFailureDescription = function() {
      return st.getLocalisedValue(this.getProperty("failureDescription"), this.options.locale);
    }, e.prototype.getFailureHeader = function() {
      return st.getLocalisedValue(this.getProperty("failureHeader"), this.options.locale);
    }, e.prototype.getHeader = function() {
      return st.getLocalisedValue(this.getProperty("header"), this.options.locale);
    }, e.prototype.getServiceLabel = function() {
      return st.getLocalisedValue(this.getProperty("label"), this.options.locale);
    }, e.prototype.getInfoUri = function() {
      var t = this.id;
      return t.endsWith("/") || (t += "/"), t += "info.json", t;
    }, e;
  })(Ni)
), q8 = (
  /** @class */
  /* @__PURE__ */ (function() {
    function n(e, t) {
      this.width = e, this.height = t;
    }
    return n;
  })()
), ks;
(function(n) {
  n[n.AUTHORIZATION_FAILED = 1] = "AUTHORIZATION_FAILED", n[n.FORBIDDEN = 2] = "FORBIDDEN", n[n.INTERNAL_SERVER_ERROR = 3] = "INTERNAL_SERVER_ERROR", n[n.RESTRICTED = 4] = "RESTRICTED";
})(ks || (ks = {}));
var W8 = (
  /** @class */
  /* @__PURE__ */ (function() {
    function n(e, t) {
      this.data = t, this.index = t.index, this.width = e;
      var i = t.getHeight() / t.getWidth();
      i ? this.height = Math.floor(this.width * i) : this.height = e, this.uri = t.getCanonicalImageUri(e), this.label = t.getLabel().getValue(), this.viewingHint = t.getViewingHint();
    }
    return n;
  })()
), V8 = /* @__PURE__ */ (function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var a in r) r.hasOwnProperty(a) && (i[a] = r[a]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
})(), H8 = (
  /** @class */
  (function(n) {
    V8(e, n);
    function e(t, i) {
      return n.call(this, t, i) || this;
    }
    return e;
  })(qm)
), Kp = (
  /** @class */
  (function() {
    function n(e, t) {
      this.label = e, this.data = t || {}, this.nodes = [];
    }
    return n.prototype.addNode = function(e) {
      this.nodes.push(e), e.parentNode = this;
    }, n.prototype.isCollection = function() {
      return this.data.type === st.normaliseType(vi.COLLECTION);
    }, n.prototype.isManifest = function() {
      return this.data.type === st.normaliseType(vi.MANIFEST);
    }, n.prototype.isRange = function() {
      return this.data.type === st.normaliseType(vi.RANGE);
    }, n;
  })()
), vi;
(function(n) {
  n.COLLECTION = "collection", n.MANIFEST = "manifest", n.RANGE = "range";
})(vi || (vi = {}));
var z8 = function(n, e) {
  return st.parseManifest(n, e);
};
const $8 = {
  "application/1d-interleaved-parityfec": { source: "iana" },
  "application/3gpdash-qoe-report+xml": { source: "iana", charset: "UTF-8", compressible: !0 },
  "application/3gpp-ims+xml": { source: "iana", compressible: !0 },
  "application/3gpphal+json": { source: "iana", compressible: !0 },
  "application/3gpphalforms+json": { source: "iana", compressible: !0 },
  "application/a2l": { source: "iana" },
  "application/ace+cbor": { source: "iana" },
  "application/activemessage": { source: "iana" },
  "application/activity+json": { source: "iana", compressible: !0 },
  "application/alto-costmap+json": { source: "iana", compressible: !0 },
  "application/alto-costmapfilter+json": { source: "iana", compressible: !0 },
  "application/alto-directory+json": { source: "iana", compressible: !0 },
  "application/alto-endpointcost+json": { source: "iana", compressible: !0 },
  "application/alto-endpointcostparams+json": { source: "iana", compressible: !0 },
  "application/alto-endpointprop+json": { source: "iana", compressible: !0 },
  "application/alto-endpointpropparams+json": { source: "iana", compressible: !0 },
  "application/alto-error+json": { source: "iana", compressible: !0 },
  "application/alto-networkmap+json": { source: "iana", compressible: !0 },
  "application/alto-networkmapfilter+json": { source: "iana", compressible: !0 },
  "application/alto-updatestreamcontrol+json": { source: "iana", compressible: !0 },
  "application/alto-updatestreamparams+json": { source: "iana", compressible: !0 },
  "application/aml": { source: "iana" },
  "application/andrew-inset": { source: "iana", extensions: ["ez"] },
  "application/applefile": { source: "iana" },
  "application/applixware": { source: "apache", extensions: ["aw"] },
  "application/at+jwt": { source: "iana" },
  "application/atf": { source: "iana" },
  "application/atfx": { source: "iana" },
  "application/atom+xml": { source: "iana", compressible: !0, extensions: ["atom"] },
  "application/atomcat+xml": { source: "iana", compressible: !0, extensions: ["atomcat"] },
  "application/atomdeleted+xml": { source: "iana", compressible: !0, extensions: ["atomdeleted"] },
  "application/atomicmail": { source: "iana" },
  "application/atomsvc+xml": { source: "iana", compressible: !0, extensions: ["atomsvc"] },
  "application/atsc-dwd+xml": { source: "iana", compressible: !0, extensions: ["dwd"] },
  "application/atsc-dynamic-event-message": { source: "iana" },
  "application/atsc-held+xml": { source: "iana", compressible: !0, extensions: ["held"] },
  "application/atsc-rdt+json": { source: "iana", compressible: !0 },
  "application/atsc-rsat+xml": { source: "iana", compressible: !0, extensions: ["rsat"] },
  "application/atxml": { source: "iana" },
  "application/auth-policy+xml": { source: "iana", compressible: !0 },
  "application/bacnet-xdd+zip": { source: "iana", compressible: !1 },
  "application/batch-smtp": { source: "iana" },
  "application/bdoc": { compressible: !1, extensions: ["bdoc"] },
  "application/beep+xml": { source: "iana", charset: "UTF-8", compressible: !0 },
  "application/calendar+json": { source: "iana", compressible: !0 },
  "application/calendar+xml": { source: "iana", compressible: !0, extensions: ["xcs"] },
  "application/call-completion": { source: "iana" },
  "application/cals-1840": { source: "iana" },
  "application/captive+json": { source: "iana", compressible: !0 },
  "application/cbor": { source: "iana" },
  "application/cbor-seq": { source: "iana" },
  "application/cccex": { source: "iana" },
  "application/ccmp+xml": { source: "iana", compressible: !0 },
  "application/ccxml+xml": { source: "iana", compressible: !0, extensions: ["ccxml"] },
  "application/cdfx+xml": { source: "iana", compressible: !0, extensions: ["cdfx"] },
  "application/cdmi-capability": { source: "iana", extensions: ["cdmia"] },
  "application/cdmi-container": { source: "iana", extensions: ["cdmic"] },
  "application/cdmi-domain": { source: "iana", extensions: ["cdmid"] },
  "application/cdmi-object": { source: "iana", extensions: ["cdmio"] },
  "application/cdmi-queue": { source: "iana", extensions: ["cdmiq"] },
  "application/cdni": { source: "iana" },
  "application/cea": { source: "iana" },
  "application/cea-2018+xml": { source: "iana", compressible: !0 },
  "application/cellml+xml": { source: "iana", compressible: !0 },
  "application/cfw": { source: "iana" },
  "application/city+json": { source: "iana", compressible: !0 },
  "application/clr": { source: "iana" },
  "application/clue+xml": { source: "iana", compressible: !0 },
  "application/clue_info+xml": { source: "iana", compressible: !0 },
  "application/cms": { source: "iana" },
  "application/cnrp+xml": { source: "iana", compressible: !0 },
  "application/coap-group+json": { source: "iana", compressible: !0 },
  "application/coap-payload": { source: "iana" },
  "application/commonground": { source: "iana" },
  "application/conference-info+xml": { source: "iana", compressible: !0 },
  "application/cose": { source: "iana" },
  "application/cose-key": { source: "iana" },
  "application/cose-key-set": { source: "iana" },
  "application/cpl+xml": { source: "iana", compressible: !0, extensions: ["cpl"] },
  "application/csrattrs": { source: "iana" },
  "application/csta+xml": { source: "iana", compressible: !0 },
  "application/cstadata+xml": { source: "iana", compressible: !0 },
  "application/csvm+json": { source: "iana", compressible: !0 },
  "application/cu-seeme": { source: "apache", extensions: ["cu"] },
  "application/cwt": { source: "iana" },
  "application/cybercash": { source: "iana" },
  "application/dart": { compressible: !0 },
  "application/dash+xml": { source: "iana", compressible: !0, extensions: ["mpd"] },
  "application/dash-patch+xml": { source: "iana", compressible: !0, extensions: ["mpp"] },
  "application/dashdelta": { source: "iana" },
  "application/davmount+xml": { source: "iana", compressible: !0, extensions: ["davmount"] },
  "application/dca-rft": { source: "iana" },
  "application/dcd": { source: "iana" },
  "application/dec-dx": { source: "iana" },
  "application/dialog-info+xml": { source: "iana", compressible: !0 },
  "application/dicom": { source: "iana" },
  "application/dicom+json": { source: "iana", compressible: !0 },
  "application/dicom+xml": { source: "iana", compressible: !0 },
  "application/dii": { source: "iana" },
  "application/dit": { source: "iana" },
  "application/dns": { source: "iana" },
  "application/dns+json": { source: "iana", compressible: !0 },
  "application/dns-message": { source: "iana" },
  "application/docbook+xml": { source: "apache", compressible: !0, extensions: ["dbk"] },
  "application/dots+cbor": { source: "iana" },
  "application/dskpp+xml": { source: "iana", compressible: !0 },
  "application/dssc+der": { source: "iana", extensions: ["dssc"] },
  "application/dssc+xml": { source: "iana", compressible: !0, extensions: ["xdssc"] },
  "application/dvcs": { source: "iana" },
  "application/ecmascript": { source: "iana", compressible: !0, extensions: ["es", "ecma"] },
  "application/edi-consent": { source: "iana" },
  "application/edi-x12": { source: "iana", compressible: !1 },
  "application/edifact": { source: "iana", compressible: !1 },
  "application/efi": { source: "iana" },
  "application/elm+json": { source: "iana", charset: "UTF-8", compressible: !0 },
  "application/elm+xml": { source: "iana", compressible: !0 },
  "application/emergencycalldata.cap+xml": { source: "iana", charset: "UTF-8", compressible: !0 },
  "application/emergencycalldata.comment+xml": { source: "iana", compressible: !0 },
  "application/emergencycalldata.control+xml": { source: "iana", compressible: !0 },
  "application/emergencycalldata.deviceinfo+xml": { source: "iana", compressible: !0 },
  "application/emergencycalldata.ecall.msd": { source: "iana" },
  "application/emergencycalldata.providerinfo+xml": { source: "iana", compressible: !0 },
  "application/emergencycalldata.serviceinfo+xml": { source: "iana", compressible: !0 },
  "application/emergencycalldata.subscriberinfo+xml": { source: "iana", compressible: !0 },
  "application/emergencycalldata.veds+xml": { source: "iana", compressible: !0 },
  "application/emma+xml": { source: "iana", compressible: !0, extensions: ["emma"] },
  "application/emotionml+xml": { source: "iana", compressible: !0, extensions: ["emotionml"] },
  "application/encaprtp": { source: "iana" },
  "application/epp+xml": { source: "iana", compressible: !0 },
  "application/epub+zip": { source: "iana", compressible: !1, extensions: ["epub"] },
  "application/eshop": { source: "iana" },
  "application/exi": { source: "iana", extensions: ["exi"] },
  "application/expect-ct-report+json": { source: "iana", compressible: !0 },
  "application/express": { source: "iana", extensions: ["exp"] },
  "application/fastinfoset": { source: "iana" },
  "application/fastsoap": { source: "iana" },
  "application/fdt+xml": { source: "iana", compressible: !0, extensions: ["fdt"] },
  "application/fhir+json": { source: "iana", charset: "UTF-8", compressible: !0 },
  "application/fhir+xml": { source: "iana", charset: "UTF-8", compressible: !0 },
  "application/fido.trusted-apps+json": { compressible: !0 },
  "application/fits": { source: "iana" },
  "application/flexfec": { source: "iana" },
  "application/font-sfnt": { source: "iana" },
  "application/font-tdpfr": { source: "iana", extensions: ["pfr"] },
  "application/font-woff": { source: "iana", compressible: !1 },
  "application/framework-attributes+xml": { source: "iana", compressible: !0 },
  "application/geo+json": { source: "iana", compressible: !0, extensions: ["geojson"] },
  "application/geo+json-seq": { source: "iana" },
  "application/geopackage+sqlite3": { source: "iana" },
  "application/geoxacml+xml": { source: "iana", compressible: !0 },
  "application/gltf-buffer": { source: "iana" },
  "application/gml+xml": { source: "iana", compressible: !0, extensions: ["gml"] },
  "application/gpx+xml": { source: "apache", compressible: !0, extensions: ["gpx"] },
  "application/gxf": { source: "apache", extensions: ["gxf"] },
  "application/gzip": { source: "iana", compressible: !1, extensions: ["gz"] },
  "application/h224": { source: "iana" },
  "application/held+xml": { source: "iana", compressible: !0 },
  "application/hjson": { extensions: ["hjson"] },
  "application/http": { source: "iana" },
  "application/hyperstudio": { source: "iana", extensions: ["stk"] },
  "application/ibe-key-request+xml": { source: "iana", compressible: !0 },
  "application/ibe-pkg-reply+xml": { source: "iana", compressible: !0 },
  "application/ibe-pp-data": { source: "iana" },
  "application/iges": { source: "iana" },
  "application/im-iscomposing+xml": { source: "iana", charset: "UTF-8", compressible: !0 },
  "application/index": { source: "iana" },
  "application/index.cmd": { source: "iana" },
  "application/index.obj": { source: "iana" },
  "application/index.response": { source: "iana" },
  "application/index.vnd": { source: "iana" },
  "application/inkml+xml": { source: "iana", compressible: !0, extensions: ["ink", "inkml"] },
  "application/iotp": { source: "iana" },
  "application/ipfix": { source: "iana", extensions: ["ipfix"] },
  "application/ipp": { source: "iana" },
  "application/isup": { source: "iana" },
  "application/its+xml": { source: "iana", compressible: !0, extensions: ["its"] },
  "application/java-archive": { source: "apache", compressible: !1, extensions: ["jar", "war", "ear"] },
  "application/java-serialized-object": { source: "apache", compressible: !1, extensions: ["ser"] },
  "application/java-vm": { source: "apache", compressible: !1, extensions: ["class"] },
  "application/javascript": { source: "iana", charset: "UTF-8", compressible: !0, extensions: ["js", "mjs"] },
  "application/jf2feed+json": { source: "iana", compressible: !0 },
  "application/jose": { source: "iana" },
  "application/jose+json": { source: "iana", compressible: !0 },
  "application/jrd+json": { source: "iana", compressible: !0 },
  "application/jscalendar+json": { source: "iana", compressible: !0 },
  "application/json": { source: "iana", charset: "UTF-8", compressible: !0, extensions: ["json", "map"] },
  "application/json-patch+json": { source: "iana", compressible: !0 },
  "application/json-seq": { source: "iana" },
  "application/json5": { extensions: ["json5"] },
  "application/jsonml+json": { source: "apache", compressible: !0, extensions: ["jsonml"] },
  "application/jwk+json": { source: "iana", compressible: !0 },
  "application/jwk-set+json": { source: "iana", compressible: !0 },
  "application/jwt": { source: "iana" },
  "application/kpml-request+xml": { source: "iana", compressible: !0 },
  "application/kpml-response+xml": { source: "iana", compressible: !0 },
  "application/ld+json": { source: "iana", compressible: !0, extensions: ["jsonld"] },
  "application/lgr+xml": { source: "iana", compressible: !0, extensions: ["lgr"] },
  "application/link-format": { source: "iana" },
  "application/load-control+xml": { source: "iana", compressible: !0 },
  "application/lost+xml": { source: "iana", compressible: !0, extensions: ["lostxml"] },
  "application/lostsync+xml": { source: "iana", compressible: !0 },
  "application/lpf+zip": { source: "iana", compressible: !1 },
  "application/lxf": { source: "iana" },
  "application/mac-binhex40": { source: "iana", extensions: ["hqx"] },
  "application/mac-compactpro": { source: "apache", extensions: ["cpt"] },
  "application/macwriteii": { source: "iana" },
  "application/mads+xml": { source: "iana", compressible: !0, extensions: ["mads"] },
  "application/manifest+json": { source: "iana", charset: "UTF-8", compressible: !0, extensions: ["webmanifest"] },
  "application/marc": { source: "iana", extensions: ["mrc"] },
  "application/marcxml+xml": { source: "iana", compressible: !0, extensions: ["mrcx"] },
  "application/mathematica": { source: "iana", extensions: ["ma", "nb", "mb"] },
  "application/mathml+xml": { source: "iana", compressible: !0, extensions: ["mathml"] },
  "application/mathml-content+xml": { source: "iana", compressible: !0 },
  "application/mathml-presentation+xml": { source: "iana", compressible: !0 },
  "application/mbms-associated-procedure-description+xml": { source: "iana", compressible: !0 },
  "application/mbms-deregister+xml": { source: "iana", compressible: !0 },
  "application/mbms-envelope+xml": { source: "iana", compressible: !0 },
  "application/mbms-msk+xml": { source: "iana", compressible: !0 },
  "application/mbms-msk-response+xml": { source: "iana", compressible: !0 },
  "application/mbms-protection-description+xml": { source: "iana", compressible: !0 },
  "application/mbms-reception-report+xml": { source: "iana", compressible: !0 },
  "application/mbms-register+xml": { source: "iana", compressible: !0 },
  "application/mbms-register-response+xml": { source: "iana", compressible: !0 },
  "application/mbms-schedule+xml": { source: "iana", compressible: !0 },
  "application/mbms-user-service-description+xml": { source: "iana", compressible: !0 },
  "application/mbox": { source: "iana", extensions: ["mbox"] },
  "application/media-policy-dataset+xml": { source: "iana", compressible: !0, extensions: ["mpf"] },
  "application/media_control+xml": { source: "iana", compressible: !0 },
  "application/mediaservercontrol+xml": { source: "iana", compressible: !0, extensions: ["mscml"] },
  "application/merge-patch+json": { source: "iana", compressible: !0 },
  "application/metalink+xml": { source: "apache", compressible: !0, extensions: ["metalink"] },
  "application/metalink4+xml": { source: "iana", compressible: !0, extensions: ["meta4"] },
  "application/mets+xml": { source: "iana", compressible: !0, extensions: ["mets"] },
  "application/mf4": { source: "iana" },
  "application/mikey": { source: "iana" },
  "application/mipc": { source: "iana" },
  "application/missing-blocks+cbor-seq": { source: "iana" },
  "application/mmt-aei+xml": { source: "iana", compressible: !0, extensions: ["maei"] },
  "application/mmt-usd+xml": { source: "iana", compressible: !0, extensions: ["musd"] },
  "application/mods+xml": { source: "iana", compressible: !0, extensions: ["mods"] },
  "application/moss-keys": { source: "iana" },
  "application/moss-signature": { source: "iana" },
  "application/mosskey-data": { source: "iana" },
  "application/mosskey-request": { source: "iana" },
  "application/mp21": { source: "iana", extensions: ["m21", "mp21"] },
  "application/mp4": { source: "iana", extensions: ["mp4s", "m4p"] },
  "application/mpeg4-generic": { source: "iana" },
  "application/mpeg4-iod": { source: "iana" },
  "application/mpeg4-iod-xmt": { source: "iana" },
  "application/mrb-consumer+xml": { source: "iana", compressible: !0 },
  "application/mrb-publish+xml": { source: "iana", compressible: !0 },
  "application/msc-ivr+xml": { source: "iana", charset: "UTF-8", compressible: !0 },
  "application/msc-mixer+xml": { source: "iana", charset: "UTF-8", compressible: !0 },
  "application/msword": { source: "iana", compressible: !1, extensions: ["doc", "dot"] },
  "application/mud+json": { source: "iana", compressible: !0 },
  "application/multipart-core": { source: "iana" },
  "application/mxf": { source: "iana", extensions: ["mxf"] },
  "application/n-quads": { source: "iana", extensions: ["nq"] },
  "application/n-triples": { source: "iana", extensions: ["nt"] },
  "application/nasdata": { source: "iana" },
  "application/news-checkgroups": { source: "iana", charset: "US-ASCII" },
  "application/news-groupinfo": { source: "iana", charset: "US-ASCII" },
  "application/news-transmission": { source: "iana" },
  "application/nlsml+xml": { source: "iana", compressible: !0 },
  "application/node": { source: "iana", extensions: ["cjs"] },
  "application/nss": { source: "iana" },
  "application/oauth-authz-req+jwt": { source: "iana" },
  "application/oblivious-dns-message": { source: "iana" },
  "application/ocsp-request": { source: "iana" },
  "application/ocsp-response": { source: "iana" },
  "application/octet-stream": { source: "iana", compressible: !1, extensions: ["bin", "dms", "lrf", "mar", "so", "dist", "distz", "pkg", "bpk", "dump", "elc", "deploy", "exe", "dll", "deb", "dmg", "iso", "img", "msi", "msp", "msm", "buffer"] },
  "application/oda": { source: "iana", extensions: ["oda"] },
  "application/odm+xml": { source: "iana", compressible: !0 },
  "application/odx": { source: "iana" },
  "application/oebps-package+xml": { source: "iana", compressible: !0, extensions: ["opf"] },
  "application/ogg": { source: "iana", compressible: !1, extensions: ["ogx"] },
  "application/omdoc+xml": { source: "apache", compressible: !0, extensions: ["omdoc"] },
  "application/onenote": { source: "apache", extensions: ["onetoc", "onetoc2", "onetmp", "onepkg"] },
  "application/opc-nodeset+xml": { source: "iana", compressible: !0 },
  "application/oscore": { source: "iana" },
  "application/oxps": { source: "iana", extensions: ["oxps"] },
  "application/p21": { source: "iana" },
  "application/p21+zip": { source: "iana", compressible: !1 },
  "application/p2p-overlay+xml": { source: "iana", compressible: !0, extensions: ["relo"] },
  "application/parityfec": { source: "iana" },
  "application/passport": { source: "iana" },
  "application/patch-ops-error+xml": { source: "iana", compressible: !0, extensions: ["xer"] },
  "application/pdf": { source: "iana", compressible: !1, extensions: ["pdf"] },
  "application/pdx": { source: "iana" },
  "application/pem-certificate-chain": { source: "iana" },
  "application/pgp-encrypted": { source: "iana", compressible: !1, extensions: ["pgp"] },
  "application/pgp-keys": { source: "iana", extensions: ["asc"] },
  "application/pgp-signature": { source: "iana", extensions: ["asc", "sig"] },
  "application/pics-rules": { source: "apache", extensions: ["prf"] },
  "application/pidf+xml": { source: "iana", charset: "UTF-8", compressible: !0 },
  "application/pidf-diff+xml": { source: "iana", charset: "UTF-8", compressible: !0 },
  "application/pkcs10": { source: "iana", extensions: ["p10"] },
  "application/pkcs12": { source: "iana" },
  "application/pkcs7-mime": { source: "iana", extensions: ["p7m", "p7c"] },
  "application/pkcs7-signature": { source: "iana", extensions: ["p7s"] },
  "application/pkcs8": { source: "iana", extensions: ["p8"] },
  "application/pkcs8-encrypted": { source: "iana" },
  "application/pkix-attr-cert": { source: "iana", extensions: ["ac"] },
  "application/pkix-cert": { source: "iana", extensions: ["cer"] },
  "application/pkix-crl": { source: "iana", extensions: ["crl"] },
  "application/pkix-pkipath": { source: "iana", extensions: ["pkipath"] },
  "application/pkixcmp": { source: "iana", extensions: ["pki"] },
  "application/pls+xml": { source: "iana", compressible: !0, extensions: ["pls"] },
  "application/poc-settings+xml": { source: "iana", charset: "UTF-8", compressible: !0 },
  "application/postscript": { source: "iana", compressible: !0, extensions: ["ai", "eps", "ps"] },
  "application/ppsp-tracker+json": { source: "iana", compressible: !0 },
  "application/problem+json": { source: "iana", compressible: !0 },
  "application/problem+xml": { source: "iana", compressible: !0 },
  "application/provenance+xml": { source: "iana", compressible: !0, extensions: ["provx"] },
  "application/prs.alvestrand.titrax-sheet": { source: "iana" },
  "application/prs.cww": { source: "iana", extensions: ["cww"] },
  "application/prs.cyn": { source: "iana", charset: "7-BIT" },
  "application/prs.hpub+zip": { source: "iana", compressible: !1 },
  "application/prs.nprend": { source: "iana" },
  "application/prs.plucker": { source: "iana" },
  "application/prs.rdf-xml-crypt": { source: "iana" },
  "application/prs.xsf+xml": { source: "iana", compressible: !0 },
  "application/pskc+xml": { source: "iana", compressible: !0, extensions: ["pskcxml"] },
  "application/pvd+json": { source: "iana", compressible: !0 },
  "application/qsig": { source: "iana" },
  "application/raml+yaml": { compressible: !0, extensions: ["raml"] },
  "application/raptorfec": { source: "iana" },
  "application/rdap+json": { source: "iana", compressible: !0 },
  "application/rdf+xml": { source: "iana", compressible: !0, extensions: ["rdf", "owl"] },
  "application/reginfo+xml": { source: "iana", compressible: !0, extensions: ["rif"] },
  "application/relax-ng-compact-syntax": { source: "iana", extensions: ["rnc"] },
  "application/remote-printing": { source: "iana" },
  "application/reputon+json": { source: "iana", compressible: !0 },
  "application/resource-lists+xml": { source: "iana", compressible: !0, extensions: ["rl"] },
  "application/resource-lists-diff+xml": { source: "iana", compressible: !0, extensions: ["rld"] },
  "application/rfc+xml": { source: "iana", compressible: !0 },
  "application/riscos": { source: "iana" },
  "application/rlmi+xml": { source: "iana", compressible: !0 },
  "application/rls-services+xml": { source: "iana", compressible: !0, extensions: ["rs"] },
  "application/route-apd+xml": { source: "iana", compressible: !0, extensions: ["rapd"] },
  "application/route-s-tsid+xml": { source: "iana", compressible: !0, extensions: ["sls"] },
  "application/route-usd+xml": { source: "iana", compressible: !0, extensions: ["rusd"] },
  "application/rpki-ghostbusters": { source: "iana", extensions: ["gbr"] },
  "application/rpki-manifest": { source: "iana", extensions: ["mft"] },
  "application/rpki-publication": { source: "iana" },
  "application/rpki-roa": { source: "iana", extensions: ["roa"] },
  "application/rpki-updown": { source: "iana" },
  "application/rsd+xml": { source: "apache", compressible: !0, extensions: ["rsd"] },
  "application/rss+xml": { source: "apache", compressible: !0, extensions: ["rss"] },
  "application/rtf": { source: "iana", compressible: !0, extensions: ["rtf"] },
  "application/rtploopback": { source: "iana" },
  "application/rtx": { source: "iana" },
  "application/samlassertion+xml": { source: "iana", compressible: !0 },
  "application/samlmetadata+xml": { source: "iana", compressible: !0 },
  "application/sarif+json": { source: "iana", compressible: !0 },
  "application/sarif-external-properties+json": { source: "iana", compressible: !0 },
  "application/sbe": { source: "iana" },
  "application/sbml+xml": { source: "iana", compressible: !0, extensions: ["sbml"] },
  "application/scaip+xml": { source: "iana", compressible: !0 },
  "application/scim+json": { source: "iana", compressible: !0 },
  "application/scvp-cv-request": { source: "iana", extensions: ["scq"] },
  "application/scvp-cv-response": { source: "iana", extensions: ["scs"] },
  "application/scvp-vp-request": { source: "iana", extensions: ["spq"] },
  "application/scvp-vp-response": { source: "iana", extensions: ["spp"] },
  "application/sdp": { source: "iana", extensions: ["sdp"] },
  "application/secevent+jwt": { source: "iana" },
  "application/senml+cbor": { source: "iana" },
  "application/senml+json": { source: "iana", compressible: !0 },
  "application/senml+xml": { source: "iana", compressible: !0, extensions: ["senmlx"] },
  "application/senml-etch+cbor": { source: "iana" },
  "application/senml-etch+json": { source: "iana", compressible: !0 },
  "application/senml-exi": { source: "iana" },
  "application/sensml+cbor": { source: "iana" },
  "application/sensml+json": { source: "iana", compressible: !0 },
  "application/sensml+xml": { source: "iana", compressible: !0, extensions: ["sensmlx"] },
  "application/sensml-exi": { source: "iana" },
  "application/sep+xml": { source: "iana", compressible: !0 },
  "application/sep-exi": { source: "iana" },
  "application/session-info": { source: "iana" },
  "application/set-payment": { source: "iana" },
  "application/set-payment-initiation": { source: "iana", extensions: ["setpay"] },
  "application/set-registration": { source: "iana" },
  "application/set-registration-initiation": { source: "iana", extensions: ["setreg"] },
  "application/sgml": { source: "iana" },
  "application/sgml-open-catalog": { source: "iana" },
  "application/shf+xml": { source: "iana", compressible: !0, extensions: ["shf"] },
  "application/sieve": { source: "iana", extensions: ["siv", "sieve"] },
  "application/simple-filter+xml": { source: "iana", compressible: !0 },
  "application/simple-message-summary": { source: "iana" },
  "application/simplesymbolcontainer": { source: "iana" },
  "application/sipc": { source: "iana" },
  "application/slate": { source: "iana" },
  "application/smil": { source: "iana" },
  "application/smil+xml": { source: "iana", compressible: !0, extensions: ["smi", "smil"] },
  "application/smpte336m": { source: "iana" },
  "application/soap+fastinfoset": { source: "iana" },
  "application/soap+xml": { source: "iana", compressible: !0 },
  "application/sparql-query": { source: "iana", extensions: ["rq"] },
  "application/sparql-results+xml": { source: "iana", compressible: !0, extensions: ["srx"] },
  "application/spdx+json": { source: "iana", compressible: !0 },
  "application/spirits-event+xml": { source: "iana", compressible: !0 },
  "application/sql": { source: "iana" },
  "application/srgs": { source: "iana", extensions: ["gram"] },
  "application/srgs+xml": { source: "iana", compressible: !0, extensions: ["grxml"] },
  "application/sru+xml": { source: "iana", compressible: !0, extensions: ["sru"] },
  "application/ssdl+xml": { source: "apache", compressible: !0, extensions: ["ssdl"] },
  "application/ssml+xml": { source: "iana", compressible: !0, extensions: ["ssml"] },
  "application/stix+json": { source: "iana", compressible: !0 },
  "application/swid+xml": { source: "iana", compressible: !0, extensions: ["swidtag"] },
  "application/tamp-apex-update": { source: "iana" },
  "application/tamp-apex-update-confirm": { source: "iana" },
  "application/tamp-community-update": { source: "iana" },
  "application/tamp-community-update-confirm": { source: "iana" },
  "application/tamp-error": { source: "iana" },
  "application/tamp-sequence-adjust": { source: "iana" },
  "application/tamp-sequence-adjust-confirm": { source: "iana" },
  "application/tamp-status-query": { source: "iana" },
  "application/tamp-status-response": { source: "iana" },
  "application/tamp-update": { source: "iana" },
  "application/tamp-update-confirm": { source: "iana" },
  "application/tar": { compressible: !0 },
  "application/taxii+json": { source: "iana", compressible: !0 },
  "application/td+json": { source: "iana", compressible: !0 },
  "application/tei+xml": { source: "iana", compressible: !0, extensions: ["tei", "teicorpus"] },
  "application/tetra_isi": { source: "iana" },
  "application/thraud+xml": { source: "iana", compressible: !0, extensions: ["tfi"] },
  "application/timestamp-query": { source: "iana" },
  "application/timestamp-reply": { source: "iana" },
  "application/timestamped-data": { source: "iana", extensions: ["tsd"] },
  "application/tlsrpt+gzip": { source: "iana" },
  "application/tlsrpt+json": { source: "iana", compressible: !0 },
  "application/tnauthlist": { source: "iana" },
  "application/token-introspection+jwt": { source: "iana" },
  "application/toml": { compressible: !0, extensions: ["toml"] },
  "application/trickle-ice-sdpfrag": { source: "iana" },
  "application/trig": { source: "iana", extensions: ["trig"] },
  "application/ttml+xml": { source: "iana", compressible: !0, extensions: ["ttml"] },
  "application/tve-trigger": { source: "iana" },
  "application/tzif": { source: "iana" },
  "application/tzif-leap": { source: "iana" },
  "application/ubjson": { compressible: !1, extensions: ["ubj"] },
  "application/ulpfec": { source: "iana" },
  "application/urc-grpsheet+xml": { source: "iana", compressible: !0 },
  "application/urc-ressheet+xml": { source: "iana", compressible: !0, extensions: ["rsheet"] },
  "application/urc-targetdesc+xml": { source: "iana", compressible: !0, extensions: ["td"] },
  "application/urc-uisocketdesc+xml": { source: "iana", compressible: !0 },
  "application/vcard+json": { source: "iana", compressible: !0 },
  "application/vcard+xml": { source: "iana", compressible: !0 },
  "application/vemmi": { source: "iana" },
  "application/vividence.scriptfile": { source: "apache" },
  "application/vnd.1000minds.decision-model+xml": { source: "iana", compressible: !0, extensions: ["1km"] },
  "application/vnd.3gpp-prose+xml": { source: "iana", compressible: !0 },
  "application/vnd.3gpp-prose-pc3ch+xml": { source: "iana", compressible: !0 },
  "application/vnd.3gpp-v2x-local-service-information": { source: "iana" },
  "application/vnd.3gpp.5gnas": { source: "iana" },
  "application/vnd.3gpp.access-transfer-events+xml": { source: "iana", compressible: !0 },
  "application/vnd.3gpp.bsf+xml": { source: "iana", compressible: !0 },
  "application/vnd.3gpp.gmop+xml": { source: "iana", compressible: !0 },
  "application/vnd.3gpp.gtpc": { source: "iana" },
  "application/vnd.3gpp.interworking-data": { source: "iana" },
  "application/vnd.3gpp.lpp": { source: "iana" },
  "application/vnd.3gpp.mc-signalling-ear": { source: "iana" },
  "application/vnd.3gpp.mcdata-affiliation-command+xml": { source: "iana", compressible: !0 },
  "application/vnd.3gpp.mcdata-info+xml": { source: "iana", compressible: !0 },
  "application/vnd.3gpp.mcdata-payload": { source: "iana" },
  "application/vnd.3gpp.mcdata-service-config+xml": { source: "iana", compressible: !0 },
  "application/vnd.3gpp.mcdata-signalling": { source: "iana" },
  "application/vnd.3gpp.mcdata-ue-config+xml": { source: "iana", compressible: !0 },
  "application/vnd.3gpp.mcdata-user-profile+xml": { source: "iana", compressible: !0 },
  "application/vnd.3gpp.mcptt-affiliation-command+xml": { source: "iana", compressible: !0 },
  "application/vnd.3gpp.mcptt-floor-request+xml": { source: "iana", compressible: !0 },
  "application/vnd.3gpp.mcptt-info+xml": { source: "iana", compressible: !0 },
  "application/vnd.3gpp.mcptt-location-info+xml": { source: "iana", compressible: !0 },
  "application/vnd.3gpp.mcptt-mbms-usage-info+xml": { source: "iana", compressible: !0 },
  "application/vnd.3gpp.mcptt-service-config+xml": { source: "iana", compressible: !0 },
  "application/vnd.3gpp.mcptt-signed+xml": { source: "iana", compressible: !0 },
  "application/vnd.3gpp.mcptt-ue-config+xml": { source: "iana", compressible: !0 },
  "application/vnd.3gpp.mcptt-ue-init-config+xml": { source: "iana", compressible: !0 },
  "application/vnd.3gpp.mcptt-user-profile+xml": { source: "iana", compressible: !0 },
  "application/vnd.3gpp.mcvideo-affiliation-command+xml": { source: "iana", compressible: !0 },
  "application/vnd.3gpp.mcvideo-affiliation-info+xml": { source: "iana", compressible: !0 },
  "application/vnd.3gpp.mcvideo-info+xml": { source: "iana", compressible: !0 },
  "application/vnd.3gpp.mcvideo-location-info+xml": { source: "iana", compressible: !0 },
  "application/vnd.3gpp.mcvideo-mbms-usage-info+xml": { source: "iana", compressible: !0 },
  "application/vnd.3gpp.mcvideo-service-config+xml": { source: "iana", compressible: !0 },
  "application/vnd.3gpp.mcvideo-transmission-request+xml": { source: "iana", compressible: !0 },
  "application/vnd.3gpp.mcvideo-ue-config+xml": { source: "iana", compressible: !0 },
  "application/vnd.3gpp.mcvideo-user-profile+xml": { source: "iana", compressible: !0 },
  "application/vnd.3gpp.mid-call+xml": { source: "iana", compressible: !0 },
  "application/vnd.3gpp.ngap": { source: "iana" },
  "application/vnd.3gpp.pfcp": { source: "iana" },
  "application/vnd.3gpp.pic-bw-large": { source: "iana", extensions: ["plb"] },
  "application/vnd.3gpp.pic-bw-small": { source: "iana", extensions: ["psb"] },
  "application/vnd.3gpp.pic-bw-var": { source: "iana", extensions: ["pvb"] },
  "application/vnd.3gpp.s1ap": { source: "iana" },
  "application/vnd.3gpp.sms": { source: "iana" },
  "application/vnd.3gpp.sms+xml": { source: "iana", compressible: !0 },
  "application/vnd.3gpp.srvcc-ext+xml": { source: "iana", compressible: !0 },
  "application/vnd.3gpp.srvcc-info+xml": { source: "iana", compressible: !0 },
  "application/vnd.3gpp.state-and-event-info+xml": { source: "iana", compressible: !0 },
  "application/vnd.3gpp.ussd+xml": { source: "iana", compressible: !0 },
  "application/vnd.3gpp2.bcmcsinfo+xml": { source: "iana", compressible: !0 },
  "application/vnd.3gpp2.sms": { source: "iana" },
  "application/vnd.3gpp2.tcap": { source: "iana", extensions: ["tcap"] },
  "application/vnd.3lightssoftware.imagescal": { source: "iana" },
  "application/vnd.3m.post-it-notes": { source: "iana", extensions: ["pwn"] },
  "application/vnd.accpac.simply.aso": { source: "iana", extensions: ["aso"] },
  "application/vnd.accpac.simply.imp": { source: "iana", extensions: ["imp"] },
  "application/vnd.acucobol": { source: "iana", extensions: ["acu"] },
  "application/vnd.acucorp": { source: "iana", extensions: ["atc", "acutc"] },
  "application/vnd.adobe.air-application-installer-package+zip": { source: "apache", compressible: !1, extensions: ["air"] },
  "application/vnd.adobe.flash.movie": { source: "iana" },
  "application/vnd.adobe.formscentral.fcdt": { source: "iana", extensions: ["fcdt"] },
  "application/vnd.adobe.fxp": { source: "iana", extensions: ["fxp", "fxpl"] },
  "application/vnd.adobe.partial-upload": { source: "iana" },
  "application/vnd.adobe.xdp+xml": { source: "iana", compressible: !0, extensions: ["xdp"] },
  "application/vnd.adobe.xfdf": { source: "iana", extensions: ["xfdf"] },
  "application/vnd.aether.imp": { source: "iana" },
  "application/vnd.afpc.afplinedata": { source: "iana" },
  "application/vnd.afpc.afplinedata-pagedef": { source: "iana" },
  "application/vnd.afpc.cmoca-cmresource": { source: "iana" },
  "application/vnd.afpc.foca-charset": { source: "iana" },
  "application/vnd.afpc.foca-codedfont": { source: "iana" },
  "application/vnd.afpc.foca-codepage": { source: "iana" },
  "application/vnd.afpc.modca": { source: "iana" },
  "application/vnd.afpc.modca-cmtable": { source: "iana" },
  "application/vnd.afpc.modca-formdef": { source: "iana" },
  "application/vnd.afpc.modca-mediummap": { source: "iana" },
  "application/vnd.afpc.modca-objectcontainer": { source: "iana" },
  "application/vnd.afpc.modca-overlay": { source: "iana" },
  "application/vnd.afpc.modca-pagesegment": { source: "iana" },
  "application/vnd.age": { source: "iana", extensions: ["age"] },
  "application/vnd.ah-barcode": { source: "iana" },
  "application/vnd.ahead.space": { source: "iana", extensions: ["ahead"] },
  "application/vnd.airzip.filesecure.azf": { source: "iana", extensions: ["azf"] },
  "application/vnd.airzip.filesecure.azs": { source: "iana", extensions: ["azs"] },
  "application/vnd.amadeus+json": { source: "iana", compressible: !0 },
  "application/vnd.amazon.ebook": { source: "apache", extensions: ["azw"] },
  "application/vnd.amazon.mobi8-ebook": { source: "iana" },
  "application/vnd.americandynamics.acc": { source: "iana", extensions: ["acc"] },
  "application/vnd.amiga.ami": { source: "iana", extensions: ["ami"] },
  "application/vnd.amundsen.maze+xml": { source: "iana", compressible: !0 },
  "application/vnd.android.ota": { source: "iana" },
  "application/vnd.android.package-archive": { source: "apache", compressible: !1, extensions: ["apk"] },
  "application/vnd.anki": { source: "iana" },
  "application/vnd.anser-web-certificate-issue-initiation": { source: "iana", extensions: ["cii"] },
  "application/vnd.anser-web-funds-transfer-initiation": { source: "apache", extensions: ["fti"] },
  "application/vnd.antix.game-component": { source: "iana", extensions: ["atx"] },
  "application/vnd.apache.arrow.file": { source: "iana" },
  "application/vnd.apache.arrow.stream": { source: "iana" },
  "application/vnd.apache.thrift.binary": { source: "iana" },
  "application/vnd.apache.thrift.compact": { source: "iana" },
  "application/vnd.apache.thrift.json": { source: "iana" },
  "application/vnd.api+json": { source: "iana", compressible: !0 },
  "application/vnd.aplextor.warrp+json": { source: "iana", compressible: !0 },
  "application/vnd.apothekende.reservation+json": { source: "iana", compressible: !0 },
  "application/vnd.apple.installer+xml": { source: "iana", compressible: !0, extensions: ["mpkg"] },
  "application/vnd.apple.keynote": { source: "iana", extensions: ["key"] },
  "application/vnd.apple.mpegurl": { source: "iana", extensions: ["m3u8"] },
  "application/vnd.apple.numbers": { source: "iana", extensions: ["numbers"] },
  "application/vnd.apple.pages": { source: "iana", extensions: ["pages"] },
  "application/vnd.apple.pkpass": { compressible: !1, extensions: ["pkpass"] },
  "application/vnd.arastra.swi": { source: "iana" },
  "application/vnd.aristanetworks.swi": { source: "iana", extensions: ["swi"] },
  "application/vnd.artisan+json": { source: "iana", compressible: !0 },
  "application/vnd.artsquare": { source: "iana" },
  "application/vnd.astraea-software.iota": { source: "iana", extensions: ["iota"] },
  "application/vnd.audiograph": { source: "iana", extensions: ["aep"] },
  "application/vnd.autopackage": { source: "iana" },
  "application/vnd.avalon+json": { source: "iana", compressible: !0 },
  "application/vnd.avistar+xml": { source: "iana", compressible: !0 },
  "application/vnd.balsamiq.bmml+xml": { source: "iana", compressible: !0, extensions: ["bmml"] },
  "application/vnd.balsamiq.bmpr": { source: "iana" },
  "application/vnd.banana-accounting": { source: "iana" },
  "application/vnd.bbf.usp.error": { source: "iana" },
  "application/vnd.bbf.usp.msg": { source: "iana" },
  "application/vnd.bbf.usp.msg+json": { source: "iana", compressible: !0 },
  "application/vnd.bekitzur-stech+json": { source: "iana", compressible: !0 },
  "application/vnd.bint.med-content": { source: "iana" },
  "application/vnd.biopax.rdf+xml": { source: "iana", compressible: !0 },
  "application/vnd.blink-idb-value-wrapper": { source: "iana" },
  "application/vnd.blueice.multipass": { source: "iana", extensions: ["mpm"] },
  "application/vnd.bluetooth.ep.oob": { source: "iana" },
  "application/vnd.bluetooth.le.oob": { source: "iana" },
  "application/vnd.bmi": { source: "iana", extensions: ["bmi"] },
  "application/vnd.bpf": { source: "iana" },
  "application/vnd.bpf3": { source: "iana" },
  "application/vnd.businessobjects": { source: "iana", extensions: ["rep"] },
  "application/vnd.byu.uapi+json": { source: "iana", compressible: !0 },
  "application/vnd.cab-jscript": { source: "iana" },
  "application/vnd.canon-cpdl": { source: "iana" },
  "application/vnd.canon-lips": { source: "iana" },
  "application/vnd.capasystems-pg+json": { source: "iana", compressible: !0 },
  "application/vnd.cendio.thinlinc.clientconf": { source: "iana" },
  "application/vnd.century-systems.tcp_stream": { source: "iana" },
  "application/vnd.chemdraw+xml": { source: "iana", compressible: !0, extensions: ["cdxml"] },
  "application/vnd.chess-pgn": { source: "iana" },
  "application/vnd.chipnuts.karaoke-mmd": { source: "iana", extensions: ["mmd"] },
  "application/vnd.ciedi": { source: "iana" },
  "application/vnd.cinderella": { source: "iana", extensions: ["cdy"] },
  "application/vnd.cirpack.isdn-ext": { source: "iana" },
  "application/vnd.citationstyles.style+xml": { source: "iana", compressible: !0, extensions: ["csl"] },
  "application/vnd.claymore": { source: "iana", extensions: ["cla"] },
  "application/vnd.cloanto.rp9": { source: "iana", extensions: ["rp9"] },
  "application/vnd.clonk.c4group": { source: "iana", extensions: ["c4g", "c4d", "c4f", "c4p", "c4u"] },
  "application/vnd.cluetrust.cartomobile-config": { source: "iana", extensions: ["c11amc"] },
  "application/vnd.cluetrust.cartomobile-config-pkg": { source: "iana", extensions: ["c11amz"] },
  "application/vnd.coffeescript": { source: "iana" },
  "application/vnd.collabio.xodocuments.document": { source: "iana" },
  "application/vnd.collabio.xodocuments.document-template": { source: "iana" },
  "application/vnd.collabio.xodocuments.presentation": { source: "iana" },
  "application/vnd.collabio.xodocuments.presentation-template": { source: "iana" },
  "application/vnd.collabio.xodocuments.spreadsheet": { source: "iana" },
  "application/vnd.collabio.xodocuments.spreadsheet-template": { source: "iana" },
  "application/vnd.collection+json": { source: "iana", compressible: !0 },
  "application/vnd.collection.doc+json": { source: "iana", compressible: !0 },
  "application/vnd.collection.next+json": { source: "iana", compressible: !0 },
  "application/vnd.comicbook+zip": { source: "iana", compressible: !1 },
  "application/vnd.comicbook-rar": { source: "iana" },
  "application/vnd.commerce-battelle": { source: "iana" },
  "application/vnd.commonspace": { source: "iana", extensions: ["csp"] },
  "application/vnd.contact.cmsg": { source: "iana", extensions: ["cdbcmsg"] },
  "application/vnd.coreos.ignition+json": { source: "iana", compressible: !0 },
  "application/vnd.cosmocaller": { source: "iana", extensions: ["cmc"] },
  "application/vnd.crick.clicker": { source: "iana", extensions: ["clkx"] },
  "application/vnd.crick.clicker.keyboard": { source: "iana", extensions: ["clkk"] },
  "application/vnd.crick.clicker.palette": { source: "iana", extensions: ["clkp"] },
  "application/vnd.crick.clicker.template": { source: "iana", extensions: ["clkt"] },
  "application/vnd.crick.clicker.wordbank": { source: "iana", extensions: ["clkw"] },
  "application/vnd.criticaltools.wbs+xml": { source: "iana", compressible: !0, extensions: ["wbs"] },
  "application/vnd.cryptii.pipe+json": { source: "iana", compressible: !0 },
  "application/vnd.crypto-shade-file": { source: "iana" },
  "application/vnd.cryptomator.encrypted": { source: "iana" },
  "application/vnd.cryptomator.vault": { source: "iana" },
  "application/vnd.ctc-posml": { source: "iana", extensions: ["pml"] },
  "application/vnd.ctct.ws+xml": { source: "iana", compressible: !0 },
  "application/vnd.cups-pdf": { source: "iana" },
  "application/vnd.cups-postscript": { source: "iana" },
  "application/vnd.cups-ppd": { source: "iana", extensions: ["ppd"] },
  "application/vnd.cups-raster": { source: "iana" },
  "application/vnd.cups-raw": { source: "iana" },
  "application/vnd.curl": { source: "iana" },
  "application/vnd.curl.car": { source: "apache", extensions: ["car"] },
  "application/vnd.curl.pcurl": { source: "apache", extensions: ["pcurl"] },
  "application/vnd.cyan.dean.root+xml": { source: "iana", compressible: !0 },
  "application/vnd.cybank": { source: "iana" },
  "application/vnd.cyclonedx+json": { source: "iana", compressible: !0 },
  "application/vnd.cyclonedx+xml": { source: "iana", compressible: !0 },
  "application/vnd.d2l.coursepackage1p0+zip": { source: "iana", compressible: !1 },
  "application/vnd.d3m-dataset": { source: "iana" },
  "application/vnd.d3m-problem": { source: "iana" },
  "application/vnd.dart": { source: "iana", compressible: !0, extensions: ["dart"] },
  "application/vnd.data-vision.rdz": { source: "iana", extensions: ["rdz"] },
  "application/vnd.datapackage+json": { source: "iana", compressible: !0 },
  "application/vnd.dataresource+json": { source: "iana", compressible: !0 },
  "application/vnd.dbf": { source: "iana", extensions: ["dbf"] },
  "application/vnd.debian.binary-package": { source: "iana" },
  "application/vnd.dece.data": { source: "iana", extensions: ["uvf", "uvvf", "uvd", "uvvd"] },
  "application/vnd.dece.ttml+xml": { source: "iana", compressible: !0, extensions: ["uvt", "uvvt"] },
  "application/vnd.dece.unspecified": { source: "iana", extensions: ["uvx", "uvvx"] },
  "application/vnd.dece.zip": { source: "iana", extensions: ["uvz", "uvvz"] },
  "application/vnd.denovo.fcselayout-link": { source: "iana", extensions: ["fe_launch"] },
  "application/vnd.desmume.movie": { source: "iana" },
  "application/vnd.dir-bi.plate-dl-nosuffix": { source: "iana" },
  "application/vnd.dm.delegation+xml": { source: "iana", compressible: !0 },
  "application/vnd.dna": { source: "iana", extensions: ["dna"] },
  "application/vnd.document+json": { source: "iana", compressible: !0 },
  "application/vnd.dolby.mlp": { source: "apache", extensions: ["mlp"] },
  "application/vnd.dolby.mobile.1": { source: "iana" },
  "application/vnd.dolby.mobile.2": { source: "iana" },
  "application/vnd.doremir.scorecloud-binary-document": { source: "iana" },
  "application/vnd.dpgraph": { source: "iana", extensions: ["dpg"] },
  "application/vnd.dreamfactory": { source: "iana", extensions: ["dfac"] },
  "application/vnd.drive+json": { source: "iana", compressible: !0 },
  "application/vnd.ds-keypoint": { source: "apache", extensions: ["kpxx"] },
  "application/vnd.dtg.local": { source: "iana" },
  "application/vnd.dtg.local.flash": { source: "iana" },
  "application/vnd.dtg.local.html": { source: "iana" },
  "application/vnd.dvb.ait": { source: "iana", extensions: ["ait"] },
  "application/vnd.dvb.dvbisl+xml": { source: "iana", compressible: !0 },
  "application/vnd.dvb.dvbj": { source: "iana" },
  "application/vnd.dvb.esgcontainer": { source: "iana" },
  "application/vnd.dvb.ipdcdftnotifaccess": { source: "iana" },
  "application/vnd.dvb.ipdcesgaccess": { source: "iana" },
  "application/vnd.dvb.ipdcesgaccess2": { source: "iana" },
  "application/vnd.dvb.ipdcesgpdd": { source: "iana" },
  "application/vnd.dvb.ipdcroaming": { source: "iana" },
  "application/vnd.dvb.iptv.alfec-base": { source: "iana" },
  "application/vnd.dvb.iptv.alfec-enhancement": { source: "iana" },
  "application/vnd.dvb.notif-aggregate-root+xml": { source: "iana", compressible: !0 },
  "application/vnd.dvb.notif-container+xml": { source: "iana", compressible: !0 },
  "application/vnd.dvb.notif-generic+xml": { source: "iana", compressible: !0 },
  "application/vnd.dvb.notif-ia-msglist+xml": { source: "iana", compressible: !0 },
  "application/vnd.dvb.notif-ia-registration-request+xml": { source: "iana", compressible: !0 },
  "application/vnd.dvb.notif-ia-registration-response+xml": { source: "iana", compressible: !0 },
  "application/vnd.dvb.notif-init+xml": { source: "iana", compressible: !0 },
  "application/vnd.dvb.pfr": { source: "iana" },
  "application/vnd.dvb.service": { source: "iana", extensions: ["svc"] },
  "application/vnd.dxr": { source: "iana" },
  "application/vnd.dynageo": { source: "iana", extensions: ["geo"] },
  "application/vnd.dzr": { source: "iana" },
  "application/vnd.easykaraoke.cdgdownload": { source: "iana" },
  "application/vnd.ecdis-update": { source: "iana" },
  "application/vnd.ecip.rlp": { source: "iana" },
  "application/vnd.eclipse.ditto+json": { source: "iana", compressible: !0 },
  "application/vnd.ecowin.chart": { source: "iana", extensions: ["mag"] },
  "application/vnd.ecowin.filerequest": { source: "iana" },
  "application/vnd.ecowin.fileupdate": { source: "iana" },
  "application/vnd.ecowin.series": { source: "iana" },
  "application/vnd.ecowin.seriesrequest": { source: "iana" },
  "application/vnd.ecowin.seriesupdate": { source: "iana" },
  "application/vnd.efi.img": { source: "iana" },
  "application/vnd.efi.iso": { source: "iana" },
  "application/vnd.emclient.accessrequest+xml": { source: "iana", compressible: !0 },
  "application/vnd.enliven": { source: "iana", extensions: ["nml"] },
  "application/vnd.enphase.envoy": { source: "iana" },
  "application/vnd.eprints.data+xml": { source: "iana", compressible: !0 },
  "application/vnd.epson.esf": { source: "iana", extensions: ["esf"] },
  "application/vnd.epson.msf": { source: "iana", extensions: ["msf"] },
  "application/vnd.epson.quickanime": { source: "iana", extensions: ["qam"] },
  "application/vnd.epson.salt": { source: "iana", extensions: ["slt"] },
  "application/vnd.epson.ssf": { source: "iana", extensions: ["ssf"] },
  "application/vnd.ericsson.quickcall": { source: "iana" },
  "application/vnd.espass-espass+zip": { source: "iana", compressible: !1 },
  "application/vnd.eszigno3+xml": { source: "iana", compressible: !0, extensions: ["es3", "et3"] },
  "application/vnd.etsi.aoc+xml": { source: "iana", compressible: !0 },
  "application/vnd.etsi.asic-e+zip": { source: "iana", compressible: !1 },
  "application/vnd.etsi.asic-s+zip": { source: "iana", compressible: !1 },
  "application/vnd.etsi.cug+xml": { source: "iana", compressible: !0 },
  "application/vnd.etsi.iptvcommand+xml": { source: "iana", compressible: !0 },
  "application/vnd.etsi.iptvdiscovery+xml": { source: "iana", compressible: !0 },
  "application/vnd.etsi.iptvprofile+xml": { source: "iana", compressible: !0 },
  "application/vnd.etsi.iptvsad-bc+xml": { source: "iana", compressible: !0 },
  "application/vnd.etsi.iptvsad-cod+xml": { source: "iana", compressible: !0 },
  "application/vnd.etsi.iptvsad-npvr+xml": { source: "iana", compressible: !0 },
  "application/vnd.etsi.iptvservice+xml": { source: "iana", compressible: !0 },
  "application/vnd.etsi.iptvsync+xml": { source: "iana", compressible: !0 },
  "application/vnd.etsi.iptvueprofile+xml": { source: "iana", compressible: !0 },
  "application/vnd.etsi.mcid+xml": { source: "iana", compressible: !0 },
  "application/vnd.etsi.mheg5": { source: "iana" },
  "application/vnd.etsi.overload-control-policy-dataset+xml": { source: "iana", compressible: !0 },
  "application/vnd.etsi.pstn+xml": { source: "iana", compressible: !0 },
  "application/vnd.etsi.sci+xml": { source: "iana", compressible: !0 },
  "application/vnd.etsi.simservs+xml": { source: "iana", compressible: !0 },
  "application/vnd.etsi.timestamp-token": { source: "iana" },
  "application/vnd.etsi.tsl+xml": { source: "iana", compressible: !0 },
  "application/vnd.etsi.tsl.der": { source: "iana" },
  "application/vnd.eu.kasparian.car+json": { source: "iana", compressible: !0 },
  "application/vnd.eudora.data": { source: "iana" },
  "application/vnd.evolv.ecig.profile": { source: "iana" },
  "application/vnd.evolv.ecig.settings": { source: "iana" },
  "application/vnd.evolv.ecig.theme": { source: "iana" },
  "application/vnd.exstream-empower+zip": { source: "iana", compressible: !1 },
  "application/vnd.exstream-package": { source: "iana" },
  "application/vnd.ezpix-album": { source: "iana", extensions: ["ez2"] },
  "application/vnd.ezpix-package": { source: "iana", extensions: ["ez3"] },
  "application/vnd.f-secure.mobile": { source: "iana" },
  "application/vnd.familysearch.gedcom+zip": { source: "iana", compressible: !1 },
  "application/vnd.fastcopy-disk-image": { source: "iana" },
  "application/vnd.fdf": { source: "iana", extensions: ["fdf"] },
  "application/vnd.fdsn.mseed": { source: "iana", extensions: ["mseed"] },
  "application/vnd.fdsn.seed": { source: "iana", extensions: ["seed", "dataless"] },
  "application/vnd.ffsns": { source: "iana" },
  "application/vnd.ficlab.flb+zip": { source: "iana", compressible: !1 },
  "application/vnd.filmit.zfc": { source: "iana" },
  "application/vnd.fints": { source: "iana" },
  "application/vnd.firemonkeys.cloudcell": { source: "iana" },
  "application/vnd.flographit": { source: "iana", extensions: ["gph"] },
  "application/vnd.fluxtime.clip": { source: "iana", extensions: ["ftc"] },
  "application/vnd.font-fontforge-sfd": { source: "iana" },
  "application/vnd.framemaker": { source: "iana", extensions: ["fm", "frame", "maker", "book"] },
  "application/vnd.frogans.fnc": { source: "iana", extensions: ["fnc"] },
  "application/vnd.frogans.ltf": { source: "iana", extensions: ["ltf"] },
  "application/vnd.fsc.weblaunch": { source: "iana", extensions: ["fsc"] },
  "application/vnd.fujifilm.fb.docuworks": { source: "iana" },
  "application/vnd.fujifilm.fb.docuworks.binder": { source: "iana" },
  "application/vnd.fujifilm.fb.docuworks.container": { source: "iana" },
  "application/vnd.fujifilm.fb.jfi+xml": { source: "iana", compressible: !0 },
  "application/vnd.fujitsu.oasys": { source: "iana", extensions: ["oas"] },
  "application/vnd.fujitsu.oasys2": { source: "iana", extensions: ["oa2"] },
  "application/vnd.fujitsu.oasys3": { source: "iana", extensions: ["oa3"] },
  "application/vnd.fujitsu.oasysgp": { source: "iana", extensions: ["fg5"] },
  "application/vnd.fujitsu.oasysprs": { source: "iana", extensions: ["bh2"] },
  "application/vnd.fujixerox.art-ex": { source: "iana" },
  "application/vnd.fujixerox.art4": { source: "iana" },
  "application/vnd.fujixerox.ddd": { source: "iana", extensions: ["ddd"] },
  "application/vnd.fujixerox.docuworks": { source: "iana", extensions: ["xdw"] },
  "application/vnd.fujixerox.docuworks.binder": { source: "iana", extensions: ["xbd"] },
  "application/vnd.fujixerox.docuworks.container": { source: "iana" },
  "application/vnd.fujixerox.hbpl": { source: "iana" },
  "application/vnd.fut-misnet": { source: "iana" },
  "application/vnd.futoin+cbor": { source: "iana" },
  "application/vnd.futoin+json": { source: "iana", compressible: !0 },
  "application/vnd.fuzzysheet": { source: "iana", extensions: ["fzs"] },
  "application/vnd.genomatix.tuxedo": { source: "iana", extensions: ["txd"] },
  "application/vnd.gentics.grd+json": { source: "iana", compressible: !0 },
  "application/vnd.geo+json": { source: "iana", compressible: !0 },
  "application/vnd.geocube+xml": { source: "iana", compressible: !0 },
  "application/vnd.geogebra.file": { source: "iana", extensions: ["ggb"] },
  "application/vnd.geogebra.slides": { source: "iana" },
  "application/vnd.geogebra.tool": { source: "iana", extensions: ["ggt"] },
  "application/vnd.geometry-explorer": { source: "iana", extensions: ["gex", "gre"] },
  "application/vnd.geonext": { source: "iana", extensions: ["gxt"] },
  "application/vnd.geoplan": { source: "iana", extensions: ["g2w"] },
  "application/vnd.geospace": { source: "iana", extensions: ["g3w"] },
  "application/vnd.gerber": { source: "iana" },
  "application/vnd.globalplatform.card-content-mgt": { source: "iana" },
  "application/vnd.globalplatform.card-content-mgt-response": { source: "iana" },
  "application/vnd.gmx": { source: "iana", extensions: ["gmx"] },
  "application/vnd.google-apps.document": { compressible: !1, extensions: ["gdoc"] },
  "application/vnd.google-apps.presentation": { compressible: !1, extensions: ["gslides"] },
  "application/vnd.google-apps.spreadsheet": { compressible: !1, extensions: ["gsheet"] },
  "application/vnd.google-earth.kml+xml": { source: "iana", compressible: !0, extensions: ["kml"] },
  "application/vnd.google-earth.kmz": { source: "iana", compressible: !1, extensions: ["kmz"] },
  "application/vnd.gov.sk.e-form+xml": { source: "iana", compressible: !0 },
  "application/vnd.gov.sk.e-form+zip": { source: "iana", compressible: !1 },
  "application/vnd.gov.sk.xmldatacontainer+xml": { source: "iana", compressible: !0 },
  "application/vnd.grafeq": { source: "iana", extensions: ["gqf", "gqs"] },
  "application/vnd.gridmp": { source: "iana" },
  "application/vnd.groove-account": { source: "iana", extensions: ["gac"] },
  "application/vnd.groove-help": { source: "iana", extensions: ["ghf"] },
  "application/vnd.groove-identity-message": { source: "iana", extensions: ["gim"] },
  "application/vnd.groove-injector": { source: "iana", extensions: ["grv"] },
  "application/vnd.groove-tool-message": { source: "iana", extensions: ["gtm"] },
  "application/vnd.groove-tool-template": { source: "iana", extensions: ["tpl"] },
  "application/vnd.groove-vcard": { source: "iana", extensions: ["vcg"] },
  "application/vnd.hal+json": { source: "iana", compressible: !0 },
  "application/vnd.hal+xml": { source: "iana", compressible: !0, extensions: ["hal"] },
  "application/vnd.handheld-entertainment+xml": { source: "iana", compressible: !0, extensions: ["zmm"] },
  "application/vnd.hbci": { source: "iana", extensions: ["hbci"] },
  "application/vnd.hc+json": { source: "iana", compressible: !0 },
  "application/vnd.hcl-bireports": { source: "iana" },
  "application/vnd.hdt": { source: "iana" },
  "application/vnd.heroku+json": { source: "iana", compressible: !0 },
  "application/vnd.hhe.lesson-player": { source: "iana", extensions: ["les"] },
  "application/vnd.hl7cda+xml": { source: "iana", charset: "UTF-8", compressible: !0 },
  "application/vnd.hl7v2+xml": { source: "iana", charset: "UTF-8", compressible: !0 },
  "application/vnd.hp-hpgl": { source: "iana", extensions: ["hpgl"] },
  "application/vnd.hp-hpid": { source: "iana", extensions: ["hpid"] },
  "application/vnd.hp-hps": { source: "iana", extensions: ["hps"] },
  "application/vnd.hp-jlyt": { source: "iana", extensions: ["jlt"] },
  "application/vnd.hp-pcl": { source: "iana", extensions: ["pcl"] },
  "application/vnd.hp-pclxl": { source: "iana", extensions: ["pclxl"] },
  "application/vnd.httphone": { source: "iana" },
  "application/vnd.hydrostatix.sof-data": { source: "iana", extensions: ["sfd-hdstx"] },
  "application/vnd.hyper+json": { source: "iana", compressible: !0 },
  "application/vnd.hyper-item+json": { source: "iana", compressible: !0 },
  "application/vnd.hyperdrive+json": { source: "iana", compressible: !0 },
  "application/vnd.hzn-3d-crossword": { source: "iana" },
  "application/vnd.ibm.afplinedata": { source: "iana" },
  "application/vnd.ibm.electronic-media": { source: "iana" },
  "application/vnd.ibm.minipay": { source: "iana", extensions: ["mpy"] },
  "application/vnd.ibm.modcap": { source: "iana", extensions: ["afp", "listafp", "list3820"] },
  "application/vnd.ibm.rights-management": { source: "iana", extensions: ["irm"] },
  "application/vnd.ibm.secure-container": { source: "iana", extensions: ["sc"] },
  "application/vnd.iccprofile": { source: "iana", extensions: ["icc", "icm"] },
  "application/vnd.ieee.1905": { source: "iana" },
  "application/vnd.igloader": { source: "iana", extensions: ["igl"] },
  "application/vnd.imagemeter.folder+zip": { source: "iana", compressible: !1 },
  "application/vnd.imagemeter.image+zip": { source: "iana", compressible: !1 },
  "application/vnd.immervision-ivp": { source: "iana", extensions: ["ivp"] },
  "application/vnd.immervision-ivu": { source: "iana", extensions: ["ivu"] },
  "application/vnd.ims.imsccv1p1": { source: "iana" },
  "application/vnd.ims.imsccv1p2": { source: "iana" },
  "application/vnd.ims.imsccv1p3": { source: "iana" },
  "application/vnd.ims.lis.v2.result+json": { source: "iana", compressible: !0 },
  "application/vnd.ims.lti.v2.toolconsumerprofile+json": { source: "iana", compressible: !0 },
  "application/vnd.ims.lti.v2.toolproxy+json": { source: "iana", compressible: !0 },
  "application/vnd.ims.lti.v2.toolproxy.id+json": { source: "iana", compressible: !0 },
  "application/vnd.ims.lti.v2.toolsettings+json": { source: "iana", compressible: !0 },
  "application/vnd.ims.lti.v2.toolsettings.simple+json": { source: "iana", compressible: !0 },
  "application/vnd.informedcontrol.rms+xml": { source: "iana", compressible: !0 },
  "application/vnd.informix-visionary": { source: "iana" },
  "application/vnd.infotech.project": { source: "iana" },
  "application/vnd.infotech.project+xml": { source: "iana", compressible: !0 },
  "application/vnd.innopath.wamp.notification": { source: "iana" },
  "application/vnd.insors.igm": { source: "iana", extensions: ["igm"] },
  "application/vnd.intercon.formnet": { source: "iana", extensions: ["xpw", "xpx"] },
  "application/vnd.intergeo": { source: "iana", extensions: ["i2g"] },
  "application/vnd.intertrust.digibox": { source: "iana" },
  "application/vnd.intertrust.nncp": { source: "iana" },
  "application/vnd.intu.qbo": { source: "iana", extensions: ["qbo"] },
  "application/vnd.intu.qfx": { source: "iana", extensions: ["qfx"] },
  "application/vnd.iptc.g2.catalogitem+xml": { source: "iana", compressible: !0 },
  "application/vnd.iptc.g2.conceptitem+xml": { source: "iana", compressible: !0 },
  "application/vnd.iptc.g2.knowledgeitem+xml": { source: "iana", compressible: !0 },
  "application/vnd.iptc.g2.newsitem+xml": { source: "iana", compressible: !0 },
  "application/vnd.iptc.g2.newsmessage+xml": { source: "iana", compressible: !0 },
  "application/vnd.iptc.g2.packageitem+xml": { source: "iana", compressible: !0 },
  "application/vnd.iptc.g2.planningitem+xml": { source: "iana", compressible: !0 },
  "application/vnd.ipunplugged.rcprofile": { source: "iana", extensions: ["rcprofile"] },
  "application/vnd.irepository.package+xml": { source: "iana", compressible: !0, extensions: ["irp"] },
  "application/vnd.is-xpr": { source: "iana", extensions: ["xpr"] },
  "application/vnd.isac.fcs": { source: "iana", extensions: ["fcs"] },
  "application/vnd.iso11783-10+zip": { source: "iana", compressible: !1 },
  "application/vnd.jam": { source: "iana", extensions: ["jam"] },
  "application/vnd.japannet-directory-service": { source: "iana" },
  "application/vnd.japannet-jpnstore-wakeup": { source: "iana" },
  "application/vnd.japannet-payment-wakeup": { source: "iana" },
  "application/vnd.japannet-registration": { source: "iana" },
  "application/vnd.japannet-registration-wakeup": { source: "iana" },
  "application/vnd.japannet-setstore-wakeup": { source: "iana" },
  "application/vnd.japannet-verification": { source: "iana" },
  "application/vnd.japannet-verification-wakeup": { source: "iana" },
  "application/vnd.jcp.javame.midlet-rms": { source: "iana", extensions: ["rms"] },
  "application/vnd.jisp": { source: "iana", extensions: ["jisp"] },
  "application/vnd.joost.joda-archive": { source: "iana", extensions: ["joda"] },
  "application/vnd.jsk.isdn-ngn": { source: "iana" },
  "application/vnd.kahootz": { source: "iana", extensions: ["ktz", "ktr"] },
  "application/vnd.kde.karbon": { source: "iana", extensions: ["karbon"] },
  "application/vnd.kde.kchart": { source: "iana", extensions: ["chrt"] },
  "application/vnd.kde.kformula": { source: "iana", extensions: ["kfo"] },
  "application/vnd.kde.kivio": { source: "iana", extensions: ["flw"] },
  "application/vnd.kde.kontour": { source: "iana", extensions: ["kon"] },
  "application/vnd.kde.kpresenter": { source: "iana", extensions: ["kpr", "kpt"] },
  "application/vnd.kde.kspread": { source: "iana", extensions: ["ksp"] },
  "application/vnd.kde.kword": { source: "iana", extensions: ["kwd", "kwt"] },
  "application/vnd.kenameaapp": { source: "iana", extensions: ["htke"] },
  "application/vnd.kidspiration": { source: "iana", extensions: ["kia"] },
  "application/vnd.kinar": { source: "iana", extensions: ["kne", "knp"] },
  "application/vnd.koan": { source: "iana", extensions: ["skp", "skd", "skt", "skm"] },
  "application/vnd.kodak-descriptor": { source: "iana", extensions: ["sse"] },
  "application/vnd.las": { source: "iana" },
  "application/vnd.las.las+json": { source: "iana", compressible: !0 },
  "application/vnd.las.las+xml": { source: "iana", compressible: !0, extensions: ["lasxml"] },
  "application/vnd.laszip": { source: "iana" },
  "application/vnd.leap+json": { source: "iana", compressible: !0 },
  "application/vnd.liberty-request+xml": { source: "iana", compressible: !0 },
  "application/vnd.llamagraphics.life-balance.desktop": { source: "iana", extensions: ["lbd"] },
  "application/vnd.llamagraphics.life-balance.exchange+xml": { source: "iana", compressible: !0, extensions: ["lbe"] },
  "application/vnd.logipipe.circuit+zip": { source: "iana", compressible: !1 },
  "application/vnd.loom": { source: "iana" },
  "application/vnd.lotus-1-2-3": { source: "iana", extensions: ["123"] },
  "application/vnd.lotus-approach": { source: "iana", extensions: ["apr"] },
  "application/vnd.lotus-freelance": { source: "iana", extensions: ["pre"] },
  "application/vnd.lotus-notes": { source: "iana", extensions: ["nsf"] },
  "application/vnd.lotus-organizer": { source: "iana", extensions: ["org"] },
  "application/vnd.lotus-screencam": { source: "iana", extensions: ["scm"] },
  "application/vnd.lotus-wordpro": { source: "iana", extensions: ["lwp"] },
  "application/vnd.macports.portpkg": { source: "iana", extensions: ["portpkg"] },
  "application/vnd.mapbox-vector-tile": { source: "iana", extensions: ["mvt"] },
  "application/vnd.marlin.drm.actiontoken+xml": { source: "iana", compressible: !0 },
  "application/vnd.marlin.drm.conftoken+xml": { source: "iana", compressible: !0 },
  "application/vnd.marlin.drm.license+xml": { source: "iana", compressible: !0 },
  "application/vnd.marlin.drm.mdcf": { source: "iana" },
  "application/vnd.mason+json": { source: "iana", compressible: !0 },
  "application/vnd.maxar.archive.3tz+zip": { source: "iana", compressible: !1 },
  "application/vnd.maxmind.maxmind-db": { source: "iana" },
  "application/vnd.mcd": { source: "iana", extensions: ["mcd"] },
  "application/vnd.medcalcdata": { source: "iana", extensions: ["mc1"] },
  "application/vnd.mediastation.cdkey": { source: "iana", extensions: ["cdkey"] },
  "application/vnd.meridian-slingshot": { source: "iana" },
  "application/vnd.mfer": { source: "iana", extensions: ["mwf"] },
  "application/vnd.mfmp": { source: "iana", extensions: ["mfm"] },
  "application/vnd.micro+json": { source: "iana", compressible: !0 },
  "application/vnd.micrografx.flo": { source: "iana", extensions: ["flo"] },
  "application/vnd.micrografx.igx": { source: "iana", extensions: ["igx"] },
  "application/vnd.microsoft.portable-executable": { source: "iana" },
  "application/vnd.microsoft.windows.thumbnail-cache": { source: "iana" },
  "application/vnd.miele+json": { source: "iana", compressible: !0 },
  "application/vnd.mif": { source: "iana", extensions: ["mif"] },
  "application/vnd.minisoft-hp3000-save": { source: "iana" },
  "application/vnd.mitsubishi.misty-guard.trustweb": { source: "iana" },
  "application/vnd.mobius.daf": { source: "iana", extensions: ["daf"] },
  "application/vnd.mobius.dis": { source: "iana", extensions: ["dis"] },
  "application/vnd.mobius.mbk": { source: "iana", extensions: ["mbk"] },
  "application/vnd.mobius.mqy": { source: "iana", extensions: ["mqy"] },
  "application/vnd.mobius.msl": { source: "iana", extensions: ["msl"] },
  "application/vnd.mobius.plc": { source: "iana", extensions: ["plc"] },
  "application/vnd.mobius.txf": { source: "iana", extensions: ["txf"] },
  "application/vnd.mophun.application": { source: "iana", extensions: ["mpn"] },
  "application/vnd.mophun.certificate": { source: "iana", extensions: ["mpc"] },
  "application/vnd.motorola.flexsuite": { source: "iana" },
  "application/vnd.motorola.flexsuite.adsi": { source: "iana" },
  "application/vnd.motorola.flexsuite.fis": { source: "iana" },
  "application/vnd.motorola.flexsuite.gotap": { source: "iana" },
  "application/vnd.motorola.flexsuite.kmr": { source: "iana" },
  "application/vnd.motorola.flexsuite.ttc": { source: "iana" },
  "application/vnd.motorola.flexsuite.wem": { source: "iana" },
  "application/vnd.motorola.iprm": { source: "iana" },
  "application/vnd.mozilla.xul+xml": { source: "iana", compressible: !0, extensions: ["xul"] },
  "application/vnd.ms-3mfdocument": { source: "iana" },
  "application/vnd.ms-artgalry": { source: "iana", extensions: ["cil"] },
  "application/vnd.ms-asf": { source: "iana" },
  "application/vnd.ms-cab-compressed": { source: "iana", extensions: ["cab"] },
  "application/vnd.ms-color.iccprofile": { source: "apache" },
  "application/vnd.ms-excel": { source: "iana", compressible: !1, extensions: ["xls", "xlm", "xla", "xlc", "xlt", "xlw"] },
  "application/vnd.ms-excel.addin.macroenabled.12": { source: "iana", extensions: ["xlam"] },
  "application/vnd.ms-excel.sheet.binary.macroenabled.12": { source: "iana", extensions: ["xlsb"] },
  "application/vnd.ms-excel.sheet.macroenabled.12": { source: "iana", extensions: ["xlsm"] },
  "application/vnd.ms-excel.template.macroenabled.12": { source: "iana", extensions: ["xltm"] },
  "application/vnd.ms-fontobject": { source: "iana", compressible: !0, extensions: ["eot"] },
  "application/vnd.ms-htmlhelp": { source: "iana", extensions: ["chm"] },
  "application/vnd.ms-ims": { source: "iana", extensions: ["ims"] },
  "application/vnd.ms-lrm": { source: "iana", extensions: ["lrm"] },
  "application/vnd.ms-office.activex+xml": { source: "iana", compressible: !0 },
  "application/vnd.ms-officetheme": { source: "iana", extensions: ["thmx"] },
  "application/vnd.ms-opentype": { source: "apache", compressible: !0 },
  "application/vnd.ms-outlook": { compressible: !1, extensions: ["msg"] },
  "application/vnd.ms-package.obfuscated-opentype": { source: "apache" },
  "application/vnd.ms-pki.seccat": { source: "apache", extensions: ["cat"] },
  "application/vnd.ms-pki.stl": { source: "apache", extensions: ["stl"] },
  "application/vnd.ms-playready.initiator+xml": { source: "iana", compressible: !0 },
  "application/vnd.ms-powerpoint": { source: "iana", compressible: !1, extensions: ["ppt", "pps", "pot"] },
  "application/vnd.ms-powerpoint.addin.macroenabled.12": { source: "iana", extensions: ["ppam"] },
  "application/vnd.ms-powerpoint.presentation.macroenabled.12": { source: "iana", extensions: ["pptm"] },
  "application/vnd.ms-powerpoint.slide.macroenabled.12": { source: "iana", extensions: ["sldm"] },
  "application/vnd.ms-powerpoint.slideshow.macroenabled.12": { source: "iana", extensions: ["ppsm"] },
  "application/vnd.ms-powerpoint.template.macroenabled.12": { source: "iana", extensions: ["potm"] },
  "application/vnd.ms-printdevicecapabilities+xml": { source: "iana", compressible: !0 },
  "application/vnd.ms-printing.printticket+xml": { source: "apache", compressible: !0 },
  "application/vnd.ms-printschematicket+xml": { source: "iana", compressible: !0 },
  "application/vnd.ms-project": { source: "iana", extensions: ["mpp", "mpt"] },
  "application/vnd.ms-tnef": { source: "iana" },
  "application/vnd.ms-windows.devicepairing": { source: "iana" },
  "application/vnd.ms-windows.nwprinting.oob": { source: "iana" },
  "application/vnd.ms-windows.printerpairing": { source: "iana" },
  "application/vnd.ms-windows.wsd.oob": { source: "iana" },
  "application/vnd.ms-wmdrm.lic-chlg-req": { source: "iana" },
  "application/vnd.ms-wmdrm.lic-resp": { source: "iana" },
  "application/vnd.ms-wmdrm.meter-chlg-req": { source: "iana" },
  "application/vnd.ms-wmdrm.meter-resp": { source: "iana" },
  "application/vnd.ms-word.document.macroenabled.12": { source: "iana", extensions: ["docm"] },
  "application/vnd.ms-word.template.macroenabled.12": { source: "iana", extensions: ["dotm"] },
  "application/vnd.ms-works": { source: "iana", extensions: ["wps", "wks", "wcm", "wdb"] },
  "application/vnd.ms-wpl": { source: "iana", extensions: ["wpl"] },
  "application/vnd.ms-xpsdocument": { source: "iana", compressible: !1, extensions: ["xps"] },
  "application/vnd.msa-disk-image": { source: "iana" },
  "application/vnd.mseq": { source: "iana", extensions: ["mseq"] },
  "application/vnd.msign": { source: "iana" },
  "application/vnd.multiad.creator": { source: "iana" },
  "application/vnd.multiad.creator.cif": { source: "iana" },
  "application/vnd.music-niff": { source: "iana" },
  "application/vnd.musician": { source: "iana", extensions: ["mus"] },
  "application/vnd.muvee.style": { source: "iana", extensions: ["msty"] },
  "application/vnd.mynfc": { source: "iana", extensions: ["taglet"] },
  "application/vnd.nacamar.ybrid+json": { source: "iana", compressible: !0 },
  "application/vnd.ncd.control": { source: "iana" },
  "application/vnd.ncd.reference": { source: "iana" },
  "application/vnd.nearst.inv+json": { source: "iana", compressible: !0 },
  "application/vnd.nebumind.line": { source: "iana" },
  "application/vnd.nervana": { source: "iana" },
  "application/vnd.netfpx": { source: "iana" },
  "application/vnd.neurolanguage.nlu": { source: "iana", extensions: ["nlu"] },
  "application/vnd.nimn": { source: "iana" },
  "application/vnd.nintendo.nitro.rom": { source: "iana" },
  "application/vnd.nintendo.snes.rom": { source: "iana" },
  "application/vnd.nitf": { source: "iana", extensions: ["ntf", "nitf"] },
  "application/vnd.noblenet-directory": { source: "iana", extensions: ["nnd"] },
  "application/vnd.noblenet-sealer": { source: "iana", extensions: ["nns"] },
  "application/vnd.noblenet-web": { source: "iana", extensions: ["nnw"] },
  "application/vnd.nokia.catalogs": { source: "iana" },
  "application/vnd.nokia.conml+wbxml": { source: "iana" },
  "application/vnd.nokia.conml+xml": { source: "iana", compressible: !0 },
  "application/vnd.nokia.iptv.config+xml": { source: "iana", compressible: !0 },
  "application/vnd.nokia.isds-radio-presets": { source: "iana" },
  "application/vnd.nokia.landmark+wbxml": { source: "iana" },
  "application/vnd.nokia.landmark+xml": { source: "iana", compressible: !0 },
  "application/vnd.nokia.landmarkcollection+xml": { source: "iana", compressible: !0 },
  "application/vnd.nokia.n-gage.ac+xml": { source: "iana", compressible: !0, extensions: ["ac"] },
  "application/vnd.nokia.n-gage.data": { source: "iana", extensions: ["ngdat"] },
  "application/vnd.nokia.n-gage.symbian.install": { source: "iana", extensions: ["n-gage"] },
  "application/vnd.nokia.ncd": { source: "iana" },
  "application/vnd.nokia.pcd+wbxml": { source: "iana" },
  "application/vnd.nokia.pcd+xml": { source: "iana", compressible: !0 },
  "application/vnd.nokia.radio-preset": { source: "iana", extensions: ["rpst"] },
  "application/vnd.nokia.radio-presets": { source: "iana", extensions: ["rpss"] },
  "application/vnd.novadigm.edm": { source: "iana", extensions: ["edm"] },
  "application/vnd.novadigm.edx": { source: "iana", extensions: ["edx"] },
  "application/vnd.novadigm.ext": { source: "iana", extensions: ["ext"] },
  "application/vnd.ntt-local.content-share": { source: "iana" },
  "application/vnd.ntt-local.file-transfer": { source: "iana" },
  "application/vnd.ntt-local.ogw_remote-access": { source: "iana" },
  "application/vnd.ntt-local.sip-ta_remote": { source: "iana" },
  "application/vnd.ntt-local.sip-ta_tcp_stream": { source: "iana" },
  "application/vnd.oasis.opendocument.chart": { source: "iana", extensions: ["odc"] },
  "application/vnd.oasis.opendocument.chart-template": { source: "iana", extensions: ["otc"] },
  "application/vnd.oasis.opendocument.database": { source: "iana", extensions: ["odb"] },
  "application/vnd.oasis.opendocument.formula": { source: "iana", extensions: ["odf"] },
  "application/vnd.oasis.opendocument.formula-template": { source: "iana", extensions: ["odft"] },
  "application/vnd.oasis.opendocument.graphics": { source: "iana", compressible: !1, extensions: ["odg"] },
  "application/vnd.oasis.opendocument.graphics-template": { source: "iana", extensions: ["otg"] },
  "application/vnd.oasis.opendocument.image": { source: "iana", extensions: ["odi"] },
  "application/vnd.oasis.opendocument.image-template": { source: "iana", extensions: ["oti"] },
  "application/vnd.oasis.opendocument.presentation": { source: "iana", compressible: !1, extensions: ["odp"] },
  "application/vnd.oasis.opendocument.presentation-template": { source: "iana", extensions: ["otp"] },
  "application/vnd.oasis.opendocument.spreadsheet": { source: "iana", compressible: !1, extensions: ["ods"] },
  "application/vnd.oasis.opendocument.spreadsheet-template": { source: "iana", extensions: ["ots"] },
  "application/vnd.oasis.opendocument.text": { source: "iana", compressible: !1, extensions: ["odt"] },
  "application/vnd.oasis.opendocument.text-master": { source: "iana", extensions: ["odm"] },
  "application/vnd.oasis.opendocument.text-template": { source: "iana", extensions: ["ott"] },
  "application/vnd.oasis.opendocument.text-web": { source: "iana", extensions: ["oth"] },
  "application/vnd.obn": { source: "iana" },
  "application/vnd.ocf+cbor": { source: "iana" },
  "application/vnd.oci.image.manifest.v1+json": { source: "iana", compressible: !0 },
  "application/vnd.oftn.l10n+json": { source: "iana", compressible: !0 },
  "application/vnd.oipf.contentaccessdownload+xml": { source: "iana", compressible: !0 },
  "application/vnd.oipf.contentaccessstreaming+xml": { source: "iana", compressible: !0 },
  "application/vnd.oipf.cspg-hexbinary": { source: "iana" },
  "application/vnd.oipf.dae.svg+xml": { source: "iana", compressible: !0 },
  "application/vnd.oipf.dae.xhtml+xml": { source: "iana", compressible: !0 },
  "application/vnd.oipf.mippvcontrolmessage+xml": { source: "iana", compressible: !0 },
  "application/vnd.oipf.pae.gem": { source: "iana" },
  "application/vnd.oipf.spdiscovery+xml": { source: "iana", compressible: !0 },
  "application/vnd.oipf.spdlist+xml": { source: "iana", compressible: !0 },
  "application/vnd.oipf.ueprofile+xml": { source: "iana", compressible: !0 },
  "application/vnd.oipf.userprofile+xml": { source: "iana", compressible: !0 },
  "application/vnd.olpc-sugar": { source: "iana", extensions: ["xo"] },
  "application/vnd.oma-scws-config": { source: "iana" },
  "application/vnd.oma-scws-http-request": { source: "iana" },
  "application/vnd.oma-scws-http-response": { source: "iana" },
  "application/vnd.oma.bcast.associated-procedure-parameter+xml": { source: "iana", compressible: !0 },
  "application/vnd.oma.bcast.drm-trigger+xml": { source: "iana", compressible: !0 },
  "application/vnd.oma.bcast.imd+xml": { source: "iana", compressible: !0 },
  "application/vnd.oma.bcast.ltkm": { source: "iana" },
  "application/vnd.oma.bcast.notification+xml": { source: "iana", compressible: !0 },
  "application/vnd.oma.bcast.provisioningtrigger": { source: "iana" },
  "application/vnd.oma.bcast.sgboot": { source: "iana" },
  "application/vnd.oma.bcast.sgdd+xml": { source: "iana", compressible: !0 },
  "application/vnd.oma.bcast.sgdu": { source: "iana" },
  "application/vnd.oma.bcast.simple-symbol-container": { source: "iana" },
  "application/vnd.oma.bcast.smartcard-trigger+xml": { source: "iana", compressible: !0 },
  "application/vnd.oma.bcast.sprov+xml": { source: "iana", compressible: !0 },
  "application/vnd.oma.bcast.stkm": { source: "iana" },
  "application/vnd.oma.cab-address-book+xml": { source: "iana", compressible: !0 },
  "application/vnd.oma.cab-feature-handler+xml": { source: "iana", compressible: !0 },
  "application/vnd.oma.cab-pcc+xml": { source: "iana", compressible: !0 },
  "application/vnd.oma.cab-subs-invite+xml": { source: "iana", compressible: !0 },
  "application/vnd.oma.cab-user-prefs+xml": { source: "iana", compressible: !0 },
  "application/vnd.oma.dcd": { source: "iana" },
  "application/vnd.oma.dcdc": { source: "iana" },
  "application/vnd.oma.dd2+xml": { source: "iana", compressible: !0, extensions: ["dd2"] },
  "application/vnd.oma.drm.risd+xml": { source: "iana", compressible: !0 },
  "application/vnd.oma.group-usage-list+xml": { source: "iana", compressible: !0 },
  "application/vnd.oma.lwm2m+cbor": { source: "iana" },
  "application/vnd.oma.lwm2m+json": { source: "iana", compressible: !0 },
  "application/vnd.oma.lwm2m+tlv": { source: "iana" },
  "application/vnd.oma.pal+xml": { source: "iana", compressible: !0 },
  "application/vnd.oma.poc.detailed-progress-report+xml": { source: "iana", compressible: !0 },
  "application/vnd.oma.poc.final-report+xml": { source: "iana", compressible: !0 },
  "application/vnd.oma.poc.groups+xml": { source: "iana", compressible: !0 },
  "application/vnd.oma.poc.invocation-descriptor+xml": { source: "iana", compressible: !0 },
  "application/vnd.oma.poc.optimized-progress-report+xml": { source: "iana", compressible: !0 },
  "application/vnd.oma.push": { source: "iana" },
  "application/vnd.oma.scidm.messages+xml": { source: "iana", compressible: !0 },
  "application/vnd.oma.xcap-directory+xml": { source: "iana", compressible: !0 },
  "application/vnd.omads-email+xml": { source: "iana", charset: "UTF-8", compressible: !0 },
  "application/vnd.omads-file+xml": { source: "iana", charset: "UTF-8", compressible: !0 },
  "application/vnd.omads-folder+xml": { source: "iana", charset: "UTF-8", compressible: !0 },
  "application/vnd.omaloc-supl-init": { source: "iana" },
  "application/vnd.onepager": { source: "iana" },
  "application/vnd.onepagertamp": { source: "iana" },
  "application/vnd.onepagertamx": { source: "iana" },
  "application/vnd.onepagertat": { source: "iana" },
  "application/vnd.onepagertatp": { source: "iana" },
  "application/vnd.onepagertatx": { source: "iana" },
  "application/vnd.openblox.game+xml": { source: "iana", compressible: !0, extensions: ["obgx"] },
  "application/vnd.openblox.game-binary": { source: "iana" },
  "application/vnd.openeye.oeb": { source: "iana" },
  "application/vnd.openofficeorg.extension": { source: "apache", extensions: ["oxt"] },
  "application/vnd.openstreetmap.data+xml": { source: "iana", compressible: !0, extensions: ["osm"] },
  "application/vnd.opentimestamps.ots": { source: "iana" },
  "application/vnd.openxmlformats-officedocument.custom-properties+xml": { source: "iana", compressible: !0 },
  "application/vnd.openxmlformats-officedocument.customxmlproperties+xml": { source: "iana", compressible: !0 },
  "application/vnd.openxmlformats-officedocument.drawing+xml": { source: "iana", compressible: !0 },
  "application/vnd.openxmlformats-officedocument.drawingml.chart+xml": { source: "iana", compressible: !0 },
  "application/vnd.openxmlformats-officedocument.drawingml.chartshapes+xml": { source: "iana", compressible: !0 },
  "application/vnd.openxmlformats-officedocument.drawingml.diagramcolors+xml": { source: "iana", compressible: !0 },
  "application/vnd.openxmlformats-officedocument.drawingml.diagramdata+xml": { source: "iana", compressible: !0 },
  "application/vnd.openxmlformats-officedocument.drawingml.diagramlayout+xml": { source: "iana", compressible: !0 },
  "application/vnd.openxmlformats-officedocument.drawingml.diagramstyle+xml": { source: "iana", compressible: !0 },
  "application/vnd.openxmlformats-officedocument.extended-properties+xml": { source: "iana", compressible: !0 },
  "application/vnd.openxmlformats-officedocument.presentationml.commentauthors+xml": { source: "iana", compressible: !0 },
  "application/vnd.openxmlformats-officedocument.presentationml.comments+xml": { source: "iana", compressible: !0 },
  "application/vnd.openxmlformats-officedocument.presentationml.handoutmaster+xml": { source: "iana", compressible: !0 },
  "application/vnd.openxmlformats-officedocument.presentationml.notesmaster+xml": { source: "iana", compressible: !0 },
  "application/vnd.openxmlformats-officedocument.presentationml.notesslide+xml": { source: "iana", compressible: !0 },
  "application/vnd.openxmlformats-officedocument.presentationml.presentation": { source: "iana", compressible: !1, extensions: ["pptx"] },
  "application/vnd.openxmlformats-officedocument.presentationml.presentation.main+xml": { source: "iana", compressible: !0 },
  "application/vnd.openxmlformats-officedocument.presentationml.presprops+xml": { source: "iana", compressible: !0 },
  "application/vnd.openxmlformats-officedocument.presentationml.slide": { source: "iana", extensions: ["sldx"] },
  "application/vnd.openxmlformats-officedocument.presentationml.slide+xml": { source: "iana", compressible: !0 },
  "application/vnd.openxmlformats-officedocument.presentationml.slidelayout+xml": { source: "iana", compressible: !0 },
  "application/vnd.openxmlformats-officedocument.presentationml.slidemaster+xml": { source: "iana", compressible: !0 },
  "application/vnd.openxmlformats-officedocument.presentationml.slideshow": { source: "iana", extensions: ["ppsx"] },
  "application/vnd.openxmlformats-officedocument.presentationml.slideshow.main+xml": { source: "iana", compressible: !0 },
  "application/vnd.openxmlformats-officedocument.presentationml.slideupdateinfo+xml": { source: "iana", compressible: !0 },
  "application/vnd.openxmlformats-officedocument.presentationml.tablestyles+xml": { source: "iana", compressible: !0 },
  "application/vnd.openxmlformats-officedocument.presentationml.tags+xml": { source: "iana", compressible: !0 },
  "application/vnd.openxmlformats-officedocument.presentationml.template": { source: "iana", extensions: ["potx"] },
  "application/vnd.openxmlformats-officedocument.presentationml.template.main+xml": { source: "iana", compressible: !0 },
  "application/vnd.openxmlformats-officedocument.presentationml.viewprops+xml": { source: "iana", compressible: !0 },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.calcchain+xml": { source: "iana", compressible: !0 },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.chartsheet+xml": { source: "iana", compressible: !0 },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.comments+xml": { source: "iana", compressible: !0 },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.connections+xml": { source: "iana", compressible: !0 },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.dialogsheet+xml": { source: "iana", compressible: !0 },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.externallink+xml": { source: "iana", compressible: !0 },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcachedefinition+xml": { source: "iana", compressible: !0 },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcacherecords+xml": { source: "iana", compressible: !0 },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.pivottable+xml": { source: "iana", compressible: !0 },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.querytable+xml": { source: "iana", compressible: !0 },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.revisionheaders+xml": { source: "iana", compressible: !0 },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.revisionlog+xml": { source: "iana", compressible: !0 },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.sharedstrings+xml": { source: "iana", compressible: !0 },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet": { source: "iana", compressible: !1, extensions: ["xlsx"] },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml": { source: "iana", compressible: !0 },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.sheetmetadata+xml": { source: "iana", compressible: !0 },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.styles+xml": { source: "iana", compressible: !0 },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.table+xml": { source: "iana", compressible: !0 },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.tablesinglecells+xml": { source: "iana", compressible: !0 },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.template": { source: "iana", extensions: ["xltx"] },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.template.main+xml": { source: "iana", compressible: !0 },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.usernames+xml": { source: "iana", compressible: !0 },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.volatiledependencies+xml": { source: "iana", compressible: !0 },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml": { source: "iana", compressible: !0 },
  "application/vnd.openxmlformats-officedocument.theme+xml": { source: "iana", compressible: !0 },
  "application/vnd.openxmlformats-officedocument.themeoverride+xml": { source: "iana", compressible: !0 },
  "application/vnd.openxmlformats-officedocument.vmldrawing": { source: "iana" },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.comments+xml": { source: "iana", compressible: !0 },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.document": { source: "iana", compressible: !1, extensions: ["docx"] },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.document.glossary+xml": { source: "iana", compressible: !0 },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.document.main+xml": { source: "iana", compressible: !0 },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.endnotes+xml": { source: "iana", compressible: !0 },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.fonttable+xml": { source: "iana", compressible: !0 },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.footer+xml": { source: "iana", compressible: !0 },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.footnotes+xml": { source: "iana", compressible: !0 },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.numbering+xml": { source: "iana", compressible: !0 },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.settings+xml": { source: "iana", compressible: !0 },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.styles+xml": { source: "iana", compressible: !0 },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.template": { source: "iana", extensions: ["dotx"] },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.template.main+xml": { source: "iana", compressible: !0 },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.websettings+xml": { source: "iana", compressible: !0 },
  "application/vnd.openxmlformats-package.core-properties+xml": { source: "iana", compressible: !0 },
  "application/vnd.openxmlformats-package.digital-signature-xmlsignature+xml": { source: "iana", compressible: !0 },
  "application/vnd.openxmlformats-package.relationships+xml": { source: "iana", compressible: !0 },
  "application/vnd.oracle.resource+json": { source: "iana", compressible: !0 },
  "application/vnd.orange.indata": { source: "iana" },
  "application/vnd.osa.netdeploy": { source: "iana" },
  "application/vnd.osgeo.mapguide.package": { source: "iana", extensions: ["mgp"] },
  "application/vnd.osgi.bundle": { source: "iana" },
  "application/vnd.osgi.dp": { source: "iana", extensions: ["dp"] },
  "application/vnd.osgi.subsystem": { source: "iana", extensions: ["esa"] },
  "application/vnd.otps.ct-kip+xml": { source: "iana", compressible: !0 },
  "application/vnd.oxli.countgraph": { source: "iana" },
  "application/vnd.pagerduty+json": { source: "iana", compressible: !0 },
  "application/vnd.palm": { source: "iana", extensions: ["pdb", "pqa", "oprc"] },
  "application/vnd.panoply": { source: "iana" },
  "application/vnd.paos.xml": { source: "iana" },
  "application/vnd.patentdive": { source: "iana" },
  "application/vnd.patientecommsdoc": { source: "iana" },
  "application/vnd.pawaafile": { source: "iana", extensions: ["paw"] },
  "application/vnd.pcos": { source: "iana" },
  "application/vnd.pg.format": { source: "iana", extensions: ["str"] },
  "application/vnd.pg.osasli": { source: "iana", extensions: ["ei6"] },
  "application/vnd.piaccess.application-licence": { source: "iana" },
  "application/vnd.picsel": { source: "iana", extensions: ["efif"] },
  "application/vnd.pmi.widget": { source: "iana", extensions: ["wg"] },
  "application/vnd.poc.group-advertisement+xml": { source: "iana", compressible: !0 },
  "application/vnd.pocketlearn": { source: "iana", extensions: ["plf"] },
  "application/vnd.powerbuilder6": { source: "iana", extensions: ["pbd"] },
  "application/vnd.powerbuilder6-s": { source: "iana" },
  "application/vnd.powerbuilder7": { source: "iana" },
  "application/vnd.powerbuilder7-s": { source: "iana" },
  "application/vnd.powerbuilder75": { source: "iana" },
  "application/vnd.powerbuilder75-s": { source: "iana" },
  "application/vnd.preminet": { source: "iana" },
  "application/vnd.previewsystems.box": { source: "iana", extensions: ["box"] },
  "application/vnd.proteus.magazine": { source: "iana", extensions: ["mgz"] },
  "application/vnd.psfs": { source: "iana" },
  "application/vnd.publishare-delta-tree": { source: "iana", extensions: ["qps"] },
  "application/vnd.pvi.ptid1": { source: "iana", extensions: ["ptid"] },
  "application/vnd.pwg-multiplexed": { source: "iana" },
  "application/vnd.pwg-xhtml-print+xml": { source: "iana", compressible: !0 },
  "application/vnd.qualcomm.brew-app-res": { source: "iana" },
  "application/vnd.quarantainenet": { source: "iana" },
  "application/vnd.quark.quarkxpress": { source: "iana", extensions: ["qxd", "qxt", "qwd", "qwt", "qxl", "qxb"] },
  "application/vnd.quobject-quoxdocument": { source: "iana" },
  "application/vnd.radisys.moml+xml": { source: "iana", compressible: !0 },
  "application/vnd.radisys.msml+xml": { source: "iana", compressible: !0 },
  "application/vnd.radisys.msml-audit+xml": { source: "iana", compressible: !0 },
  "application/vnd.radisys.msml-audit-conf+xml": { source: "iana", compressible: !0 },
  "application/vnd.radisys.msml-audit-conn+xml": { source: "iana", compressible: !0 },
  "application/vnd.radisys.msml-audit-dialog+xml": { source: "iana", compressible: !0 },
  "application/vnd.radisys.msml-audit-stream+xml": { source: "iana", compressible: !0 },
  "application/vnd.radisys.msml-conf+xml": { source: "iana", compressible: !0 },
  "application/vnd.radisys.msml-dialog+xml": { source: "iana", compressible: !0 },
  "application/vnd.radisys.msml-dialog-base+xml": { source: "iana", compressible: !0 },
  "application/vnd.radisys.msml-dialog-fax-detect+xml": { source: "iana", compressible: !0 },
  "application/vnd.radisys.msml-dialog-fax-sendrecv+xml": { source: "iana", compressible: !0 },
  "application/vnd.radisys.msml-dialog-group+xml": { source: "iana", compressible: !0 },
  "application/vnd.radisys.msml-dialog-speech+xml": { source: "iana", compressible: !0 },
  "application/vnd.radisys.msml-dialog-transform+xml": { source: "iana", compressible: !0 },
  "application/vnd.rainstor.data": { source: "iana" },
  "application/vnd.rapid": { source: "iana" },
  "application/vnd.rar": { source: "iana", extensions: ["rar"] },
  "application/vnd.realvnc.bed": { source: "iana", extensions: ["bed"] },
  "application/vnd.recordare.musicxml": { source: "iana", extensions: ["mxl"] },
  "application/vnd.recordare.musicxml+xml": { source: "iana", compressible: !0, extensions: ["musicxml"] },
  "application/vnd.renlearn.rlprint": { source: "iana" },
  "application/vnd.resilient.logic": { source: "iana" },
  "application/vnd.restful+json": { source: "iana", compressible: !0 },
  "application/vnd.rig.cryptonote": { source: "iana", extensions: ["cryptonote"] },
  "application/vnd.rim.cod": { source: "apache", extensions: ["cod"] },
  "application/vnd.rn-realmedia": { source: "apache", extensions: ["rm"] },
  "application/vnd.rn-realmedia-vbr": { source: "apache", extensions: ["rmvb"] },
  "application/vnd.route66.link66+xml": { source: "iana", compressible: !0, extensions: ["link66"] },
  "application/vnd.rs-274x": { source: "iana" },
  "application/vnd.ruckus.download": { source: "iana" },
  "application/vnd.s3sms": { source: "iana" },
  "application/vnd.sailingtracker.track": { source: "iana", extensions: ["st"] },
  "application/vnd.sar": { source: "iana" },
  "application/vnd.sbm.cid": { source: "iana" },
  "application/vnd.sbm.mid2": { source: "iana" },
  "application/vnd.scribus": { source: "iana" },
  "application/vnd.sealed.3df": { source: "iana" },
  "application/vnd.sealed.csf": { source: "iana" },
  "application/vnd.sealed.doc": { source: "iana" },
  "application/vnd.sealed.eml": { source: "iana" },
  "application/vnd.sealed.mht": { source: "iana" },
  "application/vnd.sealed.net": { source: "iana" },
  "application/vnd.sealed.ppt": { source: "iana" },
  "application/vnd.sealed.tiff": { source: "iana" },
  "application/vnd.sealed.xls": { source: "iana" },
  "application/vnd.sealedmedia.softseal.html": { source: "iana" },
  "application/vnd.sealedmedia.softseal.pdf": { source: "iana" },
  "application/vnd.seemail": { source: "iana", extensions: ["see"] },
  "application/vnd.seis+json": { source: "iana", compressible: !0 },
  "application/vnd.sema": { source: "iana", extensions: ["sema"] },
  "application/vnd.semd": { source: "iana", extensions: ["semd"] },
  "application/vnd.semf": { source: "iana", extensions: ["semf"] },
  "application/vnd.shade-save-file": { source: "iana" },
  "application/vnd.shana.informed.formdata": { source: "iana", extensions: ["ifm"] },
  "application/vnd.shana.informed.formtemplate": { source: "iana", extensions: ["itp"] },
  "application/vnd.shana.informed.interchange": { source: "iana", extensions: ["iif"] },
  "application/vnd.shana.informed.package": { source: "iana", extensions: ["ipk"] },
  "application/vnd.shootproof+json": { source: "iana", compressible: !0 },
  "application/vnd.shopkick+json": { source: "iana", compressible: !0 },
  "application/vnd.shp": { source: "iana" },
  "application/vnd.shx": { source: "iana" },
  "application/vnd.sigrok.session": { source: "iana" },
  "application/vnd.simtech-mindmapper": { source: "iana", extensions: ["twd", "twds"] },
  "application/vnd.siren+json": { source: "iana", compressible: !0 },
  "application/vnd.smaf": { source: "iana", extensions: ["mmf"] },
  "application/vnd.smart.notebook": { source: "iana" },
  "application/vnd.smart.teacher": { source: "iana", extensions: ["teacher"] },
  "application/vnd.snesdev-page-table": { source: "iana" },
  "application/vnd.software602.filler.form+xml": { source: "iana", compressible: !0, extensions: ["fo"] },
  "application/vnd.software602.filler.form-xml-zip": { source: "iana" },
  "application/vnd.solent.sdkm+xml": { source: "iana", compressible: !0, extensions: ["sdkm", "sdkd"] },
  "application/vnd.spotfire.dxp": { source: "iana", extensions: ["dxp"] },
  "application/vnd.spotfire.sfs": { source: "iana", extensions: ["sfs"] },
  "application/vnd.sqlite3": { source: "iana" },
  "application/vnd.sss-cod": { source: "iana" },
  "application/vnd.sss-dtf": { source: "iana" },
  "application/vnd.sss-ntf": { source: "iana" },
  "application/vnd.stardivision.calc": { source: "apache", extensions: ["sdc"] },
  "application/vnd.stardivision.draw": { source: "apache", extensions: ["sda"] },
  "application/vnd.stardivision.impress": { source: "apache", extensions: ["sdd"] },
  "application/vnd.stardivision.math": { source: "apache", extensions: ["smf"] },
  "application/vnd.stardivision.writer": { source: "apache", extensions: ["sdw", "vor"] },
  "application/vnd.stardivision.writer-global": { source: "apache", extensions: ["sgl"] },
  "application/vnd.stepmania.package": { source: "iana", extensions: ["smzip"] },
  "application/vnd.stepmania.stepchart": { source: "iana", extensions: ["sm"] },
  "application/vnd.street-stream": { source: "iana" },
  "application/vnd.sun.wadl+xml": { source: "iana", compressible: !0, extensions: ["wadl"] },
  "application/vnd.sun.xml.calc": { source: "apache", extensions: ["sxc"] },
  "application/vnd.sun.xml.calc.template": { source: "apache", extensions: ["stc"] },
  "application/vnd.sun.xml.draw": { source: "apache", extensions: ["sxd"] },
  "application/vnd.sun.xml.draw.template": { source: "apache", extensions: ["std"] },
  "application/vnd.sun.xml.impress": { source: "apache", extensions: ["sxi"] },
  "application/vnd.sun.xml.impress.template": { source: "apache", extensions: ["sti"] },
  "application/vnd.sun.xml.math": { source: "apache", extensions: ["sxm"] },
  "application/vnd.sun.xml.writer": { source: "apache", extensions: ["sxw"] },
  "application/vnd.sun.xml.writer.global": { source: "apache", extensions: ["sxg"] },
  "application/vnd.sun.xml.writer.template": { source: "apache", extensions: ["stw"] },
  "application/vnd.sus-calendar": { source: "iana", extensions: ["sus", "susp"] },
  "application/vnd.svd": { source: "iana", extensions: ["svd"] },
  "application/vnd.swiftview-ics": { source: "iana" },
  "application/vnd.sycle+xml": { source: "iana", compressible: !0 },
  "application/vnd.syft+json": { source: "iana", compressible: !0 },
  "application/vnd.symbian.install": { source: "apache", extensions: ["sis", "sisx"] },
  "application/vnd.syncml+xml": { source: "iana", charset: "UTF-8", compressible: !0, extensions: ["xsm"] },
  "application/vnd.syncml.dm+wbxml": { source: "iana", charset: "UTF-8", extensions: ["bdm"] },
  "application/vnd.syncml.dm+xml": { source: "iana", charset: "UTF-8", compressible: !0, extensions: ["xdm"] },
  "application/vnd.syncml.dm.notification": { source: "iana" },
  "application/vnd.syncml.dmddf+wbxml": { source: "iana" },
  "application/vnd.syncml.dmddf+xml": { source: "iana", charset: "UTF-8", compressible: !0, extensions: ["ddf"] },
  "application/vnd.syncml.dmtnds+wbxml": { source: "iana" },
  "application/vnd.syncml.dmtnds+xml": { source: "iana", charset: "UTF-8", compressible: !0 },
  "application/vnd.syncml.ds.notification": { source: "iana" },
  "application/vnd.tableschema+json": { source: "iana", compressible: !0 },
  "application/vnd.tao.intent-module-archive": { source: "iana", extensions: ["tao"] },
  "application/vnd.tcpdump.pcap": { source: "iana", extensions: ["pcap", "cap", "dmp"] },
  "application/vnd.think-cell.ppttc+json": { source: "iana", compressible: !0 },
  "application/vnd.tmd.mediaflex.api+xml": { source: "iana", compressible: !0 },
  "application/vnd.tml": { source: "iana" },
  "application/vnd.tmobile-livetv": { source: "iana", extensions: ["tmo"] },
  "application/vnd.tri.onesource": { source: "iana" },
  "application/vnd.trid.tpt": { source: "iana", extensions: ["tpt"] },
  "application/vnd.triscape.mxs": { source: "iana", extensions: ["mxs"] },
  "application/vnd.trueapp": { source: "iana", extensions: ["tra"] },
  "application/vnd.truedoc": { source: "iana" },
  "application/vnd.ubisoft.webplayer": { source: "iana" },
  "application/vnd.ufdl": { source: "iana", extensions: ["ufd", "ufdl"] },
  "application/vnd.uiq.theme": { source: "iana", extensions: ["utz"] },
  "application/vnd.umajin": { source: "iana", extensions: ["umj"] },
  "application/vnd.unity": { source: "iana", extensions: ["unityweb"] },
  "application/vnd.uoml+xml": { source: "iana", compressible: !0, extensions: ["uoml"] },
  "application/vnd.uplanet.alert": { source: "iana" },
  "application/vnd.uplanet.alert-wbxml": { source: "iana" },
  "application/vnd.uplanet.bearer-choice": { source: "iana" },
  "application/vnd.uplanet.bearer-choice-wbxml": { source: "iana" },
  "application/vnd.uplanet.cacheop": { source: "iana" },
  "application/vnd.uplanet.cacheop-wbxml": { source: "iana" },
  "application/vnd.uplanet.channel": { source: "iana" },
  "application/vnd.uplanet.channel-wbxml": { source: "iana" },
  "application/vnd.uplanet.list": { source: "iana" },
  "application/vnd.uplanet.list-wbxml": { source: "iana" },
  "application/vnd.uplanet.listcmd": { source: "iana" },
  "application/vnd.uplanet.listcmd-wbxml": { source: "iana" },
  "application/vnd.uplanet.signal": { source: "iana" },
  "application/vnd.uri-map": { source: "iana" },
  "application/vnd.valve.source.material": { source: "iana" },
  "application/vnd.vcx": { source: "iana", extensions: ["vcx"] },
  "application/vnd.vd-study": { source: "iana" },
  "application/vnd.vectorworks": { source: "iana" },
  "application/vnd.vel+json": { source: "iana", compressible: !0 },
  "application/vnd.verimatrix.vcas": { source: "iana" },
  "application/vnd.veritone.aion+json": { source: "iana", compressible: !0 },
  "application/vnd.veryant.thin": { source: "iana" },
  "application/vnd.ves.encrypted": { source: "iana" },
  "application/vnd.vidsoft.vidconference": { source: "iana" },
  "application/vnd.visio": { source: "iana", extensions: ["vsd", "vst", "vss", "vsw"] },
  "application/vnd.visionary": { source: "iana", extensions: ["vis"] },
  "application/vnd.vividence.scriptfile": { source: "iana" },
  "application/vnd.vsf": { source: "iana", extensions: ["vsf"] },
  "application/vnd.wap.sic": { source: "iana" },
  "application/vnd.wap.slc": { source: "iana" },
  "application/vnd.wap.wbxml": { source: "iana", charset: "UTF-8", extensions: ["wbxml"] },
  "application/vnd.wap.wmlc": { source: "iana", extensions: ["wmlc"] },
  "application/vnd.wap.wmlscriptc": { source: "iana", extensions: ["wmlsc"] },
  "application/vnd.webturbo": { source: "iana", extensions: ["wtb"] },
  "application/vnd.wfa.dpp": { source: "iana" },
  "application/vnd.wfa.p2p": { source: "iana" },
  "application/vnd.wfa.wsc": { source: "iana" },
  "application/vnd.windows.devicepairing": { source: "iana" },
  "application/vnd.wmc": { source: "iana" },
  "application/vnd.wmf.bootstrap": { source: "iana" },
  "application/vnd.wolfram.mathematica": { source: "iana" },
  "application/vnd.wolfram.mathematica.package": { source: "iana" },
  "application/vnd.wolfram.player": { source: "iana", extensions: ["nbp"] },
  "application/vnd.wordperfect": { source: "iana", extensions: ["wpd"] },
  "application/vnd.wqd": { source: "iana", extensions: ["wqd"] },
  "application/vnd.wrq-hp3000-labelled": { source: "iana" },
  "application/vnd.wt.stf": { source: "iana", extensions: ["stf"] },
  "application/vnd.wv.csp+wbxml": { source: "iana" },
  "application/vnd.wv.csp+xml": { source: "iana", compressible: !0 },
  "application/vnd.wv.ssp+xml": { source: "iana", compressible: !0 },
  "application/vnd.xacml+json": { source: "iana", compressible: !0 },
  "application/vnd.xara": { source: "iana", extensions: ["xar"] },
  "application/vnd.xfdl": { source: "iana", extensions: ["xfdl"] },
  "application/vnd.xfdl.webform": { source: "iana" },
  "application/vnd.xmi+xml": { source: "iana", compressible: !0 },
  "application/vnd.xmpie.cpkg": { source: "iana" },
  "application/vnd.xmpie.dpkg": { source: "iana" },
  "application/vnd.xmpie.plan": { source: "iana" },
  "application/vnd.xmpie.ppkg": { source: "iana" },
  "application/vnd.xmpie.xlim": { source: "iana" },
  "application/vnd.yamaha.hv-dic": { source: "iana", extensions: ["hvd"] },
  "application/vnd.yamaha.hv-script": { source: "iana", extensions: ["hvs"] },
  "application/vnd.yamaha.hv-voice": { source: "iana", extensions: ["hvp"] },
  "application/vnd.yamaha.openscoreformat": { source: "iana", extensions: ["osf"] },
  "application/vnd.yamaha.openscoreformat.osfpvg+xml": { source: "iana", compressible: !0, extensions: ["osfpvg"] },
  "application/vnd.yamaha.remote-setup": { source: "iana" },
  "application/vnd.yamaha.smaf-audio": { source: "iana", extensions: ["saf"] },
  "application/vnd.yamaha.smaf-phrase": { source: "iana", extensions: ["spf"] },
  "application/vnd.yamaha.through-ngn": { source: "iana" },
  "application/vnd.yamaha.tunnel-udpencap": { source: "iana" },
  "application/vnd.yaoweme": { source: "iana" },
  "application/vnd.yellowriver-custom-menu": { source: "iana", extensions: ["cmp"] },
  "application/vnd.youtube.yt": { source: "iana" },
  "application/vnd.zul": { source: "iana", extensions: ["zir", "zirz"] },
  "application/vnd.zzazz.deck+xml": { source: "iana", compressible: !0, extensions: ["zaz"] },
  "application/voicexml+xml": { source: "iana", compressible: !0, extensions: ["vxml"] },
  "application/voucher-cms+json": { source: "iana", compressible: !0 },
  "application/vq-rtcpxr": { source: "iana" },
  "application/wasm": { source: "iana", compressible: !0, extensions: ["wasm"] },
  "application/watcherinfo+xml": { source: "iana", compressible: !0, extensions: ["wif"] },
  "application/webpush-options+json": { source: "iana", compressible: !0 },
  "application/whoispp-query": { source: "iana" },
  "application/whoispp-response": { source: "iana" },
  "application/widget": { source: "iana", extensions: ["wgt"] },
  "application/winhlp": { source: "apache", extensions: ["hlp"] },
  "application/wita": { source: "iana" },
  "application/wordperfect5.1": { source: "iana" },
  "application/wsdl+xml": { source: "iana", compressible: !0, extensions: ["wsdl"] },
  "application/wspolicy+xml": { source: "iana", compressible: !0, extensions: ["wspolicy"] },
  "application/x-7z-compressed": { source: "apache", compressible: !1, extensions: ["7z"] },
  "application/x-abiword": { source: "apache", extensions: ["abw"] },
  "application/x-ace-compressed": { source: "apache", extensions: ["ace"] },
  "application/x-amf": { source: "apache" },
  "application/x-apple-diskimage": { source: "apache", extensions: ["dmg"] },
  "application/x-arj": { compressible: !1, extensions: ["arj"] },
  "application/x-authorware-bin": { source: "apache", extensions: ["aab", "x32", "u32", "vox"] },
  "application/x-authorware-map": { source: "apache", extensions: ["aam"] },
  "application/x-authorware-seg": { source: "apache", extensions: ["aas"] },
  "application/x-bcpio": { source: "apache", extensions: ["bcpio"] },
  "application/x-bdoc": { compressible: !1, extensions: ["bdoc"] },
  "application/x-bittorrent": { source: "apache", extensions: ["torrent"] },
  "application/x-blorb": { source: "apache", extensions: ["blb", "blorb"] },
  "application/x-bzip": { source: "apache", compressible: !1, extensions: ["bz"] },
  "application/x-bzip2": { source: "apache", compressible: !1, extensions: ["bz2", "boz"] },
  "application/x-cbr": { source: "apache", extensions: ["cbr", "cba", "cbt", "cbz", "cb7"] },
  "application/x-cdlink": { source: "apache", extensions: ["vcd"] },
  "application/x-cfs-compressed": { source: "apache", extensions: ["cfs"] },
  "application/x-chat": { source: "apache", extensions: ["chat"] },
  "application/x-chess-pgn": { source: "apache", extensions: ["pgn"] },
  "application/x-chrome-extension": { extensions: ["crx"] },
  "application/x-cocoa": { source: "nginx", extensions: ["cco"] },
  "application/x-compress": { source: "apache" },
  "application/x-conference": { source: "apache", extensions: ["nsc"] },
  "application/x-cpio": { source: "apache", extensions: ["cpio"] },
  "application/x-csh": { source: "apache", extensions: ["csh"] },
  "application/x-deb": { compressible: !1 },
  "application/x-debian-package": { source: "apache", extensions: ["deb", "udeb"] },
  "application/x-dgc-compressed": { source: "apache", extensions: ["dgc"] },
  "application/x-director": { source: "apache", extensions: ["dir", "dcr", "dxr", "cst", "cct", "cxt", "w3d", "fgd", "swa"] },
  "application/x-doom": { source: "apache", extensions: ["wad"] },
  "application/x-dtbncx+xml": { source: "apache", compressible: !0, extensions: ["ncx"] },
  "application/x-dtbook+xml": { source: "apache", compressible: !0, extensions: ["dtb"] },
  "application/x-dtbresource+xml": { source: "apache", compressible: !0, extensions: ["res"] },
  "application/x-dvi": { source: "apache", compressible: !1, extensions: ["dvi"] },
  "application/x-envoy": { source: "apache", extensions: ["evy"] },
  "application/x-eva": { source: "apache", extensions: ["eva"] },
  "application/x-font-bdf": { source: "apache", extensions: ["bdf"] },
  "application/x-font-dos": { source: "apache" },
  "application/x-font-framemaker": { source: "apache" },
  "application/x-font-ghostscript": { source: "apache", extensions: ["gsf"] },
  "application/x-font-libgrx": { source: "apache" },
  "application/x-font-linux-psf": { source: "apache", extensions: ["psf"] },
  "application/x-font-pcf": { source: "apache", extensions: ["pcf"] },
  "application/x-font-snf": { source: "apache", extensions: ["snf"] },
  "application/x-font-speedo": { source: "apache" },
  "application/x-font-sunos-news": { source: "apache" },
  "application/x-font-type1": { source: "apache", extensions: ["pfa", "pfb", "pfm", "afm"] },
  "application/x-font-vfont": { source: "apache" },
  "application/x-freearc": { source: "apache", extensions: ["arc"] },
  "application/x-futuresplash": { source: "apache", extensions: ["spl"] },
  "application/x-gca-compressed": { source: "apache", extensions: ["gca"] },
  "application/x-glulx": { source: "apache", extensions: ["ulx"] },
  "application/x-gnumeric": { source: "apache", extensions: ["gnumeric"] },
  "application/x-gramps-xml": { source: "apache", extensions: ["gramps"] },
  "application/x-gtar": { source: "apache", extensions: ["gtar"] },
  "application/x-gzip": { source: "apache" },
  "application/x-hdf": { source: "apache", extensions: ["hdf"] },
  "application/x-httpd-php": { compressible: !0, extensions: ["php"] },
  "application/x-install-instructions": { source: "apache", extensions: ["install"] },
  "application/x-iso9660-image": { source: "apache", extensions: ["iso"] },
  "application/x-iwork-keynote-sffkey": { extensions: ["key"] },
  "application/x-iwork-numbers-sffnumbers": { extensions: ["numbers"] },
  "application/x-iwork-pages-sffpages": { extensions: ["pages"] },
  "application/x-java-archive-diff": { source: "nginx", extensions: ["jardiff"] },
  "application/x-java-jnlp-file": { source: "apache", compressible: !1, extensions: ["jnlp"] },
  "application/x-javascript": { compressible: !0 },
  "application/x-keepass2": { extensions: ["kdbx"] },
  "application/x-latex": { source: "apache", compressible: !1, extensions: ["latex"] },
  "application/x-lua-bytecode": { extensions: ["luac"] },
  "application/x-lzh-compressed": { source: "apache", extensions: ["lzh", "lha"] },
  "application/x-makeself": { source: "nginx", extensions: ["run"] },
  "application/x-mie": { source: "apache", extensions: ["mie"] },
  "application/x-mobipocket-ebook": { source: "apache", extensions: ["prc", "mobi"] },
  "application/x-mpegurl": { compressible: !1 },
  "application/x-ms-application": { source: "apache", extensions: ["application"] },
  "application/x-ms-shortcut": { source: "apache", extensions: ["lnk"] },
  "application/x-ms-wmd": { source: "apache", extensions: ["wmd"] },
  "application/x-ms-wmz": { source: "apache", extensions: ["wmz"] },
  "application/x-ms-xbap": { source: "apache", extensions: ["xbap"] },
  "application/x-msaccess": { source: "apache", extensions: ["mdb"] },
  "application/x-msbinder": { source: "apache", extensions: ["obd"] },
  "application/x-mscardfile": { source: "apache", extensions: ["crd"] },
  "application/x-msclip": { source: "apache", extensions: ["clp"] },
  "application/x-msdos-program": { extensions: ["exe"] },
  "application/x-msdownload": { source: "apache", extensions: ["exe", "dll", "com", "bat", "msi"] },
  "application/x-msmediaview": { source: "apache", extensions: ["mvb", "m13", "m14"] },
  "application/x-msmetafile": { source: "apache", extensions: ["wmf", "wmz", "emf", "emz"] },
  "application/x-msmoney": { source: "apache", extensions: ["mny"] },
  "application/x-mspublisher": { source: "apache", extensions: ["pub"] },
  "application/x-msschedule": { source: "apache", extensions: ["scd"] },
  "application/x-msterminal": { source: "apache", extensions: ["trm"] },
  "application/x-mswrite": { source: "apache", extensions: ["wri"] },
  "application/x-netcdf": { source: "apache", extensions: ["nc", "cdf"] },
  "application/x-ns-proxy-autoconfig": { compressible: !0, extensions: ["pac"] },
  "application/x-nzb": { source: "apache", extensions: ["nzb"] },
  "application/x-perl": { source: "nginx", extensions: ["pl", "pm"] },
  "application/x-pilot": { source: "nginx", extensions: ["prc", "pdb"] },
  "application/x-pkcs12": { source: "apache", compressible: !1, extensions: ["p12", "pfx"] },
  "application/x-pkcs7-certificates": { source: "apache", extensions: ["p7b", "spc"] },
  "application/x-pkcs7-certreqresp": { source: "apache", extensions: ["p7r"] },
  "application/x-pki-message": { source: "iana" },
  "application/x-rar-compressed": { source: "apache", compressible: !1, extensions: ["rar"] },
  "application/x-redhat-package-manager": { source: "nginx", extensions: ["rpm"] },
  "application/x-research-info-systems": { source: "apache", extensions: ["ris"] },
  "application/x-sea": { source: "nginx", extensions: ["sea"] },
  "application/x-sh": { source: "apache", compressible: !0, extensions: ["sh"] },
  "application/x-shar": { source: "apache", extensions: ["shar"] },
  "application/x-shockwave-flash": { source: "apache", compressible: !1, extensions: ["swf"] },
  "application/x-silverlight-app": { source: "apache", extensions: ["xap"] },
  "application/x-sql": { source: "apache", extensions: ["sql"] },
  "application/x-stuffit": { source: "apache", compressible: !1, extensions: ["sit"] },
  "application/x-stuffitx": { source: "apache", extensions: ["sitx"] },
  "application/x-subrip": { source: "apache", extensions: ["srt"] },
  "application/x-sv4cpio": { source: "apache", extensions: ["sv4cpio"] },
  "application/x-sv4crc": { source: "apache", extensions: ["sv4crc"] },
  "application/x-t3vm-image": { source: "apache", extensions: ["t3"] },
  "application/x-tads": { source: "apache", extensions: ["gam"] },
  "application/x-tar": { source: "apache", compressible: !0, extensions: ["tar"] },
  "application/x-tcl": { source: "apache", extensions: ["tcl", "tk"] },
  "application/x-tex": { source: "apache", extensions: ["tex"] },
  "application/x-tex-tfm": { source: "apache", extensions: ["tfm"] },
  "application/x-texinfo": { source: "apache", extensions: ["texinfo", "texi"] },
  "application/x-tgif": { source: "apache", extensions: ["obj"] },
  "application/x-ustar": { source: "apache", extensions: ["ustar"] },
  "application/x-virtualbox-hdd": { compressible: !0, extensions: ["hdd"] },
  "application/x-virtualbox-ova": { compressible: !0, extensions: ["ova"] },
  "application/x-virtualbox-ovf": { compressible: !0, extensions: ["ovf"] },
  "application/x-virtualbox-vbox": { compressible: !0, extensions: ["vbox"] },
  "application/x-virtualbox-vbox-extpack": { compressible: !1, extensions: ["vbox-extpack"] },
  "application/x-virtualbox-vdi": { compressible: !0, extensions: ["vdi"] },
  "application/x-virtualbox-vhd": { compressible: !0, extensions: ["vhd"] },
  "application/x-virtualbox-vmdk": { compressible: !0, extensions: ["vmdk"] },
  "application/x-wais-source": { source: "apache", extensions: ["src"] },
  "application/x-web-app-manifest+json": { compressible: !0, extensions: ["webapp"] },
  "application/x-www-form-urlencoded": { source: "iana", compressible: !0 },
  "application/x-x509-ca-cert": { source: "iana", extensions: ["der", "crt", "pem"] },
  "application/x-x509-ca-ra-cert": { source: "iana" },
  "application/x-x509-next-ca-cert": { source: "iana" },
  "application/x-xfig": { source: "apache", extensions: ["fig"] },
  "application/x-xliff+xml": { source: "apache", compressible: !0, extensions: ["xlf"] },
  "application/x-xpinstall": { source: "apache", compressible: !1, extensions: ["xpi"] },
  "application/x-xz": { source: "apache", extensions: ["xz"] },
  "application/x-zmachine": { source: "apache", extensions: ["z1", "z2", "z3", "z4", "z5", "z6", "z7", "z8"] },
  "application/x400-bp": { source: "iana" },
  "application/xacml+xml": { source: "iana", compressible: !0 },
  "application/xaml+xml": { source: "apache", compressible: !0, extensions: ["xaml"] },
  "application/xcap-att+xml": { source: "iana", compressible: !0, extensions: ["xav"] },
  "application/xcap-caps+xml": { source: "iana", compressible: !0, extensions: ["xca"] },
  "application/xcap-diff+xml": { source: "iana", compressible: !0, extensions: ["xdf"] },
  "application/xcap-el+xml": { source: "iana", compressible: !0, extensions: ["xel"] },
  "application/xcap-error+xml": { source: "iana", compressible: !0 },
  "application/xcap-ns+xml": { source: "iana", compressible: !0, extensions: ["xns"] },
  "application/xcon-conference-info+xml": { source: "iana", compressible: !0 },
  "application/xcon-conference-info-diff+xml": { source: "iana", compressible: !0 },
  "application/xenc+xml": { source: "iana", compressible: !0, extensions: ["xenc"] },
  "application/xhtml+xml": { source: "iana", compressible: !0, extensions: ["xhtml", "xht"] },
  "application/xhtml-voice+xml": { source: "apache", compressible: !0 },
  "application/xliff+xml": { source: "iana", compressible: !0, extensions: ["xlf"] },
  "application/xml": { source: "iana", compressible: !0, extensions: ["xml", "xsl", "xsd", "rng"] },
  "application/xml-dtd": { source: "iana", compressible: !0, extensions: ["dtd"] },
  "application/xml-external-parsed-entity": { source: "iana" },
  "application/xml-patch+xml": { source: "iana", compressible: !0 },
  "application/xmpp+xml": { source: "iana", compressible: !0 },
  "application/xop+xml": { source: "iana", compressible: !0, extensions: ["xop"] },
  "application/xproc+xml": { source: "apache", compressible: !0, extensions: ["xpl"] },
  "application/xslt+xml": { source: "iana", compressible: !0, extensions: ["xsl", "xslt"] },
  "application/xspf+xml": { source: "apache", compressible: !0, extensions: ["xspf"] },
  "application/xv+xml": { source: "iana", compressible: !0, extensions: ["mxml", "xhvml", "xvml", "xvm"] },
  "application/yang": { source: "iana", extensions: ["yang"] },
  "application/yang-data+json": { source: "iana", compressible: !0 },
  "application/yang-data+xml": { source: "iana", compressible: !0 },
  "application/yang-patch+json": { source: "iana", compressible: !0 },
  "application/yang-patch+xml": { source: "iana", compressible: !0 },
  "application/yin+xml": { source: "iana", compressible: !0, extensions: ["yin"] },
  "application/zip": { source: "iana", compressible: !1, extensions: ["zip"] },
  "application/zlib": { source: "iana" },
  "application/zstd": { source: "iana" },
  "audio/1d-interleaved-parityfec": { source: "iana" },
  "audio/32kadpcm": { source: "iana" },
  "audio/3gpp": { source: "iana", compressible: !1, extensions: ["3gpp"] },
  "audio/3gpp2": { source: "iana" },
  "audio/aac": { source: "iana" },
  "audio/ac3": { source: "iana" },
  "audio/adpcm": { source: "apache", extensions: ["adp"] },
  "audio/amr": { source: "iana", extensions: ["amr"] },
  "audio/amr-wb": { source: "iana" },
  "audio/amr-wb+": { source: "iana" },
  "audio/aptx": { source: "iana" },
  "audio/asc": { source: "iana" },
  "audio/atrac-advanced-lossless": { source: "iana" },
  "audio/atrac-x": { source: "iana" },
  "audio/atrac3": { source: "iana" },
  "audio/basic": { source: "iana", compressible: !1, extensions: ["au", "snd"] },
  "audio/bv16": { source: "iana" },
  "audio/bv32": { source: "iana" },
  "audio/clearmode": { source: "iana" },
  "audio/cn": { source: "iana" },
  "audio/dat12": { source: "iana" },
  "audio/dls": { source: "iana" },
  "audio/dsr-es201108": { source: "iana" },
  "audio/dsr-es202050": { source: "iana" },
  "audio/dsr-es202211": { source: "iana" },
  "audio/dsr-es202212": { source: "iana" },
  "audio/dv": { source: "iana" },
  "audio/dvi4": { source: "iana" },
  "audio/eac3": { source: "iana" },
  "audio/encaprtp": { source: "iana" },
  "audio/evrc": { source: "iana" },
  "audio/evrc-qcp": { source: "iana" },
  "audio/evrc0": { source: "iana" },
  "audio/evrc1": { source: "iana" },
  "audio/evrcb": { source: "iana" },
  "audio/evrcb0": { source: "iana" },
  "audio/evrcb1": { source: "iana" },
  "audio/evrcnw": { source: "iana" },
  "audio/evrcnw0": { source: "iana" },
  "audio/evrcnw1": { source: "iana" },
  "audio/evrcwb": { source: "iana" },
  "audio/evrcwb0": { source: "iana" },
  "audio/evrcwb1": { source: "iana" },
  "audio/evs": { source: "iana" },
  "audio/flexfec": { source: "iana" },
  "audio/fwdred": { source: "iana" },
  "audio/g711-0": { source: "iana" },
  "audio/g719": { source: "iana" },
  "audio/g722": { source: "iana" },
  "audio/g7221": { source: "iana" },
  "audio/g723": { source: "iana" },
  "audio/g726-16": { source: "iana" },
  "audio/g726-24": { source: "iana" },
  "audio/g726-32": { source: "iana" },
  "audio/g726-40": { source: "iana" },
  "audio/g728": { source: "iana" },
  "audio/g729": { source: "iana" },
  "audio/g7291": { source: "iana" },
  "audio/g729d": { source: "iana" },
  "audio/g729e": { source: "iana" },
  "audio/gsm": { source: "iana" },
  "audio/gsm-efr": { source: "iana" },
  "audio/gsm-hr-08": { source: "iana" },
  "audio/ilbc": { source: "iana" },
  "audio/ip-mr_v2.5": { source: "iana" },
  "audio/isac": { source: "apache" },
  "audio/l16": { source: "iana" },
  "audio/l20": { source: "iana" },
  "audio/l24": { source: "iana", compressible: !1 },
  "audio/l8": { source: "iana" },
  "audio/lpc": { source: "iana" },
  "audio/melp": { source: "iana" },
  "audio/melp1200": { source: "iana" },
  "audio/melp2400": { source: "iana" },
  "audio/melp600": { source: "iana" },
  "audio/mhas": { source: "iana" },
  "audio/midi": { source: "apache", extensions: ["mid", "midi", "kar", "rmi"] },
  "audio/mobile-xmf": { source: "iana", extensions: ["mxmf"] },
  "audio/mp3": { compressible: !1, extensions: ["mp3"] },
  "audio/mp4": { source: "iana", compressible: !1, extensions: ["m4a", "mp4a"] },
  "audio/mp4a-latm": { source: "iana" },
  "audio/mpa": { source: "iana" },
  "audio/mpa-robust": { source: "iana" },
  "audio/mpeg": { source: "iana", compressible: !1, extensions: ["mpga", "mp2", "mp2a", "mp3", "m2a", "m3a"] },
  "audio/mpeg4-generic": { source: "iana" },
  "audio/musepack": { source: "apache" },
  "audio/ogg": { source: "iana", compressible: !1, extensions: ["oga", "ogg", "spx", "opus"] },
  "audio/opus": { source: "iana" },
  "audio/parityfec": { source: "iana" },
  "audio/pcma": { source: "iana" },
  "audio/pcma-wb": { source: "iana" },
  "audio/pcmu": { source: "iana" },
  "audio/pcmu-wb": { source: "iana" },
  "audio/prs.sid": { source: "iana" },
  "audio/qcelp": { source: "iana" },
  "audio/raptorfec": { source: "iana" },
  "audio/red": { source: "iana" },
  "audio/rtp-enc-aescm128": { source: "iana" },
  "audio/rtp-midi": { source: "iana" },
  "audio/rtploopback": { source: "iana" },
  "audio/rtx": { source: "iana" },
  "audio/s3m": { source: "apache", extensions: ["s3m"] },
  "audio/scip": { source: "iana" },
  "audio/silk": { source: "apache", extensions: ["sil"] },
  "audio/smv": { source: "iana" },
  "audio/smv-qcp": { source: "iana" },
  "audio/smv0": { source: "iana" },
  "audio/sofa": { source: "iana" },
  "audio/sp-midi": { source: "iana" },
  "audio/speex": { source: "iana" },
  "audio/t140c": { source: "iana" },
  "audio/t38": { source: "iana" },
  "audio/telephone-event": { source: "iana" },
  "audio/tetra_acelp": { source: "iana" },
  "audio/tetra_acelp_bb": { source: "iana" },
  "audio/tone": { source: "iana" },
  "audio/tsvcis": { source: "iana" },
  "audio/uemclip": { source: "iana" },
  "audio/ulpfec": { source: "iana" },
  "audio/usac": { source: "iana" },
  "audio/vdvi": { source: "iana" },
  "audio/vmr-wb": { source: "iana" },
  "audio/vnd.3gpp.iufp": { source: "iana" },
  "audio/vnd.4sb": { source: "iana" },
  "audio/vnd.audiokoz": { source: "iana" },
  "audio/vnd.celp": { source: "iana" },
  "audio/vnd.cisco.nse": { source: "iana" },
  "audio/vnd.cmles.radio-events": { source: "iana" },
  "audio/vnd.cns.anp1": { source: "iana" },
  "audio/vnd.cns.inf1": { source: "iana" },
  "audio/vnd.dece.audio": { source: "iana", extensions: ["uva", "uvva"] },
  "audio/vnd.digital-winds": { source: "iana", extensions: ["eol"] },
  "audio/vnd.dlna.adts": { source: "iana" },
  "audio/vnd.dolby.heaac.1": { source: "iana" },
  "audio/vnd.dolby.heaac.2": { source: "iana" },
  "audio/vnd.dolby.mlp": { source: "iana" },
  "audio/vnd.dolby.mps": { source: "iana" },
  "audio/vnd.dolby.pl2": { source: "iana" },
  "audio/vnd.dolby.pl2x": { source: "iana" },
  "audio/vnd.dolby.pl2z": { source: "iana" },
  "audio/vnd.dolby.pulse.1": { source: "iana" },
  "audio/vnd.dra": { source: "iana", extensions: ["dra"] },
  "audio/vnd.dts": { source: "iana", extensions: ["dts"] },
  "audio/vnd.dts.hd": { source: "iana", extensions: ["dtshd"] },
  "audio/vnd.dts.uhd": { source: "iana" },
  "audio/vnd.dvb.file": { source: "iana" },
  "audio/vnd.everad.plj": { source: "iana" },
  "audio/vnd.hns.audio": { source: "iana" },
  "audio/vnd.lucent.voice": { source: "iana", extensions: ["lvp"] },
  "audio/vnd.ms-playready.media.pya": { source: "iana", extensions: ["pya"] },
  "audio/vnd.nokia.mobile-xmf": { source: "iana" },
  "audio/vnd.nortel.vbk": { source: "iana" },
  "audio/vnd.nuera.ecelp4800": { source: "iana", extensions: ["ecelp4800"] },
  "audio/vnd.nuera.ecelp7470": { source: "iana", extensions: ["ecelp7470"] },
  "audio/vnd.nuera.ecelp9600": { source: "iana", extensions: ["ecelp9600"] },
  "audio/vnd.octel.sbc": { source: "iana" },
  "audio/vnd.presonus.multitrack": { source: "iana" },
  "audio/vnd.qcelp": { source: "iana" },
  "audio/vnd.rhetorex.32kadpcm": { source: "iana" },
  "audio/vnd.rip": { source: "iana", extensions: ["rip"] },
  "audio/vnd.rn-realaudio": { compressible: !1 },
  "audio/vnd.sealedmedia.softseal.mpeg": { source: "iana" },
  "audio/vnd.vmx.cvsd": { source: "iana" },
  "audio/vnd.wave": { compressible: !1 },
  "audio/vorbis": { source: "iana", compressible: !1 },
  "audio/vorbis-config": { source: "iana" },
  "audio/wav": { compressible: !1, extensions: ["wav"] },
  "audio/wave": { compressible: !1, extensions: ["wav"] },
  "audio/webm": { source: "apache", compressible: !1, extensions: ["weba"] },
  "audio/x-aac": { source: "apache", compressible: !1, extensions: ["aac"] },
  "audio/x-aiff": { source: "apache", extensions: ["aif", "aiff", "aifc"] },
  "audio/x-caf": { source: "apache", compressible: !1, extensions: ["caf"] },
  "audio/x-flac": { source: "apache", extensions: ["flac"] },
  "audio/x-m4a": { source: "nginx", extensions: ["m4a"] },
  "audio/x-matroska": { source: "apache", extensions: ["mka"] },
  "audio/x-mpegurl": { source: "apache", extensions: ["m3u"] },
  "audio/x-ms-wax": { source: "apache", extensions: ["wax"] },
  "audio/x-ms-wma": { source: "apache", extensions: ["wma"] },
  "audio/x-pn-realaudio": { source: "apache", extensions: ["ram", "ra"] },
  "audio/x-pn-realaudio-plugin": { source: "apache", extensions: ["rmp"] },
  "audio/x-realaudio": { source: "nginx", extensions: ["ra"] },
  "audio/x-tta": { source: "apache" },
  "audio/x-wav": { source: "apache", extensions: ["wav"] },
  "audio/xm": { source: "apache", extensions: ["xm"] },
  "chemical/x-cdx": { source: "apache", extensions: ["cdx"] },
  "chemical/x-cif": { source: "apache", extensions: ["cif"] },
  "chemical/x-cmdf": { source: "apache", extensions: ["cmdf"] },
  "chemical/x-cml": { source: "apache", extensions: ["cml"] },
  "chemical/x-csml": { source: "apache", extensions: ["csml"] },
  "chemical/x-pdb": { source: "apache" },
  "chemical/x-xyz": { source: "apache", extensions: ["xyz"] },
  "font/collection": { source: "iana", extensions: ["ttc"] },
  "font/otf": { source: "iana", compressible: !0, extensions: ["otf"] },
  "font/sfnt": { source: "iana" },
  "font/ttf": { source: "iana", compressible: !0, extensions: ["ttf"] },
  "font/woff": { source: "iana", extensions: ["woff"] },
  "font/woff2": { source: "iana", extensions: ["woff2"] },
  "image/aces": { source: "iana", extensions: ["exr"] },
  "image/apng": { compressible: !1, extensions: ["apng"] },
  "image/avci": { source: "iana", extensions: ["avci"] },
  "image/avcs": { source: "iana", extensions: ["avcs"] },
  "image/avif": { source: "iana", compressible: !1, extensions: ["avif"] },
  "image/bmp": { source: "iana", compressible: !0, extensions: ["bmp"] },
  "image/cgm": { source: "iana", extensions: ["cgm"] },
  "image/dicom-rle": { source: "iana", extensions: ["drle"] },
  "image/emf": { source: "iana", extensions: ["emf"] },
  "image/fits": { source: "iana", extensions: ["fits"] },
  "image/g3fax": { source: "iana", extensions: ["g3"] },
  "image/gif": { source: "iana", compressible: !1, extensions: ["gif"] },
  "image/heic": { source: "iana", extensions: ["heic"] },
  "image/heic-sequence": { source: "iana", extensions: ["heics"] },
  "image/heif": { source: "iana", extensions: ["heif"] },
  "image/heif-sequence": { source: "iana", extensions: ["heifs"] },
  "image/hej2k": { source: "iana", extensions: ["hej2"] },
  "image/hsj2": { source: "iana", extensions: ["hsj2"] },
  "image/ief": { source: "iana", extensions: ["ief"] },
  "image/jls": { source: "iana", extensions: ["jls"] },
  "image/jp2": { source: "iana", compressible: !1, extensions: ["jp2", "jpg2"] },
  "image/jpeg": { source: "iana", compressible: !1, extensions: ["jpeg", "jpg", "jpe"] },
  "image/jph": { source: "iana", extensions: ["jph"] },
  "image/jphc": { source: "iana", extensions: ["jhc"] },
  "image/jpm": { source: "iana", compressible: !1, extensions: ["jpm"] },
  "image/jpx": { source: "iana", compressible: !1, extensions: ["jpx", "jpf"] },
  "image/jxr": { source: "iana", extensions: ["jxr"] },
  "image/jxra": { source: "iana", extensions: ["jxra"] },
  "image/jxrs": { source: "iana", extensions: ["jxrs"] },
  "image/jxs": { source: "iana", extensions: ["jxs"] },
  "image/jxsc": { source: "iana", extensions: ["jxsc"] },
  "image/jxsi": { source: "iana", extensions: ["jxsi"] },
  "image/jxss": { source: "iana", extensions: ["jxss"] },
  "image/ktx": { source: "iana", extensions: ["ktx"] },
  "image/ktx2": { source: "iana", extensions: ["ktx2"] },
  "image/naplps": { source: "iana" },
  "image/pjpeg": { compressible: !1 },
  "image/png": { source: "iana", compressible: !1, extensions: ["png"] },
  "image/prs.btif": { source: "iana", extensions: ["btif"] },
  "image/prs.pti": { source: "iana", extensions: ["pti"] },
  "image/pwg-raster": { source: "iana" },
  "image/sgi": { source: "apache", extensions: ["sgi"] },
  "image/svg+xml": { source: "iana", compressible: !0, extensions: ["svg", "svgz"] },
  "image/t38": { source: "iana", extensions: ["t38"] },
  "image/tiff": { source: "iana", compressible: !1, extensions: ["tif", "tiff"] },
  "image/tiff-fx": { source: "iana", extensions: ["tfx"] },
  "image/vnd.adobe.photoshop": { source: "iana", compressible: !0, extensions: ["psd"] },
  "image/vnd.airzip.accelerator.azv": { source: "iana", extensions: ["azv"] },
  "image/vnd.cns.inf2": { source: "iana" },
  "image/vnd.dece.graphic": { source: "iana", extensions: ["uvi", "uvvi", "uvg", "uvvg"] },
  "image/vnd.djvu": { source: "iana", extensions: ["djvu", "djv"] },
  "image/vnd.dvb.subtitle": { source: "iana", extensions: ["sub"] },
  "image/vnd.dwg": { source: "iana", extensions: ["dwg"] },
  "image/vnd.dxf": { source: "iana", extensions: ["dxf"] },
  "image/vnd.fastbidsheet": { source: "iana", extensions: ["fbs"] },
  "image/vnd.fpx": { source: "iana", extensions: ["fpx"] },
  "image/vnd.fst": { source: "iana", extensions: ["fst"] },
  "image/vnd.fujixerox.edmics-mmr": { source: "iana", extensions: ["mmr"] },
  "image/vnd.fujixerox.edmics-rlc": { source: "iana", extensions: ["rlc"] },
  "image/vnd.globalgraphics.pgb": { source: "iana" },
  "image/vnd.microsoft.icon": { source: "iana", compressible: !0, extensions: ["ico"] },
  "image/vnd.mix": { source: "iana" },
  "image/vnd.mozilla.apng": { source: "iana" },
  "image/vnd.ms-dds": { compressible: !0, extensions: ["dds"] },
  "image/vnd.ms-modi": { source: "iana", extensions: ["mdi"] },
  "image/vnd.ms-photo": { source: "apache", extensions: ["wdp"] },
  "image/vnd.net-fpx": { source: "iana", extensions: ["npx"] },
  "image/vnd.pco.b16": { source: "iana", extensions: ["b16"] },
  "image/vnd.radiance": { source: "iana" },
  "image/vnd.sealed.png": { source: "iana" },
  "image/vnd.sealedmedia.softseal.gif": { source: "iana" },
  "image/vnd.sealedmedia.softseal.jpg": { source: "iana" },
  "image/vnd.svf": { source: "iana" },
  "image/vnd.tencent.tap": { source: "iana", extensions: ["tap"] },
  "image/vnd.valve.source.texture": { source: "iana", extensions: ["vtf"] },
  "image/vnd.wap.wbmp": { source: "iana", extensions: ["wbmp"] },
  "image/vnd.xiff": { source: "iana", extensions: ["xif"] },
  "image/vnd.zbrush.pcx": { source: "iana", extensions: ["pcx"] },
  "image/webp": { source: "apache", extensions: ["webp"] },
  "image/wmf": { source: "iana", extensions: ["wmf"] },
  "image/x-3ds": { source: "apache", extensions: ["3ds"] },
  "image/x-cmu-raster": { source: "apache", extensions: ["ras"] },
  "image/x-cmx": { source: "apache", extensions: ["cmx"] },
  "image/x-freehand": { source: "apache", extensions: ["fh", "fhc", "fh4", "fh5", "fh7"] },
  "image/x-icon": { source: "apache", compressible: !0, extensions: ["ico"] },
  "image/x-jng": { source: "nginx", extensions: ["jng"] },
  "image/x-mrsid-image": { source: "apache", extensions: ["sid"] },
  "image/x-ms-bmp": { source: "nginx", compressible: !0, extensions: ["bmp"] },
  "image/x-pcx": { source: "apache", extensions: ["pcx"] },
  "image/x-pict": { source: "apache", extensions: ["pic", "pct"] },
  "image/x-portable-anymap": { source: "apache", extensions: ["pnm"] },
  "image/x-portable-bitmap": { source: "apache", extensions: ["pbm"] },
  "image/x-portable-graymap": { source: "apache", extensions: ["pgm"] },
  "image/x-portable-pixmap": { source: "apache", extensions: ["ppm"] },
  "image/x-rgb": { source: "apache", extensions: ["rgb"] },
  "image/x-tga": { source: "apache", extensions: ["tga"] },
  "image/x-xbitmap": { source: "apache", extensions: ["xbm"] },
  "image/x-xcf": { compressible: !1 },
  "image/x-xpixmap": { source: "apache", extensions: ["xpm"] },
  "image/x-xwindowdump": { source: "apache", extensions: ["xwd"] },
  "message/cpim": { source: "iana" },
  "message/delivery-status": { source: "iana" },
  "message/disposition-notification": { source: "iana", extensions: ["disposition-notification"] },
  "message/external-body": { source: "iana" },
  "message/feedback-report": { source: "iana" },
  "message/global": { source: "iana", extensions: ["u8msg"] },
  "message/global-delivery-status": { source: "iana", extensions: ["u8dsn"] },
  "message/global-disposition-notification": { source: "iana", extensions: ["u8mdn"] },
  "message/global-headers": { source: "iana", extensions: ["u8hdr"] },
  "message/http": { source: "iana", compressible: !1 },
  "message/imdn+xml": { source: "iana", compressible: !0 },
  "message/news": { source: "iana" },
  "message/partial": { source: "iana", compressible: !1 },
  "message/rfc822": { source: "iana", compressible: !0, extensions: ["eml", "mime"] },
  "message/s-http": { source: "iana" },
  "message/sip": { source: "iana" },
  "message/sipfrag": { source: "iana" },
  "message/tracking-status": { source: "iana" },
  "message/vnd.si.simp": { source: "iana" },
  "message/vnd.wfa.wsc": { source: "iana", extensions: ["wsc"] },
  "model/3mf": { source: "iana", extensions: ["3mf"] },
  "model/e57": { source: "iana" },
  "model/gltf+json": { source: "iana", compressible: !0, extensions: ["gltf"] },
  "model/gltf-binary": { source: "iana", compressible: !0, extensions: ["glb"] },
  "model/iges": { source: "iana", compressible: !1, extensions: ["igs", "iges"] },
  "model/mesh": { source: "iana", compressible: !1, extensions: ["msh", "mesh", "silo"] },
  "model/mtl": { source: "iana", extensions: ["mtl"] },
  "model/obj": { source: "iana", extensions: ["obj"] },
  "model/step": { source: "iana" },
  "model/step+xml": { source: "iana", compressible: !0, extensions: ["stpx"] },
  "model/step+zip": { source: "iana", compressible: !1, extensions: ["stpz"] },
  "model/step-xml+zip": { source: "iana", compressible: !1, extensions: ["stpxz"] },
  "model/stl": { source: "iana", extensions: ["stl"] },
  "model/vnd.collada+xml": { source: "iana", compressible: !0, extensions: ["dae"] },
  "model/vnd.dwf": { source: "iana", extensions: ["dwf"] },
  "model/vnd.flatland.3dml": { source: "iana" },
  "model/vnd.gdl": { source: "iana", extensions: ["gdl"] },
  "model/vnd.gs-gdl": { source: "apache" },
  "model/vnd.gs.gdl": { source: "iana" },
  "model/vnd.gtw": { source: "iana", extensions: ["gtw"] },
  "model/vnd.moml+xml": { source: "iana", compressible: !0 },
  "model/vnd.mts": { source: "iana", extensions: ["mts"] },
  "model/vnd.opengex": { source: "iana", extensions: ["ogex"] },
  "model/vnd.parasolid.transmit.binary": { source: "iana", extensions: ["x_b"] },
  "model/vnd.parasolid.transmit.text": { source: "iana", extensions: ["x_t"] },
  "model/vnd.pytha.pyox": { source: "iana" },
  "model/vnd.rosette.annotated-data-model": { source: "iana" },
  "model/vnd.sap.vds": { source: "iana", extensions: ["vds"] },
  "model/vnd.usdz+zip": { source: "iana", compressible: !1, extensions: ["usdz"] },
  "model/vnd.valve.source.compiled-map": { source: "iana", extensions: ["bsp"] },
  "model/vnd.vtu": { source: "iana", extensions: ["vtu"] },
  "model/vrml": { source: "iana", compressible: !1, extensions: ["wrl", "vrml"] },
  "model/x3d+binary": { source: "apache", compressible: !1, extensions: ["x3db", "x3dbz"] },
  "model/x3d+fastinfoset": { source: "iana", extensions: ["x3db"] },
  "model/x3d+vrml": { source: "apache", compressible: !1, extensions: ["x3dv", "x3dvz"] },
  "model/x3d+xml": { source: "iana", compressible: !0, extensions: ["x3d", "x3dz"] },
  "model/x3d-vrml": { source: "iana", extensions: ["x3dv"] },
  "multipart/alternative": { source: "iana", compressible: !1 },
  "multipart/appledouble": { source: "iana" },
  "multipart/byteranges": { source: "iana" },
  "multipart/digest": { source: "iana" },
  "multipart/encrypted": { source: "iana", compressible: !1 },
  "multipart/form-data": { source: "iana", compressible: !1 },
  "multipart/header-set": { source: "iana" },
  "multipart/mixed": { source: "iana" },
  "multipart/multilingual": { source: "iana" },
  "multipart/parallel": { source: "iana" },
  "multipart/related": { source: "iana", compressible: !1 },
  "multipart/report": { source: "iana" },
  "multipart/signed": { source: "iana", compressible: !1 },
  "multipart/vnd.bint.med-plus": { source: "iana" },
  "multipart/voice-message": { source: "iana" },
  "multipart/x-mixed-replace": { source: "iana" },
  "text/1d-interleaved-parityfec": { source: "iana" },
  "text/cache-manifest": { source: "iana", compressible: !0, extensions: ["appcache", "manifest"] },
  "text/calendar": { source: "iana", extensions: ["ics", "ifb"] },
  "text/calender": { compressible: !0 },
  "text/cmd": { compressible: !0 },
  "text/coffeescript": { extensions: ["coffee", "litcoffee"] },
  "text/cql": { source: "iana" },
  "text/cql-expression": { source: "iana" },
  "text/cql-identifier": { source: "iana" },
  "text/css": { source: "iana", charset: "UTF-8", compressible: !0, extensions: ["css"] },
  "text/csv": { source: "iana", compressible: !0, extensions: ["csv"] },
  "text/csv-schema": { source: "iana" },
  "text/directory": { source: "iana" },
  "text/dns": { source: "iana" },
  "text/ecmascript": { source: "iana" },
  "text/encaprtp": { source: "iana" },
  "text/enriched": { source: "iana" },
  "text/fhirpath": { source: "iana" },
  "text/flexfec": { source: "iana" },
  "text/fwdred": { source: "iana" },
  "text/gff3": { source: "iana" },
  "text/grammar-ref-list": { source: "iana" },
  "text/html": { source: "iana", compressible: !0, extensions: ["html", "htm", "shtml"] },
  "text/jade": { extensions: ["jade"] },
  "text/javascript": { source: "iana", compressible: !0 },
  "text/jcr-cnd": { source: "iana" },
  "text/jsx": { compressible: !0, extensions: ["jsx"] },
  "text/less": { compressible: !0, extensions: ["less"] },
  "text/markdown": { source: "iana", compressible: !0, extensions: ["markdown", "md"] },
  "text/mathml": { source: "nginx", extensions: ["mml"] },
  "text/mdx": { compressible: !0, extensions: ["mdx"] },
  "text/mizar": { source: "iana" },
  "text/n3": { source: "iana", charset: "UTF-8", compressible: !0, extensions: ["n3"] },
  "text/parameters": { source: "iana", charset: "UTF-8" },
  "text/parityfec": { source: "iana" },
  "text/plain": { source: "iana", compressible: !0, extensions: ["txt", "text", "conf", "def", "list", "log", "in", "ini"] },
  "text/provenance-notation": { source: "iana", charset: "UTF-8" },
  "text/prs.fallenstein.rst": { source: "iana" },
  "text/prs.lines.tag": { source: "iana", extensions: ["dsc"] },
  "text/prs.prop.logic": { source: "iana" },
  "text/raptorfec": { source: "iana" },
  "text/red": { source: "iana" },
  "text/rfc822-headers": { source: "iana" },
  "text/richtext": { source: "iana", compressible: !0, extensions: ["rtx"] },
  "text/rtf": { source: "iana", compressible: !0, extensions: ["rtf"] },
  "text/rtp-enc-aescm128": { source: "iana" },
  "text/rtploopback": { source: "iana" },
  "text/rtx": { source: "iana" },
  "text/sgml": { source: "iana", extensions: ["sgml", "sgm"] },
  "text/shaclc": { source: "iana" },
  "text/shex": { source: "iana", extensions: ["shex"] },
  "text/slim": { extensions: ["slim", "slm"] },
  "text/spdx": { source: "iana", extensions: ["spdx"] },
  "text/strings": { source: "iana" },
  "text/stylus": { extensions: ["stylus", "styl"] },
  "text/t140": { source: "iana" },
  "text/tab-separated-values": { source: "iana", compressible: !0, extensions: ["tsv"] },
  "text/troff": { source: "iana", extensions: ["t", "tr", "roff", "man", "me", "ms"] },
  "text/turtle": { source: "iana", charset: "UTF-8", extensions: ["ttl"] },
  "text/ulpfec": { source: "iana" },
  "text/uri-list": { source: "iana", compressible: !0, extensions: ["uri", "uris", "urls"] },
  "text/vcard": { source: "iana", compressible: !0, extensions: ["vcard"] },
  "text/vnd.a": { source: "iana" },
  "text/vnd.abc": { source: "iana" },
  "text/vnd.ascii-art": { source: "iana" },
  "text/vnd.curl": { source: "iana", extensions: ["curl"] },
  "text/vnd.curl.dcurl": { source: "apache", extensions: ["dcurl"] },
  "text/vnd.curl.mcurl": { source: "apache", extensions: ["mcurl"] },
  "text/vnd.curl.scurl": { source: "apache", extensions: ["scurl"] },
  "text/vnd.debian.copyright": { source: "iana", charset: "UTF-8" },
  "text/vnd.dmclientscript": { source: "iana" },
  "text/vnd.dvb.subtitle": { source: "iana", extensions: ["sub"] },
  "text/vnd.esmertec.theme-descriptor": { source: "iana", charset: "UTF-8" },
  "text/vnd.familysearch.gedcom": { source: "iana", extensions: ["ged"] },
  "text/vnd.ficlab.flt": { source: "iana" },
  "text/vnd.fly": { source: "iana", extensions: ["fly"] },
  "text/vnd.fmi.flexstor": { source: "iana", extensions: ["flx"] },
  "text/vnd.gml": { source: "iana" },
  "text/vnd.graphviz": { source: "iana", extensions: ["gv"] },
  "text/vnd.hans": { source: "iana" },
  "text/vnd.hgl": { source: "iana" },
  "text/vnd.in3d.3dml": { source: "iana", extensions: ["3dml"] },
  "text/vnd.in3d.spot": { source: "iana", extensions: ["spot"] },
  "text/vnd.iptc.newsml": { source: "iana" },
  "text/vnd.iptc.nitf": { source: "iana" },
  "text/vnd.latex-z": { source: "iana" },
  "text/vnd.motorola.reflex": { source: "iana" },
  "text/vnd.ms-mediapackage": { source: "iana" },
  "text/vnd.net2phone.commcenter.command": { source: "iana" },
  "text/vnd.radisys.msml-basic-layout": { source: "iana" },
  "text/vnd.senx.warpscript": { source: "iana" },
  "text/vnd.si.uricatalogue": { source: "iana" },
  "text/vnd.sosi": { source: "iana" },
  "text/vnd.sun.j2me.app-descriptor": { source: "iana", charset: "UTF-8", extensions: ["jad"] },
  "text/vnd.trolltech.linguist": { source: "iana", charset: "UTF-8" },
  "text/vnd.wap.si": { source: "iana" },
  "text/vnd.wap.sl": { source: "iana" },
  "text/vnd.wap.wml": { source: "iana", extensions: ["wml"] },
  "text/vnd.wap.wmlscript": { source: "iana", extensions: ["wmls"] },
  "text/vtt": { source: "iana", charset: "UTF-8", compressible: !0, extensions: ["vtt"] },
  "text/x-asm": { source: "apache", extensions: ["s", "asm"] },
  "text/x-c": { source: "apache", extensions: ["c", "cc", "cxx", "cpp", "h", "hh", "dic"] },
  "text/x-component": { source: "nginx", extensions: ["htc"] },
  "text/x-fortran": { source: "apache", extensions: ["f", "for", "f77", "f90"] },
  "text/x-gwt-rpc": { compressible: !0 },
  "text/x-handlebars-template": { extensions: ["hbs"] },
  "text/x-java-source": { source: "apache", extensions: ["java"] },
  "text/x-jquery-tmpl": { compressible: !0 },
  "text/x-lua": { extensions: ["lua"] },
  "text/x-markdown": { compressible: !0, extensions: ["mkd"] },
  "text/x-nfo": { source: "apache", extensions: ["nfo"] },
  "text/x-opml": { source: "apache", extensions: ["opml"] },
  "text/x-org": { compressible: !0, extensions: ["org"] },
  "text/x-pascal": { source: "apache", extensions: ["p", "pas"] },
  "text/x-processing": { compressible: !0, extensions: ["pde"] },
  "text/x-sass": { extensions: ["sass"] },
  "text/x-scss": { extensions: ["scss"] },
  "text/x-setext": { source: "apache", extensions: ["etx"] },
  "text/x-sfv": { source: "apache", extensions: ["sfv"] },
  "text/x-suse-ymp": { compressible: !0, extensions: ["ymp"] },
  "text/x-uuencode": { source: "apache", extensions: ["uu"] },
  "text/x-vcalendar": { source: "apache", extensions: ["vcs"] },
  "text/x-vcard": { source: "apache", extensions: ["vcf"] },
  "text/xml": { source: "iana", compressible: !0, extensions: ["xml"] },
  "text/xml-external-parsed-entity": { source: "iana" },
  "text/yaml": { compressible: !0, extensions: ["yaml", "yml"] },
  "video/1d-interleaved-parityfec": { source: "iana" },
  "video/3gpp": { source: "iana", extensions: ["3gp", "3gpp"] },
  "video/3gpp-tt": { source: "iana" },
  "video/3gpp2": { source: "iana", extensions: ["3g2"] },
  "video/av1": { source: "iana" },
  "video/bmpeg": { source: "iana" },
  "video/bt656": { source: "iana" },
  "video/celb": { source: "iana" },
  "video/dv": { source: "iana" },
  "video/encaprtp": { source: "iana" },
  "video/ffv1": { source: "iana" },
  "video/flexfec": { source: "iana" },
  "video/h261": { source: "iana", extensions: ["h261"] },
  "video/h263": { source: "iana", extensions: ["h263"] },
  "video/h263-1998": { source: "iana" },
  "video/h263-2000": { source: "iana" },
  "video/h264": { source: "iana", extensions: ["h264"] },
  "video/h264-rcdo": { source: "iana" },
  "video/h264-svc": { source: "iana" },
  "video/h265": { source: "iana" },
  "video/iso.segment": { source: "iana", extensions: ["m4s"] },
  "video/jpeg": { source: "iana", extensions: ["jpgv"] },
  "video/jpeg2000": { source: "iana" },
  "video/jpm": { source: "apache", extensions: ["jpm", "jpgm"] },
  "video/jxsv": { source: "iana" },
  "video/mj2": { source: "iana", extensions: ["mj2", "mjp2"] },
  "video/mp1s": { source: "iana" },
  "video/mp2p": { source: "iana" },
  "video/mp2t": { source: "iana", extensions: ["ts"] },
  "video/mp4": { source: "iana", compressible: !1, extensions: ["mp4", "mp4v", "mpg4"] },
  "video/mp4v-es": { source: "iana" },
  "video/mpeg": { source: "iana", compressible: !1, extensions: ["mpeg", "mpg", "mpe", "m1v", "m2v"] },
  "video/mpeg4-generic": { source: "iana" },
  "video/mpv": { source: "iana" },
  "video/nv": { source: "iana" },
  "video/ogg": { source: "iana", compressible: !1, extensions: ["ogv"] },
  "video/parityfec": { source: "iana" },
  "video/pointer": { source: "iana" },
  "video/quicktime": { source: "iana", compressible: !1, extensions: ["qt", "mov"] },
  "video/raptorfec": { source: "iana" },
  "video/raw": { source: "iana" },
  "video/rtp-enc-aescm128": { source: "iana" },
  "video/rtploopback": { source: "iana" },
  "video/rtx": { source: "iana" },
  "video/scip": { source: "iana" },
  "video/smpte291": { source: "iana" },
  "video/smpte292m": { source: "iana" },
  "video/ulpfec": { source: "iana" },
  "video/vc1": { source: "iana" },
  "video/vc2": { source: "iana" },
  "video/vnd.cctv": { source: "iana" },
  "video/vnd.dece.hd": { source: "iana", extensions: ["uvh", "uvvh"] },
  "video/vnd.dece.mobile": { source: "iana", extensions: ["uvm", "uvvm"] },
  "video/vnd.dece.mp4": { source: "iana" },
  "video/vnd.dece.pd": { source: "iana", extensions: ["uvp", "uvvp"] },
  "video/vnd.dece.sd": { source: "iana", extensions: ["uvs", "uvvs"] },
  "video/vnd.dece.video": { source: "iana", extensions: ["uvv", "uvvv"] },
  "video/vnd.directv.mpeg": { source: "iana" },
  "video/vnd.directv.mpeg-tts": { source: "iana" },
  "video/vnd.dlna.mpeg-tts": { source: "iana" },
  "video/vnd.dvb.file": { source: "iana", extensions: ["dvb"] },
  "video/vnd.fvt": { source: "iana", extensions: ["fvt"] },
  "video/vnd.hns.video": { source: "iana" },
  "video/vnd.iptvforum.1dparityfec-1010": { source: "iana" },
  "video/vnd.iptvforum.1dparityfec-2005": { source: "iana" },
  "video/vnd.iptvforum.2dparityfec-1010": { source: "iana" },
  "video/vnd.iptvforum.2dparityfec-2005": { source: "iana" },
  "video/vnd.iptvforum.ttsavc": { source: "iana" },
  "video/vnd.iptvforum.ttsmpeg2": { source: "iana" },
  "video/vnd.motorola.video": { source: "iana" },
  "video/vnd.motorola.videop": { source: "iana" },
  "video/vnd.mpegurl": { source: "iana", extensions: ["mxu", "m4u"] },
  "video/vnd.ms-playready.media.pyv": { source: "iana", extensions: ["pyv"] },
  "video/vnd.nokia.interleaved-multimedia": { source: "iana" },
  "video/vnd.nokia.mp4vr": { source: "iana" },
  "video/vnd.nokia.videovoip": { source: "iana" },
  "video/vnd.objectvideo": { source: "iana" },
  "video/vnd.radgamettools.bink": { source: "iana" },
  "video/vnd.radgamettools.smacker": { source: "iana" },
  "video/vnd.sealed.mpeg1": { source: "iana" },
  "video/vnd.sealed.mpeg4": { source: "iana" },
  "video/vnd.sealed.swf": { source: "iana" },
  "video/vnd.sealedmedia.softseal.mov": { source: "iana" },
  "video/vnd.uvvu.mp4": { source: "iana", extensions: ["uvu", "uvvu"] },
  "video/vnd.vivo": { source: "iana", extensions: ["viv"] },
  "video/vnd.youtube.yt": { source: "iana" },
  "video/vp8": { source: "iana" },
  "video/vp9": { source: "iana" },
  "video/webm": { source: "apache", compressible: !1, extensions: ["webm"] },
  "video/x-f4v": { source: "apache", extensions: ["f4v"] },
  "video/x-fli": { source: "apache", extensions: ["fli"] },
  "video/x-flv": { source: "apache", compressible: !1, extensions: ["flv"] },
  "video/x-m4v": { source: "apache", extensions: ["m4v"] },
  "video/x-matroska": { source: "apache", compressible: !1, extensions: ["mkv", "mk3d", "mks"] },
  "video/x-mng": { source: "apache", extensions: ["mng"] },
  "video/x-ms-asf": { source: "apache", extensions: ["asf", "asx"] },
  "video/x-ms-vob": { source: "apache", extensions: ["vob"] },
  "video/x-ms-wm": { source: "apache", extensions: ["wm"] },
  "video/x-ms-wmv": { source: "apache", compressible: !1, extensions: ["wmv"] },
  "video/x-ms-wmx": { source: "apache", extensions: ["wmx"] },
  "video/x-ms-wvx": { source: "apache", extensions: ["wvx"] },
  "video/x-msvideo": { source: "apache", extensions: ["avi"] },
  "video/x-sgi-movie": { source: "apache", extensions: ["movie"] },
  "video/x-smv": { source: "apache", extensions: ["smv"] },
  "x-conference/x-cooltalk": { source: "apache", extensions: ["ice"] },
  "x-shader/x-fragment": { compressible: !0 },
  "x-shader/x-vertex": { compressible: !0 }
};
/*!
 * mime-db
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2015-2022 Douglas Christopher Wilson
 * MIT Licensed
 */
var pd, $b;
function G8() {
  return $b || ($b = 1, pd = $8), pd;
}
var X8 = G8();
const K8 = /* @__PURE__ */ Qt(X8);
var $n = {}, Gn = {}, md = {}, Xn = {}, $o = {}, Gb;
function Y8() {
  return Gb || (Gb = 1, Object.defineProperty($o, "__esModule", { value: !0 }), $o.default = new Uint16Array(
    // prettier-ignore
    '<\0\0\0\0\0\0EMabcfglmnoprstu\\bfmsligP&cutereve;iyx}rc;r;ravepha;acr;d;gpon;f;plyFunction;ingcsr;ign;ildemlaceforsucrkslash;;ed;y;crtause;noullis;a;r;pf;eve;cmpeq;HOacdefhilorsucy;PYcpyute;;italDifferentialD;leys;aeioron;dilrc;nint;ot;dnilla;terDot;i;rcleDMPTot;inus;lus;imes;ocskwiseContourIntegral;eCurlyDQoubleQuote;uote;lnpuon;e;gitruent;nt;ourIntegral;fr;oduct;nterClockwiseContourIntegral;oss;cr;p;Cap;DJSZacefios;otrahd;cy;cy;cy;grsger;r;hv;ayron;;l;ta;r;afcmriticalADGTcute;o;bleAcute;rave;ilde;ond;ferentialD;\0\0\0\0f;;DEot;qual;bleCDLRUVontourIntegrao\0\0nArrow;eoftARTrrow;ightArrow;engLReftARrrow;ightArrow;ightArrow;ightATrrow;ee;p\0\0rrow;ownArrow;erticalBar;nABLRTarrow;BUar;pArrow;reve;eft\0\0ightVector;eeVector;ector;Bar;ight\0eeVector;ector;Bar;ee;Arrow;ctr;rok;NTacdfglmopqstuxG;Hcuteaiyron;rc;ot;r;raveement;apcr;ty\0\0mallSquare;erySmallSquare;gpon;f;silon;uail;Tilde;librium;cir;m;a;mlipsts;onentialE;cfiosy;r;lled\0\0mallSquare;erySmallSquare;\0\0\0f;All;riertrf;cJTabcdfgorstcy;>mma;d;reve;eiydil;rc;;ot;r;;pf;eaterEFGLSTqual;Less;ullEqual;reater;ess;lantEqual;ilde;cr;;AacfiosuRDcy;ctek;;irc;r;lbertSpace;\0f;izontalLine;ctrok;mpownHumqual;EJOacdfgmnostucy;lig;cy;cuteiyrc;ot;r;rave;apcgr;inaryI;lie\0;egrral;section;isibleCTomma;imes;gpton;f;a;cr;ilde;\0cy;lcfosuiyrc;;r;pf;\0r;rcy;kcy;HJacfoscy;cy;ppa;eydil;;r;pf;cr;JTaceflmostcy;<cmnprute;bda;g;lacetrf;r;aeyron;dil;;fstACDFRTUVarnrgleBracket;row;BRar;ightArrow;eiling;o\0bleBracket;n\0eeVector;ector;Bar;loor;ightAVrrow;ector;ere;AVrrow;ector;iangle;BEar;qual;pDTVownVector;eeVector;ector;Bar;ector;Bar;ightsEFGLSTqualGreater;ullEqual;reater;ess;lantEqual;ilde;r;;eftarrow;idot;npwgLRlreftARrrow;ightArrow;ightArrow;eftarightightf;erLReftArrow;ightArrow;cht;rok;;acefiosup;y;dliumSpace;lintrf;r;nusPlus;pf;c;Jacefostucy;cute;aeyron;dil;;gswativeMTVediumSpace;hicneryThitedGLreaterGreateessLesLine;r;Bnptreak;BreakingSpace;f;;CDEGHLNPRSTVoungruent;pCap;oubleVerticalBar;lqxement;ual;Tilde;ists;reater;EFGLSTqual;ullEqual;reater;ess;lantEqual;ilde;umpownHump;qual;efstTriangle;BEar;qual;s;EGLSTqual;reater;ess;lantEqual;ilde;estedGLreaterGreater;essLess;recedes;ESqual;lantEqual;eiverseElement;ghtTriangle;BEar;qual;quuareSubpset;Equal;erset;Equal;bcpset;Equal;ceeds;ESTqual;lantEqual;ilde;erset;Equal;ilde;EFTqual;ullEqual;ilde;erticalBar;cr;ilde;Eacdfgmoprstuvlig;cuteiyrc;blac;r;raveaeicr;ga;cron;pf;enCurlyDQoubleQuote;uote;;clr;ashidees;mlerBParr;acek;et;arenthesis;acfhilorsrtialD;y;r;i;;usMinus;ipncareplanf;;eiocedes;ESTqual;lantEqual;ilde;me;dpuct;ortion;al;cir;;UfosOT"r;pf;cr;BEacefhiorsuarr;Gcnrute;g;r;tl;aeyron;dil;;;verseEUlqement;uilibrium;pEquilibrium;ro;ghtACDFTUVanrgleBracket;row;BLar;eftArrow;eiling;o\0bleBracket;n\0eeVector;ector;Bar;loor;ere;AVrrow;ector;iangle;BEar;qual;pDTVownVector;eeVector;ector;Bar;ector;Bar;puf;ndImplies;ightarrow;chr;;leDelayed;HOacfhimoqstuCcHcy;y;FTcy;cute;;aeiyron;dil;rc;;r;ortDLRUownArroweftArrowightArrowpArrow;gma;allCircle;pf;\0\0t;are;ISUntersection;ubpset;Equal;erset;Equal;nion;cr;ar;bcmp;set;Equal;cheeds;ESTqual;lantEqual;ilde;Th;;esrset;Equal;etHRSacfhiorsORNADE;Hccy;y;bu;;aeyron;dil;;r;ei\0efore;a;cnkSpace;Space;lde;EFTqual;ullEqual;ilde;pf;ipleDot;ctr;rok;\0\0\0\0\0\0\0cruter;ocir;r\0y;ve;iyrc;blac;r;raveacr;dierBParr;acek;et;arenthesis;on;Plus;gpon;f;ADETadpsrrow;BDar;ownArrow;ownArrow;quilibrium;ee;Arrow;ownerLReftArrow;ightArrow;i;lon;ing;cr;ilde;mlDbcdefosvash;ar;y;ash;l;er;btyar;;icalBLSTar;ine;eparator;ilde;ThinSpace;r;pf;cr;dash;cefosirc;dge;r;pf;cr;fiosr;;pf;cr;AIUacfosucy;cy;cy;cuteiyrc;;r;pf;cr;ml;Hacdefoscy;cute;ayron;;ot;\0oWidta;r;pf;cr;\0\0\0\0\0\0\0cutereve;;Ediuy;;rcte;lig;r;raveepfpsym;ha;apcclr;g;\0\0;adsvnd;;lope;;;elmrsz;esd;a;;;;;;;;t;vb;d;pth;arr;gpon;f;;Eaeiop;cir;;d;s;rox;eingctyr;;mp;eildemlcioninnt;Nabcdefiklnoprsuot;crkcepsong;psilon;rime;im;eq;ee;ed;gerk;tbrk;oy;quo;cmprtaus;eptyv;snoahw;;een;r;gcostuvwaiurc;pdptot;lus;imes;\0\0cup;ar;riangleduown;p;plus;earow;akocnklstozenge;riangle;dlrown;eft;ight;k;\0\0;;4;ck;eo;q=uiv;t;ptwxf;;tomtie;DHUVbdhmptuvLRlr;;;;;DUdu;;;;LRlr;;;;;HLRhlr;;;;;;ox;LRlr;;;;;DUdu;;;;inus;lus;imes;LRlr;;;;;HLRhlr;;;;;;evbarceior;mi;m;el;bh;sub;l;etp;Ee;;q\0\0\0\0\0\0\0\0\0\0cprute;;abcdsnd;rcup;aup;p;ot;;eot;aeiu\0s;on;dilrc;ps;sm;ot;dmnilptyv;t;err;ceiy;ck;mark;r;Ecefms;;elq;e\0\0rrowlreft;ight;RSacd;st;irc;ash;nint;id;cir;ubs;uit\0on;e;q\0\0a;t;;flemxente\0;dot;nfry;o;sr;aorr;ss;cur;bp;e;;e;dot;delprvwarrlr;;\0\0r;c;arr;p;;bcdosrcap;aup;p;ot;r;;alrvrr;m;yevwq\0\0reuee;edge;enearrowlreftightecioninnt;lcty;AHabcdefhijlorstuwzrar;glrsger;eth;h;varow;aayron;;;aogrr;tseq;glmta;ptyv;irsht;;arlraegsvm;osnd;suit;amma;in;;iode;ontimes;ncy;c\0\0rn;op;lptuwlar;f;;empsq;dot;inus;lus;quare;blebarwedgnadhownarrowarpoonlrefighkaro\0\0rn;op;cotry;;l;rok;drot;i;fahraangle;ciy;grarr;DacdefglmnopqrstuxDoocsuteter;aioyron;r;clon;;ot;Drot;;;rsave;dot;;ilsnters;;;dot;apscr;ty;svetp1;;;gs;p;gpon;f;alsr;sl;us;i;lvon;csuviorc\0\0antgltressaeils;st;v;DD;parsl;Daot;rr;cdir;oah;mrlo;cipl;seoctationential\0\0\0\0\0\0\0llingdotsey;male;ilrlig;\0\0g;ig;;lig;lig;fjaltt;ig;ns;of;\0f;ak;v;artint;aocs\0\0;;;;\0;;\0\0;;5;\0;;8;l;wn;cr;Eabcdefgijlnorstv;l;cmpute;ma;d;reve;iyrc;;ot;;lqs;qslan;cdlc;ot;o;l;;es;r;;gmel;cy;;Eaj;;;Eaes;p;prox;q;qim;pf;cir;m;el;;>;cdlqrci;r;ot;Par;uest;adels\0pror;qlqlesienrtneqq;Aabcefkosyrilmrrsfildrcy;;cwir;;ar;irc;alrrts;uitlip;con;r;sewarow;arow;amoprrr;tht;klreftarrow;ightarrow;f;bar;cltr;asrok;bpull;hen\0\0\0\0\0\0cute;iyrc;cxy;clfr;rave;inoinnt;t;fin;ta;lig;aopcgtr;elpinarh;f;ed;;cfotare;in;tie;do;celpal;grerarhk;rod;cgpty;on;f;a;uestcir;n;Edsv;ot;;v;;ilde;\0cy;lcfmosuiyrc;;r;ath;pf;\0r;rcy;kcy;acfghjosppa;v;eydil;;r;reen;cy;cy;pf;cr;ABEHabcdefghjlmnoprstuvartrail;arr;;g;ar;\0\0\0\0\0\0\0\0\0ute;mptyv;rabda;g;dl;;uor;bfhlpst;fs;s;p;l;im;l;;aeil;;s;abrrr;rk;akcek;;es;ldu;;aeuyron;diil;;cqrsa;uo;rduhar;shar;h;;fgqstahlrtrrow;taarpoonduownpeftarrows;ightahsrrow;sarpoonquigarrohreetimes;;qslan;cdgsc;ot;o;r;;es;adegspproot;qgqgtiilrsht;;;E;rdu;l;lk;cy;;achtrorneard;ri;iodot;ust;acheEaes;p;prox;q;qim;abnoptwznrg;r;rglmreftarightapsto;ightparrowlrefight;aflr;;us;imes;st;;efngear;lt;achmtrornear;d;;ri;achiqtquo;r;m;eg;;buo;r;rok;<;cdhilqrci;r;remes;arr;uest;Piar;;efrdushar;har;enrtneqq;DacdefhilnopsuDot;clprret;;ese;sto;dluowefker;oymma;;ash;asuredangler;o;cdnro;acdsir;otus;bd;u;p;dpels;f;ctr;pos;lmtimap;GLRVabcdefghijlmoprstuvwgt;;veltftarrrow;ightarrow;;;vightarrow;Ddash;ash;bcnptlaute;g;;Eiop;d;s;rour;al;s\0pmp;eaeouy\0;on;dil;ng;dot;p;;ash;;Aadqsxrr;rhrk;;oot;uieiar;ist;sr;Eest;qs;qslani;rAaprrr;ar;;sv;d;cy;AEadestr;rr;r;;fqstarrroightarro;qslan;si;ri;eiptf;;inn;Edv;ot;;;i;v;;aorr;astllel;;lint;;ceu;c;eAaitrrr;cw;;ghtarrowri;echimpqu;ceru;ort\0\0arm;e;qsubpbcp;Ees;et;eq;qc;e;Ees;et;eq;qgilrldeianglelreft;eight;e;m;esro;p;DHadgilrsash;arr;p;ash;et;;>nfin;Aetrr;;;r<ie;Atrr;rie;im;Aanrr;rhrk;;oear;\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0csuteiyr;c;abioslac;v;old;lig;crir;;\0\0\0n;ave;bmar;acitrirr;oss;n;aeicr;ga;cdnron;;pf;aelr;rp;;adiosvr;efmr;ofgof;r;lope;;cloashl;idees;as;mlbar;\0\0\0\0\0\0\0\0\0r;ast;lle\0\0m;;y;rcimptnt;od;il;enk;r;imo;v;mane;;tvchfork;aunckk;h;s;abcdemstcir;ir;ou;;nim;wo;ipuntint;f;nd;Eaceinosu;p;u;c;acenspprourlyeaespprox;qq;im;ime;sEasdfpalslar;ine;urf;;trel;cir;;ncsp;fiopsur;pf;rime;cr;aeoteirnionnt;st;eABHabcdefhilmnoprstuxartrail;arar;cdenqrteu;te;imptyv;g;del;;uor;abcfhlpstwp;;fs;;s;l;im;l;;aiil;o;nalabrrrk;akcek;;es;ldu;;aeuyron;diil;;clqsa;dhar;uo;rh;acgl;ipsnart;ilrsht;;aordu;l;;v;gnshtahlrstrrow;taarpoonduowpeftahrrowarpoonightarrows;quigarrohreetimes;g;ingdotseahmra;oust;achemid;abptnrg;r;raflr;;us;imes;apr;gt;olint;arachqquo;r;buo;rhirremes;i;efltri;luhar;;\0\0\0\0\0\0\0cute;qu;Eaceinpsy;\0;on;u;dil;rc;Eas;p;im;olint;i;ot;be;Aacmstxrr;rhr;oti;war;minnut;r;oacoyrp;hycy;;rt\0\0iaragmma;fv;;deglnprot;;q;E;;E;e;lus;arr;araeitlslsetmhp;parsl;dle;;e;s;flptcy;;b;ar;f;adres;uitcsuaup;s;p;s;ubp;eset;e;eset;e;afrarcemtr;tmiararr;fanighteppsilohsbcmnp;Edemnprs;ot;;dot;ult;Ee;;lus;arr;eiut;enq;qeq;qm;bp;;c;acenspprourlyeaespproqg;123;Edehlmnps;ost;ub;;dot;soul;b;arr;ult;Ee;;lus;eiut;enq;qeq;qm;bp;;Aanrr;rhr;owar;lig\0\0\0\0\0\0\0\0\0\0\0\0get;;raeyron;dil;;lrec;r;eiko\0e4fa;svym;cnkaspproimsasrnes;bd;ar;;eps;bcfot;ir;;ork;rime;aipdadempstngle;dlqrowneft;e;ight;eot;inus;lus;b;ime;ezium;chtry;;cy;rok;ioxheadlreftarroightarrowAHabcdfghlmoprstuwrar;cruter\0y;ve;iyrc;abhrlac;airsht;;raverlrlk;ct\0\0rn;erop;ri;alcr;gpon;f;adhlsuownarpoonlrefighi;hlonparrows;cit\0\0rn;erop;ng;ri;cr;dirot;lde;i;famrlangle;ABDacdeflnoprszrar;v;asnrgrt;eknprstappothinhirop;hiugmbpsetneq;q;setneq;q;hretianglelreftighty;ashelr;bear;q;lip;btar;trsubppf;rotrcur;bpnEenEeigzag;cefoprsirc;dibgar;e;q;erp;r;pf;;eatcr;\0\0\0\0\0\0\0trr;Aarr;Aarrais;dptfl;imAarrcqr;ptracefiosucuyte;iyrc;;nr;cy;pf;cr;cmy;lacdefhioswcute;ayron;;ot;ettra;r;cy;grarr;pf;cr;jn;j;'.split("").map(function(n) {
      return n.charCodeAt(0);
    })
  )), $o;
}
var Go = {}, Xb;
function Q8() {
  return Xb || (Xb = 1, Object.defineProperty(Go, "__esModule", { value: !0 }), Go.default = new Uint16Array(
    // prettier-ignore
    "aglq	\x1B\0\0p;os;t;t;uot;".split("").map(function(n) {
      return n.charCodeAt(0);
    })
  )), Go;
}
var gd = {}, Kb;
function Yb() {
  return Kb || (Kb = 1, (function(n) {
    var e;
    Object.defineProperty(n, "__esModule", { value: !0 }), n.replaceCodePoint = n.fromCodePoint = void 0;
    var t = /* @__PURE__ */ new Map([
      [0, 65533],
      // C1 Unicode control character reference replacements
      [128, 8364],
      [130, 8218],
      [131, 402],
      [132, 8222],
      [133, 8230],
      [134, 8224],
      [135, 8225],
      [136, 710],
      [137, 8240],
      [138, 352],
      [139, 8249],
      [140, 338],
      [142, 381],
      [145, 8216],
      [146, 8217],
      [147, 8220],
      [148, 8221],
      [149, 8226],
      [150, 8211],
      [151, 8212],
      [152, 732],
      [153, 8482],
      [154, 353],
      [155, 8250],
      [156, 339],
      [158, 382],
      [159, 376]
    ]);
    n.fromCodePoint = // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition, node/no-unsupported-features/es-builtins
    (e = String.fromCodePoint) !== null && e !== void 0 ? e : function(a) {
      var s = "";
      return a > 65535 && (a -= 65536, s += String.fromCharCode(a >>> 10 & 1023 | 55296), a = 56320 | a & 1023), s += String.fromCharCode(a), s;
    };
    function i(a) {
      var s;
      return a >= 55296 && a <= 57343 || a > 1114111 ? 65533 : (s = t.get(a)) !== null && s !== void 0 ? s : a;
    }
    n.replaceCodePoint = i;
    function r(a) {
      return (0, n.fromCodePoint)(i(a));
    }
    n.default = r;
  })(gd)), gd;
}
var Qb;
function ec() {
  return Qb || (Qb = 1, (function(n) {
    var e = Xn && Xn.__createBinding || (Object.create ? (function(j, C, k, I) {
      I === void 0 && (I = k);
      var $ = Object.getOwnPropertyDescriptor(C, k);
      (!$ || ("get" in $ ? !C.__esModule : $.writable || $.configurable)) && ($ = { enumerable: !0, get: function() {
        return C[k];
      } }), Object.defineProperty(j, I, $);
    }) : (function(j, C, k, I) {
      I === void 0 && (I = k), j[I] = C[k];
    })), t = Xn && Xn.__setModuleDefault || (Object.create ? (function(j, C) {
      Object.defineProperty(j, "default", { enumerable: !0, value: C });
    }) : function(j, C) {
      j.default = C;
    }), i = Xn && Xn.__importStar || function(j) {
      if (j && j.__esModule) return j;
      var C = {};
      if (j != null) for (var k in j) k !== "default" && Object.prototype.hasOwnProperty.call(j, k) && e(C, j, k);
      return t(C, j), C;
    }, r = Xn && Xn.__importDefault || function(j) {
      return j && j.__esModule ? j : { default: j };
    };
    Object.defineProperty(n, "__esModule", { value: !0 }), n.decodeXML = n.decodeHTMLStrict = n.decodeHTMLAttribute = n.decodeHTML = n.determineBranch = n.EntityDecoder = n.DecodingMode = n.BinTrieFlags = n.fromCodePoint = n.replaceCodePoint = n.decodeCodePoint = n.xmlDecodeTree = n.htmlDecodeTree = void 0;
    var a = r(/* @__PURE__ */ Y8());
    n.htmlDecodeTree = a.default;
    var s = r(/* @__PURE__ */ Q8());
    n.xmlDecodeTree = s.default;
    var o = i(/* @__PURE__ */ Yb());
    n.decodeCodePoint = o.default;
    var u = /* @__PURE__ */ Yb();
    Object.defineProperty(n, "replaceCodePoint", { enumerable: !0, get: function() {
      return u.replaceCodePoint;
    } }), Object.defineProperty(n, "fromCodePoint", { enumerable: !0, get: function() {
      return u.fromCodePoint;
    } });
    var c;
    (function(j) {
      j[j.NUM = 35] = "NUM", j[j.SEMI = 59] = "SEMI", j[j.EQUALS = 61] = "EQUALS", j[j.ZERO = 48] = "ZERO", j[j.NINE = 57] = "NINE", j[j.LOWER_A = 97] = "LOWER_A", j[j.LOWER_F = 102] = "LOWER_F", j[j.LOWER_X = 120] = "LOWER_X", j[j.LOWER_Z = 122] = "LOWER_Z", j[j.UPPER_A = 65] = "UPPER_A", j[j.UPPER_F = 70] = "UPPER_F", j[j.UPPER_Z = 90] = "UPPER_Z";
    })(c || (c = {}));
    var l = 32, h;
    (function(j) {
      j[j.VALUE_LENGTH = 49152] = "VALUE_LENGTH", j[j.BRANCH_LENGTH = 16256] = "BRANCH_LENGTH", j[j.JUMP_TABLE = 127] = "JUMP_TABLE";
    })(h = n.BinTrieFlags || (n.BinTrieFlags = {}));
    function f(j) {
      return j >= c.ZERO && j <= c.NINE;
    }
    function d(j) {
      return j >= c.UPPER_A && j <= c.UPPER_F || j >= c.LOWER_A && j <= c.LOWER_F;
    }
    function y(j) {
      return j >= c.UPPER_A && j <= c.UPPER_Z || j >= c.LOWER_A && j <= c.LOWER_Z || f(j);
    }
    function m(j) {
      return j === c.EQUALS || y(j);
    }
    var b;
    (function(j) {
      j[j.EntityStart = 0] = "EntityStart", j[j.NumericStart = 1] = "NumericStart", j[j.NumericDecimal = 2] = "NumericDecimal", j[j.NumericHex = 3] = "NumericHex", j[j.NamedEntity = 4] = "NamedEntity";
    })(b || (b = {}));
    var p;
    (function(j) {
      j[j.Legacy = 0] = "Legacy", j[j.Strict = 1] = "Strict", j[j.Attribute = 2] = "Attribute";
    })(p = n.DecodingMode || (n.DecodingMode = {}));
    var g = (
      /** @class */
      (function() {
        function j(C, k, I) {
          this.decodeTree = C, this.emitCodePoint = k, this.errors = I, this.state = b.EntityStart, this.consumed = 1, this.result = 0, this.treeIndex = 0, this.excess = 1, this.decodeMode = p.Strict;
        }
        return j.prototype.startEntity = function(C) {
          this.decodeMode = C, this.state = b.EntityStart, this.result = 0, this.treeIndex = 0, this.excess = 1, this.consumed = 1;
        }, j.prototype.write = function(C, k) {
          switch (this.state) {
            case b.EntityStart:
              return C.charCodeAt(k) === c.NUM ? (this.state = b.NumericStart, this.consumed += 1, this.stateNumericStart(C, k + 1)) : (this.state = b.NamedEntity, this.stateNamedEntity(C, k));
            case b.NumericStart:
              return this.stateNumericStart(C, k);
            case b.NumericDecimal:
              return this.stateNumericDecimal(C, k);
            case b.NumericHex:
              return this.stateNumericHex(C, k);
            case b.NamedEntity:
              return this.stateNamedEntity(C, k);
          }
        }, j.prototype.stateNumericStart = function(C, k) {
          return k >= C.length ? -1 : (C.charCodeAt(k) | l) === c.LOWER_X ? (this.state = b.NumericHex, this.consumed += 1, this.stateNumericHex(C, k + 1)) : (this.state = b.NumericDecimal, this.stateNumericDecimal(C, k));
        }, j.prototype.addToNumericResult = function(C, k, I, $) {
          if (k !== I) {
            var W = I - k;
            this.result = this.result * Math.pow($, W) + parseInt(C.substr(k, W), $), this.consumed += W;
          }
        }, j.prototype.stateNumericHex = function(C, k) {
          for (var I = k; k < C.length; ) {
            var $ = C.charCodeAt(k);
            if (f($) || d($))
              k += 1;
            else
              return this.addToNumericResult(C, I, k, 16), this.emitNumericEntity($, 3);
          }
          return this.addToNumericResult(C, I, k, 16), -1;
        }, j.prototype.stateNumericDecimal = function(C, k) {
          for (var I = k; k < C.length; ) {
            var $ = C.charCodeAt(k);
            if (f($))
              k += 1;
            else
              return this.addToNumericResult(C, I, k, 10), this.emitNumericEntity($, 2);
          }
          return this.addToNumericResult(C, I, k, 10), -1;
        }, j.prototype.emitNumericEntity = function(C, k) {
          var I;
          if (this.consumed <= k)
            return (I = this.errors) === null || I === void 0 || I.absenceOfDigitsInNumericCharacterReference(this.consumed), 0;
          if (C === c.SEMI)
            this.consumed += 1;
          else if (this.decodeMode === p.Strict)
            return 0;
          return this.emitCodePoint((0, o.replaceCodePoint)(this.result), this.consumed), this.errors && (C !== c.SEMI && this.errors.missingSemicolonAfterCharacterReference(), this.errors.validateNumericCharacterReference(this.result)), this.consumed;
        }, j.prototype.stateNamedEntity = function(C, k) {
          for (var I = this.decodeTree, $ = I[this.treeIndex], W = ($ & h.VALUE_LENGTH) >> 14; k < C.length; k++, this.excess++) {
            var B = C.charCodeAt(k);
            if (this.treeIndex = _(I, $, this.treeIndex + Math.max(1, W), B), this.treeIndex < 0)
              return this.result === 0 || // If we are parsing an attribute
              this.decodeMode === p.Attribute && // We shouldn't have consumed any characters after the entity,
              (W === 0 || // And there should be no invalid characters.
              m(B)) ? 0 : this.emitNotTerminatedNamedEntity();
            if ($ = I[this.treeIndex], W = ($ & h.VALUE_LENGTH) >> 14, W !== 0) {
              if (B === c.SEMI)
                return this.emitNamedEntityData(this.treeIndex, W, this.consumed + this.excess);
              this.decodeMode !== p.Strict && (this.result = this.treeIndex, this.consumed += this.excess, this.excess = 0);
            }
          }
          return -1;
        }, j.prototype.emitNotTerminatedNamedEntity = function() {
          var C, k = this, I = k.result, $ = k.decodeTree, W = ($[I] & h.VALUE_LENGTH) >> 14;
          return this.emitNamedEntityData(I, W, this.consumed), (C = this.errors) === null || C === void 0 || C.missingSemicolonAfterCharacterReference(), this.consumed;
        }, j.prototype.emitNamedEntityData = function(C, k, I) {
          var $ = this.decodeTree;
          return this.emitCodePoint(k === 1 ? $[C] & ~h.VALUE_LENGTH : $[C + 1], I), k === 3 && this.emitCodePoint($[C + 2], I), I;
        }, j.prototype.end = function() {
          var C;
          switch (this.state) {
            case b.NamedEntity:
              return this.result !== 0 && (this.decodeMode !== p.Attribute || this.result === this.treeIndex) ? this.emitNotTerminatedNamedEntity() : 0;
            // Otherwise, emit a numeric entity if we have one.
            case b.NumericDecimal:
              return this.emitNumericEntity(0, 2);
            case b.NumericHex:
              return this.emitNumericEntity(0, 3);
            case b.NumericStart:
              return (C = this.errors) === null || C === void 0 || C.absenceOfDigitsInNumericCharacterReference(this.consumed), 0;
            case b.EntityStart:
              return 0;
          }
        }, j;
      })()
    );
    n.EntityDecoder = g;
    function v(j) {
      var C = "", k = new g(j, function(I) {
        return C += (0, o.fromCodePoint)(I);
      });
      return function($, W) {
        for (var B = 0, z = 0; (z = $.indexOf("&", z)) >= 0; ) {
          C += $.slice(B, z), k.startEntity(W);
          var q = k.write(
            $,
            // Skip the "&"
            z + 1
          );
          if (q < 0) {
            B = z + k.end();
            break;
          }
          B = z + q, z = q === 0 ? B + 1 : B;
        }
        var Y = C + $.slice(B);
        return C = "", Y;
      };
    }
    function _(j, C, k, I) {
      var $ = (C & h.BRANCH_LENGTH) >> 7, W = C & h.JUMP_TABLE;
      if ($ === 0)
        return W !== 0 && I === W ? k : -1;
      if (W) {
        var B = I - W;
        return B < 0 || B >= $ ? -1 : j[k + B] - 1;
      }
      for (var z = k, q = z + $ - 1; z <= q; ) {
        var Y = z + q >>> 1, H = j[Y];
        if (H < I)
          z = Y + 1;
        else if (H > I)
          q = Y - 1;
        else
          return j[Y + $];
      }
      return -1;
    }
    n.determineBranch = _;
    var x = v(a.default), T = v(s.default);
    function E(j, C) {
      return C === void 0 && (C = p.Legacy), x(j, C);
    }
    n.decodeHTML = E;
    function U(j) {
      return x(j, p.Attribute);
    }
    n.decodeHTMLAttribute = U;
    function D(j) {
      return x(j, p.Strict);
    }
    n.decodeHTMLStrict = D;
    function L(j) {
      return T(j, p.Strict);
    }
    n.decodeXML = L;
  })(Xn)), Xn;
}
var Zb;
function IT() {
  return Zb || (Zb = 1, (function(n) {
    Object.defineProperty(n, "__esModule", { value: !0 }), n.QuoteType = void 0;
    var e = /* @__PURE__ */ ec(), t;
    (function(f) {
      f[f.Tab = 9] = "Tab", f[f.NewLine = 10] = "NewLine", f[f.FormFeed = 12] = "FormFeed", f[f.CarriageReturn = 13] = "CarriageReturn", f[f.Space = 32] = "Space", f[f.ExclamationMark = 33] = "ExclamationMark", f[f.Number = 35] = "Number", f[f.Amp = 38] = "Amp", f[f.SingleQuote = 39] = "SingleQuote", f[f.DoubleQuote = 34] = "DoubleQuote", f[f.Dash = 45] = "Dash", f[f.Slash = 47] = "Slash", f[f.Zero = 48] = "Zero", f[f.Nine = 57] = "Nine", f[f.Semi = 59] = "Semi", f[f.Lt = 60] = "Lt", f[f.Eq = 61] = "Eq", f[f.Gt = 62] = "Gt", f[f.Questionmark = 63] = "Questionmark", f[f.UpperA = 65] = "UpperA", f[f.LowerA = 97] = "LowerA", f[f.UpperF = 70] = "UpperF", f[f.LowerF = 102] = "LowerF", f[f.UpperZ = 90] = "UpperZ", f[f.LowerZ = 122] = "LowerZ", f[f.LowerX = 120] = "LowerX", f[f.OpeningSquareBracket = 91] = "OpeningSquareBracket";
    })(t || (t = {}));
    var i;
    (function(f) {
      f[f.Text = 1] = "Text", f[f.BeforeTagName = 2] = "BeforeTagName", f[f.InTagName = 3] = "InTagName", f[f.InSelfClosingTag = 4] = "InSelfClosingTag", f[f.BeforeClosingTagName = 5] = "BeforeClosingTagName", f[f.InClosingTagName = 6] = "InClosingTagName", f[f.AfterClosingTagName = 7] = "AfterClosingTagName", f[f.BeforeAttributeName = 8] = "BeforeAttributeName", f[f.InAttributeName = 9] = "InAttributeName", f[f.AfterAttributeName = 10] = "AfterAttributeName", f[f.BeforeAttributeValue = 11] = "BeforeAttributeValue", f[f.InAttributeValueDq = 12] = "InAttributeValueDq", f[f.InAttributeValueSq = 13] = "InAttributeValueSq", f[f.InAttributeValueNq = 14] = "InAttributeValueNq", f[f.BeforeDeclaration = 15] = "BeforeDeclaration", f[f.InDeclaration = 16] = "InDeclaration", f[f.InProcessingInstruction = 17] = "InProcessingInstruction", f[f.BeforeComment = 18] = "BeforeComment", f[f.CDATASequence = 19] = "CDATASequence", f[f.InSpecialComment = 20] = "InSpecialComment", f[f.InCommentLike = 21] = "InCommentLike", f[f.BeforeSpecialS = 22] = "BeforeSpecialS", f[f.SpecialStartSequence = 23] = "SpecialStartSequence", f[f.InSpecialTag = 24] = "InSpecialTag", f[f.BeforeEntity = 25] = "BeforeEntity", f[f.BeforeNumericEntity = 26] = "BeforeNumericEntity", f[f.InNamedEntity = 27] = "InNamedEntity", f[f.InNumericEntity = 28] = "InNumericEntity", f[f.InHexEntity = 29] = "InHexEntity";
    })(i || (i = {}));
    function r(f) {
      return f === t.Space || f === t.NewLine || f === t.Tab || f === t.FormFeed || f === t.CarriageReturn;
    }
    function a(f) {
      return f === t.Slash || f === t.Gt || r(f);
    }
    function s(f) {
      return f >= t.Zero && f <= t.Nine;
    }
    function o(f) {
      return f >= t.LowerA && f <= t.LowerZ || f >= t.UpperA && f <= t.UpperZ;
    }
    function u(f) {
      return f >= t.UpperA && f <= t.UpperF || f >= t.LowerA && f <= t.LowerF;
    }
    var c;
    (function(f) {
      f[f.NoValue = 0] = "NoValue", f[f.Unquoted = 1] = "Unquoted", f[f.Single = 2] = "Single", f[f.Double = 3] = "Double";
    })(c = n.QuoteType || (n.QuoteType = {}));
    var l = {
      Cdata: new Uint8Array([67, 68, 65, 84, 65, 91]),
      CdataEnd: new Uint8Array([93, 93, 62]),
      CommentEnd: new Uint8Array([45, 45, 62]),
      ScriptEnd: new Uint8Array([60, 47, 115, 99, 114, 105, 112, 116]),
      StyleEnd: new Uint8Array([60, 47, 115, 116, 121, 108, 101]),
      TitleEnd: new Uint8Array([60, 47, 116, 105, 116, 108, 101])
      // `</title`
    }, h = (
      /** @class */
      (function() {
        function f(d, y) {
          var m = d.xmlMode, b = m === void 0 ? !1 : m, p = d.decodeEntities, g = p === void 0 ? !0 : p;
          this.cbs = y, this.state = i.Text, this.buffer = "", this.sectionStart = 0, this.index = 0, this.baseState = i.Text, this.isSpecial = !1, this.running = !0, this.offset = 0, this.currentSequence = void 0, this.sequenceIndex = 0, this.trieIndex = 0, this.trieCurrent = 0, this.entityResult = 0, this.entityExcess = 0, this.xmlMode = b, this.decodeEntities = g, this.entityTrie = b ? e.xmlDecodeTree : e.htmlDecodeTree;
        }
        return f.prototype.reset = function() {
          this.state = i.Text, this.buffer = "", this.sectionStart = 0, this.index = 0, this.baseState = i.Text, this.currentSequence = void 0, this.running = !0, this.offset = 0;
        }, f.prototype.write = function(d) {
          this.offset += this.buffer.length, this.buffer = d, this.parse();
        }, f.prototype.end = function() {
          this.running && this.finish();
        }, f.prototype.pause = function() {
          this.running = !1;
        }, f.prototype.resume = function() {
          this.running = !0, this.index < this.buffer.length + this.offset && this.parse();
        }, f.prototype.getIndex = function() {
          return this.index;
        }, f.prototype.getSectionStart = function() {
          return this.sectionStart;
        }, f.prototype.stateText = function(d) {
          d === t.Lt || !this.decodeEntities && this.fastForwardTo(t.Lt) ? (this.index > this.sectionStart && this.cbs.ontext(this.sectionStart, this.index), this.state = i.BeforeTagName, this.sectionStart = this.index) : this.decodeEntities && d === t.Amp && (this.state = i.BeforeEntity);
        }, f.prototype.stateSpecialStartSequence = function(d) {
          var y = this.sequenceIndex === this.currentSequence.length, m = y ? (
            // If we are at the end of the sequence, make sure the tag name has ended
            a(d)
          ) : (
            // Otherwise, do a case-insensitive comparison
            (d | 32) === this.currentSequence[this.sequenceIndex]
          );
          if (!m)
            this.isSpecial = !1;
          else if (!y) {
            this.sequenceIndex++;
            return;
          }
          this.sequenceIndex = 0, this.state = i.InTagName, this.stateInTagName(d);
        }, f.prototype.stateInSpecialTag = function(d) {
          if (this.sequenceIndex === this.currentSequence.length) {
            if (d === t.Gt || r(d)) {
              var y = this.index - this.currentSequence.length;
              if (this.sectionStart < y) {
                var m = this.index;
                this.index = y, this.cbs.ontext(this.sectionStart, y), this.index = m;
              }
              this.isSpecial = !1, this.sectionStart = y + 2, this.stateInClosingTagName(d);
              return;
            }
            this.sequenceIndex = 0;
          }
          (d | 32) === this.currentSequence[this.sequenceIndex] ? this.sequenceIndex += 1 : this.sequenceIndex === 0 ? this.currentSequence === l.TitleEnd ? this.decodeEntities && d === t.Amp && (this.state = i.BeforeEntity) : this.fastForwardTo(t.Lt) && (this.sequenceIndex = 1) : this.sequenceIndex = +(d === t.Lt);
        }, f.prototype.stateCDATASequence = function(d) {
          d === l.Cdata[this.sequenceIndex] ? ++this.sequenceIndex === l.Cdata.length && (this.state = i.InCommentLike, this.currentSequence = l.CdataEnd, this.sequenceIndex = 0, this.sectionStart = this.index + 1) : (this.sequenceIndex = 0, this.state = i.InDeclaration, this.stateInDeclaration(d));
        }, f.prototype.fastForwardTo = function(d) {
          for (; ++this.index < this.buffer.length + this.offset; )
            if (this.buffer.charCodeAt(this.index - this.offset) === d)
              return !0;
          return this.index = this.buffer.length + this.offset - 1, !1;
        }, f.prototype.stateInCommentLike = function(d) {
          d === this.currentSequence[this.sequenceIndex] ? ++this.sequenceIndex === this.currentSequence.length && (this.currentSequence === l.CdataEnd ? this.cbs.oncdata(this.sectionStart, this.index, 2) : this.cbs.oncomment(this.sectionStart, this.index, 2), this.sequenceIndex = 0, this.sectionStart = this.index + 1, this.state = i.Text) : this.sequenceIndex === 0 ? this.fastForwardTo(this.currentSequence[0]) && (this.sequenceIndex = 1) : d !== this.currentSequence[this.sequenceIndex - 1] && (this.sequenceIndex = 0);
        }, f.prototype.isTagStartChar = function(d) {
          return this.xmlMode ? !a(d) : o(d);
        }, f.prototype.startSpecial = function(d, y) {
          this.isSpecial = !0, this.currentSequence = d, this.sequenceIndex = y, this.state = i.SpecialStartSequence;
        }, f.prototype.stateBeforeTagName = function(d) {
          if (d === t.ExclamationMark)
            this.state = i.BeforeDeclaration, this.sectionStart = this.index + 1;
          else if (d === t.Questionmark)
            this.state = i.InProcessingInstruction, this.sectionStart = this.index + 1;
          else if (this.isTagStartChar(d)) {
            var y = d | 32;
            this.sectionStart = this.index, !this.xmlMode && y === l.TitleEnd[2] ? this.startSpecial(l.TitleEnd, 3) : this.state = !this.xmlMode && y === l.ScriptEnd[2] ? i.BeforeSpecialS : i.InTagName;
          } else d === t.Slash ? this.state = i.BeforeClosingTagName : (this.state = i.Text, this.stateText(d));
        }, f.prototype.stateInTagName = function(d) {
          a(d) && (this.cbs.onopentagname(this.sectionStart, this.index), this.sectionStart = -1, this.state = i.BeforeAttributeName, this.stateBeforeAttributeName(d));
        }, f.prototype.stateBeforeClosingTagName = function(d) {
          r(d) || (d === t.Gt ? this.state = i.Text : (this.state = this.isTagStartChar(d) ? i.InClosingTagName : i.InSpecialComment, this.sectionStart = this.index));
        }, f.prototype.stateInClosingTagName = function(d) {
          (d === t.Gt || r(d)) && (this.cbs.onclosetag(this.sectionStart, this.index), this.sectionStart = -1, this.state = i.AfterClosingTagName, this.stateAfterClosingTagName(d));
        }, f.prototype.stateAfterClosingTagName = function(d) {
          (d === t.Gt || this.fastForwardTo(t.Gt)) && (this.state = i.Text, this.baseState = i.Text, this.sectionStart = this.index + 1);
        }, f.prototype.stateBeforeAttributeName = function(d) {
          d === t.Gt ? (this.cbs.onopentagend(this.index), this.isSpecial ? (this.state = i.InSpecialTag, this.sequenceIndex = 0) : this.state = i.Text, this.baseState = this.state, this.sectionStart = this.index + 1) : d === t.Slash ? this.state = i.InSelfClosingTag : r(d) || (this.state = i.InAttributeName, this.sectionStart = this.index);
        }, f.prototype.stateInSelfClosingTag = function(d) {
          d === t.Gt ? (this.cbs.onselfclosingtag(this.index), this.state = i.Text, this.baseState = i.Text, this.sectionStart = this.index + 1, this.isSpecial = !1) : r(d) || (this.state = i.BeforeAttributeName, this.stateBeforeAttributeName(d));
        }, f.prototype.stateInAttributeName = function(d) {
          (d === t.Eq || a(d)) && (this.cbs.onattribname(this.sectionStart, this.index), this.sectionStart = -1, this.state = i.AfterAttributeName, this.stateAfterAttributeName(d));
        }, f.prototype.stateAfterAttributeName = function(d) {
          d === t.Eq ? this.state = i.BeforeAttributeValue : d === t.Slash || d === t.Gt ? (this.cbs.onattribend(c.NoValue, this.index), this.state = i.BeforeAttributeName, this.stateBeforeAttributeName(d)) : r(d) || (this.cbs.onattribend(c.NoValue, this.index), this.state = i.InAttributeName, this.sectionStart = this.index);
        }, f.prototype.stateBeforeAttributeValue = function(d) {
          d === t.DoubleQuote ? (this.state = i.InAttributeValueDq, this.sectionStart = this.index + 1) : d === t.SingleQuote ? (this.state = i.InAttributeValueSq, this.sectionStart = this.index + 1) : r(d) || (this.sectionStart = this.index, this.state = i.InAttributeValueNq, this.stateInAttributeValueNoQuotes(d));
        }, f.prototype.handleInAttributeValue = function(d, y) {
          d === y || !this.decodeEntities && this.fastForwardTo(y) ? (this.cbs.onattribdata(this.sectionStart, this.index), this.sectionStart = -1, this.cbs.onattribend(y === t.DoubleQuote ? c.Double : c.Single, this.index), this.state = i.BeforeAttributeName) : this.decodeEntities && d === t.Amp && (this.baseState = this.state, this.state = i.BeforeEntity);
        }, f.prototype.stateInAttributeValueDoubleQuotes = function(d) {
          this.handleInAttributeValue(d, t.DoubleQuote);
        }, f.prototype.stateInAttributeValueSingleQuotes = function(d) {
          this.handleInAttributeValue(d, t.SingleQuote);
        }, f.prototype.stateInAttributeValueNoQuotes = function(d) {
          r(d) || d === t.Gt ? (this.cbs.onattribdata(this.sectionStart, this.index), this.sectionStart = -1, this.cbs.onattribend(c.Unquoted, this.index), this.state = i.BeforeAttributeName, this.stateBeforeAttributeName(d)) : this.decodeEntities && d === t.Amp && (this.baseState = this.state, this.state = i.BeforeEntity);
        }, f.prototype.stateBeforeDeclaration = function(d) {
          d === t.OpeningSquareBracket ? (this.state = i.CDATASequence, this.sequenceIndex = 0) : this.state = d === t.Dash ? i.BeforeComment : i.InDeclaration;
        }, f.prototype.stateInDeclaration = function(d) {
          (d === t.Gt || this.fastForwardTo(t.Gt)) && (this.cbs.ondeclaration(this.sectionStart, this.index), this.state = i.Text, this.sectionStart = this.index + 1);
        }, f.prototype.stateInProcessingInstruction = function(d) {
          (d === t.Gt || this.fastForwardTo(t.Gt)) && (this.cbs.onprocessinginstruction(this.sectionStart, this.index), this.state = i.Text, this.sectionStart = this.index + 1);
        }, f.prototype.stateBeforeComment = function(d) {
          d === t.Dash ? (this.state = i.InCommentLike, this.currentSequence = l.CommentEnd, this.sequenceIndex = 2, this.sectionStart = this.index + 1) : this.state = i.InDeclaration;
        }, f.prototype.stateInSpecialComment = function(d) {
          (d === t.Gt || this.fastForwardTo(t.Gt)) && (this.cbs.oncomment(this.sectionStart, this.index, 0), this.state = i.Text, this.sectionStart = this.index + 1);
        }, f.prototype.stateBeforeSpecialS = function(d) {
          var y = d | 32;
          y === l.ScriptEnd[3] ? this.startSpecial(l.ScriptEnd, 4) : y === l.StyleEnd[3] ? this.startSpecial(l.StyleEnd, 4) : (this.state = i.InTagName, this.stateInTagName(d));
        }, f.prototype.stateBeforeEntity = function(d) {
          this.entityExcess = 1, this.entityResult = 0, d === t.Number ? this.state = i.BeforeNumericEntity : d === t.Amp || (this.trieIndex = 0, this.trieCurrent = this.entityTrie[0], this.state = i.InNamedEntity, this.stateInNamedEntity(d));
        }, f.prototype.stateInNamedEntity = function(d) {
          if (this.entityExcess += 1, this.trieIndex = (0, e.determineBranch)(this.entityTrie, this.trieCurrent, this.trieIndex + 1, d), this.trieIndex < 0) {
            this.emitNamedEntity(), this.index--;
            return;
          }
          this.trieCurrent = this.entityTrie[this.trieIndex];
          var y = this.trieCurrent & e.BinTrieFlags.VALUE_LENGTH;
          if (y) {
            var m = (y >> 14) - 1;
            if (!this.allowLegacyEntity() && d !== t.Semi)
              this.trieIndex += m;
            else {
              var b = this.index - this.entityExcess + 1;
              b > this.sectionStart && this.emitPartial(this.sectionStart, b), this.entityResult = this.trieIndex, this.trieIndex += m, this.entityExcess = 0, this.sectionStart = this.index + 1, m === 0 && this.emitNamedEntity();
            }
          }
        }, f.prototype.emitNamedEntity = function() {
          if (this.state = this.baseState, this.entityResult !== 0) {
            var d = (this.entityTrie[this.entityResult] & e.BinTrieFlags.VALUE_LENGTH) >> 14;
            switch (d) {
              case 1: {
                this.emitCodePoint(this.entityTrie[this.entityResult] & ~e.BinTrieFlags.VALUE_LENGTH);
                break;
              }
              case 2: {
                this.emitCodePoint(this.entityTrie[this.entityResult + 1]);
                break;
              }
              case 3:
                this.emitCodePoint(this.entityTrie[this.entityResult + 1]), this.emitCodePoint(this.entityTrie[this.entityResult + 2]);
            }
          }
        }, f.prototype.stateBeforeNumericEntity = function(d) {
          (d | 32) === t.LowerX ? (this.entityExcess++, this.state = i.InHexEntity) : (this.state = i.InNumericEntity, this.stateInNumericEntity(d));
        }, f.prototype.emitNumericEntity = function(d) {
          var y = this.index - this.entityExcess - 1, m = y + 2 + +(this.state === i.InHexEntity);
          m !== this.index && (y > this.sectionStart && this.emitPartial(this.sectionStart, y), this.sectionStart = this.index + Number(d), this.emitCodePoint((0, e.replaceCodePoint)(this.entityResult))), this.state = this.baseState;
        }, f.prototype.stateInNumericEntity = function(d) {
          d === t.Semi ? this.emitNumericEntity(!0) : s(d) ? (this.entityResult = this.entityResult * 10 + (d - t.Zero), this.entityExcess++) : (this.allowLegacyEntity() ? this.emitNumericEntity(!1) : this.state = this.baseState, this.index--);
        }, f.prototype.stateInHexEntity = function(d) {
          d === t.Semi ? this.emitNumericEntity(!0) : s(d) ? (this.entityResult = this.entityResult * 16 + (d - t.Zero), this.entityExcess++) : u(d) ? (this.entityResult = this.entityResult * 16 + ((d | 32) - t.LowerA + 10), this.entityExcess++) : (this.allowLegacyEntity() ? this.emitNumericEntity(!1) : this.state = this.baseState, this.index--);
        }, f.prototype.allowLegacyEntity = function() {
          return !this.xmlMode && (this.baseState === i.Text || this.baseState === i.InSpecialTag);
        }, f.prototype.cleanup = function() {
          this.running && this.sectionStart !== this.index && (this.state === i.Text || this.state === i.InSpecialTag && this.sequenceIndex === 0 ? (this.cbs.ontext(this.sectionStart, this.index), this.sectionStart = this.index) : (this.state === i.InAttributeValueDq || this.state === i.InAttributeValueSq || this.state === i.InAttributeValueNq) && (this.cbs.onattribdata(this.sectionStart, this.index), this.sectionStart = this.index));
        }, f.prototype.shouldContinue = function() {
          return this.index < this.buffer.length + this.offset && this.running;
        }, f.prototype.parse = function() {
          for (; this.shouldContinue(); ) {
            var d = this.buffer.charCodeAt(this.index - this.offset);
            switch (this.state) {
              case i.Text: {
                this.stateText(d);
                break;
              }
              case i.SpecialStartSequence: {
                this.stateSpecialStartSequence(d);
                break;
              }
              case i.InSpecialTag: {
                this.stateInSpecialTag(d);
                break;
              }
              case i.CDATASequence: {
                this.stateCDATASequence(d);
                break;
              }
              case i.InAttributeValueDq: {
                this.stateInAttributeValueDoubleQuotes(d);
                break;
              }
              case i.InAttributeName: {
                this.stateInAttributeName(d);
                break;
              }
              case i.InCommentLike: {
                this.stateInCommentLike(d);
                break;
              }
              case i.InSpecialComment: {
                this.stateInSpecialComment(d);
                break;
              }
              case i.BeforeAttributeName: {
                this.stateBeforeAttributeName(d);
                break;
              }
              case i.InTagName: {
                this.stateInTagName(d);
                break;
              }
              case i.InClosingTagName: {
                this.stateInClosingTagName(d);
                break;
              }
              case i.BeforeTagName: {
                this.stateBeforeTagName(d);
                break;
              }
              case i.AfterAttributeName: {
                this.stateAfterAttributeName(d);
                break;
              }
              case i.InAttributeValueSq: {
                this.stateInAttributeValueSingleQuotes(d);
                break;
              }
              case i.BeforeAttributeValue: {
                this.stateBeforeAttributeValue(d);
                break;
              }
              case i.BeforeClosingTagName: {
                this.stateBeforeClosingTagName(d);
                break;
              }
              case i.AfterClosingTagName: {
                this.stateAfterClosingTagName(d);
                break;
              }
              case i.BeforeSpecialS: {
                this.stateBeforeSpecialS(d);
                break;
              }
              case i.InAttributeValueNq: {
                this.stateInAttributeValueNoQuotes(d);
                break;
              }
              case i.InSelfClosingTag: {
                this.stateInSelfClosingTag(d);
                break;
              }
              case i.InDeclaration: {
                this.stateInDeclaration(d);
                break;
              }
              case i.BeforeDeclaration: {
                this.stateBeforeDeclaration(d);
                break;
              }
              case i.BeforeComment: {
                this.stateBeforeComment(d);
                break;
              }
              case i.InProcessingInstruction: {
                this.stateInProcessingInstruction(d);
                break;
              }
              case i.InNamedEntity: {
                this.stateInNamedEntity(d);
                break;
              }
              case i.BeforeEntity: {
                this.stateBeforeEntity(d);
                break;
              }
              case i.InHexEntity: {
                this.stateInHexEntity(d);
                break;
              }
              case i.InNumericEntity: {
                this.stateInNumericEntity(d);
                break;
              }
              default:
                this.stateBeforeNumericEntity(d);
            }
            this.index++;
          }
          this.cleanup();
        }, f.prototype.finish = function() {
          this.state === i.InNamedEntity && this.emitNamedEntity(), this.sectionStart < this.index && this.handleTrailingData(), this.cbs.onend();
        }, f.prototype.handleTrailingData = function() {
          var d = this.buffer.length + this.offset;
          this.state === i.InCommentLike ? this.currentSequence === l.CdataEnd ? this.cbs.oncdata(this.sectionStart, d, 0) : this.cbs.oncomment(this.sectionStart, d, 0) : this.state === i.InNumericEntity && this.allowLegacyEntity() ? this.emitNumericEntity(!1) : this.state === i.InHexEntity && this.allowLegacyEntity() ? this.emitNumericEntity(!1) : this.state === i.InTagName || this.state === i.BeforeAttributeName || this.state === i.BeforeAttributeValue || this.state === i.AfterAttributeName || this.state === i.InAttributeName || this.state === i.InAttributeValueSq || this.state === i.InAttributeValueDq || this.state === i.InAttributeValueNq || this.state === i.InClosingTagName || this.cbs.ontext(this.sectionStart, d);
        }, f.prototype.emitPartial = function(d, y) {
          this.baseState !== i.Text && this.baseState !== i.InSpecialTag ? this.cbs.onattribdata(d, y) : this.cbs.ontext(d, y);
        }, f.prototype.emitCodePoint = function(d) {
          this.baseState !== i.Text && this.baseState !== i.InSpecialTag ? this.cbs.onattribentity(d) : this.cbs.ontextentity(d);
        }, f;
      })()
    );
    n.default = h;
  })(md)), md;
}
var Jb;
function ey() {
  if (Jb) return Gn;
  Jb = 1;
  var n = Gn && Gn.__createBinding || (Object.create ? (function(b, p, g, v) {
    v === void 0 && (v = g);
    var _ = Object.getOwnPropertyDescriptor(p, g);
    (!_ || ("get" in _ ? !p.__esModule : _.writable || _.configurable)) && (_ = { enumerable: !0, get: function() {
      return p[g];
    } }), Object.defineProperty(b, v, _);
  }) : (function(b, p, g, v) {
    v === void 0 && (v = g), b[v] = p[g];
  })), e = Gn && Gn.__setModuleDefault || (Object.create ? (function(b, p) {
    Object.defineProperty(b, "default", { enumerable: !0, value: p });
  }) : function(b, p) {
    b.default = p;
  }), t = Gn && Gn.__importStar || function(b) {
    if (b && b.__esModule) return b;
    var p = {};
    if (b != null) for (var g in b) g !== "default" && Object.prototype.hasOwnProperty.call(b, g) && n(p, b, g);
    return e(p, b), p;
  };
  Object.defineProperty(Gn, "__esModule", { value: !0 }), Gn.Parser = void 0;
  var i = t(/* @__PURE__ */ IT()), r = /* @__PURE__ */ ec(), a = /* @__PURE__ */ new Set([
    "input",
    "option",
    "optgroup",
    "select",
    "button",
    "datalist",
    "textarea"
  ]), s = /* @__PURE__ */ new Set(["p"]), o = /* @__PURE__ */ new Set(["thead", "tbody"]), u = /* @__PURE__ */ new Set(["dd", "dt"]), c = /* @__PURE__ */ new Set(["rt", "rp"]), l = /* @__PURE__ */ new Map([
    ["tr", /* @__PURE__ */ new Set(["tr", "th", "td"])],
    ["th", /* @__PURE__ */ new Set(["th"])],
    ["td", /* @__PURE__ */ new Set(["thead", "th", "td"])],
    ["body", /* @__PURE__ */ new Set(["head", "link", "script"])],
    ["li", /* @__PURE__ */ new Set(["li"])],
    ["p", s],
    ["h1", s],
    ["h2", s],
    ["h3", s],
    ["h4", s],
    ["h5", s],
    ["h6", s],
    ["select", a],
    ["input", a],
    ["output", a],
    ["button", a],
    ["datalist", a],
    ["textarea", a],
    ["option", /* @__PURE__ */ new Set(["option"])],
    ["optgroup", /* @__PURE__ */ new Set(["optgroup", "option"])],
    ["dd", u],
    ["dt", u],
    ["address", s],
    ["article", s],
    ["aside", s],
    ["blockquote", s],
    ["details", s],
    ["div", s],
    ["dl", s],
    ["fieldset", s],
    ["figcaption", s],
    ["figure", s],
    ["footer", s],
    ["form", s],
    ["header", s],
    ["hr", s],
    ["main", s],
    ["nav", s],
    ["ol", s],
    ["pre", s],
    ["section", s],
    ["table", s],
    ["ul", s],
    ["rt", c],
    ["rp", c],
    ["tbody", o],
    ["tfoot", o]
  ]), h = /* @__PURE__ */ new Set([
    "area",
    "base",
    "basefont",
    "br",
    "col",
    "command",
    "embed",
    "frame",
    "hr",
    "img",
    "input",
    "isindex",
    "keygen",
    "link",
    "meta",
    "param",
    "source",
    "track",
    "wbr"
  ]), f = /* @__PURE__ */ new Set(["math", "svg"]), d = /* @__PURE__ */ new Set([
    "mi",
    "mo",
    "mn",
    "ms",
    "mtext",
    "annotation-xml",
    "foreignobject",
    "desc",
    "title"
  ]), y = /\s|\//, m = (
    /** @class */
    (function() {
      function b(p, g) {
        g === void 0 && (g = {});
        var v, _, x, T, E;
        this.options = g, this.startIndex = 0, this.endIndex = 0, this.openTagStart = 0, this.tagname = "", this.attribname = "", this.attribvalue = "", this.attribs = null, this.stack = [], this.foreignContext = [], this.buffers = [], this.bufferOffset = 0, this.writeIndex = 0, this.ended = !1, this.cbs = p ?? {}, this.lowerCaseTagNames = (v = g.lowerCaseTags) !== null && v !== void 0 ? v : !g.xmlMode, this.lowerCaseAttributeNames = (_ = g.lowerCaseAttributeNames) !== null && _ !== void 0 ? _ : !g.xmlMode, this.tokenizer = new ((x = g.Tokenizer) !== null && x !== void 0 ? x : i.default)(this.options, this), (E = (T = this.cbs).onparserinit) === null || E === void 0 || E.call(T, this);
      }
      return b.prototype.ontext = function(p, g) {
        var v, _, x = this.getSlice(p, g);
        this.endIndex = g - 1, (_ = (v = this.cbs).ontext) === null || _ === void 0 || _.call(v, x), this.startIndex = g;
      }, b.prototype.ontextentity = function(p) {
        var g, v, _ = this.tokenizer.getSectionStart();
        this.endIndex = _ - 1, (v = (g = this.cbs).ontext) === null || v === void 0 || v.call(g, (0, r.fromCodePoint)(p)), this.startIndex = _;
      }, b.prototype.isVoidElement = function(p) {
        return !this.options.xmlMode && h.has(p);
      }, b.prototype.onopentagname = function(p, g) {
        this.endIndex = g;
        var v = this.getSlice(p, g);
        this.lowerCaseTagNames && (v = v.toLowerCase()), this.emitOpenTag(v);
      }, b.prototype.emitOpenTag = function(p) {
        var g, v, _, x;
        this.openTagStart = this.startIndex, this.tagname = p;
        var T = !this.options.xmlMode && l.get(p);
        if (T)
          for (; this.stack.length > 0 && T.has(this.stack[this.stack.length - 1]); ) {
            var E = this.stack.pop();
            (v = (g = this.cbs).onclosetag) === null || v === void 0 || v.call(g, E, !0);
          }
        this.isVoidElement(p) || (this.stack.push(p), f.has(p) ? this.foreignContext.push(!0) : d.has(p) && this.foreignContext.push(!1)), (x = (_ = this.cbs).onopentagname) === null || x === void 0 || x.call(_, p), this.cbs.onopentag && (this.attribs = {});
      }, b.prototype.endOpenTag = function(p) {
        var g, v;
        this.startIndex = this.openTagStart, this.attribs && ((v = (g = this.cbs).onopentag) === null || v === void 0 || v.call(g, this.tagname, this.attribs, p), this.attribs = null), this.cbs.onclosetag && this.isVoidElement(this.tagname) && this.cbs.onclosetag(this.tagname, !0), this.tagname = "";
      }, b.prototype.onopentagend = function(p) {
        this.endIndex = p, this.endOpenTag(!1), this.startIndex = p + 1;
      }, b.prototype.onclosetag = function(p, g) {
        var v, _, x, T, E, U;
        this.endIndex = g;
        var D = this.getSlice(p, g);
        if (this.lowerCaseTagNames && (D = D.toLowerCase()), (f.has(D) || d.has(D)) && this.foreignContext.pop(), this.isVoidElement(D))
          !this.options.xmlMode && D === "br" && ((_ = (v = this.cbs).onopentagname) === null || _ === void 0 || _.call(v, "br"), (T = (x = this.cbs).onopentag) === null || T === void 0 || T.call(x, "br", {}, !0), (U = (E = this.cbs).onclosetag) === null || U === void 0 || U.call(E, "br", !1));
        else {
          var L = this.stack.lastIndexOf(D);
          if (L !== -1)
            if (this.cbs.onclosetag)
              for (var j = this.stack.length - L; j--; )
                this.cbs.onclosetag(this.stack.pop(), j !== 0);
            else
              this.stack.length = L;
          else !this.options.xmlMode && D === "p" && (this.emitOpenTag("p"), this.closeCurrentTag(!0));
        }
        this.startIndex = g + 1;
      }, b.prototype.onselfclosingtag = function(p) {
        this.endIndex = p, this.options.xmlMode || this.options.recognizeSelfClosing || this.foreignContext[this.foreignContext.length - 1] ? (this.closeCurrentTag(!1), this.startIndex = p + 1) : this.onopentagend(p);
      }, b.prototype.closeCurrentTag = function(p) {
        var g, v, _ = this.tagname;
        this.endOpenTag(p), this.stack[this.stack.length - 1] === _ && ((v = (g = this.cbs).onclosetag) === null || v === void 0 || v.call(g, _, !p), this.stack.pop());
      }, b.prototype.onattribname = function(p, g) {
        this.startIndex = p;
        var v = this.getSlice(p, g);
        this.attribname = this.lowerCaseAttributeNames ? v.toLowerCase() : v;
      }, b.prototype.onattribdata = function(p, g) {
        this.attribvalue += this.getSlice(p, g);
      }, b.prototype.onattribentity = function(p) {
        this.attribvalue += (0, r.fromCodePoint)(p);
      }, b.prototype.onattribend = function(p, g) {
        var v, _;
        this.endIndex = g, (_ = (v = this.cbs).onattribute) === null || _ === void 0 || _.call(v, this.attribname, this.attribvalue, p === i.QuoteType.Double ? '"' : p === i.QuoteType.Single ? "'" : p === i.QuoteType.NoValue ? void 0 : null), this.attribs && !Object.prototype.hasOwnProperty.call(this.attribs, this.attribname) && (this.attribs[this.attribname] = this.attribvalue), this.attribvalue = "";
      }, b.prototype.getInstructionName = function(p) {
        var g = p.search(y), v = g < 0 ? p : p.substr(0, g);
        return this.lowerCaseTagNames && (v = v.toLowerCase()), v;
      }, b.prototype.ondeclaration = function(p, g) {
        this.endIndex = g;
        var v = this.getSlice(p, g);
        if (this.cbs.onprocessinginstruction) {
          var _ = this.getInstructionName(v);
          this.cbs.onprocessinginstruction("!".concat(_), "!".concat(v));
        }
        this.startIndex = g + 1;
      }, b.prototype.onprocessinginstruction = function(p, g) {
        this.endIndex = g;
        var v = this.getSlice(p, g);
        if (this.cbs.onprocessinginstruction) {
          var _ = this.getInstructionName(v);
          this.cbs.onprocessinginstruction("?".concat(_), "?".concat(v));
        }
        this.startIndex = g + 1;
      }, b.prototype.oncomment = function(p, g, v) {
        var _, x, T, E;
        this.endIndex = g, (x = (_ = this.cbs).oncomment) === null || x === void 0 || x.call(_, this.getSlice(p, g - v)), (E = (T = this.cbs).oncommentend) === null || E === void 0 || E.call(T), this.startIndex = g + 1;
      }, b.prototype.oncdata = function(p, g, v) {
        var _, x, T, E, U, D, L, j, C, k;
        this.endIndex = g;
        var I = this.getSlice(p, g - v);
        this.options.xmlMode || this.options.recognizeCDATA ? ((x = (_ = this.cbs).oncdatastart) === null || x === void 0 || x.call(_), (E = (T = this.cbs).ontext) === null || E === void 0 || E.call(T, I), (D = (U = this.cbs).oncdataend) === null || D === void 0 || D.call(U)) : ((j = (L = this.cbs).oncomment) === null || j === void 0 || j.call(L, "[CDATA[".concat(I, "]]")), (k = (C = this.cbs).oncommentend) === null || k === void 0 || k.call(C)), this.startIndex = g + 1;
      }, b.prototype.onend = function() {
        var p, g;
        if (this.cbs.onclosetag) {
          this.endIndex = this.startIndex;
          for (var v = this.stack.length; v > 0; this.cbs.onclosetag(this.stack[--v], !0))
            ;
        }
        (g = (p = this.cbs).onend) === null || g === void 0 || g.call(p);
      }, b.prototype.reset = function() {
        var p, g, v, _;
        (g = (p = this.cbs).onreset) === null || g === void 0 || g.call(p), this.tokenizer.reset(), this.tagname = "", this.attribname = "", this.attribs = null, this.stack.length = 0, this.startIndex = 0, this.endIndex = 0, (_ = (v = this.cbs).onparserinit) === null || _ === void 0 || _.call(v, this), this.buffers.length = 0, this.bufferOffset = 0, this.writeIndex = 0, this.ended = !1;
      }, b.prototype.parseComplete = function(p) {
        this.reset(), this.end(p);
      }, b.prototype.getSlice = function(p, g) {
        for (; p - this.bufferOffset >= this.buffers[0].length; )
          this.shiftBuffer();
        for (var v = this.buffers[0].slice(p - this.bufferOffset, g - this.bufferOffset); g - this.bufferOffset > this.buffers[0].length; )
          this.shiftBuffer(), v += this.buffers[0].slice(0, g - this.bufferOffset);
        return v;
      }, b.prototype.shiftBuffer = function() {
        this.bufferOffset += this.buffers[0].length, this.writeIndex--, this.buffers.shift();
      }, b.prototype.write = function(p) {
        var g, v;
        if (this.ended) {
          (v = (g = this.cbs).onerror) === null || v === void 0 || v.call(g, new Error(".write() after done!"));
          return;
        }
        this.buffers.push(p), this.tokenizer.running && (this.tokenizer.write(p), this.writeIndex++);
      }, b.prototype.end = function(p) {
        var g, v;
        if (this.ended) {
          (v = (g = this.cbs).onerror) === null || v === void 0 || v.call(g, new Error(".end() after done!"));
          return;
        }
        p && this.write(p), this.ended = !0, this.tokenizer.end();
      }, b.prototype.pause = function() {
        this.tokenizer.pause();
      }, b.prototype.resume = function() {
        for (this.tokenizer.resume(); this.tokenizer.running && this.writeIndex < this.buffers.length; )
          this.tokenizer.write(this.buffers[this.writeIndex++]);
        this.ended && this.tokenizer.end();
      }, b.prototype.parseChunk = function(p) {
        this.write(p);
      }, b.prototype.done = function(p) {
        this.end(p);
      }, b;
    })()
  );
  return Gn.Parser = m, Gn;
}
var mr = {}, bd = {}, ty;
function io() {
  return ty || (ty = 1, (function(n) {
    Object.defineProperty(n, "__esModule", { value: !0 }), n.Doctype = n.CDATA = n.Tag = n.Style = n.Script = n.Comment = n.Directive = n.Text = n.Root = n.isTag = n.ElementType = void 0;
    var e;
    (function(i) {
      i.Root = "root", i.Text = "text", i.Directive = "directive", i.Comment = "comment", i.Script = "script", i.Style = "style", i.Tag = "tag", i.CDATA = "cdata", i.Doctype = "doctype";
    })(e = n.ElementType || (n.ElementType = {}));
    function t(i) {
      return i.type === e.Tag || i.type === e.Script || i.type === e.Style;
    }
    n.isTag = t, n.Root = e.Root, n.Text = e.Text, n.Directive = e.Directive, n.Comment = e.Comment, n.Script = e.Script, n.Style = e.Style, n.Tag = e.Tag, n.CDATA = e.CDATA, n.Doctype = e.Doctype;
  })(bd)), bd;
}
var it = {}, ny;
function iy() {
  if (ny) return it;
  ny = 1;
  var n = it && it.__extends || /* @__PURE__ */ (function() {
    var x = function(T, E) {
      return x = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(U, D) {
        U.__proto__ = D;
      } || function(U, D) {
        for (var L in D) Object.prototype.hasOwnProperty.call(D, L) && (U[L] = D[L]);
      }, x(T, E);
    };
    return function(T, E) {
      if (typeof E != "function" && E !== null)
        throw new TypeError("Class extends value " + String(E) + " is not a constructor or null");
      x(T, E);
      function U() {
        this.constructor = T;
      }
      T.prototype = E === null ? Object.create(E) : (U.prototype = E.prototype, new U());
    };
  })(), e = it && it.__assign || function() {
    return e = Object.assign || function(x) {
      for (var T, E = 1, U = arguments.length; E < U; E++) {
        T = arguments[E];
        for (var D in T) Object.prototype.hasOwnProperty.call(T, D) && (x[D] = T[D]);
      }
      return x;
    }, e.apply(this, arguments);
  };
  Object.defineProperty(it, "__esModule", { value: !0 }), it.cloneNode = it.hasChildren = it.isDocument = it.isDirective = it.isComment = it.isText = it.isCDATA = it.isTag = it.Element = it.Document = it.CDATA = it.NodeWithChildren = it.ProcessingInstruction = it.Comment = it.Text = it.DataNode = it.Node = void 0;
  var t = /* @__PURE__ */ io(), i = (
    /** @class */
    (function() {
      function x() {
        this.parent = null, this.prev = null, this.next = null, this.startIndex = null, this.endIndex = null;
      }
      return Object.defineProperty(x.prototype, "parentNode", {
        // Read-write aliases for properties
        /**
         * Same as {@link parent}.
         * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
         */
        get: function() {
          return this.parent;
        },
        set: function(T) {
          this.parent = T;
        },
        enumerable: !1,
        configurable: !0
      }), Object.defineProperty(x.prototype, "previousSibling", {
        /**
         * Same as {@link prev}.
         * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
         */
        get: function() {
          return this.prev;
        },
        set: function(T) {
          this.prev = T;
        },
        enumerable: !1,
        configurable: !0
      }), Object.defineProperty(x.prototype, "nextSibling", {
        /**
         * Same as {@link next}.
         * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
         */
        get: function() {
          return this.next;
        },
        set: function(T) {
          this.next = T;
        },
        enumerable: !1,
        configurable: !0
      }), x.prototype.cloneNode = function(T) {
        return T === void 0 && (T = !1), v(this, T);
      }, x;
    })()
  );
  it.Node = i;
  var r = (
    /** @class */
    (function(x) {
      n(T, x);
      function T(E) {
        var U = x.call(this) || this;
        return U.data = E, U;
      }
      return Object.defineProperty(T.prototype, "nodeValue", {
        /**
         * Same as {@link data}.
         * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
         */
        get: function() {
          return this.data;
        },
        set: function(E) {
          this.data = E;
        },
        enumerable: !1,
        configurable: !0
      }), T;
    })(i)
  );
  it.DataNode = r;
  var a = (
    /** @class */
    (function(x) {
      n(T, x);
      function T() {
        var E = x !== null && x.apply(this, arguments) || this;
        return E.type = t.ElementType.Text, E;
      }
      return Object.defineProperty(T.prototype, "nodeType", {
        get: function() {
          return 3;
        },
        enumerable: !1,
        configurable: !0
      }), T;
    })(r)
  );
  it.Text = a;
  var s = (
    /** @class */
    (function(x) {
      n(T, x);
      function T() {
        var E = x !== null && x.apply(this, arguments) || this;
        return E.type = t.ElementType.Comment, E;
      }
      return Object.defineProperty(T.prototype, "nodeType", {
        get: function() {
          return 8;
        },
        enumerable: !1,
        configurable: !0
      }), T;
    })(r)
  );
  it.Comment = s;
  var o = (
    /** @class */
    (function(x) {
      n(T, x);
      function T(E, U) {
        var D = x.call(this, U) || this;
        return D.name = E, D.type = t.ElementType.Directive, D;
      }
      return Object.defineProperty(T.prototype, "nodeType", {
        get: function() {
          return 1;
        },
        enumerable: !1,
        configurable: !0
      }), T;
    })(r)
  );
  it.ProcessingInstruction = o;
  var u = (
    /** @class */
    (function(x) {
      n(T, x);
      function T(E) {
        var U = x.call(this) || this;
        return U.children = E, U;
      }
      return Object.defineProperty(T.prototype, "firstChild", {
        // Aliases
        /** First child of the node. */
        get: function() {
          var E;
          return (E = this.children[0]) !== null && E !== void 0 ? E : null;
        },
        enumerable: !1,
        configurable: !0
      }), Object.defineProperty(T.prototype, "lastChild", {
        /** Last child of the node. */
        get: function() {
          return this.children.length > 0 ? this.children[this.children.length - 1] : null;
        },
        enumerable: !1,
        configurable: !0
      }), Object.defineProperty(T.prototype, "childNodes", {
        /**
         * Same as {@link children}.
         * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
         */
        get: function() {
          return this.children;
        },
        set: function(E) {
          this.children = E;
        },
        enumerable: !1,
        configurable: !0
      }), T;
    })(i)
  );
  it.NodeWithChildren = u;
  var c = (
    /** @class */
    (function(x) {
      n(T, x);
      function T() {
        var E = x !== null && x.apply(this, arguments) || this;
        return E.type = t.ElementType.CDATA, E;
      }
      return Object.defineProperty(T.prototype, "nodeType", {
        get: function() {
          return 4;
        },
        enumerable: !1,
        configurable: !0
      }), T;
    })(u)
  );
  it.CDATA = c;
  var l = (
    /** @class */
    (function(x) {
      n(T, x);
      function T() {
        var E = x !== null && x.apply(this, arguments) || this;
        return E.type = t.ElementType.Root, E;
      }
      return Object.defineProperty(T.prototype, "nodeType", {
        get: function() {
          return 9;
        },
        enumerable: !1,
        configurable: !0
      }), T;
    })(u)
  );
  it.Document = l;
  var h = (
    /** @class */
    (function(x) {
      n(T, x);
      function T(E, U, D, L) {
        D === void 0 && (D = []), L === void 0 && (L = E === "script" ? t.ElementType.Script : E === "style" ? t.ElementType.Style : t.ElementType.Tag);
        var j = x.call(this, D) || this;
        return j.name = E, j.attribs = U, j.type = L, j;
      }
      return Object.defineProperty(T.prototype, "nodeType", {
        get: function() {
          return 1;
        },
        enumerable: !1,
        configurable: !0
      }), Object.defineProperty(T.prototype, "tagName", {
        // DOM Level 1 aliases
        /**
         * Same as {@link name}.
         * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
         */
        get: function() {
          return this.name;
        },
        set: function(E) {
          this.name = E;
        },
        enumerable: !1,
        configurable: !0
      }), Object.defineProperty(T.prototype, "attributes", {
        get: function() {
          var E = this;
          return Object.keys(this.attribs).map(function(U) {
            var D, L;
            return {
              name: U,
              value: E.attribs[U],
              namespace: (D = E["x-attribsNamespace"]) === null || D === void 0 ? void 0 : D[U],
              prefix: (L = E["x-attribsPrefix"]) === null || L === void 0 ? void 0 : L[U]
            };
          });
        },
        enumerable: !1,
        configurable: !0
      }), T;
    })(u)
  );
  it.Element = h;
  function f(x) {
    return (0, t.isTag)(x);
  }
  it.isTag = f;
  function d(x) {
    return x.type === t.ElementType.CDATA;
  }
  it.isCDATA = d;
  function y(x) {
    return x.type === t.ElementType.Text;
  }
  it.isText = y;
  function m(x) {
    return x.type === t.ElementType.Comment;
  }
  it.isComment = m;
  function b(x) {
    return x.type === t.ElementType.Directive;
  }
  it.isDirective = b;
  function p(x) {
    return x.type === t.ElementType.Root;
  }
  it.isDocument = p;
  function g(x) {
    return Object.prototype.hasOwnProperty.call(x, "children");
  }
  it.hasChildren = g;
  function v(x, T) {
    T === void 0 && (T = !1);
    var E;
    if (y(x))
      E = new a(x.data);
    else if (m(x))
      E = new s(x.data);
    else if (f(x)) {
      var U = T ? _(x.children) : [], D = new h(x.name, e({}, x.attribs), U);
      U.forEach(function(k) {
        return k.parent = D;
      }), x.namespace != null && (D.namespace = x.namespace), x["x-attribsNamespace"] && (D["x-attribsNamespace"] = e({}, x["x-attribsNamespace"])), x["x-attribsPrefix"] && (D["x-attribsPrefix"] = e({}, x["x-attribsPrefix"])), E = D;
    } else if (d(x)) {
      var U = T ? _(x.children) : [], L = new c(U);
      U.forEach(function(I) {
        return I.parent = L;
      }), E = L;
    } else if (p(x)) {
      var U = T ? _(x.children) : [], j = new l(U);
      U.forEach(function(I) {
        return I.parent = j;
      }), x["x-mode"] && (j["x-mode"] = x["x-mode"]), E = j;
    } else if (b(x)) {
      var C = new o(x.name, x.data);
      x["x-name"] != null && (C["x-name"] = x["x-name"], C["x-publicId"] = x["x-publicId"], C["x-systemId"] = x["x-systemId"]), E = C;
    } else
      throw new Error("Not implemented yet: ".concat(x.type));
    return E.startIndex = x.startIndex, E.endIndex = x.endIndex, x.sourceCodeLocation != null && (E.sourceCodeLocation = x.sourceCodeLocation), E;
  }
  it.cloneNode = v;
  function _(x) {
    for (var T = x.map(function(U) {
      return v(U, !0);
    }), E = 1; E < T.length; E++)
      T[E].prev = T[E - 1], T[E - 1].next = T[E];
    return T;
  }
  return it;
}
var ry;
function Zi() {
  return ry || (ry = 1, (function(n) {
    var e = mr && mr.__createBinding || (Object.create ? (function(o, u, c, l) {
      l === void 0 && (l = c);
      var h = Object.getOwnPropertyDescriptor(u, c);
      (!h || ("get" in h ? !u.__esModule : h.writable || h.configurable)) && (h = { enumerable: !0, get: function() {
        return u[c];
      } }), Object.defineProperty(o, l, h);
    }) : (function(o, u, c, l) {
      l === void 0 && (l = c), o[l] = u[c];
    })), t = mr && mr.__exportStar || function(o, u) {
      for (var c in o) c !== "default" && !Object.prototype.hasOwnProperty.call(u, c) && e(u, o, c);
    };
    Object.defineProperty(n, "__esModule", { value: !0 }), n.DomHandler = void 0;
    var i = /* @__PURE__ */ io(), r = /* @__PURE__ */ iy();
    t(/* @__PURE__ */ iy(), n);
    var a = {
      withStartIndices: !1,
      withEndIndices: !1,
      xmlMode: !1
    }, s = (
      /** @class */
      (function() {
        function o(u, c, l) {
          this.dom = [], this.root = new r.Document(this.dom), this.done = !1, this.tagStack = [this.root], this.lastNode = null, this.parser = null, typeof c == "function" && (l = c, c = a), typeof u == "object" && (c = u, u = void 0), this.callback = u ?? null, this.options = c ?? a, this.elementCB = l ?? null;
        }
        return o.prototype.onparserinit = function(u) {
          this.parser = u;
        }, o.prototype.onreset = function() {
          this.dom = [], this.root = new r.Document(this.dom), this.done = !1, this.tagStack = [this.root], this.lastNode = null, this.parser = null;
        }, o.prototype.onend = function() {
          this.done || (this.done = !0, this.parser = null, this.handleCallback(null));
        }, o.prototype.onerror = function(u) {
          this.handleCallback(u);
        }, o.prototype.onclosetag = function() {
          this.lastNode = null;
          var u = this.tagStack.pop();
          this.options.withEndIndices && (u.endIndex = this.parser.endIndex), this.elementCB && this.elementCB(u);
        }, o.prototype.onopentag = function(u, c) {
          var l = this.options.xmlMode ? i.ElementType.Tag : void 0, h = new r.Element(u, c, void 0, l);
          this.addNode(h), this.tagStack.push(h);
        }, o.prototype.ontext = function(u) {
          var c = this.lastNode;
          if (c && c.type === i.ElementType.Text)
            c.data += u, this.options.withEndIndices && (c.endIndex = this.parser.endIndex);
          else {
            var l = new r.Text(u);
            this.addNode(l), this.lastNode = l;
          }
        }, o.prototype.oncomment = function(u) {
          if (this.lastNode && this.lastNode.type === i.ElementType.Comment) {
            this.lastNode.data += u;
            return;
          }
          var c = new r.Comment(u);
          this.addNode(c), this.lastNode = c;
        }, o.prototype.oncommentend = function() {
          this.lastNode = null;
        }, o.prototype.oncdatastart = function() {
          var u = new r.Text(""), c = new r.CDATA([u]);
          this.addNode(c), u.parent = c, this.lastNode = u;
        }, o.prototype.oncdataend = function() {
          this.lastNode = null;
        }, o.prototype.onprocessinginstruction = function(u, c) {
          var l = new r.ProcessingInstruction(u, c);
          this.addNode(l);
        }, o.prototype.handleCallback = function(u) {
          if (typeof this.callback == "function")
            this.callback(u, this.dom);
          else if (u)
            throw u;
        }, o.prototype.addNode = function(u) {
          var c = this.tagStack[this.tagStack.length - 1], l = c.children[c.children.length - 1];
          this.options.withStartIndices && (u.startIndex = this.parser.startIndex), this.options.withEndIndices && (u.endIndex = this.parser.endIndex), c.children.push(u), l && (u.prev = l, l.next = u), u.parent = c, this.lastNode = null;
        }, o;
      })()
    );
    n.DomHandler = s, n.default = s;
  })(mr)), mr;
}
var gr = {}, tn = {}, dn = {}, yd = {}, Di = {}, Xo = {}, ay;
function Z8() {
  if (ay) return Xo;
  ay = 1, Object.defineProperty(Xo, "__esModule", { value: !0 });
  function n(e) {
    for (var t = 1; t < e.length; t++)
      e[t][0] += e[t - 1][0] + 1;
    return e;
  }
  return Xo.default = new Map(/* @__PURE__ */ n([[9, "&Tab;"], [0, "&NewLine;"], [22, "&excl;"], [0, "&quot;"], [0, "&num;"], [0, "&dollar;"], [0, "&percnt;"], [0, "&amp;"], [0, "&apos;"], [0, "&lpar;"], [0, "&rpar;"], [0, "&ast;"], [0, "&plus;"], [0, "&comma;"], [1, "&period;"], [0, "&sol;"], [10, "&colon;"], [0, "&semi;"], [0, { v: "&lt;", n: 8402, o: "&nvlt;" }], [0, { v: "&equals;", n: 8421, o: "&bne;" }], [0, { v: "&gt;", n: 8402, o: "&nvgt;" }], [0, "&quest;"], [0, "&commat;"], [26, "&lbrack;"], [0, "&bsol;"], [0, "&rbrack;"], [0, "&Hat;"], [0, "&lowbar;"], [0, "&DiacriticalGrave;"], [5, { n: 106, o: "&fjlig;" }], [20, "&lbrace;"], [0, "&verbar;"], [0, "&rbrace;"], [34, "&nbsp;"], [0, "&iexcl;"], [0, "&cent;"], [0, "&pound;"], [0, "&curren;"], [0, "&yen;"], [0, "&brvbar;"], [0, "&sect;"], [0, "&die;"], [0, "&copy;"], [0, "&ordf;"], [0, "&laquo;"], [0, "&not;"], [0, "&shy;"], [0, "&circledR;"], [0, "&macr;"], [0, "&deg;"], [0, "&PlusMinus;"], [0, "&sup2;"], [0, "&sup3;"], [0, "&acute;"], [0, "&micro;"], [0, "&para;"], [0, "&centerdot;"], [0, "&cedil;"], [0, "&sup1;"], [0, "&ordm;"], [0, "&raquo;"], [0, "&frac14;"], [0, "&frac12;"], [0, "&frac34;"], [0, "&iquest;"], [0, "&Agrave;"], [0, "&Aacute;"], [0, "&Acirc;"], [0, "&Atilde;"], [0, "&Auml;"], [0, "&angst;"], [0, "&AElig;"], [0, "&Ccedil;"], [0, "&Egrave;"], [0, "&Eacute;"], [0, "&Ecirc;"], [0, "&Euml;"], [0, "&Igrave;"], [0, "&Iacute;"], [0, "&Icirc;"], [0, "&Iuml;"], [0, "&ETH;"], [0, "&Ntilde;"], [0, "&Ograve;"], [0, "&Oacute;"], [0, "&Ocirc;"], [0, "&Otilde;"], [0, "&Ouml;"], [0, "&times;"], [0, "&Oslash;"], [0, "&Ugrave;"], [0, "&Uacute;"], [0, "&Ucirc;"], [0, "&Uuml;"], [0, "&Yacute;"], [0, "&THORN;"], [0, "&szlig;"], [0, "&agrave;"], [0, "&aacute;"], [0, "&acirc;"], [0, "&atilde;"], [0, "&auml;"], [0, "&aring;"], [0, "&aelig;"], [0, "&ccedil;"], [0, "&egrave;"], [0, "&eacute;"], [0, "&ecirc;"], [0, "&euml;"], [0, "&igrave;"], [0, "&iacute;"], [0, "&icirc;"], [0, "&iuml;"], [0, "&eth;"], [0, "&ntilde;"], [0, "&ograve;"], [0, "&oacute;"], [0, "&ocirc;"], [0, "&otilde;"], [0, "&ouml;"], [0, "&div;"], [0, "&oslash;"], [0, "&ugrave;"], [0, "&uacute;"], [0, "&ucirc;"], [0, "&uuml;"], [0, "&yacute;"], [0, "&thorn;"], [0, "&yuml;"], [0, "&Amacr;"], [0, "&amacr;"], [0, "&Abreve;"], [0, "&abreve;"], [0, "&Aogon;"], [0, "&aogon;"], [0, "&Cacute;"], [0, "&cacute;"], [0, "&Ccirc;"], [0, "&ccirc;"], [0, "&Cdot;"], [0, "&cdot;"], [0, "&Ccaron;"], [0, "&ccaron;"], [0, "&Dcaron;"], [0, "&dcaron;"], [0, "&Dstrok;"], [0, "&dstrok;"], [0, "&Emacr;"], [0, "&emacr;"], [2, "&Edot;"], [0, "&edot;"], [0, "&Eogon;"], [0, "&eogon;"], [0, "&Ecaron;"], [0, "&ecaron;"], [0, "&Gcirc;"], [0, "&gcirc;"], [0, "&Gbreve;"], [0, "&gbreve;"], [0, "&Gdot;"], [0, "&gdot;"], [0, "&Gcedil;"], [1, "&Hcirc;"], [0, "&hcirc;"], [0, "&Hstrok;"], [0, "&hstrok;"], [0, "&Itilde;"], [0, "&itilde;"], [0, "&Imacr;"], [0, "&imacr;"], [2, "&Iogon;"], [0, "&iogon;"], [0, "&Idot;"], [0, "&imath;"], [0, "&IJlig;"], [0, "&ijlig;"], [0, "&Jcirc;"], [0, "&jcirc;"], [0, "&Kcedil;"], [0, "&kcedil;"], [0, "&kgreen;"], [0, "&Lacute;"], [0, "&lacute;"], [0, "&Lcedil;"], [0, "&lcedil;"], [0, "&Lcaron;"], [0, "&lcaron;"], [0, "&Lmidot;"], [0, "&lmidot;"], [0, "&Lstrok;"], [0, "&lstrok;"], [0, "&Nacute;"], [0, "&nacute;"], [0, "&Ncedil;"], [0, "&ncedil;"], [0, "&Ncaron;"], [0, "&ncaron;"], [0, "&napos;"], [0, "&ENG;"], [0, "&eng;"], [0, "&Omacr;"], [0, "&omacr;"], [2, "&Odblac;"], [0, "&odblac;"], [0, "&OElig;"], [0, "&oelig;"], [0, "&Racute;"], [0, "&racute;"], [0, "&Rcedil;"], [0, "&rcedil;"], [0, "&Rcaron;"], [0, "&rcaron;"], [0, "&Sacute;"], [0, "&sacute;"], [0, "&Scirc;"], [0, "&scirc;"], [0, "&Scedil;"], [0, "&scedil;"], [0, "&Scaron;"], [0, "&scaron;"], [0, "&Tcedil;"], [0, "&tcedil;"], [0, "&Tcaron;"], [0, "&tcaron;"], [0, "&Tstrok;"], [0, "&tstrok;"], [0, "&Utilde;"], [0, "&utilde;"], [0, "&Umacr;"], [0, "&umacr;"], [0, "&Ubreve;"], [0, "&ubreve;"], [0, "&Uring;"], [0, "&uring;"], [0, "&Udblac;"], [0, "&udblac;"], [0, "&Uogon;"], [0, "&uogon;"], [0, "&Wcirc;"], [0, "&wcirc;"], [0, "&Ycirc;"], [0, "&ycirc;"], [0, "&Yuml;"], [0, "&Zacute;"], [0, "&zacute;"], [0, "&Zdot;"], [0, "&zdot;"], [0, "&Zcaron;"], [0, "&zcaron;"], [19, "&fnof;"], [34, "&imped;"], [63, "&gacute;"], [65, "&jmath;"], [142, "&circ;"], [0, "&caron;"], [16, "&breve;"], [0, "&DiacriticalDot;"], [0, "&ring;"], [0, "&ogon;"], [0, "&DiacriticalTilde;"], [0, "&dblac;"], [51, "&DownBreve;"], [127, "&Alpha;"], [0, "&Beta;"], [0, "&Gamma;"], [0, "&Delta;"], [0, "&Epsilon;"], [0, "&Zeta;"], [0, "&Eta;"], [0, "&Theta;"], [0, "&Iota;"], [0, "&Kappa;"], [0, "&Lambda;"], [0, "&Mu;"], [0, "&Nu;"], [0, "&Xi;"], [0, "&Omicron;"], [0, "&Pi;"], [0, "&Rho;"], [1, "&Sigma;"], [0, "&Tau;"], [0, "&Upsilon;"], [0, "&Phi;"], [0, "&Chi;"], [0, "&Psi;"], [0, "&ohm;"], [7, "&alpha;"], [0, "&beta;"], [0, "&gamma;"], [0, "&delta;"], [0, "&epsi;"], [0, "&zeta;"], [0, "&eta;"], [0, "&theta;"], [0, "&iota;"], [0, "&kappa;"], [0, "&lambda;"], [0, "&mu;"], [0, "&nu;"], [0, "&xi;"], [0, "&omicron;"], [0, "&pi;"], [0, "&rho;"], [0, "&sigmaf;"], [0, "&sigma;"], [0, "&tau;"], [0, "&upsi;"], [0, "&phi;"], [0, "&chi;"], [0, "&psi;"], [0, "&omega;"], [7, "&thetasym;"], [0, "&Upsi;"], [2, "&phiv;"], [0, "&piv;"], [5, "&Gammad;"], [0, "&digamma;"], [18, "&kappav;"], [0, "&rhov;"], [3, "&epsiv;"], [0, "&backepsilon;"], [10, "&IOcy;"], [0, "&DJcy;"], [0, "&GJcy;"], [0, "&Jukcy;"], [0, "&DScy;"], [0, "&Iukcy;"], [0, "&YIcy;"], [0, "&Jsercy;"], [0, "&LJcy;"], [0, "&NJcy;"], [0, "&TSHcy;"], [0, "&KJcy;"], [1, "&Ubrcy;"], [0, "&DZcy;"], [0, "&Acy;"], [0, "&Bcy;"], [0, "&Vcy;"], [0, "&Gcy;"], [0, "&Dcy;"], [0, "&IEcy;"], [0, "&ZHcy;"], [0, "&Zcy;"], [0, "&Icy;"], [0, "&Jcy;"], [0, "&Kcy;"], [0, "&Lcy;"], [0, "&Mcy;"], [0, "&Ncy;"], [0, "&Ocy;"], [0, "&Pcy;"], [0, "&Rcy;"], [0, "&Scy;"], [0, "&Tcy;"], [0, "&Ucy;"], [0, "&Fcy;"], [0, "&KHcy;"], [0, "&TScy;"], [0, "&CHcy;"], [0, "&SHcy;"], [0, "&SHCHcy;"], [0, "&HARDcy;"], [0, "&Ycy;"], [0, "&SOFTcy;"], [0, "&Ecy;"], [0, "&YUcy;"], [0, "&YAcy;"], [0, "&acy;"], [0, "&bcy;"], [0, "&vcy;"], [0, "&gcy;"], [0, "&dcy;"], [0, "&iecy;"], [0, "&zhcy;"], [0, "&zcy;"], [0, "&icy;"], [0, "&jcy;"], [0, "&kcy;"], [0, "&lcy;"], [0, "&mcy;"], [0, "&ncy;"], [0, "&ocy;"], [0, "&pcy;"], [0, "&rcy;"], [0, "&scy;"], [0, "&tcy;"], [0, "&ucy;"], [0, "&fcy;"], [0, "&khcy;"], [0, "&tscy;"], [0, "&chcy;"], [0, "&shcy;"], [0, "&shchcy;"], [0, "&hardcy;"], [0, "&ycy;"], [0, "&softcy;"], [0, "&ecy;"], [0, "&yucy;"], [0, "&yacy;"], [1, "&iocy;"], [0, "&djcy;"], [0, "&gjcy;"], [0, "&jukcy;"], [0, "&dscy;"], [0, "&iukcy;"], [0, "&yicy;"], [0, "&jsercy;"], [0, "&ljcy;"], [0, "&njcy;"], [0, "&tshcy;"], [0, "&kjcy;"], [1, "&ubrcy;"], [0, "&dzcy;"], [7074, "&ensp;"], [0, "&emsp;"], [0, "&emsp13;"], [0, "&emsp14;"], [1, "&numsp;"], [0, "&puncsp;"], [0, "&ThinSpace;"], [0, "&hairsp;"], [0, "&NegativeMediumSpace;"], [0, "&zwnj;"], [0, "&zwj;"], [0, "&lrm;"], [0, "&rlm;"], [0, "&dash;"], [2, "&ndash;"], [0, "&mdash;"], [0, "&horbar;"], [0, "&Verbar;"], [1, "&lsquo;"], [0, "&CloseCurlyQuote;"], [0, "&lsquor;"], [1, "&ldquo;"], [0, "&CloseCurlyDoubleQuote;"], [0, "&bdquo;"], [1, "&dagger;"], [0, "&Dagger;"], [0, "&bull;"], [2, "&nldr;"], [0, "&hellip;"], [9, "&permil;"], [0, "&pertenk;"], [0, "&prime;"], [0, "&Prime;"], [0, "&tprime;"], [0, "&backprime;"], [3, "&lsaquo;"], [0, "&rsaquo;"], [3, "&oline;"], [2, "&caret;"], [1, "&hybull;"], [0, "&frasl;"], [10, "&bsemi;"], [7, "&qprime;"], [7, { v: "&MediumSpace;", n: 8202, o: "&ThickSpace;" }], [0, "&NoBreak;"], [0, "&af;"], [0, "&InvisibleTimes;"], [0, "&ic;"], [72, "&euro;"], [46, "&tdot;"], [0, "&DotDot;"], [37, "&complexes;"], [2, "&incare;"], [4, "&gscr;"], [0, "&hamilt;"], [0, "&Hfr;"], [0, "&Hopf;"], [0, "&planckh;"], [0, "&hbar;"], [0, "&imagline;"], [0, "&Ifr;"], [0, "&lagran;"], [0, "&ell;"], [1, "&naturals;"], [0, "&numero;"], [0, "&copysr;"], [0, "&weierp;"], [0, "&Popf;"], [0, "&Qopf;"], [0, "&realine;"], [0, "&real;"], [0, "&reals;"], [0, "&rx;"], [3, "&trade;"], [1, "&integers;"], [2, "&mho;"], [0, "&zeetrf;"], [0, "&iiota;"], [2, "&bernou;"], [0, "&Cayleys;"], [1, "&escr;"], [0, "&Escr;"], [0, "&Fouriertrf;"], [1, "&Mellintrf;"], [0, "&order;"], [0, "&alefsym;"], [0, "&beth;"], [0, "&gimel;"], [0, "&daleth;"], [12, "&CapitalDifferentialD;"], [0, "&dd;"], [0, "&ee;"], [0, "&ii;"], [10, "&frac13;"], [0, "&frac23;"], [0, "&frac15;"], [0, "&frac25;"], [0, "&frac35;"], [0, "&frac45;"], [0, "&frac16;"], [0, "&frac56;"], [0, "&frac18;"], [0, "&frac38;"], [0, "&frac58;"], [0, "&frac78;"], [49, "&larr;"], [0, "&ShortUpArrow;"], [0, "&rarr;"], [0, "&darr;"], [0, "&harr;"], [0, "&updownarrow;"], [0, "&nwarr;"], [0, "&nearr;"], [0, "&LowerRightArrow;"], [0, "&LowerLeftArrow;"], [0, "&nlarr;"], [0, "&nrarr;"], [1, { v: "&rarrw;", n: 824, o: "&nrarrw;" }], [0, "&Larr;"], [0, "&Uarr;"], [0, "&Rarr;"], [0, "&Darr;"], [0, "&larrtl;"], [0, "&rarrtl;"], [0, "&LeftTeeArrow;"], [0, "&mapstoup;"], [0, "&map;"], [0, "&DownTeeArrow;"], [1, "&hookleftarrow;"], [0, "&hookrightarrow;"], [0, "&larrlp;"], [0, "&looparrowright;"], [0, "&harrw;"], [0, "&nharr;"], [1, "&lsh;"], [0, "&rsh;"], [0, "&ldsh;"], [0, "&rdsh;"], [1, "&crarr;"], [0, "&cularr;"], [0, "&curarr;"], [2, "&circlearrowleft;"], [0, "&circlearrowright;"], [0, "&leftharpoonup;"], [0, "&DownLeftVector;"], [0, "&RightUpVector;"], [0, "&LeftUpVector;"], [0, "&rharu;"], [0, "&DownRightVector;"], [0, "&dharr;"], [0, "&dharl;"], [0, "&RightArrowLeftArrow;"], [0, "&udarr;"], [0, "&LeftArrowRightArrow;"], [0, "&leftleftarrows;"], [0, "&upuparrows;"], [0, "&rightrightarrows;"], [0, "&ddarr;"], [0, "&leftrightharpoons;"], [0, "&Equilibrium;"], [0, "&nlArr;"], [0, "&nhArr;"], [0, "&nrArr;"], [0, "&DoubleLeftArrow;"], [0, "&DoubleUpArrow;"], [0, "&DoubleRightArrow;"], [0, "&dArr;"], [0, "&DoubleLeftRightArrow;"], [0, "&DoubleUpDownArrow;"], [0, "&nwArr;"], [0, "&neArr;"], [0, "&seArr;"], [0, "&swArr;"], [0, "&lAarr;"], [0, "&rAarr;"], [1, "&zigrarr;"], [6, "&larrb;"], [0, "&rarrb;"], [15, "&DownArrowUpArrow;"], [7, "&loarr;"], [0, "&roarr;"], [0, "&hoarr;"], [0, "&forall;"], [0, "&comp;"], [0, { v: "&part;", n: 824, o: "&npart;" }], [0, "&exist;"], [0, "&nexist;"], [0, "&empty;"], [1, "&Del;"], [0, "&Element;"], [0, "&NotElement;"], [1, "&ni;"], [0, "&notni;"], [2, "&prod;"], [0, "&coprod;"], [0, "&sum;"], [0, "&minus;"], [0, "&MinusPlus;"], [0, "&dotplus;"], [1, "&Backslash;"], [0, "&lowast;"], [0, "&compfn;"], [1, "&radic;"], [2, "&prop;"], [0, "&infin;"], [0, "&angrt;"], [0, { v: "&ang;", n: 8402, o: "&nang;" }], [0, "&angmsd;"], [0, "&angsph;"], [0, "&mid;"], [0, "&nmid;"], [0, "&DoubleVerticalBar;"], [0, "&NotDoubleVerticalBar;"], [0, "&and;"], [0, "&or;"], [0, { v: "&cap;", n: 65024, o: "&caps;" }], [0, { v: "&cup;", n: 65024, o: "&cups;" }], [0, "&int;"], [0, "&Int;"], [0, "&iiint;"], [0, "&conint;"], [0, "&Conint;"], [0, "&Cconint;"], [0, "&cwint;"], [0, "&ClockwiseContourIntegral;"], [0, "&awconint;"], [0, "&there4;"], [0, "&becaus;"], [0, "&ratio;"], [0, "&Colon;"], [0, "&dotminus;"], [1, "&mDDot;"], [0, "&homtht;"], [0, { v: "&sim;", n: 8402, o: "&nvsim;" }], [0, { v: "&backsim;", n: 817, o: "&race;" }], [0, { v: "&ac;", n: 819, o: "&acE;" }], [0, "&acd;"], [0, "&VerticalTilde;"], [0, "&NotTilde;"], [0, { v: "&eqsim;", n: 824, o: "&nesim;" }], [0, "&sime;"], [0, "&NotTildeEqual;"], [0, "&cong;"], [0, "&simne;"], [0, "&ncong;"], [0, "&ap;"], [0, "&nap;"], [0, "&ape;"], [0, { v: "&apid;", n: 824, o: "&napid;" }], [0, "&backcong;"], [0, { v: "&asympeq;", n: 8402, o: "&nvap;" }], [0, { v: "&bump;", n: 824, o: "&nbump;" }], [0, { v: "&bumpe;", n: 824, o: "&nbumpe;" }], [0, { v: "&doteq;", n: 824, o: "&nedot;" }], [0, "&doteqdot;"], [0, "&efDot;"], [0, "&erDot;"], [0, "&Assign;"], [0, "&ecolon;"], [0, "&ecir;"], [0, "&circeq;"], [1, "&wedgeq;"], [0, "&veeeq;"], [1, "&triangleq;"], [2, "&equest;"], [0, "&ne;"], [0, { v: "&Congruent;", n: 8421, o: "&bnequiv;" }], [0, "&nequiv;"], [1, { v: "&le;", n: 8402, o: "&nvle;" }], [0, { v: "&ge;", n: 8402, o: "&nvge;" }], [0, { v: "&lE;", n: 824, o: "&nlE;" }], [0, { v: "&gE;", n: 824, o: "&ngE;" }], [0, { v: "&lnE;", n: 65024, o: "&lvertneqq;" }], [0, { v: "&gnE;", n: 65024, o: "&gvertneqq;" }], [0, { v: "&ll;", n: new Map(/* @__PURE__ */ n([[824, "&nLtv;"], [7577, "&nLt;"]])) }], [0, { v: "&gg;", n: new Map(/* @__PURE__ */ n([[824, "&nGtv;"], [7577, "&nGt;"]])) }], [0, "&between;"], [0, "&NotCupCap;"], [0, "&nless;"], [0, "&ngt;"], [0, "&nle;"], [0, "&nge;"], [0, "&lesssim;"], [0, "&GreaterTilde;"], [0, "&nlsim;"], [0, "&ngsim;"], [0, "&LessGreater;"], [0, "&gl;"], [0, "&NotLessGreater;"], [0, "&NotGreaterLess;"], [0, "&pr;"], [0, "&sc;"], [0, "&prcue;"], [0, "&sccue;"], [0, "&PrecedesTilde;"], [0, { v: "&scsim;", n: 824, o: "&NotSucceedsTilde;" }], [0, "&NotPrecedes;"], [0, "&NotSucceeds;"], [0, { v: "&sub;", n: 8402, o: "&NotSubset;" }], [0, { v: "&sup;", n: 8402, o: "&NotSuperset;" }], [0, "&nsub;"], [0, "&nsup;"], [0, "&sube;"], [0, "&supe;"], [0, "&NotSubsetEqual;"], [0, "&NotSupersetEqual;"], [0, { v: "&subne;", n: 65024, o: "&varsubsetneq;" }], [0, { v: "&supne;", n: 65024, o: "&varsupsetneq;" }], [1, "&cupdot;"], [0, "&UnionPlus;"], [0, { v: "&sqsub;", n: 824, o: "&NotSquareSubset;" }], [0, { v: "&sqsup;", n: 824, o: "&NotSquareSuperset;" }], [0, "&sqsube;"], [0, "&sqsupe;"], [0, { v: "&sqcap;", n: 65024, o: "&sqcaps;" }], [0, { v: "&sqcup;", n: 65024, o: "&sqcups;" }], [0, "&CirclePlus;"], [0, "&CircleMinus;"], [0, "&CircleTimes;"], [0, "&osol;"], [0, "&CircleDot;"], [0, "&circledcirc;"], [0, "&circledast;"], [1, "&circleddash;"], [0, "&boxplus;"], [0, "&boxminus;"], [0, "&boxtimes;"], [0, "&dotsquare;"], [0, "&RightTee;"], [0, "&dashv;"], [0, "&DownTee;"], [0, "&bot;"], [1, "&models;"], [0, "&DoubleRightTee;"], [0, "&Vdash;"], [0, "&Vvdash;"], [0, "&VDash;"], [0, "&nvdash;"], [0, "&nvDash;"], [0, "&nVdash;"], [0, "&nVDash;"], [0, "&prurel;"], [1, "&LeftTriangle;"], [0, "&RightTriangle;"], [0, { v: "&LeftTriangleEqual;", n: 8402, o: "&nvltrie;" }], [0, { v: "&RightTriangleEqual;", n: 8402, o: "&nvrtrie;" }], [0, "&origof;"], [0, "&imof;"], [0, "&multimap;"], [0, "&hercon;"], [0, "&intcal;"], [0, "&veebar;"], [1, "&barvee;"], [0, "&angrtvb;"], [0, "&lrtri;"], [0, "&bigwedge;"], [0, "&bigvee;"], [0, "&bigcap;"], [0, "&bigcup;"], [0, "&diam;"], [0, "&sdot;"], [0, "&sstarf;"], [0, "&divideontimes;"], [0, "&bowtie;"], [0, "&ltimes;"], [0, "&rtimes;"], [0, "&leftthreetimes;"], [0, "&rightthreetimes;"], [0, "&backsimeq;"], [0, "&curlyvee;"], [0, "&curlywedge;"], [0, "&Sub;"], [0, "&Sup;"], [0, "&Cap;"], [0, "&Cup;"], [0, "&fork;"], [0, "&epar;"], [0, "&lessdot;"], [0, "&gtdot;"], [0, { v: "&Ll;", n: 824, o: "&nLl;" }], [0, { v: "&Gg;", n: 824, o: "&nGg;" }], [0, { v: "&leg;", n: 65024, o: "&lesg;" }], [0, { v: "&gel;", n: 65024, o: "&gesl;" }], [2, "&cuepr;"], [0, "&cuesc;"], [0, "&NotPrecedesSlantEqual;"], [0, "&NotSucceedsSlantEqual;"], [0, "&NotSquareSubsetEqual;"], [0, "&NotSquareSupersetEqual;"], [2, "&lnsim;"], [0, "&gnsim;"], [0, "&precnsim;"], [0, "&scnsim;"], [0, "&nltri;"], [0, "&NotRightTriangle;"], [0, "&nltrie;"], [0, "&NotRightTriangleEqual;"], [0, "&vellip;"], [0, "&ctdot;"], [0, "&utdot;"], [0, "&dtdot;"], [0, "&disin;"], [0, "&isinsv;"], [0, "&isins;"], [0, { v: "&isindot;", n: 824, o: "&notindot;" }], [0, "&notinvc;"], [0, "&notinvb;"], [1, { v: "&isinE;", n: 824, o: "&notinE;" }], [0, "&nisd;"], [0, "&xnis;"], [0, "&nis;"], [0, "&notnivc;"], [0, "&notnivb;"], [6, "&barwed;"], [0, "&Barwed;"], [1, "&lceil;"], [0, "&rceil;"], [0, "&LeftFloor;"], [0, "&rfloor;"], [0, "&drcrop;"], [0, "&dlcrop;"], [0, "&urcrop;"], [0, "&ulcrop;"], [0, "&bnot;"], [1, "&profline;"], [0, "&profsurf;"], [1, "&telrec;"], [0, "&target;"], [5, "&ulcorn;"], [0, "&urcorn;"], [0, "&dlcorn;"], [0, "&drcorn;"], [2, "&frown;"], [0, "&smile;"], [9, "&cylcty;"], [0, "&profalar;"], [7, "&topbot;"], [6, "&ovbar;"], [1, "&solbar;"], [60, "&angzarr;"], [51, "&lmoustache;"], [0, "&rmoustache;"], [2, "&OverBracket;"], [0, "&bbrk;"], [0, "&bbrktbrk;"], [37, "&OverParenthesis;"], [0, "&UnderParenthesis;"], [0, "&OverBrace;"], [0, "&UnderBrace;"], [2, "&trpezium;"], [4, "&elinters;"], [59, "&blank;"], [164, "&circledS;"], [55, "&boxh;"], [1, "&boxv;"], [9, "&boxdr;"], [3, "&boxdl;"], [3, "&boxur;"], [3, "&boxul;"], [3, "&boxvr;"], [7, "&boxvl;"], [7, "&boxhd;"], [7, "&boxhu;"], [7, "&boxvh;"], [19, "&boxH;"], [0, "&boxV;"], [0, "&boxdR;"], [0, "&boxDr;"], [0, "&boxDR;"], [0, "&boxdL;"], [0, "&boxDl;"], [0, "&boxDL;"], [0, "&boxuR;"], [0, "&boxUr;"], [0, "&boxUR;"], [0, "&boxuL;"], [0, "&boxUl;"], [0, "&boxUL;"], [0, "&boxvR;"], [0, "&boxVr;"], [0, "&boxVR;"], [0, "&boxvL;"], [0, "&boxVl;"], [0, "&boxVL;"], [0, "&boxHd;"], [0, "&boxhD;"], [0, "&boxHD;"], [0, "&boxHu;"], [0, "&boxhU;"], [0, "&boxHU;"], [0, "&boxvH;"], [0, "&boxVh;"], [0, "&boxVH;"], [19, "&uhblk;"], [3, "&lhblk;"], [3, "&block;"], [8, "&blk14;"], [0, "&blk12;"], [0, "&blk34;"], [13, "&square;"], [8, "&blacksquare;"], [0, "&EmptyVerySmallSquare;"], [1, "&rect;"], [0, "&marker;"], [2, "&fltns;"], [1, "&bigtriangleup;"], [0, "&blacktriangle;"], [0, "&triangle;"], [2, "&blacktriangleright;"], [0, "&rtri;"], [3, "&bigtriangledown;"], [0, "&blacktriangledown;"], [0, "&dtri;"], [2, "&blacktriangleleft;"], [0, "&ltri;"], [6, "&loz;"], [0, "&cir;"], [32, "&tridot;"], [2, "&bigcirc;"], [8, "&ultri;"], [0, "&urtri;"], [0, "&lltri;"], [0, "&EmptySmallSquare;"], [0, "&FilledSmallSquare;"], [8, "&bigstar;"], [0, "&star;"], [7, "&phone;"], [49, "&female;"], [1, "&male;"], [29, "&spades;"], [2, "&clubs;"], [1, "&hearts;"], [0, "&diamondsuit;"], [3, "&sung;"], [2, "&flat;"], [0, "&natural;"], [0, "&sharp;"], [163, "&check;"], [3, "&cross;"], [8, "&malt;"], [21, "&sext;"], [33, "&VerticalSeparator;"], [25, "&lbbrk;"], [0, "&rbbrk;"], [84, "&bsolhsub;"], [0, "&suphsol;"], [28, "&LeftDoubleBracket;"], [0, "&RightDoubleBracket;"], [0, "&lang;"], [0, "&rang;"], [0, "&Lang;"], [0, "&Rang;"], [0, "&loang;"], [0, "&roang;"], [7, "&longleftarrow;"], [0, "&longrightarrow;"], [0, "&longleftrightarrow;"], [0, "&DoubleLongLeftArrow;"], [0, "&DoubleLongRightArrow;"], [0, "&DoubleLongLeftRightArrow;"], [1, "&longmapsto;"], [2, "&dzigrarr;"], [258, "&nvlArr;"], [0, "&nvrArr;"], [0, "&nvHarr;"], [0, "&Map;"], [6, "&lbarr;"], [0, "&bkarow;"], [0, "&lBarr;"], [0, "&dbkarow;"], [0, "&drbkarow;"], [0, "&DDotrahd;"], [0, "&UpArrowBar;"], [0, "&DownArrowBar;"], [2, "&Rarrtl;"], [2, "&latail;"], [0, "&ratail;"], [0, "&lAtail;"], [0, "&rAtail;"], [0, "&larrfs;"], [0, "&rarrfs;"], [0, "&larrbfs;"], [0, "&rarrbfs;"], [2, "&nwarhk;"], [0, "&nearhk;"], [0, "&hksearow;"], [0, "&hkswarow;"], [0, "&nwnear;"], [0, "&nesear;"], [0, "&seswar;"], [0, "&swnwar;"], [8, { v: "&rarrc;", n: 824, o: "&nrarrc;" }], [1, "&cudarrr;"], [0, "&ldca;"], [0, "&rdca;"], [0, "&cudarrl;"], [0, "&larrpl;"], [2, "&curarrm;"], [0, "&cularrp;"], [7, "&rarrpl;"], [2, "&harrcir;"], [0, "&Uarrocir;"], [0, "&lurdshar;"], [0, "&ldrushar;"], [2, "&LeftRightVector;"], [0, "&RightUpDownVector;"], [0, "&DownLeftRightVector;"], [0, "&LeftUpDownVector;"], [0, "&LeftVectorBar;"], [0, "&RightVectorBar;"], [0, "&RightUpVectorBar;"], [0, "&RightDownVectorBar;"], [0, "&DownLeftVectorBar;"], [0, "&DownRightVectorBar;"], [0, "&LeftUpVectorBar;"], [0, "&LeftDownVectorBar;"], [0, "&LeftTeeVector;"], [0, "&RightTeeVector;"], [0, "&RightUpTeeVector;"], [0, "&RightDownTeeVector;"], [0, "&DownLeftTeeVector;"], [0, "&DownRightTeeVector;"], [0, "&LeftUpTeeVector;"], [0, "&LeftDownTeeVector;"], [0, "&lHar;"], [0, "&uHar;"], [0, "&rHar;"], [0, "&dHar;"], [0, "&luruhar;"], [0, "&ldrdhar;"], [0, "&ruluhar;"], [0, "&rdldhar;"], [0, "&lharul;"], [0, "&llhard;"], [0, "&rharul;"], [0, "&lrhard;"], [0, "&udhar;"], [0, "&duhar;"], [0, "&RoundImplies;"], [0, "&erarr;"], [0, "&simrarr;"], [0, "&larrsim;"], [0, "&rarrsim;"], [0, "&rarrap;"], [0, "&ltlarr;"], [1, "&gtrarr;"], [0, "&subrarr;"], [1, "&suplarr;"], [0, "&lfisht;"], [0, "&rfisht;"], [0, "&ufisht;"], [0, "&dfisht;"], [5, "&lopar;"], [0, "&ropar;"], [4, "&lbrke;"], [0, "&rbrke;"], [0, "&lbrkslu;"], [0, "&rbrksld;"], [0, "&lbrksld;"], [0, "&rbrkslu;"], [0, "&langd;"], [0, "&rangd;"], [0, "&lparlt;"], [0, "&rpargt;"], [0, "&gtlPar;"], [0, "&ltrPar;"], [3, "&vzigzag;"], [1, "&vangrt;"], [0, "&angrtvbd;"], [6, "&ange;"], [0, "&range;"], [0, "&dwangle;"], [0, "&uwangle;"], [0, "&angmsdaa;"], [0, "&angmsdab;"], [0, "&angmsdac;"], [0, "&angmsdad;"], [0, "&angmsdae;"], [0, "&angmsdaf;"], [0, "&angmsdag;"], [0, "&angmsdah;"], [0, "&bemptyv;"], [0, "&demptyv;"], [0, "&cemptyv;"], [0, "&raemptyv;"], [0, "&laemptyv;"], [0, "&ohbar;"], [0, "&omid;"], [0, "&opar;"], [1, "&operp;"], [1, "&olcross;"], [0, "&odsold;"], [1, "&olcir;"], [0, "&ofcir;"], [0, "&olt;"], [0, "&ogt;"], [0, "&cirscir;"], [0, "&cirE;"], [0, "&solb;"], [0, "&bsolb;"], [3, "&boxbox;"], [3, "&trisb;"], [0, "&rtriltri;"], [0, { v: "&LeftTriangleBar;", n: 824, o: "&NotLeftTriangleBar;" }], [0, { v: "&RightTriangleBar;", n: 824, o: "&NotRightTriangleBar;" }], [11, "&iinfin;"], [0, "&infintie;"], [0, "&nvinfin;"], [4, "&eparsl;"], [0, "&smeparsl;"], [0, "&eqvparsl;"], [5, "&blacklozenge;"], [8, "&RuleDelayed;"], [1, "&dsol;"], [9, "&bigodot;"], [0, "&bigoplus;"], [0, "&bigotimes;"], [1, "&biguplus;"], [1, "&bigsqcup;"], [5, "&iiiint;"], [0, "&fpartint;"], [2, "&cirfnint;"], [0, "&awint;"], [0, "&rppolint;"], [0, "&scpolint;"], [0, "&npolint;"], [0, "&pointint;"], [0, "&quatint;"], [0, "&intlarhk;"], [10, "&pluscir;"], [0, "&plusacir;"], [0, "&simplus;"], [0, "&plusdu;"], [0, "&plussim;"], [0, "&plustwo;"], [1, "&mcomma;"], [0, "&minusdu;"], [2, "&loplus;"], [0, "&roplus;"], [0, "&Cross;"], [0, "&timesd;"], [0, "&timesbar;"], [1, "&smashp;"], [0, "&lotimes;"], [0, "&rotimes;"], [0, "&otimesas;"], [0, "&Otimes;"], [0, "&odiv;"], [0, "&triplus;"], [0, "&triminus;"], [0, "&tritime;"], [0, "&intprod;"], [2, "&amalg;"], [0, "&capdot;"], [1, "&ncup;"], [0, "&ncap;"], [0, "&capand;"], [0, "&cupor;"], [0, "&cupcap;"], [0, "&capcup;"], [0, "&cupbrcap;"], [0, "&capbrcup;"], [0, "&cupcup;"], [0, "&capcap;"], [0, "&ccups;"], [0, "&ccaps;"], [2, "&ccupssm;"], [2, "&And;"], [0, "&Or;"], [0, "&andand;"], [0, "&oror;"], [0, "&orslope;"], [0, "&andslope;"], [1, "&andv;"], [0, "&orv;"], [0, "&andd;"], [0, "&ord;"], [1, "&wedbar;"], [6, "&sdote;"], [3, "&simdot;"], [2, { v: "&congdot;", n: 824, o: "&ncongdot;" }], [0, "&easter;"], [0, "&apacir;"], [0, { v: "&apE;", n: 824, o: "&napE;" }], [0, "&eplus;"], [0, "&pluse;"], [0, "&Esim;"], [0, "&Colone;"], [0, "&Equal;"], [1, "&ddotseq;"], [0, "&equivDD;"], [0, "&ltcir;"], [0, "&gtcir;"], [0, "&ltquest;"], [0, "&gtquest;"], [0, { v: "&leqslant;", n: 824, o: "&nleqslant;" }], [0, { v: "&geqslant;", n: 824, o: "&ngeqslant;" }], [0, "&lesdot;"], [0, "&gesdot;"], [0, "&lesdoto;"], [0, "&gesdoto;"], [0, "&lesdotor;"], [0, "&gesdotol;"], [0, "&lap;"], [0, "&gap;"], [0, "&lne;"], [0, "&gne;"], [0, "&lnap;"], [0, "&gnap;"], [0, "&lEg;"], [0, "&gEl;"], [0, "&lsime;"], [0, "&gsime;"], [0, "&lsimg;"], [0, "&gsiml;"], [0, "&lgE;"], [0, "&glE;"], [0, "&lesges;"], [0, "&gesles;"], [0, "&els;"], [0, "&egs;"], [0, "&elsdot;"], [0, "&egsdot;"], [0, "&el;"], [0, "&eg;"], [2, "&siml;"], [0, "&simg;"], [0, "&simlE;"], [0, "&simgE;"], [0, { v: "&LessLess;", n: 824, o: "&NotNestedLessLess;" }], [0, { v: "&GreaterGreater;", n: 824, o: "&NotNestedGreaterGreater;" }], [1, "&glj;"], [0, "&gla;"], [0, "&ltcc;"], [0, "&gtcc;"], [0, "&lescc;"], [0, "&gescc;"], [0, "&smt;"], [0, "&lat;"], [0, { v: "&smte;", n: 65024, o: "&smtes;" }], [0, { v: "&late;", n: 65024, o: "&lates;" }], [0, "&bumpE;"], [0, { v: "&PrecedesEqual;", n: 824, o: "&NotPrecedesEqual;" }], [0, { v: "&sce;", n: 824, o: "&NotSucceedsEqual;" }], [2, "&prE;"], [0, "&scE;"], [0, "&precneqq;"], [0, "&scnE;"], [0, "&prap;"], [0, "&scap;"], [0, "&precnapprox;"], [0, "&scnap;"], [0, "&Pr;"], [0, "&Sc;"], [0, "&subdot;"], [0, "&supdot;"], [0, "&subplus;"], [0, "&supplus;"], [0, "&submult;"], [0, "&supmult;"], [0, "&subedot;"], [0, "&supedot;"], [0, { v: "&subE;", n: 824, o: "&nsubE;" }], [0, { v: "&supE;", n: 824, o: "&nsupE;" }], [0, "&subsim;"], [0, "&supsim;"], [2, { v: "&subnE;", n: 65024, o: "&varsubsetneqq;" }], [0, { v: "&supnE;", n: 65024, o: "&varsupsetneqq;" }], [2, "&csub;"], [0, "&csup;"], [0, "&csube;"], [0, "&csupe;"], [0, "&subsup;"], [0, "&supsub;"], [0, "&subsub;"], [0, "&supsup;"], [0, "&suphsub;"], [0, "&supdsub;"], [0, "&forkv;"], [0, "&topfork;"], [0, "&mlcp;"], [8, "&Dashv;"], [1, "&Vdashl;"], [0, "&Barv;"], [0, "&vBar;"], [0, "&vBarv;"], [1, "&Vbar;"], [0, "&Not;"], [0, "&bNot;"], [0, "&rnmid;"], [0, "&cirmid;"], [0, "&midcir;"], [0, "&topcir;"], [0, "&nhpar;"], [0, "&parsim;"], [9, { v: "&parsl;", n: 8421, o: "&nparsl;" }], [44343, { n: new Map(/* @__PURE__ */ n([[56476, "&Ascr;"], [1, "&Cscr;"], [0, "&Dscr;"], [2, "&Gscr;"], [2, "&Jscr;"], [0, "&Kscr;"], [2, "&Nscr;"], [0, "&Oscr;"], [0, "&Pscr;"], [0, "&Qscr;"], [1, "&Sscr;"], [0, "&Tscr;"], [0, "&Uscr;"], [0, "&Vscr;"], [0, "&Wscr;"], [0, "&Xscr;"], [0, "&Yscr;"], [0, "&Zscr;"], [0, "&ascr;"], [0, "&bscr;"], [0, "&cscr;"], [0, "&dscr;"], [1, "&fscr;"], [1, "&hscr;"], [0, "&iscr;"], [0, "&jscr;"], [0, "&kscr;"], [0, "&lscr;"], [0, "&mscr;"], [0, "&nscr;"], [1, "&pscr;"], [0, "&qscr;"], [0, "&rscr;"], [0, "&sscr;"], [0, "&tscr;"], [0, "&uscr;"], [0, "&vscr;"], [0, "&wscr;"], [0, "&xscr;"], [0, "&yscr;"], [0, "&zscr;"], [52, "&Afr;"], [0, "&Bfr;"], [1, "&Dfr;"], [0, "&Efr;"], [0, "&Ffr;"], [0, "&Gfr;"], [2, "&Jfr;"], [0, "&Kfr;"], [0, "&Lfr;"], [0, "&Mfr;"], [0, "&Nfr;"], [0, "&Ofr;"], [0, "&Pfr;"], [0, "&Qfr;"], [1, "&Sfr;"], [0, "&Tfr;"], [0, "&Ufr;"], [0, "&Vfr;"], [0, "&Wfr;"], [0, "&Xfr;"], [0, "&Yfr;"], [1, "&afr;"], [0, "&bfr;"], [0, "&cfr;"], [0, "&dfr;"], [0, "&efr;"], [0, "&ffr;"], [0, "&gfr;"], [0, "&hfr;"], [0, "&ifr;"], [0, "&jfr;"], [0, "&kfr;"], [0, "&lfr;"], [0, "&mfr;"], [0, "&nfr;"], [0, "&ofr;"], [0, "&pfr;"], [0, "&qfr;"], [0, "&rfr;"], [0, "&sfr;"], [0, "&tfr;"], [0, "&ufr;"], [0, "&vfr;"], [0, "&wfr;"], [0, "&xfr;"], [0, "&yfr;"], [0, "&zfr;"], [0, "&Aopf;"], [0, "&Bopf;"], [1, "&Dopf;"], [0, "&Eopf;"], [0, "&Fopf;"], [0, "&Gopf;"], [1, "&Iopf;"], [0, "&Jopf;"], [0, "&Kopf;"], [0, "&Lopf;"], [0, "&Mopf;"], [1, "&Oopf;"], [3, "&Sopf;"], [0, "&Topf;"], [0, "&Uopf;"], [0, "&Vopf;"], [0, "&Wopf;"], [0, "&Xopf;"], [0, "&Yopf;"], [1, "&aopf;"], [0, "&bopf;"], [0, "&copf;"], [0, "&dopf;"], [0, "&eopf;"], [0, "&fopf;"], [0, "&gopf;"], [0, "&hopf;"], [0, "&iopf;"], [0, "&jopf;"], [0, "&kopf;"], [0, "&lopf;"], [0, "&mopf;"], [0, "&nopf;"], [0, "&oopf;"], [0, "&popf;"], [0, "&qopf;"], [0, "&ropf;"], [0, "&sopf;"], [0, "&topf;"], [0, "&uopf;"], [0, "&vopf;"], [0, "&wopf;"], [0, "&xopf;"], [0, "&yopf;"], [0, "&zopf;"]])) }], [8906, "&fflig;"], [0, "&filig;"], [0, "&fllig;"], [0, "&ffilig;"], [0, "&ffllig;"]])), Xo;
}
var vd = {}, sy;
function Yp() {
  return sy || (sy = 1, (function(n) {
    Object.defineProperty(n, "__esModule", { value: !0 }), n.escapeText = n.escapeAttribute = n.escapeUTF8 = n.escape = n.encodeXML = n.getCodePoint = n.xmlReplacer = void 0, n.xmlReplacer = /["&'<>$\x80-\uFFFF]/g;
    var e = /* @__PURE__ */ new Map([
      [34, "&quot;"],
      [38, "&amp;"],
      [39, "&apos;"],
      [60, "&lt;"],
      [62, "&gt;"]
    ]);
    n.getCodePoint = // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
    String.prototype.codePointAt != null ? function(r, a) {
      return r.codePointAt(a);
    } : (
      // http://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae
      function(r, a) {
        return (r.charCodeAt(a) & 64512) === 55296 ? (r.charCodeAt(a) - 55296) * 1024 + r.charCodeAt(a + 1) - 56320 + 65536 : r.charCodeAt(a);
      }
    );
    function t(r) {
      for (var a = "", s = 0, o; (o = n.xmlReplacer.exec(r)) !== null; ) {
        var u = o.index, c = r.charCodeAt(u), l = e.get(c);
        l !== void 0 ? (a += r.substring(s, u) + l, s = u + 1) : (a += "".concat(r.substring(s, u), "&#x").concat((0, n.getCodePoint)(r, u).toString(16), ";"), s = n.xmlReplacer.lastIndex += +((c & 64512) === 55296));
      }
      return a + r.substr(s);
    }
    n.encodeXML = t, n.escape = t;
    function i(r, a) {
      return function(o) {
        for (var u, c = 0, l = ""; u = r.exec(o); )
          c !== u.index && (l += o.substring(c, u.index)), l += a.get(u[0].charCodeAt(0)), c = u.index + 1;
        return l + o.substring(c);
      };
    }
    n.escapeUTF8 = i(/[&<>'"]/g, e), n.escapeAttribute = i(/["&\u00A0]/g, /* @__PURE__ */ new Map([
      [34, "&quot;"],
      [38, "&amp;"],
      [160, "&nbsp;"]
    ])), n.escapeText = i(/[&<>\u00A0]/g, /* @__PURE__ */ new Map([
      [38, "&amp;"],
      [60, "&lt;"],
      [62, "&gt;"],
      [160, "&nbsp;"]
    ]));
  })(vd)), vd;
}
var oy;
function uy() {
  if (oy) return Di;
  oy = 1;
  var n = Di && Di.__importDefault || function(o) {
    return o && o.__esModule ? o : { default: o };
  };
  Object.defineProperty(Di, "__esModule", { value: !0 }), Di.encodeNonAsciiHTML = Di.encodeHTML = void 0;
  var e = n(/* @__PURE__ */ Z8()), t = /* @__PURE__ */ Yp(), i = /[\t\n!-,./:-@[-`\f{-}$\x80-\uFFFF]/g;
  function r(o) {
    return s(i, o);
  }
  Di.encodeHTML = r;
  function a(o) {
    return s(t.xmlReplacer, o);
  }
  Di.encodeNonAsciiHTML = a;
  function s(o, u) {
    for (var c = "", l = 0, h; (h = o.exec(u)) !== null; ) {
      var f = h.index;
      c += u.substring(l, f);
      var d = u.charCodeAt(f), y = e.default.get(d);
      if (typeof y == "object") {
        if (f + 1 < u.length) {
          var m = u.charCodeAt(f + 1), b = typeof y.n == "number" ? y.n === m ? y.o : void 0 : y.n.get(m);
          if (b !== void 0) {
            c += b, l = o.lastIndex += 1;
            continue;
          }
        }
        y = y.v;
      }
      if (y !== void 0)
        c += y, l = f + 1;
      else {
        var p = (0, t.getCodePoint)(u, f);
        c += "&#x".concat(p.toString(16), ";"), l = o.lastIndex += +(p !== d);
      }
    }
    return c + u.substr(l);
  }
  return Di;
}
var cy;
function J8() {
  return cy || (cy = 1, (function(n) {
    Object.defineProperty(n, "__esModule", { value: !0 }), n.decodeXMLStrict = n.decodeHTML5Strict = n.decodeHTML4Strict = n.decodeHTML5 = n.decodeHTML4 = n.decodeHTMLAttribute = n.decodeHTMLStrict = n.decodeHTML = n.decodeXML = n.DecodingMode = n.EntityDecoder = n.encodeHTML5 = n.encodeHTML4 = n.encodeNonAsciiHTML = n.encodeHTML = n.escapeText = n.escapeAttribute = n.escapeUTF8 = n.escape = n.encodeXML = n.encode = n.decodeStrict = n.decode = n.EncodingMode = n.EntityLevel = void 0;
    var e = /* @__PURE__ */ ec(), t = /* @__PURE__ */ uy(), i = /* @__PURE__ */ Yp(), r;
    (function(f) {
      f[f.XML = 0] = "XML", f[f.HTML = 1] = "HTML";
    })(r = n.EntityLevel || (n.EntityLevel = {}));
    var a;
    (function(f) {
      f[f.UTF8 = 0] = "UTF8", f[f.ASCII = 1] = "ASCII", f[f.Extensive = 2] = "Extensive", f[f.Attribute = 3] = "Attribute", f[f.Text = 4] = "Text";
    })(a = n.EncodingMode || (n.EncodingMode = {}));
    function s(f, d) {
      d === void 0 && (d = r.XML);
      var y = typeof d == "number" ? d : d.level;
      if (y === r.HTML) {
        var m = typeof d == "object" ? d.mode : void 0;
        return (0, e.decodeHTML)(f, m);
      }
      return (0, e.decodeXML)(f);
    }
    n.decode = s;
    function o(f, d) {
      var y;
      d === void 0 && (d = r.XML);
      var m = typeof d == "number" ? { level: d } : d;
      return (y = m.mode) !== null && y !== void 0 || (m.mode = e.DecodingMode.Strict), s(f, m);
    }
    n.decodeStrict = o;
    function u(f, d) {
      d === void 0 && (d = r.XML);
      var y = typeof d == "number" ? { level: d } : d;
      return y.mode === a.UTF8 ? (0, i.escapeUTF8)(f) : y.mode === a.Attribute ? (0, i.escapeAttribute)(f) : y.mode === a.Text ? (0, i.escapeText)(f) : y.level === r.HTML ? y.mode === a.ASCII ? (0, t.encodeNonAsciiHTML)(f) : (0, t.encodeHTML)(f) : (0, i.encodeXML)(f);
    }
    n.encode = u;
    var c = /* @__PURE__ */ Yp();
    Object.defineProperty(n, "encodeXML", { enumerable: !0, get: function() {
      return c.encodeXML;
    } }), Object.defineProperty(n, "escape", { enumerable: !0, get: function() {
      return c.escape;
    } }), Object.defineProperty(n, "escapeUTF8", { enumerable: !0, get: function() {
      return c.escapeUTF8;
    } }), Object.defineProperty(n, "escapeAttribute", { enumerable: !0, get: function() {
      return c.escapeAttribute;
    } }), Object.defineProperty(n, "escapeText", { enumerable: !0, get: function() {
      return c.escapeText;
    } });
    var l = /* @__PURE__ */ uy();
    Object.defineProperty(n, "encodeHTML", { enumerable: !0, get: function() {
      return l.encodeHTML;
    } }), Object.defineProperty(n, "encodeNonAsciiHTML", { enumerable: !0, get: function() {
      return l.encodeNonAsciiHTML;
    } }), Object.defineProperty(n, "encodeHTML4", { enumerable: !0, get: function() {
      return l.encodeHTML;
    } }), Object.defineProperty(n, "encodeHTML5", { enumerable: !0, get: function() {
      return l.encodeHTML;
    } });
    var h = /* @__PURE__ */ ec();
    Object.defineProperty(n, "EntityDecoder", { enumerable: !0, get: function() {
      return h.EntityDecoder;
    } }), Object.defineProperty(n, "DecodingMode", { enumerable: !0, get: function() {
      return h.DecodingMode;
    } }), Object.defineProperty(n, "decodeXML", { enumerable: !0, get: function() {
      return h.decodeXML;
    } }), Object.defineProperty(n, "decodeHTML", { enumerable: !0, get: function() {
      return h.decodeHTML;
    } }), Object.defineProperty(n, "decodeHTMLStrict", { enumerable: !0, get: function() {
      return h.decodeHTMLStrict;
    } }), Object.defineProperty(n, "decodeHTMLAttribute", { enumerable: !0, get: function() {
      return h.decodeHTMLAttribute;
    } }), Object.defineProperty(n, "decodeHTML4", { enumerable: !0, get: function() {
      return h.decodeHTML;
    } }), Object.defineProperty(n, "decodeHTML5", { enumerable: !0, get: function() {
      return h.decodeHTML;
    } }), Object.defineProperty(n, "decodeHTML4Strict", { enumerable: !0, get: function() {
      return h.decodeHTMLStrict;
    } }), Object.defineProperty(n, "decodeHTML5Strict", { enumerable: !0, get: function() {
      return h.decodeHTMLStrict;
    } }), Object.defineProperty(n, "decodeXMLStrict", { enumerable: !0, get: function() {
      return h.decodeXML;
    } });
  })(yd)), yd;
}
var br = {}, ly;
function e4() {
  return ly || (ly = 1, Object.defineProperty(br, "__esModule", { value: !0 }), br.attributeNames = br.elementNames = void 0, br.elementNames = new Map([
    "altGlyph",
    "altGlyphDef",
    "altGlyphItem",
    "animateColor",
    "animateMotion",
    "animateTransform",
    "clipPath",
    "feBlend",
    "feColorMatrix",
    "feComponentTransfer",
    "feComposite",
    "feConvolveMatrix",
    "feDiffuseLighting",
    "feDisplacementMap",
    "feDistantLight",
    "feDropShadow",
    "feFlood",
    "feFuncA",
    "feFuncB",
    "feFuncG",
    "feFuncR",
    "feGaussianBlur",
    "feImage",
    "feMerge",
    "feMergeNode",
    "feMorphology",
    "feOffset",
    "fePointLight",
    "feSpecularLighting",
    "feSpotLight",
    "feTile",
    "feTurbulence",
    "foreignObject",
    "glyphRef",
    "linearGradient",
    "radialGradient",
    "textPath"
  ].map(function(n) {
    return [n.toLowerCase(), n];
  })), br.attributeNames = new Map([
    "definitionURL",
    "attributeName",
    "attributeType",
    "baseFrequency",
    "baseProfile",
    "calcMode",
    "clipPathUnits",
    "diffuseConstant",
    "edgeMode",
    "filterUnits",
    "glyphRef",
    "gradientTransform",
    "gradientUnits",
    "kernelMatrix",
    "kernelUnitLength",
    "keyPoints",
    "keySplines",
    "keyTimes",
    "lengthAdjust",
    "limitingConeAngle",
    "markerHeight",
    "markerUnits",
    "markerWidth",
    "maskContentUnits",
    "maskUnits",
    "numOctaves",
    "pathLength",
    "patternContentUnits",
    "patternTransform",
    "patternUnits",
    "pointsAtX",
    "pointsAtY",
    "pointsAtZ",
    "preserveAlpha",
    "preserveAspectRatio",
    "primitiveUnits",
    "refX",
    "refY",
    "repeatCount",
    "repeatDur",
    "requiredExtensions",
    "requiredFeatures",
    "specularConstant",
    "specularExponent",
    "spreadMethod",
    "startOffset",
    "stdDeviation",
    "stitchTiles",
    "surfaceScale",
    "systemLanguage",
    "tableValues",
    "targetX",
    "targetY",
    "textLength",
    "viewBox",
    "viewTarget",
    "xChannelSelector",
    "yChannelSelector",
    "zoomAndPan"
  ].map(function(n) {
    return [n.toLowerCase(), n];
  }))), br;
}
var dy;
function t4() {
  if (dy) return dn;
  dy = 1;
  var n = dn && dn.__assign || function() {
    return n = Object.assign || function(_) {
      for (var x, T = 1, E = arguments.length; T < E; T++) {
        x = arguments[T];
        for (var U in x) Object.prototype.hasOwnProperty.call(x, U) && (_[U] = x[U]);
      }
      return _;
    }, n.apply(this, arguments);
  }, e = dn && dn.__createBinding || (Object.create ? (function(_, x, T, E) {
    E === void 0 && (E = T);
    var U = Object.getOwnPropertyDescriptor(x, T);
    (!U || ("get" in U ? !x.__esModule : U.writable || U.configurable)) && (U = { enumerable: !0, get: function() {
      return x[T];
    } }), Object.defineProperty(_, E, U);
  }) : (function(_, x, T, E) {
    E === void 0 && (E = T), _[E] = x[T];
  })), t = dn && dn.__setModuleDefault || (Object.create ? (function(_, x) {
    Object.defineProperty(_, "default", { enumerable: !0, value: x });
  }) : function(_, x) {
    _.default = x;
  }), i = dn && dn.__importStar || function(_) {
    if (_ && _.__esModule) return _;
    var x = {};
    if (_ != null) for (var T in _) T !== "default" && Object.prototype.hasOwnProperty.call(_, T) && e(x, _, T);
    return t(x, _), x;
  };
  Object.defineProperty(dn, "__esModule", { value: !0 }), dn.render = void 0;
  var r = i(/* @__PURE__ */ io()), a = /* @__PURE__ */ J8(), s = /* @__PURE__ */ e4(), o = /* @__PURE__ */ new Set([
    "style",
    "script",
    "xmp",
    "iframe",
    "noembed",
    "noframes",
    "plaintext",
    "noscript"
  ]);
  function u(_) {
    return _.replace(/"/g, "&quot;");
  }
  function c(_, x) {
    var T;
    if (_) {
      var E = ((T = x.encodeEntities) !== null && T !== void 0 ? T : x.decodeEntities) === !1 ? u : x.xmlMode || x.encodeEntities !== "utf8" ? a.encodeXML : a.escapeAttribute;
      return Object.keys(_).map(function(U) {
        var D, L, j = (D = _[U]) !== null && D !== void 0 ? D : "";
        return x.xmlMode === "foreign" && (U = (L = s.attributeNames.get(U)) !== null && L !== void 0 ? L : U), !x.emptyAttrs && !x.xmlMode && j === "" ? U : "".concat(U, '="').concat(E(j), '"');
      }).join(" ");
    }
  }
  var l = /* @__PURE__ */ new Set([
    "area",
    "base",
    "basefont",
    "br",
    "col",
    "command",
    "embed",
    "frame",
    "hr",
    "img",
    "input",
    "isindex",
    "keygen",
    "link",
    "meta",
    "param",
    "source",
    "track",
    "wbr"
  ]);
  function h(_, x) {
    x === void 0 && (x = {});
    for (var T = ("length" in _) ? _ : [_], E = "", U = 0; U < T.length; U++)
      E += f(T[U], x);
    return E;
  }
  dn.render = h, dn.default = h;
  function f(_, x) {
    switch (_.type) {
      case r.Root:
        return h(_.children, x);
      // @ts-expect-error We don't use `Doctype` yet
      case r.Doctype:
      case r.Directive:
        return b(_);
      case r.Comment:
        return v(_);
      case r.CDATA:
        return g(_);
      case r.Script:
      case r.Style:
      case r.Tag:
        return m(_, x);
      case r.Text:
        return p(_, x);
    }
  }
  var d = /* @__PURE__ */ new Set([
    "mi",
    "mo",
    "mn",
    "ms",
    "mtext",
    "annotation-xml",
    "foreignObject",
    "desc",
    "title"
  ]), y = /* @__PURE__ */ new Set(["svg", "math"]);
  function m(_, x) {
    var T;
    x.xmlMode === "foreign" && (_.name = (T = s.elementNames.get(_.name)) !== null && T !== void 0 ? T : _.name, _.parent && d.has(_.parent.name) && (x = n(n({}, x), { xmlMode: !1 }))), !x.xmlMode && y.has(_.name) && (x = n(n({}, x), { xmlMode: "foreign" }));
    var E = "<".concat(_.name), U = c(_.attribs, x);
    return U && (E += " ".concat(U)), _.children.length === 0 && (x.xmlMode ? (
      // In XML mode or foreign mode, and user hasn't explicitly turned off self-closing tags
      x.selfClosingTags !== !1
    ) : (
      // User explicitly asked for self-closing tags, even in HTML mode
      x.selfClosingTags && l.has(_.name)
    )) ? (x.xmlMode || (E += " "), E += "/>") : (E += ">", _.children.length > 0 && (E += h(_.children, x)), (x.xmlMode || !l.has(_.name)) && (E += "</".concat(_.name, ">"))), E;
  }
  function b(_) {
    return "<".concat(_.data, ">");
  }
  function p(_, x) {
    var T, E = _.data || "";
    return ((T = x.encodeEntities) !== null && T !== void 0 ? T : x.decodeEntities) !== !1 && !(!x.xmlMode && _.parent && o.has(_.parent.name)) && (E = x.xmlMode || x.encodeEntities !== "utf8" ? (0, a.encodeXML)(E) : (0, a.escapeText)(E)), E;
  }
  function g(_) {
    return "<![CDATA[".concat(_.children[0].data, "]]>");
  }
  function v(_) {
    return "<!--".concat(_.data, "-->");
  }
  return dn;
}
var fy;
function UT() {
  if (fy) return tn;
  fy = 1;
  var n = tn && tn.__importDefault || function(c) {
    return c && c.__esModule ? c : { default: c };
  };
  Object.defineProperty(tn, "__esModule", { value: !0 }), tn.innerText = tn.textContent = tn.getText = tn.getInnerHTML = tn.getOuterHTML = void 0;
  var e = /* @__PURE__ */ Zi(), t = n(/* @__PURE__ */ t4()), i = /* @__PURE__ */ io();
  function r(c, l) {
    return (0, t.default)(c, l);
  }
  tn.getOuterHTML = r;
  function a(c, l) {
    return (0, e.hasChildren)(c) ? c.children.map(function(h) {
      return r(h, l);
    }).join("") : "";
  }
  tn.getInnerHTML = a;
  function s(c) {
    return Array.isArray(c) ? c.map(s).join("") : (0, e.isTag)(c) ? c.name === "br" ? `
` : s(c.children) : (0, e.isCDATA)(c) ? s(c.children) : (0, e.isText)(c) ? c.data : "";
  }
  tn.getText = s;
  function o(c) {
    return Array.isArray(c) ? c.map(o).join("") : (0, e.hasChildren)(c) && !(0, e.isComment)(c) ? o(c.children) : (0, e.isText)(c) ? c.data : "";
  }
  tn.textContent = o;
  function u(c) {
    return Array.isArray(c) ? c.map(u).join("") : (0, e.hasChildren)(c) && (c.type === i.ElementType.Tag || (0, e.isCDATA)(c)) ? u(c.children) : (0, e.isText)(c) ? c.data : "";
  }
  return tn.innerText = u, tn;
}
var Nt = {}, hy;
function n4() {
  if (hy) return Nt;
  hy = 1, Object.defineProperty(Nt, "__esModule", { value: !0 }), Nt.prevElementSibling = Nt.nextElementSibling = Nt.getName = Nt.hasAttrib = Nt.getAttributeValue = Nt.getSiblings = Nt.getParent = Nt.getChildren = void 0;
  var n = /* @__PURE__ */ Zi();
  function e(c) {
    return (0, n.hasChildren)(c) ? c.children : [];
  }
  Nt.getChildren = e;
  function t(c) {
    return c.parent || null;
  }
  Nt.getParent = t;
  function i(c) {
    var l, h, f = t(c);
    if (f != null)
      return e(f);
    for (var d = [c], y = c.prev, m = c.next; y != null; )
      d.unshift(y), l = y, y = l.prev;
    for (; m != null; )
      d.push(m), h = m, m = h.next;
    return d;
  }
  Nt.getSiblings = i;
  function r(c, l) {
    var h;
    return (h = c.attribs) === null || h === void 0 ? void 0 : h[l];
  }
  Nt.getAttributeValue = r;
  function a(c, l) {
    return c.attribs != null && Object.prototype.hasOwnProperty.call(c.attribs, l) && c.attribs[l] != null;
  }
  Nt.hasAttrib = a;
  function s(c) {
    return c.name;
  }
  Nt.getName = s;
  function o(c) {
    for (var l, h = c.next; h !== null && !(0, n.isTag)(h); )
      l = h, h = l.next;
    return h;
  }
  Nt.nextElementSibling = o;
  function u(c) {
    for (var l, h = c.prev; h !== null && !(0, n.isTag)(h); )
      l = h, h = l.prev;
    return h;
  }
  return Nt.prevElementSibling = u, Nt;
}
var nn = {}, py;
function i4() {
  if (py) return nn;
  py = 1, Object.defineProperty(nn, "__esModule", { value: !0 }), nn.prepend = nn.prependChild = nn.append = nn.appendChild = nn.replaceElement = nn.removeElement = void 0;
  function n(s) {
    if (s.prev && (s.prev.next = s.next), s.next && (s.next.prev = s.prev), s.parent) {
      var o = s.parent.children, u = o.lastIndexOf(s);
      u >= 0 && o.splice(u, 1);
    }
    s.next = null, s.prev = null, s.parent = null;
  }
  nn.removeElement = n;
  function e(s, o) {
    var u = o.prev = s.prev;
    u && (u.next = o);
    var c = o.next = s.next;
    c && (c.prev = o);
    var l = o.parent = s.parent;
    if (l) {
      var h = l.children;
      h[h.lastIndexOf(s)] = o, s.parent = null;
    }
  }
  nn.replaceElement = e;
  function t(s, o) {
    if (n(o), o.next = null, o.parent = s, s.children.push(o) > 1) {
      var u = s.children[s.children.length - 2];
      u.next = o, o.prev = u;
    } else
      o.prev = null;
  }
  nn.appendChild = t;
  function i(s, o) {
    n(o);
    var u = s.parent, c = s.next;
    if (o.next = c, o.prev = s, s.next = o, o.parent = u, c) {
      if (c.prev = o, u) {
        var l = u.children;
        l.splice(l.lastIndexOf(c), 0, o);
      }
    } else u && u.children.push(o);
  }
  nn.append = i;
  function r(s, o) {
    if (n(o), o.parent = s, o.prev = null, s.children.unshift(o) !== 1) {
      var u = s.children[1];
      u.prev = o, o.next = u;
    } else
      o.next = null;
  }
  nn.prependChild = r;
  function a(s, o) {
    n(o);
    var u = s.parent;
    if (u) {
      var c = u.children;
      c.splice(c.indexOf(s), 0, o);
    }
    s.prev && (s.prev.next = o), o.parent = u, o.prev = s.prev, o.next = s, s.prev = o;
  }
  return nn.prepend = a, nn;
}
var rn = {}, my;
function RT() {
  if (my) return rn;
  my = 1, Object.defineProperty(rn, "__esModule", { value: !0 }), rn.findAll = rn.existsOne = rn.findOne = rn.findOneChild = rn.find = rn.filter = void 0;
  var n = /* @__PURE__ */ Zi();
  function e(o, u, c, l) {
    return c === void 0 && (c = !0), l === void 0 && (l = 1 / 0), t(o, Array.isArray(u) ? u : [u], c, l);
  }
  rn.filter = e;
  function t(o, u, c, l) {
    for (var h = [], f = [u], d = [0]; ; ) {
      if (d[0] >= f[0].length) {
        if (d.length === 1)
          return h;
        f.shift(), d.shift();
        continue;
      }
      var y = f[0][d[0]++];
      if (o(y) && (h.push(y), --l <= 0))
        return h;
      c && (0, n.hasChildren)(y) && y.children.length > 0 && (d.unshift(0), f.unshift(y.children));
    }
  }
  rn.find = t;
  function i(o, u) {
    return u.find(o);
  }
  rn.findOneChild = i;
  function r(o, u, c) {
    c === void 0 && (c = !0);
    for (var l = null, h = 0; h < u.length && !l; h++) {
      var f = u[h];
      if ((0, n.isTag)(f))
        o(f) ? l = f : c && f.children.length > 0 && (l = r(o, f.children, !0));
      else continue;
    }
    return l;
  }
  rn.findOne = r;
  function a(o, u) {
    return u.some(function(c) {
      return (0, n.isTag)(c) && (o(c) || a(o, c.children));
    });
  }
  rn.existsOne = a;
  function s(o, u) {
    for (var c = [], l = [u], h = [0]; ; ) {
      if (h[0] >= l[0].length) {
        if (l.length === 1)
          return c;
        l.shift(), h.shift();
        continue;
      }
      var f = l[0][h[0]++];
      (0, n.isTag)(f) && (o(f) && c.push(f), f.children.length > 0 && (h.unshift(0), l.unshift(f.children)));
    }
  }
  return rn.findAll = s, rn;
}
var xn = {}, gy;
function OT() {
  if (gy) return xn;
  gy = 1, Object.defineProperty(xn, "__esModule", { value: !0 }), xn.getElementsByTagType = xn.getElementsByTagName = xn.getElementById = xn.getElements = xn.testElement = void 0;
  var n = /* @__PURE__ */ Zi(), e = /* @__PURE__ */ RT(), t = {
    tag_name: function(h) {
      return typeof h == "function" ? function(f) {
        return (0, n.isTag)(f) && h(f.name);
      } : h === "*" ? n.isTag : function(f) {
        return (0, n.isTag)(f) && f.name === h;
      };
    },
    tag_type: function(h) {
      return typeof h == "function" ? function(f) {
        return h(f.type);
      } : function(f) {
        return f.type === h;
      };
    },
    tag_contains: function(h) {
      return typeof h == "function" ? function(f) {
        return (0, n.isText)(f) && h(f.data);
      } : function(f) {
        return (0, n.isText)(f) && f.data === h;
      };
    }
  };
  function i(h, f) {
    return typeof f == "function" ? function(d) {
      return (0, n.isTag)(d) && f(d.attribs[h]);
    } : function(d) {
      return (0, n.isTag)(d) && d.attribs[h] === f;
    };
  }
  function r(h, f) {
    return function(d) {
      return h(d) || f(d);
    };
  }
  function a(h) {
    var f = Object.keys(h).map(function(d) {
      var y = h[d];
      return Object.prototype.hasOwnProperty.call(t, d) ? t[d](y) : i(d, y);
    });
    return f.length === 0 ? null : f.reduce(r);
  }
  function s(h, f) {
    var d = a(h);
    return d ? d(f) : !0;
  }
  xn.testElement = s;
  function o(h, f, d, y) {
    y === void 0 && (y = 1 / 0);
    var m = a(h);
    return m ? (0, e.filter)(m, f, d, y) : [];
  }
  xn.getElements = o;
  function u(h, f, d) {
    return d === void 0 && (d = !0), Array.isArray(f) || (f = [f]), (0, e.findOne)(i("id", h), f, d);
  }
  xn.getElementById = u;
  function c(h, f, d, y) {
    return d === void 0 && (d = !0), y === void 0 && (y = 1 / 0), (0, e.filter)(t.tag_name(h), f, d, y);
  }
  xn.getElementsByTagName = c;
  function l(h, f, d, y) {
    return d === void 0 && (d = !0), y === void 0 && (y = 1 / 0), (0, e.filter)(t.tag_type(h), f, d, y);
  }
  return xn.getElementsByTagType = l, xn;
}
var xd = {}, by;
function r4() {
  return by || (by = 1, (function(n) {
    Object.defineProperty(n, "__esModule", { value: !0 }), n.uniqueSort = n.compareDocumentPosition = n.DocumentPosition = n.removeSubsets = void 0;
    var e = /* @__PURE__ */ Zi();
    function t(s) {
      for (var o = s.length; --o >= 0; ) {
        var u = s[o];
        if (o > 0 && s.lastIndexOf(u, o - 1) >= 0) {
          s.splice(o, 1);
          continue;
        }
        for (var c = u.parent; c; c = c.parent)
          if (s.includes(c)) {
            s.splice(o, 1);
            break;
          }
      }
      return s;
    }
    n.removeSubsets = t;
    var i;
    (function(s) {
      s[s.DISCONNECTED = 1] = "DISCONNECTED", s[s.PRECEDING = 2] = "PRECEDING", s[s.FOLLOWING = 4] = "FOLLOWING", s[s.CONTAINS = 8] = "CONTAINS", s[s.CONTAINED_BY = 16] = "CONTAINED_BY";
    })(i = n.DocumentPosition || (n.DocumentPosition = {}));
    function r(s, o) {
      var u = [], c = [];
      if (s === o)
        return 0;
      for (var l = (0, e.hasChildren)(s) ? s : s.parent; l; )
        u.unshift(l), l = l.parent;
      for (l = (0, e.hasChildren)(o) ? o : o.parent; l; )
        c.unshift(l), l = l.parent;
      for (var h = Math.min(u.length, c.length), f = 0; f < h && u[f] === c[f]; )
        f++;
      if (f === 0)
        return i.DISCONNECTED;
      var d = u[f - 1], y = d.children, m = u[f], b = c[f];
      return y.indexOf(m) > y.indexOf(b) ? d === o ? i.FOLLOWING | i.CONTAINED_BY : i.FOLLOWING : d === s ? i.PRECEDING | i.CONTAINS : i.PRECEDING;
    }
    n.compareDocumentPosition = r;
    function a(s) {
      return s = s.filter(function(o, u, c) {
        return !c.includes(o, u + 1);
      }), s.sort(function(o, u) {
        var c = r(o, u);
        return c & i.PRECEDING ? -1 : c & i.FOLLOWING ? 1 : 0;
      }), s;
    }
    n.uniqueSort = a;
  })(xd)), xd;
}
var as = {}, yy;
function a4() {
  if (yy) return as;
  yy = 1, Object.defineProperty(as, "__esModule", { value: !0 }), as.getFeed = void 0;
  var n = /* @__PURE__ */ UT(), e = /* @__PURE__ */ OT();
  function t(f) {
    var d = u(h, f);
    return d ? d.name === "feed" ? i(d) : r(d) : null;
  }
  as.getFeed = t;
  function i(f) {
    var d, y = f.children, m = {
      type: "atom",
      items: (0, e.getElementsByTagName)("entry", y).map(function(g) {
        var v, _ = g.children, x = { media: o(_) };
        l(x, "id", "id", _), l(x, "title", "title", _);
        var T = (v = u("link", _)) === null || v === void 0 ? void 0 : v.attribs.href;
        T && (x.link = T);
        var E = c("summary", _) || c("content", _);
        E && (x.description = E);
        var U = c("updated", _);
        return U && (x.pubDate = new Date(U)), x;
      })
    };
    l(m, "id", "id", y), l(m, "title", "title", y);
    var b = (d = u("link", y)) === null || d === void 0 ? void 0 : d.attribs.href;
    b && (m.link = b), l(m, "description", "subtitle", y);
    var p = c("updated", y);
    return p && (m.updated = new Date(p)), l(m, "author", "email", y, !0), m;
  }
  function r(f) {
    var d, y, m = (y = (d = u("channel", f.children)) === null || d === void 0 ? void 0 : d.children) !== null && y !== void 0 ? y : [], b = {
      type: f.name.substr(0, 3),
      id: "",
      items: (0, e.getElementsByTagName)("item", f.children).map(function(g) {
        var v = g.children, _ = { media: o(v) };
        l(_, "id", "guid", v), l(_, "title", "title", v), l(_, "link", "link", v), l(_, "description", "description", v);
        var x = c("pubDate", v) || c("dc:date", v);
        return x && (_.pubDate = new Date(x)), _;
      })
    };
    l(b, "title", "title", m), l(b, "link", "link", m), l(b, "description", "description", m);
    var p = c("lastBuildDate", m);
    return p && (b.updated = new Date(p)), l(b, "author", "managingEditor", m, !0), b;
  }
  var a = ["url", "type", "lang"], s = [
    "fileSize",
    "bitrate",
    "framerate",
    "samplingrate",
    "channels",
    "duration",
    "height",
    "width"
  ];
  function o(f) {
    return (0, e.getElementsByTagName)("media:content", f).map(function(d) {
      for (var y = d.attribs, m = {
        medium: y.medium,
        isDefault: !!y.isDefault
      }, b = 0, p = a; b < p.length; b++) {
        var g = p[b];
        y[g] && (m[g] = y[g]);
      }
      for (var v = 0, _ = s; v < _.length; v++) {
        var g = _[v];
        y[g] && (m[g] = parseInt(y[g], 10));
      }
      return y.expression && (m.expression = y.expression), m;
    });
  }
  function u(f, d) {
    return (0, e.getElementsByTagName)(f, d, !0, 1)[0];
  }
  function c(f, d, y) {
    return y === void 0 && (y = !1), (0, n.textContent)((0, e.getElementsByTagName)(f, d, y, 1)).trim();
  }
  function l(f, d, y, m, b) {
    b === void 0 && (b = !1);
    var p = c(y, m, b);
    p && (f[d] = p);
  }
  function h(f) {
    return f === "rss" || f === "feed" || f === "rdf:RDF";
  }
  return as;
}
var vy;
function _d() {
  return vy || (vy = 1, (function(n) {
    var e = gr && gr.__createBinding || (Object.create ? (function(r, a, s, o) {
      o === void 0 && (o = s);
      var u = Object.getOwnPropertyDescriptor(a, s);
      (!u || ("get" in u ? !a.__esModule : u.writable || u.configurable)) && (u = { enumerable: !0, get: function() {
        return a[s];
      } }), Object.defineProperty(r, o, u);
    }) : (function(r, a, s, o) {
      o === void 0 && (o = s), r[o] = a[s];
    })), t = gr && gr.__exportStar || function(r, a) {
      for (var s in r) s !== "default" && !Object.prototype.hasOwnProperty.call(a, s) && e(a, r, s);
    };
    Object.defineProperty(n, "__esModule", { value: !0 }), n.hasChildren = n.isDocument = n.isComment = n.isText = n.isCDATA = n.isTag = void 0, t(/* @__PURE__ */ UT(), n), t(/* @__PURE__ */ n4(), n), t(/* @__PURE__ */ i4(), n), t(/* @__PURE__ */ RT(), n), t(/* @__PURE__ */ OT(), n), t(/* @__PURE__ */ r4(), n), t(/* @__PURE__ */ a4(), n);
    var i = /* @__PURE__ */ Zi();
    Object.defineProperty(n, "isTag", { enumerable: !0, get: function() {
      return i.isTag;
    } }), Object.defineProperty(n, "isCDATA", { enumerable: !0, get: function() {
      return i.isCDATA;
    } }), Object.defineProperty(n, "isText", { enumerable: !0, get: function() {
      return i.isText;
    } }), Object.defineProperty(n, "isComment", { enumerable: !0, get: function() {
      return i.isComment;
    } }), Object.defineProperty(n, "isDocument", { enumerable: !0, get: function() {
      return i.isDocument;
    } }), Object.defineProperty(n, "hasChildren", { enumerable: !0, get: function() {
      return i.hasChildren;
    } });
  })(gr)), gr;
}
var xy;
function s4() {
  return xy || (xy = 1, (function(n) {
    var e = $n && $n.__createBinding || (Object.create ? (function(p, g, v, _) {
      _ === void 0 && (_ = v);
      var x = Object.getOwnPropertyDescriptor(g, v);
      (!x || ("get" in x ? !g.__esModule : x.writable || x.configurable)) && (x = { enumerable: !0, get: function() {
        return g[v];
      } }), Object.defineProperty(p, _, x);
    }) : (function(p, g, v, _) {
      _ === void 0 && (_ = v), p[_] = g[v];
    })), t = $n && $n.__setModuleDefault || (Object.create ? (function(p, g) {
      Object.defineProperty(p, "default", { enumerable: !0, value: g });
    }) : function(p, g) {
      p.default = g;
    }), i = $n && $n.__importStar || function(p) {
      if (p && p.__esModule) return p;
      var g = {};
      if (p != null) for (var v in p) v !== "default" && Object.prototype.hasOwnProperty.call(p, v) && e(g, p, v);
      return t(g, p), g;
    }, r = $n && $n.__importDefault || function(p) {
      return p && p.__esModule ? p : { default: p };
    };
    Object.defineProperty(n, "__esModule", { value: !0 }), n.DomUtils = n.parseFeed = n.getFeed = n.ElementType = n.Tokenizer = n.createDomStream = n.parseDOM = n.parseDocument = n.DefaultHandler = n.DomHandler = n.Parser = void 0;
    var a = /* @__PURE__ */ ey(), s = /* @__PURE__ */ ey();
    Object.defineProperty(n, "Parser", { enumerable: !0, get: function() {
      return s.Parser;
    } });
    var o = /* @__PURE__ */ Zi(), u = /* @__PURE__ */ Zi();
    Object.defineProperty(n, "DomHandler", { enumerable: !0, get: function() {
      return u.DomHandler;
    } }), Object.defineProperty(n, "DefaultHandler", { enumerable: !0, get: function() {
      return u.DomHandler;
    } });
    function c(p, g) {
      var v = new o.DomHandler(void 0, g);
      return new a.Parser(v, g).end(p), v.root;
    }
    n.parseDocument = c;
    function l(p, g) {
      return c(p, g).children;
    }
    n.parseDOM = l;
    function h(p, g, v) {
      var _ = new o.DomHandler(p, g, v);
      return new a.Parser(_, g);
    }
    n.createDomStream = h;
    var f = /* @__PURE__ */ IT();
    Object.defineProperty(n, "Tokenizer", { enumerable: !0, get: function() {
      return r(f).default;
    } }), n.ElementType = i(/* @__PURE__ */ io());
    var d = /* @__PURE__ */ _d(), y = /* @__PURE__ */ _d();
    Object.defineProperty(n, "getFeed", { enumerable: !0, get: function() {
      return y.getFeed;
    } });
    var m = { xmlMode: !0 };
    function b(p, g) {
      return g === void 0 && (g = m), (0, d.getFeed)(l(p, g));
    }
    n.parseFeed = b, n.DomUtils = i(/* @__PURE__ */ _d());
  })($n)), $n;
}
var Td, _y;
function o4() {
  return _y || (_y = 1, Td = (n) => {
    if (typeof n != "string")
      throw new TypeError("Expected a string");
    return n.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d");
  }), Td;
}
var Ko = {}, Ty;
function u4() {
  if (Ty) return Ko;
  Ty = 1, Object.defineProperty(Ko, "__esModule", { value: !0 });
  /*!
   * is-plain-object <https://github.com/jonschlinkert/is-plain-object>
   *
   * Copyright (c) 2014-2017, Jon Schlinkert.
   * Released under the MIT License.
   */
  function n(t) {
    return Object.prototype.toString.call(t) === "[object Object]";
  }
  function e(t) {
    var i, r;
    return n(t) === !1 ? !1 : (i = t.constructor, i === void 0 ? !0 : (r = i.prototype, !(n(r) === !1 || r.hasOwnProperty("isPrototypeOf") === !1)));
  }
  return Ko.isPlainObject = e, Ko;
}
var wd, wy;
function c4() {
  if (wy) return wd;
  wy = 1;
  var n = function(g) {
    return e(g) && !t(g);
  };
  function e(p) {
    return !!p && typeof p == "object";
  }
  function t(p) {
    var g = Object.prototype.toString.call(p);
    return g === "[object RegExp]" || g === "[object Date]" || a(p);
  }
  var i = typeof Symbol == "function" && Symbol.for, r = i ? Symbol.for("react.element") : 60103;
  function a(p) {
    return p.$$typeof === r;
  }
  function s(p) {
    return Array.isArray(p) ? [] : {};
  }
  function o(p, g) {
    return g.clone !== !1 && g.isMergeableObject(p) ? m(s(p), p, g) : p;
  }
  function u(p, g, v) {
    return p.concat(g).map(function(_) {
      return o(_, v);
    });
  }
  function c(p, g) {
    if (!g.customMerge)
      return m;
    var v = g.customMerge(p);
    return typeof v == "function" ? v : m;
  }
  function l(p) {
    return Object.getOwnPropertySymbols ? Object.getOwnPropertySymbols(p).filter(function(g) {
      return Object.propertyIsEnumerable.call(p, g);
    }) : [];
  }
  function h(p) {
    return Object.keys(p).concat(l(p));
  }
  function f(p, g) {
    try {
      return g in p;
    } catch {
      return !1;
    }
  }
  function d(p, g) {
    return f(p, g) && !(Object.hasOwnProperty.call(p, g) && Object.propertyIsEnumerable.call(p, g));
  }
  function y(p, g, v) {
    var _ = {};
    return v.isMergeableObject(p) && h(p).forEach(function(x) {
      _[x] = o(p[x], v);
    }), h(g).forEach(function(x) {
      d(p, x) || (f(p, x) && v.isMergeableObject(g[x]) ? _[x] = c(x, v)(p[x], g[x], v) : _[x] = o(g[x], v));
    }), _;
  }
  function m(p, g, v) {
    v = v || {}, v.arrayMerge = v.arrayMerge || u, v.isMergeableObject = v.isMergeableObject || n, v.cloneUnlessOtherwiseSpecified = o;
    var _ = Array.isArray(g), x = Array.isArray(p), T = _ === x;
    return T ? _ ? v.arrayMerge(p, g, v) : y(p, g, v) : o(g, v);
  }
  m.all = function(g, v) {
    if (!Array.isArray(g))
      throw new Error("first argument should be an array");
    return g.reduce(function(_, x) {
      return m(_, x, v);
    }, {});
  };
  var b = m;
  return wd = b, wd;
}
var Du = { exports: {} }, l4 = Du.exports, Ey;
function d4() {
  return Ey || (Ey = 1, (function(n) {
    (function(e, t) {
      n.exports ? n.exports = t() : e.parseSrcset = t();
    })(l4, function() {
      return function(e) {
        function t(_) {
          return _ === " " || // space
          _ === "	" || // horizontal tab
          _ === `
` || // new line
          _ === "\f" || // form feed
          _ === "\r";
        }
        function i(_) {
          var x, T = _.exec(e.substring(b));
          if (T)
            return x = T[0], b += x.length, x;
        }
        for (var r = e.length, a = /^[ \t\n\r\u000c]+/, s = /^[, \t\n\r\u000c]+/, o = /^[^ \t\n\r\u000c]+/, u = /[,]+$/, c = /^\d+$/, l = /^-?(?:[0-9]+|[0-9]*\.[0-9]+)(?:[eE][+-]?[0-9]+)?$/, h, f, d, y, m, b = 0, p = []; ; ) {
          if (i(s), b >= r)
            return p;
          h = i(o), f = [], h.slice(-1) === "," ? (h = h.replace(u, ""), v()) : g();
        }
        function g() {
          for (i(a), d = "", y = "in descriptor"; ; ) {
            if (m = e.charAt(b), y === "in descriptor")
              if (t(m))
                d && (f.push(d), d = "", y = "after descriptor");
              else if (m === ",") {
                b += 1, d && f.push(d), v();
                return;
              } else if (m === "(")
                d = d + m, y = "in parens";
              else if (m === "") {
                d && f.push(d), v();
                return;
              } else
                d = d + m;
            else if (y === "in parens")
              if (m === ")")
                d = d + m, y = "in descriptor";
              else if (m === "") {
                f.push(d), v();
                return;
              } else
                d = d + m;
            else if (y === "after descriptor" && !t(m))
              if (m === "") {
                v();
                return;
              } else
                y = "in descriptor", b -= 1;
            b += 1;
          }
        }
        function v() {
          var _ = !1, x, T, E, U, D = {}, L, j, C, k, I;
          for (U = 0; U < f.length; U++)
            L = f[U], j = L[L.length - 1], C = L.substring(0, L.length - 1), k = parseInt(C, 10), I = parseFloat(C), c.test(C) && j === "w" ? ((x || T) && (_ = !0), k === 0 ? _ = !0 : x = k) : l.test(C) && j === "x" ? ((x || T || E) && (_ = !0), I < 0 ? _ = !0 : T = I) : c.test(C) && j === "h" ? ((E || T) && (_ = !0), k === 0 ? _ = !0 : E = k) : _ = !0;
          _ ? console && console.log && console.log("Invalid srcset descriptor found in '" + e + "' at '" + L + "'.") : (D.url = h, x && (D.w = x), T && (D.d = T), E && (D.h = E), p.push(D));
        }
      };
    });
  })(Du)), Du.exports;
}
var Yo = { exports: {} }, Dy;
function f4() {
  if (Dy) return Yo.exports;
  Dy = 1;
  var n = String, e = function() {
    return { isColorSupported: !1, reset: n, bold: n, dim: n, italic: n, underline: n, inverse: n, hidden: n, strikethrough: n, black: n, red: n, green: n, yellow: n, blue: n, magenta: n, cyan: n, white: n, gray: n, bgBlack: n, bgRed: n, bgGreen: n, bgYellow: n, bgBlue: n, bgMagenta: n, bgCyan: n, bgWhite: n, blackBright: n, redBright: n, greenBright: n, yellowBright: n, blueBright: n, magentaBright: n, cyanBright: n, whiteBright: n, bgBlackBright: n, bgRedBright: n, bgGreenBright: n, bgYellowBright: n, bgBlueBright: n, bgMagentaBright: n, bgCyanBright: n, bgWhiteBright: n };
  };
  return Yo.exports = e(), Yo.exports.createColors = e, Yo.exports;
}
const h4 = {}, p4 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: h4
}, Symbol.toStringTag, { value: "Module" })), ni = /* @__PURE__ */ kc(p4);
var Ed, Sy;
function Vm() {
  if (Sy) return Ed;
  Sy = 1;
  let n = /* @__PURE__ */ f4(), e = ni;
  class t extends Error {
    constructor(r, a, s, o, u, c) {
      super(r), this.name = "CssSyntaxError", this.reason = r, u && (this.file = u), o && (this.source = o), c && (this.plugin = c), typeof a < "u" && typeof s < "u" && (typeof a == "number" ? (this.line = a, this.column = s) : (this.line = a.line, this.column = a.column, this.endLine = s.line, this.endColumn = s.column)), this.setMessage(), Error.captureStackTrace && Error.captureStackTrace(this, t);
    }
    setMessage() {
      this.message = this.plugin ? this.plugin + ": " : "", this.message += this.file ? this.file : "<css input>", typeof this.line < "u" && (this.message += ":" + this.line + ":" + this.column), this.message += ": " + this.reason;
    }
    showSourceCode(r) {
      if (!this.source) return "";
      let a = this.source;
      r == null && (r = n.isColorSupported);
      let s = (d) => d, o = (d) => d, u = (d) => d;
      if (r) {
        let { bold: d, gray: y, red: m } = n.createColors(!0);
        o = (b) => d(m(b)), s = (b) => y(b), e && (u = (b) => e(b));
      }
      let c = a.split(/\r?\n/), l = Math.max(this.line - 3, 0), h = Math.min(this.line + 2, c.length), f = String(h).length;
      return c.slice(l, h).map((d, y) => {
        let m = l + 1 + y, b = " " + (" " + m).slice(-f) + " | ";
        if (m === this.line) {
          if (d.length > 160) {
            let g = 20, v = Math.max(0, this.column - g), _ = Math.max(
              this.column + g,
              this.endColumn + g
            ), x = d.slice(v, _), T = s(b.replace(/\d/g, " ")) + d.slice(0, Math.min(this.column - 1, g - 1)).replace(/[^\t]/g, " ");
            return o(">") + s(b) + u(x) + `
 ` + T + o("^");
          }
          let p = s(b.replace(/\d/g, " ")) + d.slice(0, this.column - 1).replace(/[^\t]/g, " ");
          return o(">") + s(b) + u(d) + `
 ` + p + o("^");
        }
        return " " + s(b) + u(d);
      }).join(`
`);
    }
    toString() {
      let r = this.showSourceCode();
      return r && (r = `

` + r + `
`), this.name + ": " + this.message + r;
    }
  }
  return Ed = t, t.default = t, Ed;
}
var Dd, Cy;
function LT() {
  if (Cy) return Dd;
  Cy = 1;
  const n = {
    after: `
`,
    beforeClose: `
`,
    beforeComment: `
`,
    beforeDecl: `
`,
    beforeOpen: " ",
    beforeRule: `
`,
    colon: ": ",
    commentLeft: " ",
    commentRight: " ",
    emptyBody: "",
    indent: "    ",
    semicolon: !1
  };
  function e(i) {
    return i[0].toUpperCase() + i.slice(1);
  }
  class t {
    constructor(r) {
      this.builder = r;
    }
    atrule(r, a) {
      let s = "@" + r.name, o = r.params ? this.rawValue(r, "params") : "";
      if (typeof r.raws.afterName < "u" ? s += r.raws.afterName : o && (s += " "), r.nodes)
        this.block(r, s + o);
      else {
        let u = (r.raws.between || "") + (a ? ";" : "");
        this.builder(s + o + u, r);
      }
    }
    beforeAfter(r, a) {
      let s;
      r.type === "decl" ? s = this.raw(r, null, "beforeDecl") : r.type === "comment" ? s = this.raw(r, null, "beforeComment") : a === "before" ? s = this.raw(r, null, "beforeRule") : s = this.raw(r, null, "beforeClose");
      let o = r.parent, u = 0;
      for (; o && o.type !== "root"; )
        u += 1, o = o.parent;
      if (s.includes(`
`)) {
        let c = this.raw(r, null, "indent");
        if (c.length)
          for (let l = 0; l < u; l++) s += c;
      }
      return s;
    }
    block(r, a) {
      let s = this.raw(r, "between", "beforeOpen");
      this.builder(a + s + "{", r, "start");
      let o;
      r.nodes && r.nodes.length ? (this.body(r), o = this.raw(r, "after")) : o = this.raw(r, "after", "emptyBody"), o && this.builder(o), this.builder("}", r, "end");
    }
    body(r) {
      let a = r.nodes.length - 1;
      for (; a > 0 && r.nodes[a].type === "comment"; )
        a -= 1;
      let s = this.raw(r, "semicolon");
      for (let o = 0; o < r.nodes.length; o++) {
        let u = r.nodes[o], c = this.raw(u, "before");
        c && this.builder(c), this.stringify(u, a !== o || s);
      }
    }
    comment(r) {
      let a = this.raw(r, "left", "commentLeft"), s = this.raw(r, "right", "commentRight");
      this.builder("/*" + a + r.text + s + "*/", r);
    }
    decl(r, a) {
      let s = this.raw(r, "between", "colon"), o = r.prop + s + this.rawValue(r, "value");
      r.important && (o += r.raws.important || " !important"), a && (o += ";"), this.builder(o, r);
    }
    document(r) {
      this.body(r);
    }
    raw(r, a, s) {
      let o;
      if (s || (s = a), a && (o = r.raws[a], typeof o < "u"))
        return o;
      let u = r.parent;
      if (s === "before" && (!u || u.type === "root" && u.first === r || u && u.type === "document"))
        return "";
      if (!u) return n[s];
      let c = r.root();
      if (c.rawCache || (c.rawCache = {}), typeof c.rawCache[s] < "u")
        return c.rawCache[s];
      if (s === "before" || s === "after")
        return this.beforeAfter(r, s);
      {
        let l = "raw" + e(s);
        this[l] ? o = this[l](c, r) : c.walk((h) => {
          if (o = h.raws[a], typeof o < "u") return !1;
        });
      }
      return typeof o > "u" && (o = n[s]), c.rawCache[s] = o, o;
    }
    rawBeforeClose(r) {
      let a;
      return r.walk((s) => {
        if (s.nodes && s.nodes.length > 0 && typeof s.raws.after < "u")
          return a = s.raws.after, a.includes(`
`) && (a = a.replace(/[^\n]+$/, "")), !1;
      }), a && (a = a.replace(/\S/g, "")), a;
    }
    rawBeforeComment(r, a) {
      let s;
      return r.walkComments((o) => {
        if (typeof o.raws.before < "u")
          return s = o.raws.before, s.includes(`
`) && (s = s.replace(/[^\n]+$/, "")), !1;
      }), typeof s > "u" ? s = this.raw(a, null, "beforeDecl") : s && (s = s.replace(/\S/g, "")), s;
    }
    rawBeforeDecl(r, a) {
      let s;
      return r.walkDecls((o) => {
        if (typeof o.raws.before < "u")
          return s = o.raws.before, s.includes(`
`) && (s = s.replace(/[^\n]+$/, "")), !1;
      }), typeof s > "u" ? s = this.raw(a, null, "beforeRule") : s && (s = s.replace(/\S/g, "")), s;
    }
    rawBeforeOpen(r) {
      let a;
      return r.walk((s) => {
        if (s.type !== "decl" && (a = s.raws.between, typeof a < "u"))
          return !1;
      }), a;
    }
    rawBeforeRule(r) {
      let a;
      return r.walk((s) => {
        if (s.nodes && (s.parent !== r || r.first !== s) && typeof s.raws.before < "u")
          return a = s.raws.before, a.includes(`
`) && (a = a.replace(/[^\n]+$/, "")), !1;
      }), a && (a = a.replace(/\S/g, "")), a;
    }
    rawColon(r) {
      let a;
      return r.walkDecls((s) => {
        if (typeof s.raws.between < "u")
          return a = s.raws.between.replace(/[^\s:]/g, ""), !1;
      }), a;
    }
    rawEmptyBody(r) {
      let a;
      return r.walk((s) => {
        if (s.nodes && s.nodes.length === 0 && (a = s.raws.after, typeof a < "u"))
          return !1;
      }), a;
    }
    rawIndent(r) {
      if (r.raws.indent) return r.raws.indent;
      let a;
      return r.walk((s) => {
        let o = s.parent;
        if (o && o !== r && o.parent && o.parent === r && typeof s.raws.before < "u") {
          let u = s.raws.before.split(`
`);
          return a = u[u.length - 1], a = a.replace(/\S/g, ""), !1;
        }
      }), a;
    }
    rawSemicolon(r) {
      let a;
      return r.walk((s) => {
        if (s.nodes && s.nodes.length && s.last.type === "decl" && (a = s.raws.semicolon, typeof a < "u"))
          return !1;
      }), a;
    }
    rawValue(r, a) {
      let s = r[a], o = r.raws[a];
      return o && o.value === s ? o.raw : s;
    }
    root(r) {
      this.body(r), r.raws.after && this.builder(r.raws.after);
    }
    rule(r) {
      this.block(r, this.rawValue(r, "selector")), r.raws.ownSemicolon && this.builder(r.raws.ownSemicolon, r, "end");
    }
    stringify(r, a) {
      if (!this[r.type])
        throw new Error(
          "Unknown AST node type " + r.type + ". Maybe you need to change PostCSS stringifier."
        );
      this[r.type](r, a);
    }
  }
  return Dd = t, t.default = t, Dd;
}
var Sd, Ay;
function Uc() {
  if (Ay) return Sd;
  Ay = 1;
  let n = LT();
  function e(t, i) {
    new n(i).stringify(t);
  }
  return Sd = e, e.default = e, Sd;
}
var Qo = {}, ky;
function Hm() {
  return ky || (ky = 1, Qo.isClean = Symbol("isClean"), Qo.my = Symbol("my")), Qo;
}
var Cd, Iy;
function Rc() {
  if (Iy) return Cd;
  Iy = 1;
  let n = Vm(), e = LT(), t = Uc(), { isClean: i, my: r } = Hm();
  function a(u, c) {
    let l = new u.constructor();
    for (let h in u) {
      if (!Object.prototype.hasOwnProperty.call(u, h) || h === "proxyCache") continue;
      let f = u[h], d = typeof f;
      h === "parent" && d === "object" ? c && (l[h] = c) : h === "source" ? l[h] = f : Array.isArray(f) ? l[h] = f.map((y) => a(y, l)) : (d === "object" && f !== null && (f = a(f)), l[h] = f);
    }
    return l;
  }
  function s(u, c) {
    if (c && typeof c.offset < "u")
      return c.offset;
    let l = 1, h = 1, f = 0;
    for (let d = 0; d < u.length; d++) {
      if (h === c.line && l === c.column) {
        f = d;
        break;
      }
      u[d] === `
` ? (l = 1, h += 1) : l += 1;
    }
    return f;
  }
  class o {
    get proxyOf() {
      return this;
    }
    constructor(c = {}) {
      this.raws = {}, this[i] = !1, this[r] = !0;
      for (let l in c)
        if (l === "nodes") {
          this.nodes = [];
          for (let h of c[l])
            typeof h.clone == "function" ? this.append(h.clone()) : this.append(h);
        } else
          this[l] = c[l];
    }
    addToError(c) {
      if (c.postcssNode = this, c.stack && this.source && /\n\s{4}at /.test(c.stack)) {
        let l = this.source;
        c.stack = c.stack.replace(
          /\n\s{4}at /,
          `$&${l.input.from}:${l.start.line}:${l.start.column}$&`
        );
      }
      return c;
    }
    after(c) {
      return this.parent.insertAfter(this, c), this;
    }
    assign(c = {}) {
      for (let l in c)
        this[l] = c[l];
      return this;
    }
    before(c) {
      return this.parent.insertBefore(this, c), this;
    }
    cleanRaws(c) {
      delete this.raws.before, delete this.raws.after, c || delete this.raws.between;
    }
    clone(c = {}) {
      let l = a(this);
      for (let h in c)
        l[h] = c[h];
      return l;
    }
    cloneAfter(c = {}) {
      let l = this.clone(c);
      return this.parent.insertAfter(this, l), l;
    }
    cloneBefore(c = {}) {
      let l = this.clone(c);
      return this.parent.insertBefore(this, l), l;
    }
    error(c, l = {}) {
      if (this.source) {
        let { end: h, start: f } = this.rangeBy(l);
        return this.source.input.error(
          c,
          { column: f.column, line: f.line },
          { column: h.column, line: h.line },
          l
        );
      }
      return new n(c);
    }
    getProxyProcessor() {
      return {
        get(c, l) {
          return l === "proxyOf" ? c : l === "root" ? () => c.root().toProxy() : c[l];
        },
        set(c, l, h) {
          return c[l] === h || (c[l] = h, (l === "prop" || l === "value" || l === "name" || l === "params" || l === "important" || /* c8 ignore next */
          l === "text") && c.markDirty()), !0;
        }
      };
    }
    /* c8 ignore next 3 */
    markClean() {
      this[i] = !0;
    }
    markDirty() {
      if (this[i]) {
        this[i] = !1;
        let c = this;
        for (; c = c.parent; )
          c[i] = !1;
      }
    }
    next() {
      if (!this.parent) return;
      let c = this.parent.index(this);
      return this.parent.nodes[c + 1];
    }
    positionBy(c = {}) {
      let l = this.source.start;
      if (c.index)
        l = this.positionInside(c.index);
      else if (c.word) {
        let h = "document" in this.source.input ? this.source.input.document : this.source.input.css, d = h.slice(
          s(h, this.source.start),
          s(h, this.source.end)
        ).indexOf(c.word);
        d !== -1 && (l = this.positionInside(d));
      }
      return l;
    }
    positionInside(c) {
      let l = this.source.start.column, h = this.source.start.line, f = "document" in this.source.input ? this.source.input.document : this.source.input.css, d = s(f, this.source.start), y = d + c;
      for (let m = d; m < y; m++)
        f[m] === `
` ? (l = 1, h += 1) : l += 1;
      return { column: l, line: h, offset: y };
    }
    prev() {
      if (!this.parent) return;
      let c = this.parent.index(this);
      return this.parent.nodes[c - 1];
    }
    rangeBy(c = {}) {
      let l = "document" in this.source.input ? this.source.input.document : this.source.input.css, h = {
        column: this.source.start.column,
        line: this.source.start.line,
        offset: s(l, this.source.start)
      }, f = this.source.end ? {
        column: this.source.end.column + 1,
        line: this.source.end.line,
        offset: typeof this.source.end.offset == "number" ? (
          // `source.end.offset` is exclusive, so we don't need to add 1
          this.source.end.offset
        ) : (
          // Since line/column in this.source.end is inclusive,
          // the `sourceOffset(... , this.source.end)` returns an inclusive offset.
          // So, we add 1 to convert it to exclusive.
          s(l, this.source.end) + 1
        )
      } : {
        column: h.column + 1,
        line: h.line,
        offset: h.offset + 1
      };
      if (c.word) {
        let y = l.slice(
          s(l, this.source.start),
          s(l, this.source.end)
        ).indexOf(c.word);
        y !== -1 && (h = this.positionInside(y), f = this.positionInside(y + c.word.length));
      } else
        c.start ? h = {
          column: c.start.column,
          line: c.start.line,
          offset: s(l, c.start)
        } : c.index && (h = this.positionInside(c.index)), c.end ? f = {
          column: c.end.column,
          line: c.end.line,
          offset: s(l, c.end)
        } : typeof c.endIndex == "number" ? f = this.positionInside(c.endIndex) : c.index && (f = this.positionInside(c.index + 1));
      return (f.line < h.line || f.line === h.line && f.column <= h.column) && (f = {
        column: h.column + 1,
        line: h.line,
        offset: h.offset + 1
      }), { end: f, start: h };
    }
    raw(c, l) {
      return new e().raw(this, c, l);
    }
    remove() {
      return this.parent && this.parent.removeChild(this), this.parent = void 0, this;
    }
    replaceWith(...c) {
      if (this.parent) {
        let l = this, h = !1;
        for (let f of c)
          f === this ? h = !0 : h ? (this.parent.insertAfter(l, f), l = f) : this.parent.insertBefore(l, f);
        h || this.remove();
      }
      return this;
    }
    root() {
      let c = this;
      for (; c.parent && c.parent.type !== "document"; )
        c = c.parent;
      return c;
    }
    toJSON(c, l) {
      let h = {}, f = l == null;
      l = l || /* @__PURE__ */ new Map();
      let d = 0;
      for (let y in this) {
        if (!Object.prototype.hasOwnProperty.call(this, y) || y === "parent" || y === "proxyCache") continue;
        let m = this[y];
        if (Array.isArray(m))
          h[y] = m.map((b) => typeof b == "object" && b.toJSON ? b.toJSON(null, l) : b);
        else if (typeof m == "object" && m.toJSON)
          h[y] = m.toJSON(null, l);
        else if (y === "source") {
          if (m == null) continue;
          let b = l.get(m.input);
          b == null && (b = d, l.set(m.input, d), d++), h[y] = {
            end: m.end,
            inputId: b,
            start: m.start
          };
        } else
          h[y] = m;
      }
      return f && (h.inputs = [...l.keys()].map((y) => y.toJSON())), h;
    }
    toProxy() {
      return this.proxyCache || (this.proxyCache = new Proxy(this, this.getProxyProcessor())), this.proxyCache;
    }
    toString(c = t) {
      c.stringify && (c = c.stringify);
      let l = "";
      return c(this, (h) => {
        l += h;
      }), l;
    }
    warn(c, l, h = {}) {
      let f = { node: this };
      for (let d in h) f[d] = h[d];
      return c.warn(l, f);
    }
  }
  return Cd = o, o.default = o, Cd;
}
var Ad, Uy;
function Oc() {
  if (Uy) return Ad;
  Uy = 1;
  let n = Rc();
  class e extends n {
    constructor(i) {
      super(i), this.type = "comment";
    }
  }
  return Ad = e, e.default = e, Ad;
}
var kd, Ry;
function Lc() {
  if (Ry) return kd;
  Ry = 1;
  let n = Rc();
  class e extends n {
    get variable() {
      return this.prop.startsWith("--") || this.prop[0] === "$";
    }
    constructor(i) {
      i && typeof i.value < "u" && typeof i.value != "string" && (i = { ...i, value: String(i.value) }), super(i), this.type = "decl";
    }
  }
  return kd = e, e.default = e, kd;
}
var Id, Oy;
function Br() {
  if (Oy) return Id;
  Oy = 1;
  let n = Oc(), e = Lc(), t = Rc(), { isClean: i, my: r } = Hm(), a, s, o, u;
  function c(f) {
    return f.map((d) => (d.nodes && (d.nodes = c(d.nodes)), delete d.source, d));
  }
  function l(f) {
    if (f[i] = !1, f.proxyOf.nodes)
      for (let d of f.proxyOf.nodes)
        l(d);
  }
  class h extends t {
    get first() {
      if (this.proxyOf.nodes)
        return this.proxyOf.nodes[0];
    }
    get last() {
      if (this.proxyOf.nodes)
        return this.proxyOf.nodes[this.proxyOf.nodes.length - 1];
    }
    append(...d) {
      for (let y of d) {
        let m = this.normalize(y, this.last);
        for (let b of m) this.proxyOf.nodes.push(b);
      }
      return this.markDirty(), this;
    }
    cleanRaws(d) {
      if (super.cleanRaws(d), this.nodes)
        for (let y of this.nodes) y.cleanRaws(d);
    }
    each(d) {
      if (!this.proxyOf.nodes) return;
      let y = this.getIterator(), m, b;
      for (; this.indexes[y] < this.proxyOf.nodes.length && (m = this.indexes[y], b = d(this.proxyOf.nodes[m], m), b !== !1); )
        this.indexes[y] += 1;
      return delete this.indexes[y], b;
    }
    every(d) {
      return this.nodes.every(d);
    }
    getIterator() {
      this.lastEach || (this.lastEach = 0), this.indexes || (this.indexes = {}), this.lastEach += 1;
      let d = this.lastEach;
      return this.indexes[d] = 0, d;
    }
    getProxyProcessor() {
      return {
        get(d, y) {
          return y === "proxyOf" ? d : d[y] ? y === "each" || typeof y == "string" && y.startsWith("walk") ? (...m) => d[y](
            ...m.map((b) => typeof b == "function" ? (p, g) => b(p.toProxy(), g) : b)
          ) : y === "every" || y === "some" ? (m) => d[y](
            (b, ...p) => m(b.toProxy(), ...p)
          ) : y === "root" ? () => d.root().toProxy() : y === "nodes" ? d.nodes.map((m) => m.toProxy()) : y === "first" || y === "last" ? d[y].toProxy() : d[y] : d[y];
        },
        set(d, y, m) {
          return d[y] === m || (d[y] = m, (y === "name" || y === "params" || y === "selector") && d.markDirty()), !0;
        }
      };
    }
    index(d) {
      return typeof d == "number" ? d : (d.proxyOf && (d = d.proxyOf), this.proxyOf.nodes.indexOf(d));
    }
    insertAfter(d, y) {
      let m = this.index(d), b = this.normalize(y, this.proxyOf.nodes[m]).reverse();
      m = this.index(d);
      for (let g of b) this.proxyOf.nodes.splice(m + 1, 0, g);
      let p;
      for (let g in this.indexes)
        p = this.indexes[g], m < p && (this.indexes[g] = p + b.length);
      return this.markDirty(), this;
    }
    insertBefore(d, y) {
      let m = this.index(d), b = m === 0 ? "prepend" : !1, p = this.normalize(
        y,
        this.proxyOf.nodes[m],
        b
      ).reverse();
      m = this.index(d);
      for (let v of p) this.proxyOf.nodes.splice(m, 0, v);
      let g;
      for (let v in this.indexes)
        g = this.indexes[v], m <= g && (this.indexes[v] = g + p.length);
      return this.markDirty(), this;
    }
    normalize(d, y) {
      if (typeof d == "string")
        d = c(s(d).nodes);
      else if (typeof d > "u")
        d = [];
      else if (Array.isArray(d)) {
        d = d.slice(0);
        for (let b of d)
          b.parent && b.parent.removeChild(b, "ignore");
      } else if (d.type === "root" && this.type !== "document") {
        d = d.nodes.slice(0);
        for (let b of d)
          b.parent && b.parent.removeChild(b, "ignore");
      } else if (d.type)
        d = [d];
      else if (d.prop) {
        if (typeof d.value > "u")
          throw new Error("Value field is missed in node creation");
        typeof d.value != "string" && (d.value = String(d.value)), d = [new e(d)];
      } else if (d.selector || d.selectors)
        d = [new u(d)];
      else if (d.name)
        d = [new a(d)];
      else if (d.text)
        d = [new n(d)];
      else
        throw new Error("Unknown node type in node creation");
      return d.map((b) => (b[r] || h.rebuild(b), b = b.proxyOf, b.parent && b.parent.removeChild(b), b[i] && l(b), b.raws || (b.raws = {}), typeof b.raws.before > "u" && y && typeof y.raws.before < "u" && (b.raws.before = y.raws.before.replace(/\S/g, "")), b.parent = this.proxyOf, b));
    }
    prepend(...d) {
      d = d.reverse();
      for (let y of d) {
        let m = this.normalize(y, this.first, "prepend").reverse();
        for (let b of m) this.proxyOf.nodes.unshift(b);
        for (let b in this.indexes)
          this.indexes[b] = this.indexes[b] + m.length;
      }
      return this.markDirty(), this;
    }
    push(d) {
      return d.parent = this, this.proxyOf.nodes.push(d), this;
    }
    removeAll() {
      for (let d of this.proxyOf.nodes) d.parent = void 0;
      return this.proxyOf.nodes = [], this.markDirty(), this;
    }
    removeChild(d) {
      d = this.index(d), this.proxyOf.nodes[d].parent = void 0, this.proxyOf.nodes.splice(d, 1);
      let y;
      for (let m in this.indexes)
        y = this.indexes[m], y >= d && (this.indexes[m] = y - 1);
      return this.markDirty(), this;
    }
    replaceValues(d, y, m) {
      return m || (m = y, y = {}), this.walkDecls((b) => {
        y.props && !y.props.includes(b.prop) || y.fast && !b.value.includes(y.fast) || (b.value = b.value.replace(d, m));
      }), this.markDirty(), this;
    }
    some(d) {
      return this.nodes.some(d);
    }
    walk(d) {
      return this.each((y, m) => {
        let b;
        try {
          b = d(y, m);
        } catch (p) {
          throw y.addToError(p);
        }
        return b !== !1 && y.walk && (b = y.walk(d)), b;
      });
    }
    walkAtRules(d, y) {
      return y ? d instanceof RegExp ? this.walk((m, b) => {
        if (m.type === "atrule" && d.test(m.name))
          return y(m, b);
      }) : this.walk((m, b) => {
        if (m.type === "atrule" && m.name === d)
          return y(m, b);
      }) : (y = d, this.walk((m, b) => {
        if (m.type === "atrule")
          return y(m, b);
      }));
    }
    walkComments(d) {
      return this.walk((y, m) => {
        if (y.type === "comment")
          return d(y, m);
      });
    }
    walkDecls(d, y) {
      return y ? d instanceof RegExp ? this.walk((m, b) => {
        if (m.type === "decl" && d.test(m.prop))
          return y(m, b);
      }) : this.walk((m, b) => {
        if (m.type === "decl" && m.prop === d)
          return y(m, b);
      }) : (y = d, this.walk((m, b) => {
        if (m.type === "decl")
          return y(m, b);
      }));
    }
    walkRules(d, y) {
      return y ? d instanceof RegExp ? this.walk((m, b) => {
        if (m.type === "rule" && d.test(m.selector))
          return y(m, b);
      }) : this.walk((m, b) => {
        if (m.type === "rule" && m.selector === d)
          return y(m, b);
      }) : (y = d, this.walk((m, b) => {
        if (m.type === "rule")
          return y(m, b);
      }));
    }
  }
  return h.registerParse = (f) => {
    s = f;
  }, h.registerRule = (f) => {
    u = f;
  }, h.registerAtRule = (f) => {
    a = f;
  }, h.registerRoot = (f) => {
    o = f;
  }, Id = h, h.default = h, h.rebuild = (f) => {
    f.type === "atrule" ? Object.setPrototypeOf(f, a.prototype) : f.type === "rule" ? Object.setPrototypeOf(f, u.prototype) : f.type === "decl" ? Object.setPrototypeOf(f, e.prototype) : f.type === "comment" ? Object.setPrototypeOf(f, n.prototype) : f.type === "root" && Object.setPrototypeOf(f, o.prototype), f[r] = !0, f.nodes && f.nodes.forEach((d) => {
      h.rebuild(d);
    });
  }, Id;
}
var Ud, Ly;
function zm() {
  if (Ly) return Ud;
  Ly = 1;
  let n = Br();
  class e extends n {
    constructor(i) {
      super(i), this.type = "atrule";
    }
    append(...i) {
      return this.proxyOf.nodes || (this.nodes = []), super.append(...i);
    }
    prepend(...i) {
      return this.proxyOf.nodes || (this.nodes = []), super.prepend(...i);
    }
  }
  return Ud = e, e.default = e, n.registerAtRule(e), Ud;
}
var Rd, Py;
function $m() {
  if (Py) return Rd;
  Py = 1;
  let n = Br(), e, t;
  class i extends n {
    constructor(a) {
      super({ type: "document", ...a }), this.nodes || (this.nodes = []);
    }
    toResult(a = {}) {
      return new e(new t(), this, a).stringify();
    }
  }
  return i.registerLazyResult = (r) => {
    e = r;
  }, i.registerProcessor = (r) => {
    t = r;
  }, Rd = i, i.default = i, Rd;
}
var Od, Fy;
function m4() {
  if (Fy) return Od;
  Fy = 1;
  let n = "useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict";
  return Od = { nanoid: (i = 21) => {
    let r = "", a = i | 0;
    for (; a--; )
      r += n[Math.random() * 64 | 0];
    return r;
  }, customAlphabet: (i, r = 21) => (a = r) => {
    let s = "", o = a | 0;
    for (; o--; )
      s += i[Math.random() * i.length | 0];
    return s;
  } }, Od;
}
var Ld, Ny;
function Pc() {
  if (Ny) return Ld;
  Ny = 1;
  function n(r) {
    if (typeof r != "string")
      throw new TypeError("Path must be a string. Received " + JSON.stringify(r));
  }
  function e(r, a) {
    for (var s = "", o = 0, u = -1, c = 0, l, h = 0; h <= r.length; ++h) {
      if (h < r.length)
        l = r.charCodeAt(h);
      else {
        if (l === 47)
          break;
        l = 47;
      }
      if (l === 47) {
        if (!(u === h - 1 || c === 1)) if (u !== h - 1 && c === 2) {
          if (s.length < 2 || o !== 2 || s.charCodeAt(s.length - 1) !== 46 || s.charCodeAt(s.length - 2) !== 46) {
            if (s.length > 2) {
              var f = s.lastIndexOf("/");
              if (f !== s.length - 1) {
                f === -1 ? (s = "", o = 0) : (s = s.slice(0, f), o = s.length - 1 - s.lastIndexOf("/")), u = h, c = 0;
                continue;
              }
            } else if (s.length === 2 || s.length === 1) {
              s = "", o = 0, u = h, c = 0;
              continue;
            }
          }
          a && (s.length > 0 ? s += "/.." : s = "..", o = 2);
        } else
          s.length > 0 ? s += "/" + r.slice(u + 1, h) : s = r.slice(u + 1, h), o = h - u - 1;
        u = h, c = 0;
      } else l === 46 && c !== -1 ? ++c : c = -1;
    }
    return s;
  }
  function t(r, a) {
    var s = a.dir || a.root, o = a.base || (a.name || "") + (a.ext || "");
    return s ? s === a.root ? s + o : s + r + o : o;
  }
  var i = {
    // path.resolve([from ...], to)
    resolve: function() {
      for (var a = "", s = !1, o, u = arguments.length - 1; u >= -1 && !s; u--) {
        var c;
        u >= 0 ? c = arguments[u] : (o === void 0 && (o = process.cwd()), c = o), n(c), c.length !== 0 && (a = c + "/" + a, s = c.charCodeAt(0) === 47);
      }
      return a = e(a, !s), s ? a.length > 0 ? "/" + a : "/" : a.length > 0 ? a : ".";
    },
    normalize: function(a) {
      if (n(a), a.length === 0) return ".";
      var s = a.charCodeAt(0) === 47, o = a.charCodeAt(a.length - 1) === 47;
      return a = e(a, !s), a.length === 0 && !s && (a = "."), a.length > 0 && o && (a += "/"), s ? "/" + a : a;
    },
    isAbsolute: function(a) {
      return n(a), a.length > 0 && a.charCodeAt(0) === 47;
    },
    join: function() {
      if (arguments.length === 0)
        return ".";
      for (var a, s = 0; s < arguments.length; ++s) {
        var o = arguments[s];
        n(o), o.length > 0 && (a === void 0 ? a = o : a += "/" + o);
      }
      return a === void 0 ? "." : i.normalize(a);
    },
    relative: function(a, s) {
      if (n(a), n(s), a === s || (a = i.resolve(a), s = i.resolve(s), a === s)) return "";
      for (var o = 1; o < a.length && a.charCodeAt(o) === 47; ++o)
        ;
      for (var u = a.length, c = u - o, l = 1; l < s.length && s.charCodeAt(l) === 47; ++l)
        ;
      for (var h = s.length, f = h - l, d = c < f ? c : f, y = -1, m = 0; m <= d; ++m) {
        if (m === d) {
          if (f > d) {
            if (s.charCodeAt(l + m) === 47)
              return s.slice(l + m + 1);
            if (m === 0)
              return s.slice(l + m);
          } else c > d && (a.charCodeAt(o + m) === 47 ? y = m : m === 0 && (y = 0));
          break;
        }
        var b = a.charCodeAt(o + m), p = s.charCodeAt(l + m);
        if (b !== p)
          break;
        b === 47 && (y = m);
      }
      var g = "";
      for (m = o + y + 1; m <= u; ++m)
        (m === u || a.charCodeAt(m) === 47) && (g.length === 0 ? g += ".." : g += "/..");
      return g.length > 0 ? g + s.slice(l + y) : (l += y, s.charCodeAt(l) === 47 && ++l, s.slice(l));
    },
    _makeLong: function(a) {
      return a;
    },
    dirname: function(a) {
      if (n(a), a.length === 0) return ".";
      for (var s = a.charCodeAt(0), o = s === 47, u = -1, c = !0, l = a.length - 1; l >= 1; --l)
        if (s = a.charCodeAt(l), s === 47) {
          if (!c) {
            u = l;
            break;
          }
        } else
          c = !1;
      return u === -1 ? o ? "/" : "." : o && u === 1 ? "//" : a.slice(0, u);
    },
    basename: function(a, s) {
      if (s !== void 0 && typeof s != "string") throw new TypeError('"ext" argument must be a string');
      n(a);
      var o = 0, u = -1, c = !0, l;
      if (s !== void 0 && s.length > 0 && s.length <= a.length) {
        if (s.length === a.length && s === a) return "";
        var h = s.length - 1, f = -1;
        for (l = a.length - 1; l >= 0; --l) {
          var d = a.charCodeAt(l);
          if (d === 47) {
            if (!c) {
              o = l + 1;
              break;
            }
          } else
            f === -1 && (c = !1, f = l + 1), h >= 0 && (d === s.charCodeAt(h) ? --h === -1 && (u = l) : (h = -1, u = f));
        }
        return o === u ? u = f : u === -1 && (u = a.length), a.slice(o, u);
      } else {
        for (l = a.length - 1; l >= 0; --l)
          if (a.charCodeAt(l) === 47) {
            if (!c) {
              o = l + 1;
              break;
            }
          } else u === -1 && (c = !1, u = l + 1);
        return u === -1 ? "" : a.slice(o, u);
      }
    },
    extname: function(a) {
      n(a);
      for (var s = -1, o = 0, u = -1, c = !0, l = 0, h = a.length - 1; h >= 0; --h) {
        var f = a.charCodeAt(h);
        if (f === 47) {
          if (!c) {
            o = h + 1;
            break;
          }
          continue;
        }
        u === -1 && (c = !1, u = h + 1), f === 46 ? s === -1 ? s = h : l !== 1 && (l = 1) : s !== -1 && (l = -1);
      }
      return s === -1 || u === -1 || // We saw a non-dot character immediately before the dot
      l === 0 || // The (right-most) trimmed path component is exactly '..'
      l === 1 && s === u - 1 && s === o + 1 ? "" : a.slice(s, u);
    },
    format: function(a) {
      if (a === null || typeof a != "object")
        throw new TypeError('The "pathObject" argument must be of type Object. Received type ' + typeof a);
      return t("/", a);
    },
    parse: function(a) {
      n(a);
      var s = { root: "", dir: "", base: "", ext: "", name: "" };
      if (a.length === 0) return s;
      var o = a.charCodeAt(0), u = o === 47, c;
      u ? (s.root = "/", c = 1) : c = 0;
      for (var l = -1, h = 0, f = -1, d = !0, y = a.length - 1, m = 0; y >= c; --y) {
        if (o = a.charCodeAt(y), o === 47) {
          if (!d) {
            h = y + 1;
            break;
          }
          continue;
        }
        f === -1 && (d = !1, f = y + 1), o === 46 ? l === -1 ? l = y : m !== 1 && (m = 1) : l !== -1 && (m = -1);
      }
      return l === -1 || f === -1 || // We saw a non-dot character immediately before the dot
      m === 0 || // The (right-most) trimmed path component is exactly '..'
      m === 1 && l === f - 1 && l === h + 1 ? f !== -1 && (h === 0 && u ? s.base = s.name = a.slice(1, f) : s.base = s.name = a.slice(h, f)) : (h === 0 && u ? (s.name = a.slice(1, l), s.base = a.slice(1, f)) : (s.name = a.slice(h, l), s.base = a.slice(h, f)), s.ext = a.slice(l, f)), h > 0 ? s.dir = a.slice(0, h - 1) : u && (s.dir = "/"), s;
    },
    sep: "/",
    delimiter: ":",
    win32: null,
    posix: null
  };
  return i.posix = i, Ld = i, Ld;
}
var Pd, My;
function PT() {
  if (My) return Pd;
  My = 1;
  let { existsSync: n, readFileSync: e } = ni, { dirname: t, join: i } = Pc(), { SourceMapConsumer: r, SourceMapGenerator: a } = ni;
  function s(u) {
    return Buffer ? Buffer.from(u, "base64").toString() : window.atob(u);
  }
  class o {
    constructor(c, l) {
      if (l.map === !1) return;
      this.loadAnnotation(c), this.inline = this.startWith(this.annotation, "data:");
      let h = l.map ? l.map.prev : void 0, f = this.loadMap(l.from, h);
      !this.mapFile && l.from && (this.mapFile = l.from), this.mapFile && (this.root = t(this.mapFile)), f && (this.text = f);
    }
    consumer() {
      return this.consumerCache || (this.consumerCache = new r(this.text)), this.consumerCache;
    }
    decodeInline(c) {
      let l = /^data:application\/json;charset=utf-?8;base64,/, h = /^data:application\/json;base64,/, f = /^data:application\/json;charset=utf-?8,/, d = /^data:application\/json,/, y = c.match(f) || c.match(d);
      if (y)
        return decodeURIComponent(c.substr(y[0].length));
      let m = c.match(l) || c.match(h);
      if (m)
        return s(c.substr(m[0].length));
      let b = c.match(/data:application\/json;([^,]+),/)[1];
      throw new Error("Unsupported source map encoding " + b);
    }
    getAnnotationURL(c) {
      return c.replace(/^\/\*\s*# sourceMappingURL=/, "").trim();
    }
    isMap(c) {
      return typeof c != "object" ? !1 : typeof c.mappings == "string" || typeof c._mappings == "string" || Array.isArray(c.sections);
    }
    loadAnnotation(c) {
      let l = c.match(/\/\*\s*# sourceMappingURL=/g);
      if (!l) return;
      let h = c.lastIndexOf(l.pop()), f = c.indexOf("*/", h);
      h > -1 && f > -1 && (this.annotation = this.getAnnotationURL(c.substring(h, f)));
    }
    loadFile(c) {
      if (this.root = t(c), n(c))
        return this.mapFile = c, e(c, "utf-8").toString().trim();
    }
    loadMap(c, l) {
      if (l === !1) return !1;
      if (l) {
        if (typeof l == "string")
          return l;
        if (typeof l == "function") {
          let h = l(c);
          if (h) {
            let f = this.loadFile(h);
            if (!f)
              throw new Error(
                "Unable to load previous source map: " + h.toString()
              );
            return f;
          }
        } else {
          if (l instanceof r)
            return a.fromSourceMap(l).toString();
          if (l instanceof a)
            return l.toString();
          if (this.isMap(l))
            return JSON.stringify(l);
          throw new Error(
            "Unsupported previous source map format: " + l.toString()
          );
        }
      } else {
        if (this.inline)
          return this.decodeInline(this.annotation);
        if (this.annotation) {
          let h = this.annotation;
          return c && (h = i(t(c), h)), this.loadFile(h);
        }
      }
    }
    startWith(c, l) {
      return c ? c.substr(0, l.length) === l : !1;
    }
    withContent() {
      return !!(this.consumer().sourcesContent && this.consumer().sourcesContent.length > 0);
    }
  }
  return Pd = o, o.default = o, Pd;
}
var Fd, By;
function Fc() {
  if (By) return Fd;
  By = 1;
  let { nanoid: n } = /* @__PURE__ */ m4(), { isAbsolute: e, resolve: t } = Pc(), { SourceMapConsumer: i, SourceMapGenerator: r } = ni, { fileURLToPath: a, pathToFileURL: s } = ni, o = Vm(), u = PT(), c = ni, l = Symbol("lineToIndexCache"), h = !!(i && r), f = !!(t && e);
  function d(m) {
    if (m[l]) return m[l];
    let b = m.css.split(`
`), p = new Array(b.length), g = 0;
    for (let v = 0, _ = b.length; v < _; v++)
      p[v] = g, g += b[v].length + 1;
    return m[l] = p, p;
  }
  class y {
    get from() {
      return this.file || this.id;
    }
    constructor(b, p = {}) {
      if (b === null || typeof b > "u" || typeof b == "object" && !b.toString)
        throw new Error(`PostCSS received ${b} instead of CSS string`);
      if (this.css = b.toString(), this.css[0] === "\uFEFF" || this.css[0] === "" ? (this.hasBOM = !0, this.css = this.css.slice(1)) : this.hasBOM = !1, this.document = this.css, p.document && (this.document = p.document.toString()), p.from && (!f || /^\w+:\/\//.test(p.from) || e(p.from) ? this.file = p.from : this.file = t(p.from)), f && h) {
        let g = new u(this.css, p);
        if (g.text) {
          this.map = g;
          let v = g.consumer().file;
          !this.file && v && (this.file = this.mapResolve(v));
        }
      }
      this.file || (this.id = "<input css " + n(6) + ">"), this.map && (this.map.file = this.from);
    }
    error(b, p, g, v = {}) {
      let _, x, T, E, U;
      if (p && typeof p == "object") {
        let L = p, j = g;
        if (typeof L.offset == "number") {
          E = L.offset;
          let C = this.fromOffset(E);
          p = C.line, g = C.col;
        } else
          p = L.line, g = L.column, E = this.fromLineAndColumn(p, g);
        if (typeof j.offset == "number") {
          T = j.offset;
          let C = this.fromOffset(T);
          x = C.line, _ = C.col;
        } else
          x = j.line, _ = j.column, T = this.fromLineAndColumn(j.line, j.column);
      } else if (g)
        E = this.fromLineAndColumn(p, g);
      else {
        E = p;
        let L = this.fromOffset(E);
        p = L.line, g = L.col;
      }
      let D = this.origin(p, g, x, _);
      return D ? U = new o(
        b,
        D.endLine === void 0 ? D.line : { column: D.column, line: D.line },
        D.endLine === void 0 ? D.column : { column: D.endColumn, line: D.endLine },
        D.source,
        D.file,
        v.plugin
      ) : U = new o(
        b,
        x === void 0 ? p : { column: g, line: p },
        x === void 0 ? g : { column: _, line: x },
        this.css,
        this.file,
        v.plugin
      ), U.input = { column: g, endColumn: _, endLine: x, endOffset: T, line: p, offset: E, source: this.css }, this.file && (s && (U.input.url = s(this.file).toString()), U.input.file = this.file), U;
    }
    fromLineAndColumn(b, p) {
      return d(this)[b - 1] + p - 1;
    }
    fromOffset(b) {
      let p = d(this), g = p[p.length - 1], v = 0;
      if (b >= g)
        v = p.length - 1;
      else {
        let _ = p.length - 2, x;
        for (; v < _; )
          if (x = v + (_ - v >> 1), b < p[x])
            _ = x - 1;
          else if (b >= p[x + 1])
            v = x + 1;
          else {
            v = x;
            break;
          }
      }
      return {
        col: b - p[v] + 1,
        line: v + 1
      };
    }
    mapResolve(b) {
      return /^\w+:\/\//.test(b) ? b : t(this.map.consumer().sourceRoot || this.map.root || ".", b);
    }
    origin(b, p, g, v) {
      if (!this.map) return !1;
      let _ = this.map.consumer(), x = _.originalPositionFor({ column: p, line: b });
      if (!x.source) return !1;
      let T;
      typeof g == "number" && (T = _.originalPositionFor({ column: v, line: g }));
      let E;
      e(x.source) ? E = s(x.source) : E = new URL(
        x.source,
        this.map.consumer().sourceRoot || s(this.map.mapFile)
      );
      let U = {
        column: x.column,
        endColumn: T && T.column,
        endLine: T && T.line,
        line: x.line,
        url: E.toString()
      };
      if (E.protocol === "file:")
        if (a)
          U.file = a(E);
        else
          throw new Error("file: protocol is not available in this PostCSS build");
      let D = _.sourceContentFor(x.source);
      return D && (U.source = D), U;
    }
    toJSON() {
      let b = {};
      for (let p of ["hasBOM", "css", "file", "id"])
        this[p] != null && (b[p] = this[p]);
      return this.map && (b.map = { ...this.map }, b.map.consumerCache && (b.map.consumerCache = void 0)), b;
    }
  }
  return Fd = y, y.default = y, c && c.registerInput && c.registerInput(y), Fd;
}
var Nd, jy;
function ro() {
  if (jy) return Nd;
  jy = 1;
  let n = Br(), e, t;
  class i extends n {
    constructor(a) {
      super(a), this.type = "root", this.nodes || (this.nodes = []);
    }
    normalize(a, s, o) {
      let u = super.normalize(a);
      if (s) {
        if (o === "prepend")
          this.nodes.length > 1 ? s.raws.before = this.nodes[1].raws.before : delete s.raws.before;
        else if (this.first !== s)
          for (let c of u)
            c.raws.before = s.raws.before;
      }
      return u;
    }
    removeChild(a, s) {
      let o = this.index(a);
      return !s && o === 0 && this.nodes.length > 1 && (this.nodes[1].raws.before = this.nodes[o].raws.before), super.removeChild(a);
    }
    toResult(a = {}) {
      return new e(new t(), this, a).stringify();
    }
  }
  return i.registerLazyResult = (r) => {
    e = r;
  }, i.registerProcessor = (r) => {
    t = r;
  }, Nd = i, i.default = i, n.registerRoot(i), Nd;
}
var Md, qy;
function FT() {
  if (qy) return Md;
  qy = 1;
  let n = {
    comma(e) {
      return n.split(e, [","], !0);
    },
    space(e) {
      let t = [" ", `
`, "	"];
      return n.split(e, t);
    },
    split(e, t, i) {
      let r = [], a = "", s = !1, o = 0, u = !1, c = "", l = !1;
      for (let h of e)
        l ? l = !1 : h === "\\" ? l = !0 : u ? h === c && (u = !1) : h === '"' || h === "'" ? (u = !0, c = h) : h === "(" ? o += 1 : h === ")" ? o > 0 && (o -= 1) : o === 0 && t.includes(h) && (s = !0), s ? (a !== "" && r.push(a.trim()), a = "", s = !1) : a += h;
      return (i || a !== "") && r.push(a.trim()), r;
    }
  };
  return Md = n, n.default = n, Md;
}
var Bd, Wy;
function Gm() {
  if (Wy) return Bd;
  Wy = 1;
  let n = Br(), e = FT();
  class t extends n {
    get selectors() {
      return e.comma(this.selector);
    }
    set selectors(r) {
      let a = this.selector ? this.selector.match(/,\s*/) : null, s = a ? a[0] : "," + this.raw("between", "beforeOpen");
      this.selector = r.join(s);
    }
    constructor(r) {
      super(r), this.type = "rule", this.nodes || (this.nodes = []);
    }
  }
  return Bd = t, t.default = t, n.registerRule(t), Bd;
}
var jd, Vy;
function g4() {
  if (Vy) return jd;
  Vy = 1;
  let n = zm(), e = Oc(), t = Lc(), i = Fc(), r = PT(), a = ro(), s = Gm();
  function o(u, c) {
    if (Array.isArray(u)) return u.map((f) => o(f));
    let { inputs: l, ...h } = u;
    if (l) {
      c = [];
      for (let f of l) {
        let d = { ...f, __proto__: i.prototype };
        d.map && (d.map = {
          ...d.map,
          __proto__: r.prototype
        }), c.push(d);
      }
    }
    if (h.nodes && (h.nodes = u.nodes.map((f) => o(f, c))), h.source) {
      let { inputId: f, ...d } = h.source;
      h.source = d, f != null && (h.source.input = c[f]);
    }
    if (h.type === "root")
      return new a(h);
    if (h.type === "decl")
      return new t(h);
    if (h.type === "rule")
      return new s(h);
    if (h.type === "comment")
      return new e(h);
    if (h.type === "atrule")
      return new n(h);
    throw new Error("Unknown node type: " + u.type);
  }
  return jd = o, o.default = o, jd;
}
var qd, Hy;
function NT() {
  if (Hy) return qd;
  Hy = 1;
  let { dirname: n, relative: e, resolve: t, sep: i } = Pc(), { SourceMapConsumer: r, SourceMapGenerator: a } = ni, { pathToFileURL: s } = ni, o = Fc(), u = !!(r && a), c = !!(n && t && e && i);
  class l {
    constructor(f, d, y, m) {
      this.stringify = f, this.mapOpts = y.map || {}, this.root = d, this.opts = y, this.css = m, this.originalCSS = m, this.usesFileUrls = !this.mapOpts.from && this.mapOpts.absolute, this.memoizedFileURLs = /* @__PURE__ */ new Map(), this.memoizedPaths = /* @__PURE__ */ new Map(), this.memoizedURLs = /* @__PURE__ */ new Map();
    }
    addAnnotation() {
      let f;
      this.isInline() ? f = "data:application/json;base64," + this.toBase64(this.map.toString()) : typeof this.mapOpts.annotation == "string" ? f = this.mapOpts.annotation : typeof this.mapOpts.annotation == "function" ? f = this.mapOpts.annotation(this.opts.to, this.root) : f = this.outputFile() + ".map";
      let d = `
`;
      this.css.includes(`\r
`) && (d = `\r
`), this.css += d + "/*# sourceMappingURL=" + f + " */";
    }
    applyPrevMaps() {
      for (let f of this.previous()) {
        let d = this.toUrl(this.path(f.file)), y = f.root || n(f.file), m;
        this.mapOpts.sourcesContent === !1 ? (m = new r(f.text), m.sourcesContent && (m.sourcesContent = null)) : m = f.consumer(), this.map.applySourceMap(m, d, this.toUrl(this.path(y)));
      }
    }
    clearAnnotation() {
      if (this.mapOpts.annotation !== !1)
        if (this.root) {
          let f;
          for (let d = this.root.nodes.length - 1; d >= 0; d--)
            f = this.root.nodes[d], f.type === "comment" && f.text.startsWith("# sourceMappingURL=") && this.root.removeChild(d);
        } else this.css && (this.css = this.css.replace(/\n*\/\*#[\S\s]*?\*\/$/gm, ""));
    }
    generate() {
      if (this.clearAnnotation(), c && u && this.isMap())
        return this.generateMap();
      {
        let f = "";
        return this.stringify(this.root, (d) => {
          f += d;
        }), [f];
      }
    }
    generateMap() {
      if (this.root)
        this.generateString();
      else if (this.previous().length === 1) {
        let f = this.previous()[0].consumer();
        f.file = this.outputFile(), this.map = a.fromSourceMap(f, {
          ignoreInvalidMapping: !0
        });
      } else
        this.map = new a({
          file: this.outputFile(),
          ignoreInvalidMapping: !0
        }), this.map.addMapping({
          generated: { column: 0, line: 1 },
          original: { column: 0, line: 1 },
          source: this.opts.from ? this.toUrl(this.path(this.opts.from)) : "<no source>"
        });
      return this.isSourcesContent() && this.setSourcesContent(), this.root && this.previous().length > 0 && this.applyPrevMaps(), this.isAnnotation() && this.addAnnotation(), this.isInline() ? [this.css] : [this.css, this.map];
    }
    generateString() {
      this.css = "", this.map = new a({
        file: this.outputFile(),
        ignoreInvalidMapping: !0
      });
      let f = 1, d = 1, y = "<no source>", m = {
        generated: { column: 0, line: 0 },
        original: { column: 0, line: 0 },
        source: ""
      }, b, p;
      this.stringify(this.root, (g, v, _) => {
        if (this.css += g, v && _ !== "end" && (m.generated.line = f, m.generated.column = d - 1, v.source && v.source.start ? (m.source = this.sourcePath(v), m.original.line = v.source.start.line, m.original.column = v.source.start.column - 1, this.map.addMapping(m)) : (m.source = y, m.original.line = 1, m.original.column = 0, this.map.addMapping(m))), p = g.match(/\n/g), p ? (f += p.length, b = g.lastIndexOf(`
`), d = g.length - b) : d += g.length, v && _ !== "start") {
          let x = v.parent || { raws: {} };
          (!(v.type === "decl" || v.type === "atrule" && !v.nodes) || v !== x.last || x.raws.semicolon) && (v.source && v.source.end ? (m.source = this.sourcePath(v), m.original.line = v.source.end.line, m.original.column = v.source.end.column - 1, m.generated.line = f, m.generated.column = d - 2, this.map.addMapping(m)) : (m.source = y, m.original.line = 1, m.original.column = 0, m.generated.line = f, m.generated.column = d - 1, this.map.addMapping(m)));
        }
      });
    }
    isAnnotation() {
      return this.isInline() ? !0 : typeof this.mapOpts.annotation < "u" ? this.mapOpts.annotation : this.previous().length ? this.previous().some((f) => f.annotation) : !0;
    }
    isInline() {
      if (typeof this.mapOpts.inline < "u")
        return this.mapOpts.inline;
      let f = this.mapOpts.annotation;
      return typeof f < "u" && f !== !0 ? !1 : this.previous().length ? this.previous().some((d) => d.inline) : !0;
    }
    isMap() {
      return typeof this.opts.map < "u" ? !!this.opts.map : this.previous().length > 0;
    }
    isSourcesContent() {
      return typeof this.mapOpts.sourcesContent < "u" ? this.mapOpts.sourcesContent : this.previous().length ? this.previous().some((f) => f.withContent()) : !0;
    }
    outputFile() {
      return this.opts.to ? this.path(this.opts.to) : this.opts.from ? this.path(this.opts.from) : "to.css";
    }
    path(f) {
      if (this.mapOpts.absolute || f.charCodeAt(0) === 60 || /^\w+:\/\//.test(f)) return f;
      let d = this.memoizedPaths.get(f);
      if (d) return d;
      let y = this.opts.to ? n(this.opts.to) : ".";
      typeof this.mapOpts.annotation == "string" && (y = n(t(y, this.mapOpts.annotation)));
      let m = e(y, f);
      return this.memoizedPaths.set(f, m), m;
    }
    previous() {
      if (!this.previousMaps)
        if (this.previousMaps = [], this.root)
          this.root.walk((f) => {
            if (f.source && f.source.input.map) {
              let d = f.source.input.map;
              this.previousMaps.includes(d) || this.previousMaps.push(d);
            }
          });
        else {
          let f = new o(this.originalCSS, this.opts);
          f.map && this.previousMaps.push(f.map);
        }
      return this.previousMaps;
    }
    setSourcesContent() {
      let f = {};
      if (this.root)
        this.root.walk((d) => {
          if (d.source) {
            let y = d.source.input.from;
            if (y && !f[y]) {
              f[y] = !0;
              let m = this.usesFileUrls ? this.toFileUrl(y) : this.toUrl(this.path(y));
              this.map.setSourceContent(m, d.source.input.css);
            }
          }
        });
      else if (this.css) {
        let d = this.opts.from ? this.toUrl(this.path(this.opts.from)) : "<no source>";
        this.map.setSourceContent(d, this.css);
      }
    }
    sourcePath(f) {
      return this.mapOpts.from ? this.toUrl(this.mapOpts.from) : this.usesFileUrls ? this.toFileUrl(f.source.input.from) : this.toUrl(this.path(f.source.input.from));
    }
    toBase64(f) {
      return Buffer ? Buffer.from(f).toString("base64") : window.btoa(unescape(encodeURIComponent(f)));
    }
    toFileUrl(f) {
      let d = this.memoizedFileURLs.get(f);
      if (d) return d;
      if (s) {
        let y = s(f).toString();
        return this.memoizedFileURLs.set(f, y), y;
      } else
        throw new Error(
          "`map.absolute` option is not available in this PostCSS build"
        );
    }
    toUrl(f) {
      let d = this.memoizedURLs.get(f);
      if (d) return d;
      i === "\\" && (f = f.replace(/\\/g, "/"));
      let y = encodeURI(f).replace(/[#?]/g, encodeURIComponent);
      return this.memoizedURLs.set(f, y), y;
    }
  }
  return qd = l, qd;
}
var Wd, zy;
function b4() {
  if (zy) return Wd;
  zy = 1;
  const n = 39, e = 34, t = 92, i = 47, r = 10, a = 32, s = 12, o = 9, u = 13, c = 91, l = 93, h = 40, f = 41, d = 123, y = 125, m = 59, b = 42, p = 58, g = 64, v = /[\t\n\f\r "#'()/;[\\\]{}]/g, _ = /[\t\n\f\r !"#'():;@[\\\]{}]|\/(?=\*)/g, x = /.[\r\n"'(/\\]/, T = /[\da-f]/i;
  return Wd = function(U, D = {}) {
    let L = U.css.valueOf(), j = D.ignoreErrors, C, k, I, $, W, B, z, q, Y, H, K = L.length, ie = 0, ge = [], pe = [];
    function ce() {
      return ie;
    }
    function oe(F) {
      throw U.error("Unclosed " + F, ie);
    }
    function De() {
      return pe.length === 0 && ie >= K;
    }
    function Re(F) {
      if (pe.length) return pe.pop();
      if (ie >= K) return;
      let P = F ? F.ignoreUnclosed : !1;
      switch (C = L.charCodeAt(ie), C) {
        case r:
        case a:
        case o:
        case u:
        case s: {
          $ = ie;
          do
            $ += 1, C = L.charCodeAt($);
          while (C === a || C === r || C === o || C === u || C === s);
          B = ["space", L.slice(ie, $)], ie = $ - 1;
          break;
        }
        case c:
        case l:
        case d:
        case y:
        case p:
        case m:
        case f: {
          let ne = String.fromCharCode(C);
          B = [ne, ne, ie];
          break;
        }
        case h: {
          if (H = ge.length ? ge.pop()[1] : "", Y = L.charCodeAt(ie + 1), H === "url" && Y !== n && Y !== e && Y !== a && Y !== r && Y !== o && Y !== s && Y !== u) {
            $ = ie;
            do {
              if (z = !1, $ = L.indexOf(")", $ + 1), $ === -1)
                if (j || P) {
                  $ = ie;
                  break;
                } else
                  oe("bracket");
              for (q = $; L.charCodeAt(q - 1) === t; )
                q -= 1, z = !z;
            } while (z);
            B = ["brackets", L.slice(ie, $ + 1), ie, $], ie = $;
          } else
            $ = L.indexOf(")", ie + 1), k = L.slice(ie, $ + 1), $ === -1 || x.test(k) ? B = ["(", "(", ie] : (B = ["brackets", k, ie, $], ie = $);
          break;
        }
        case n:
        case e: {
          W = C === n ? "'" : '"', $ = ie;
          do {
            if (z = !1, $ = L.indexOf(W, $ + 1), $ === -1)
              if (j || P) {
                $ = ie + 1;
                break;
              } else
                oe("string");
            for (q = $; L.charCodeAt(q - 1) === t; )
              q -= 1, z = !z;
          } while (z);
          B = ["string", L.slice(ie, $ + 1), ie, $], ie = $;
          break;
        }
        case g: {
          v.lastIndex = ie + 1, v.test(L), v.lastIndex === 0 ? $ = L.length - 1 : $ = v.lastIndex - 2, B = ["at-word", L.slice(ie, $ + 1), ie, $], ie = $;
          break;
        }
        case t: {
          for ($ = ie, I = !0; L.charCodeAt($ + 1) === t; )
            $ += 1, I = !I;
          if (C = L.charCodeAt($ + 1), I && C !== i && C !== a && C !== r && C !== o && C !== u && C !== s && ($ += 1, T.test(L.charAt($)))) {
            for (; T.test(L.charAt($ + 1)); )
              $ += 1;
            L.charCodeAt($ + 1) === a && ($ += 1);
          }
          B = ["word", L.slice(ie, $ + 1), ie, $], ie = $;
          break;
        }
        default: {
          C === i && L.charCodeAt(ie + 1) === b ? ($ = L.indexOf("*/", ie + 2) + 1, $ === 0 && (j || P ? $ = L.length : oe("comment")), B = ["comment", L.slice(ie, $ + 1), ie, $], ie = $) : (_.lastIndex = ie + 1, _.test(L), _.lastIndex === 0 ? $ = L.length - 1 : $ = _.lastIndex - 2, B = ["word", L.slice(ie, $ + 1), ie, $], ge.push(B), ie = $);
          break;
        }
      }
      return ie++, B;
    }
    function Me(F) {
      pe.push(F);
    }
    return {
      back: Me,
      endOfFile: De,
      nextToken: Re,
      position: ce
    };
  }, Wd;
}
var Vd, $y;
function y4() {
  if ($y) return Vd;
  $y = 1;
  let n = zm(), e = Oc(), t = Lc(), i = ro(), r = Gm(), a = b4();
  const s = {
    empty: !0,
    space: !0
  };
  function o(c) {
    for (let l = c.length - 1; l >= 0; l--) {
      let h = c[l], f = h[3] || h[2];
      if (f) return f;
    }
  }
  class u {
    constructor(l) {
      this.input = l, this.root = new i(), this.current = this.root, this.spaces = "", this.semicolon = !1, this.createTokenizer(), this.root.source = { input: l, start: { column: 1, line: 1, offset: 0 } };
    }
    atrule(l) {
      let h = new n();
      h.name = l[1].slice(1), h.name === "" && this.unnamedAtrule(h, l), this.init(h, l[2]);
      let f, d, y, m = !1, b = !1, p = [], g = [];
      for (; !this.tokenizer.endOfFile(); ) {
        if (l = this.tokenizer.nextToken(), f = l[0], f === "(" || f === "[" ? g.push(f === "(" ? ")" : "]") : f === "{" && g.length > 0 ? g.push("}") : f === g[g.length - 1] && g.pop(), g.length === 0)
          if (f === ";") {
            h.source.end = this.getPosition(l[2]), h.source.end.offset++, this.semicolon = !0;
            break;
          } else if (f === "{") {
            b = !0;
            break;
          } else if (f === "}") {
            if (p.length > 0) {
              for (y = p.length - 1, d = p[y]; d && d[0] === "space"; )
                d = p[--y];
              d && (h.source.end = this.getPosition(d[3] || d[2]), h.source.end.offset++);
            }
            this.end(l);
            break;
          } else
            p.push(l);
        else
          p.push(l);
        if (this.tokenizer.endOfFile()) {
          m = !0;
          break;
        }
      }
      h.raws.between = this.spacesAndCommentsFromEnd(p), p.length ? (h.raws.afterName = this.spacesAndCommentsFromStart(p), this.raw(h, "params", p), m && (l = p[p.length - 1], h.source.end = this.getPosition(l[3] || l[2]), h.source.end.offset++, this.spaces = h.raws.between, h.raws.between = "")) : (h.raws.afterName = "", h.params = ""), b && (h.nodes = [], this.current = h);
    }
    checkMissedSemicolon(l) {
      let h = this.colon(l);
      if (h === !1) return;
      let f = 0, d;
      for (let y = h - 1; y >= 0 && (d = l[y], !(d[0] !== "space" && (f += 1, f === 2))); y--)
        ;
      throw this.input.error(
        "Missed semicolon",
        d[0] === "word" ? d[3] + 1 : d[2]
      );
    }
    colon(l) {
      let h = 0, f, d, y;
      for (let [m, b] of l.entries()) {
        if (d = b, y = d[0], y === "(" && (h += 1), y === ")" && (h -= 1), h === 0 && y === ":")
          if (!f)
            this.doubleColon(d);
          else {
            if (f[0] === "word" && f[1] === "progid")
              continue;
            return m;
          }
        f = d;
      }
      return !1;
    }
    comment(l) {
      let h = new e();
      this.init(h, l[2]), h.source.end = this.getPosition(l[3] || l[2]), h.source.end.offset++;
      let f = l[1].slice(2, -2);
      if (/^\s*$/.test(f))
        h.text = "", h.raws.left = f, h.raws.right = "";
      else {
        let d = f.match(/^(\s*)([^]*\S)(\s*)$/);
        h.text = d[2], h.raws.left = d[1], h.raws.right = d[3];
      }
    }
    createTokenizer() {
      this.tokenizer = a(this.input);
    }
    decl(l, h) {
      let f = new t();
      this.init(f, l[0][2]);
      let d = l[l.length - 1];
      for (d[0] === ";" && (this.semicolon = !0, l.pop()), f.source.end = this.getPosition(
        d[3] || d[2] || o(l)
      ), f.source.end.offset++; l[0][0] !== "word"; )
        l.length === 1 && this.unknownWord(l), f.raws.before += l.shift()[1];
      for (f.source.start = this.getPosition(l[0][2]), f.prop = ""; l.length; ) {
        let g = l[0][0];
        if (g === ":" || g === "space" || g === "comment")
          break;
        f.prop += l.shift()[1];
      }
      f.raws.between = "";
      let y;
      for (; l.length; )
        if (y = l.shift(), y[0] === ":") {
          f.raws.between += y[1];
          break;
        } else
          y[0] === "word" && /\w/.test(y[1]) && this.unknownWord([y]), f.raws.between += y[1];
      (f.prop[0] === "_" || f.prop[0] === "*") && (f.raws.before += f.prop[0], f.prop = f.prop.slice(1));
      let m = [], b;
      for (; l.length && (b = l[0][0], !(b !== "space" && b !== "comment")); )
        m.push(l.shift());
      this.precheckMissedSemicolon(l);
      for (let g = l.length - 1; g >= 0; g--) {
        if (y = l[g], y[1].toLowerCase() === "!important") {
          f.important = !0;
          let v = this.stringFrom(l, g);
          v = this.spacesFromEnd(l) + v, v !== " !important" && (f.raws.important = v);
          break;
        } else if (y[1].toLowerCase() === "important") {
          let v = l.slice(0), _ = "";
          for (let x = g; x > 0; x--) {
            let T = v[x][0];
            if (_.trim().startsWith("!") && T !== "space")
              break;
            _ = v.pop()[1] + _;
          }
          _.trim().startsWith("!") && (f.important = !0, f.raws.important = _, l = v);
        }
        if (y[0] !== "space" && y[0] !== "comment")
          break;
      }
      l.some((g) => g[0] !== "space" && g[0] !== "comment") && (f.raws.between += m.map((g) => g[1]).join(""), m = []), this.raw(f, "value", m.concat(l), h), f.value.includes(":") && !h && this.checkMissedSemicolon(l);
    }
    doubleColon(l) {
      throw this.input.error(
        "Double colon",
        { offset: l[2] },
        { offset: l[2] + l[1].length }
      );
    }
    emptyRule(l) {
      let h = new r();
      this.init(h, l[2]), h.selector = "", h.raws.between = "", this.current = h;
    }
    end(l) {
      this.current.nodes && this.current.nodes.length && (this.current.raws.semicolon = this.semicolon), this.semicolon = !1, this.current.raws.after = (this.current.raws.after || "") + this.spaces, this.spaces = "", this.current.parent ? (this.current.source.end = this.getPosition(l[2]), this.current.source.end.offset++, this.current = this.current.parent) : this.unexpectedClose(l);
    }
    endFile() {
      this.current.parent && this.unclosedBlock(), this.current.nodes && this.current.nodes.length && (this.current.raws.semicolon = this.semicolon), this.current.raws.after = (this.current.raws.after || "") + this.spaces, this.root.source.end = this.getPosition(this.tokenizer.position());
    }
    freeSemicolon(l) {
      if (this.spaces += l[1], this.current.nodes) {
        let h = this.current.nodes[this.current.nodes.length - 1];
        h && h.type === "rule" && !h.raws.ownSemicolon && (h.raws.ownSemicolon = this.spaces, this.spaces = "", h.source.end = this.getPosition(l[2]), h.source.end.offset += h.raws.ownSemicolon.length);
      }
    }
    // Helpers
    getPosition(l) {
      let h = this.input.fromOffset(l);
      return {
        column: h.col,
        line: h.line,
        offset: l
      };
    }
    init(l, h) {
      this.current.push(l), l.source = {
        input: this.input,
        start: this.getPosition(h)
      }, l.raws.before = this.spaces, this.spaces = "", l.type !== "comment" && (this.semicolon = !1);
    }
    other(l) {
      let h = !1, f = null, d = !1, y = null, m = [], b = l[1].startsWith("--"), p = [], g = l;
      for (; g; ) {
        if (f = g[0], p.push(g), f === "(" || f === "[")
          y || (y = g), m.push(f === "(" ? ")" : "]");
        else if (b && d && f === "{")
          y || (y = g), m.push("}");
        else if (m.length === 0)
          if (f === ";")
            if (d) {
              this.decl(p, b);
              return;
            } else
              break;
          else if (f === "{") {
            this.rule(p);
            return;
          } else if (f === "}") {
            this.tokenizer.back(p.pop()), h = !0;
            break;
          } else f === ":" && (d = !0);
        else f === m[m.length - 1] && (m.pop(), m.length === 0 && (y = null));
        g = this.tokenizer.nextToken();
      }
      if (this.tokenizer.endOfFile() && (h = !0), m.length > 0 && this.unclosedBracket(y), h && d) {
        if (!b)
          for (; p.length && (g = p[p.length - 1][0], !(g !== "space" && g !== "comment")); )
            this.tokenizer.back(p.pop());
        this.decl(p, b);
      } else
        this.unknownWord(p);
    }
    parse() {
      let l;
      for (; !this.tokenizer.endOfFile(); )
        switch (l = this.tokenizer.nextToken(), l[0]) {
          case "space":
            this.spaces += l[1];
            break;
          case ";":
            this.freeSemicolon(l);
            break;
          case "}":
            this.end(l);
            break;
          case "comment":
            this.comment(l);
            break;
          case "at-word":
            this.atrule(l);
            break;
          case "{":
            this.emptyRule(l);
            break;
          default:
            this.other(l);
            break;
        }
      this.endFile();
    }
    precheckMissedSemicolon() {
    }
    raw(l, h, f, d) {
      let y, m, b = f.length, p = "", g = !0, v, _;
      for (let x = 0; x < b; x += 1)
        y = f[x], m = y[0], m === "space" && x === b - 1 && !d ? g = !1 : m === "comment" ? (_ = f[x - 1] ? f[x - 1][0] : "empty", v = f[x + 1] ? f[x + 1][0] : "empty", !s[_] && !s[v] ? p.slice(-1) === "," ? g = !1 : p += y[1] : g = !1) : p += y[1];
      if (!g) {
        let x = f.reduce((T, E) => T + E[1], "");
        l.raws[h] = { raw: x, value: p };
      }
      l[h] = p;
    }
    rule(l) {
      l.pop();
      let h = new r();
      this.init(h, l[0][2]), h.raws.between = this.spacesAndCommentsFromEnd(l), this.raw(h, "selector", l), this.current = h;
    }
    spacesAndCommentsFromEnd(l) {
      let h, f = "";
      for (; l.length && (h = l[l.length - 1][0], !(h !== "space" && h !== "comment")); )
        f = l.pop()[1] + f;
      return f;
    }
    // Errors
    spacesAndCommentsFromStart(l) {
      let h, f = "";
      for (; l.length && (h = l[0][0], !(h !== "space" && h !== "comment")); )
        f += l.shift()[1];
      return f;
    }
    spacesFromEnd(l) {
      let h, f = "";
      for (; l.length && (h = l[l.length - 1][0], h === "space"); )
        f = l.pop()[1] + f;
      return f;
    }
    stringFrom(l, h) {
      let f = "";
      for (let d = h; d < l.length; d++)
        f += l[d][1];
      return l.splice(h, l.length - h), f;
    }
    unclosedBlock() {
      let l = this.current.source.start;
      throw this.input.error("Unclosed block", l.line, l.column);
    }
    unclosedBracket(l) {
      throw this.input.error(
        "Unclosed bracket",
        { offset: l[2] },
        { offset: l[2] + 1 }
      );
    }
    unexpectedClose(l) {
      throw this.input.error(
        "Unexpected }",
        { offset: l[2] },
        { offset: l[2] + 1 }
      );
    }
    unknownWord(l) {
      throw this.input.error(
        "Unknown word " + l[0][1],
        { offset: l[0][2] },
        { offset: l[0][2] + l[0][1].length }
      );
    }
    unnamedAtrule(l, h) {
      throw this.input.error(
        "At-rule without name",
        { offset: h[2] },
        { offset: h[2] + h[1].length }
      );
    }
  }
  return Vd = u, Vd;
}
var Hd, Gy;
function Xm() {
  if (Gy) return Hd;
  Gy = 1;
  let n = Br(), e = Fc(), t = y4();
  function i(r, a) {
    let s = new e(r, a), o = new t(s);
    try {
      o.parse();
    } catch (u) {
      throw u;
    }
    return o.root;
  }
  return Hd = i, i.default = i, n.registerParse(i), Hd;
}
var zd, Xy;
function MT() {
  if (Xy) return zd;
  Xy = 1;
  class n {
    constructor(t, i = {}) {
      if (this.type = "warning", this.text = t, i.node && i.node.source) {
        let r = i.node.rangeBy(i);
        this.line = r.start.line, this.column = r.start.column, this.endLine = r.end.line, this.endColumn = r.end.column;
      }
      for (let r in i) this[r] = i[r];
    }
    toString() {
      return this.node ? this.node.error(this.text, {
        index: this.index,
        plugin: this.plugin,
        word: this.word
      }).message : this.plugin ? this.plugin + ": " + this.text : this.text;
    }
  }
  return zd = n, n.default = n, zd;
}
var $d, Ky;
function Km() {
  if (Ky) return $d;
  Ky = 1;
  let n = MT();
  class e {
    get content() {
      return this.css;
    }
    constructor(i, r, a) {
      this.processor = i, this.messages = [], this.root = r, this.opts = a, this.css = "", this.map = void 0;
    }
    toString() {
      return this.css;
    }
    warn(i, r = {}) {
      r.plugin || this.lastPlugin && this.lastPlugin.postcssPlugin && (r.plugin = this.lastPlugin.postcssPlugin);
      let a = new n(i, r);
      return this.messages.push(a), a;
    }
    warnings() {
      return this.messages.filter((i) => i.type === "warning");
    }
  }
  return $d = e, e.default = e, $d;
}
var Gd, Yy;
function BT() {
  if (Yy) return Gd;
  Yy = 1;
  let n = Br(), e = $m(), t = NT(), i = Xm(), r = Km(), a = ro(), s = Uc(), { isClean: o, my: u } = Hm();
  const c = {
    atrule: "AtRule",
    comment: "Comment",
    decl: "Declaration",
    document: "Document",
    root: "Root",
    rule: "Rule"
  }, l = {
    AtRule: !0,
    AtRuleExit: !0,
    Comment: !0,
    CommentExit: !0,
    Declaration: !0,
    DeclarationExit: !0,
    Document: !0,
    DocumentExit: !0,
    Once: !0,
    OnceExit: !0,
    postcssPlugin: !0,
    prepare: !0,
    Root: !0,
    RootExit: !0,
    Rule: !0,
    RuleExit: !0
  }, h = {
    Once: !0,
    postcssPlugin: !0,
    prepare: !0
  }, f = 0;
  function d(v) {
    return typeof v == "object" && typeof v.then == "function";
  }
  function y(v) {
    let _ = !1, x = c[v.type];
    return v.type === "decl" ? _ = v.prop.toLowerCase() : v.type === "atrule" && (_ = v.name.toLowerCase()), _ && v.append ? [
      x,
      x + "-" + _,
      f,
      x + "Exit",
      x + "Exit-" + _
    ] : _ ? [x, x + "-" + _, x + "Exit", x + "Exit-" + _] : v.append ? [x, f, x + "Exit"] : [x, x + "Exit"];
  }
  function m(v) {
    let _;
    return v.type === "document" ? _ = ["Document", f, "DocumentExit"] : v.type === "root" ? _ = ["Root", f, "RootExit"] : _ = y(v), {
      eventIndex: 0,
      events: _,
      iterator: 0,
      node: v,
      visitorIndex: 0,
      visitors: []
    };
  }
  function b(v) {
    return v[o] = !1, v.nodes && v.nodes.forEach((_) => b(_)), v;
  }
  let p = {};
  class g {
    get content() {
      return this.stringify().content;
    }
    get css() {
      return this.stringify().css;
    }
    get map() {
      return this.stringify().map;
    }
    get messages() {
      return this.sync().messages;
    }
    get opts() {
      return this.result.opts;
    }
    get processor() {
      return this.result.processor;
    }
    get root() {
      return this.sync().root;
    }
    get [Symbol.toStringTag]() {
      return "LazyResult";
    }
    constructor(_, x, T) {
      this.stringified = !1, this.processed = !1;
      let E;
      if (typeof x == "object" && x !== null && (x.type === "root" || x.type === "document"))
        E = b(x);
      else if (x instanceof g || x instanceof r)
        E = b(x.root), x.map && (typeof T.map > "u" && (T.map = {}), T.map.inline || (T.map.inline = !1), T.map.prev = x.map);
      else {
        let U = i;
        T.syntax && (U = T.syntax.parse), T.parser && (U = T.parser), U.parse && (U = U.parse);
        try {
          E = U(x, T);
        } catch (D) {
          this.processed = !0, this.error = D;
        }
        E && !E[u] && n.rebuild(E);
      }
      this.result = new r(_, E, T), this.helpers = { ...p, postcss: p, result: this.result }, this.plugins = this.processor.plugins.map((U) => typeof U == "object" && U.prepare ? { ...U, ...U.prepare(this.result) } : U);
    }
    async() {
      return this.error ? Promise.reject(this.error) : this.processed ? Promise.resolve(this.result) : (this.processing || (this.processing = this.runAsync()), this.processing);
    }
    catch(_) {
      return this.async().catch(_);
    }
    finally(_) {
      return this.async().then(_, _);
    }
    getAsyncError() {
      throw new Error("Use process(css).then(cb) to work with async plugins");
    }
    handleError(_, x) {
      let T = this.result.lastPlugin;
      try {
        x && x.addToError(_), this.error = _, _.name === "CssSyntaxError" && !_.plugin ? (_.plugin = T.postcssPlugin, _.setMessage()) : T.postcssVersion;
      } catch (E) {
        console && console.error && console.error(E);
      }
      return _;
    }
    prepareVisitors() {
      this.listeners = {};
      let _ = (x, T, E) => {
        this.listeners[T] || (this.listeners[T] = []), this.listeners[T].push([x, E]);
      };
      for (let x of this.plugins)
        if (typeof x == "object")
          for (let T in x) {
            if (!l[T] && /^[A-Z]/.test(T))
              throw new Error(
                `Unknown event ${T} in ${x.postcssPlugin}. Try to update PostCSS (${this.processor.version} now).`
              );
            if (!h[T])
              if (typeof x[T] == "object")
                for (let E in x[T])
                  E === "*" ? _(x, T, x[T][E]) : _(
                    x,
                    T + "-" + E.toLowerCase(),
                    x[T][E]
                  );
              else typeof x[T] == "function" && _(x, T, x[T]);
          }
      this.hasListener = Object.keys(this.listeners).length > 0;
    }
    async runAsync() {
      this.plugin = 0;
      for (let _ = 0; _ < this.plugins.length; _++) {
        let x = this.plugins[_], T = this.runOnRoot(x);
        if (d(T))
          try {
            await T;
          } catch (E) {
            throw this.handleError(E);
          }
      }
      if (this.prepareVisitors(), this.hasListener) {
        let _ = this.result.root;
        for (; !_[o]; ) {
          _[o] = !0;
          let x = [m(_)];
          for (; x.length > 0; ) {
            let T = this.visitTick(x);
            if (d(T))
              try {
                await T;
              } catch (E) {
                let U = x[x.length - 1].node;
                throw this.handleError(E, U);
              }
          }
        }
        if (this.listeners.OnceExit)
          for (let [x, T] of this.listeners.OnceExit) {
            this.result.lastPlugin = x;
            try {
              if (_.type === "document") {
                let E = _.nodes.map(
                  (U) => T(U, this.helpers)
                );
                await Promise.all(E);
              } else
                await T(_, this.helpers);
            } catch (E) {
              throw this.handleError(E);
            }
          }
      }
      return this.processed = !0, this.stringify();
    }
    runOnRoot(_) {
      this.result.lastPlugin = _;
      try {
        if (typeof _ == "object" && _.Once) {
          if (this.result.root.type === "document") {
            let x = this.result.root.nodes.map(
              (T) => _.Once(T, this.helpers)
            );
            return d(x[0]) ? Promise.all(x) : x;
          }
          return _.Once(this.result.root, this.helpers);
        } else if (typeof _ == "function")
          return _(this.result.root, this.result);
      } catch (x) {
        throw this.handleError(x);
      }
    }
    stringify() {
      if (this.error) throw this.error;
      if (this.stringified) return this.result;
      this.stringified = !0, this.sync();
      let _ = this.result.opts, x = s;
      _.syntax && (x = _.syntax.stringify), _.stringifier && (x = _.stringifier), x.stringify && (x = x.stringify);
      let E = new t(x, this.result.root, this.result.opts).generate();
      return this.result.css = E[0], this.result.map = E[1], this.result;
    }
    sync() {
      if (this.error) throw this.error;
      if (this.processed) return this.result;
      if (this.processed = !0, this.processing)
        throw this.getAsyncError();
      for (let _ of this.plugins) {
        let x = this.runOnRoot(_);
        if (d(x))
          throw this.getAsyncError();
      }
      if (this.prepareVisitors(), this.hasListener) {
        let _ = this.result.root;
        for (; !_[o]; )
          _[o] = !0, this.walkSync(_);
        if (this.listeners.OnceExit)
          if (_.type === "document")
            for (let x of _.nodes)
              this.visitSync(this.listeners.OnceExit, x);
          else
            this.visitSync(this.listeners.OnceExit, _);
      }
      return this.result;
    }
    then(_, x) {
      return this.async().then(_, x);
    }
    toString() {
      return this.css;
    }
    visitSync(_, x) {
      for (let [T, E] of _) {
        this.result.lastPlugin = T;
        let U;
        try {
          U = E(x, this.helpers);
        } catch (D) {
          throw this.handleError(D, x.proxyOf);
        }
        if (x.type !== "root" && x.type !== "document" && !x.parent)
          return !0;
        if (d(U))
          throw this.getAsyncError();
      }
    }
    visitTick(_) {
      let x = _[_.length - 1], { node: T, visitors: E } = x;
      if (T.type !== "root" && T.type !== "document" && !T.parent) {
        _.pop();
        return;
      }
      if (E.length > 0 && x.visitorIndex < E.length) {
        let [D, L] = E[x.visitorIndex];
        x.visitorIndex += 1, x.visitorIndex === E.length && (x.visitors = [], x.visitorIndex = 0), this.result.lastPlugin = D;
        try {
          return L(T.toProxy(), this.helpers);
        } catch (j) {
          throw this.handleError(j, T);
        }
      }
      if (x.iterator !== 0) {
        let D = x.iterator, L;
        for (; L = T.nodes[T.indexes[D]]; )
          if (T.indexes[D] += 1, !L[o]) {
            L[o] = !0, _.push(m(L));
            return;
          }
        x.iterator = 0, delete T.indexes[D];
      }
      let U = x.events;
      for (; x.eventIndex < U.length; ) {
        let D = U[x.eventIndex];
        if (x.eventIndex += 1, D === f) {
          T.nodes && T.nodes.length && (T[o] = !0, x.iterator = T.getIterator());
          return;
        } else if (this.listeners[D]) {
          x.visitors = this.listeners[D];
          return;
        }
      }
      _.pop();
    }
    walkSync(_) {
      _[o] = !0;
      let x = y(_);
      for (let T of x)
        if (T === f)
          _.nodes && _.each((E) => {
            E[o] || this.walkSync(E);
          });
        else {
          let E = this.listeners[T];
          if (E && this.visitSync(E, _.toProxy()))
            return;
        }
    }
    warnings() {
      return this.sync().warnings();
    }
  }
  return g.registerPostcss = (v) => {
    p = v;
  }, Gd = g, g.default = g, a.registerLazyResult(g), e.registerLazyResult(g), Gd;
}
var Xd, Qy;
function v4() {
  if (Qy) return Xd;
  Qy = 1;
  let n = NT(), e = Xm();
  const t = Km();
  let i = Uc();
  class r {
    get content() {
      return this.result.css;
    }
    get css() {
      return this.result.css;
    }
    get map() {
      return this.result.map;
    }
    get messages() {
      return [];
    }
    get opts() {
      return this.result.opts;
    }
    get processor() {
      return this.result.processor;
    }
    get root() {
      if (this._root)
        return this._root;
      let s, o = e;
      try {
        s = o(this._css, this._opts);
      } catch (u) {
        this.error = u;
      }
      if (this.error)
        throw this.error;
      return this._root = s, s;
    }
    get [Symbol.toStringTag]() {
      return "NoWorkResult";
    }
    constructor(s, o, u) {
      o = o.toString(), this.stringified = !1, this._processor = s, this._css = o, this._opts = u, this._map = void 0;
      let c, l = i;
      this.result = new t(this._processor, c, this._opts), this.result.css = o;
      let h = this;
      Object.defineProperty(this.result, "root", {
        get() {
          return h.root;
        }
      });
      let f = new n(l, c, this._opts, o);
      if (f.isMap()) {
        let [d, y] = f.generate();
        d && (this.result.css = d), y && (this.result.map = y);
      } else
        f.clearAnnotation(), this.result.css = f.css;
    }
    async() {
      return this.error ? Promise.reject(this.error) : Promise.resolve(this.result);
    }
    catch(s) {
      return this.async().catch(s);
    }
    finally(s) {
      return this.async().then(s, s);
    }
    sync() {
      if (this.error) throw this.error;
      return this.result;
    }
    then(s, o) {
      return this.async().then(s, o);
    }
    toString() {
      return this._css;
    }
    warnings() {
      return [];
    }
  }
  return Xd = r, r.default = r, Xd;
}
var Kd, Zy;
function x4() {
  if (Zy) return Kd;
  Zy = 1;
  let n = $m(), e = BT(), t = v4(), i = ro();
  class r {
    constructor(s = []) {
      this.version = "8.5.6", this.plugins = this.normalize(s);
    }
    normalize(s) {
      let o = [];
      for (let u of s)
        if (u.postcss === !0 ? u = u() : u.postcss && (u = u.postcss), typeof u == "object" && Array.isArray(u.plugins))
          o = o.concat(u.plugins);
        else if (typeof u == "object" && u.postcssPlugin)
          o.push(u);
        else if (typeof u == "function")
          o.push(u);
        else if (!(typeof u == "object" && (u.parse || u.stringify))) throw new Error(u + " is not a PostCSS plugin");
      return o;
    }
    process(s, o = {}) {
      return !this.plugins.length && !o.parser && !o.stringifier && !o.syntax ? new t(this, s, o) : new e(this, s, o);
    }
    use(s) {
      return this.plugins = this.plugins.concat(this.normalize([s])), this;
    }
  }
  return Kd = r, r.default = r, i.registerProcessor(r), n.registerProcessor(r), Kd;
}
var Yd, Jy;
function _4() {
  if (Jy) return Yd;
  Jy = 1;
  let n = zm(), e = Oc(), t = Br(), i = Vm(), r = Lc(), a = $m(), s = g4(), o = Fc(), u = BT(), c = FT(), l = Rc(), h = Xm(), f = x4(), d = Km(), y = ro(), m = Gm(), b = Uc(), p = MT();
  function g(...v) {
    return v.length === 1 && Array.isArray(v[0]) && (v = v[0]), new f(v);
  }
  return g.plugin = function(_, x) {
    let T = !1;
    function E(...D) {
      console && console.warn && !T && (T = !0, console.warn(
        _ + `: postcss.plugin was deprecated. Migration guide:
https://evilmartians.com/chronicles/postcss-8-plugin-migration`
      ), process.env.LANG && process.env.LANG.startsWith("cn") && console.warn(
        _ + `:  postcss.plugin . :
https://www.w3ctech.com/topic/2226`
      ));
      let L = x(...D);
      return L.postcssPlugin = _, L.postcssVersion = new f().version, L;
    }
    let U;
    return Object.defineProperty(E, "postcss", {
      get() {
        return U || (U = E()), U;
      }
    }), E.process = function(D, L, j) {
      return g([E(j)]).process(D, L);
    }, E;
  }, g.stringify = b, g.parse = h, g.fromJSON = s, g.list = c, g.comment = (v) => new e(v), g.atRule = (v) => new n(v), g.decl = (v) => new r(v), g.rule = (v) => new m(v), g.root = (v) => new y(v), g.document = (v) => new a(v), g.CssSyntaxError = i, g.Declaration = r, g.Container = t, g.Processor = f, g.Document = a, g.Comment = e, g.Warning = p, g.AtRule = n, g.Result = d, g.Input = o, g.Rule = m, g.Root = y, g.Node = l, u.registerPostcss(g), Yd = g, g.default = g, Yd;
}
var Qd, ev;
function T4() {
  if (ev) return Qd;
  ev = 1;
  const n = /* @__PURE__ */ s4(), e = o4(), { isPlainObject: t } = u4(), i = c4(), r = d4(), { parse: a } = _4(), s = [
    "img",
    "audio",
    "video",
    "picture",
    "svg",
    "object",
    "map",
    "iframe",
    "embed"
  ], o = ["script", "style"];
  function u(b, p) {
    b && Object.keys(b).forEach(function(g) {
      p(b[g], g);
    });
  }
  function c(b, p) {
    return {}.hasOwnProperty.call(b, p);
  }
  function l(b, p) {
    const g = [];
    return u(b, function(v) {
      p(v) && g.push(v);
    }), g;
  }
  function h(b) {
    for (const p in b)
      if (c(b, p))
        return !1;
    return !0;
  }
  function f(b) {
    return b.map(function(p) {
      if (!p.url)
        throw new Error("URL missing");
      return p.url + (p.w ? ` ${p.w}w` : "") + (p.h ? ` ${p.h}h` : "") + (p.d ? ` ${p.d}x` : "");
    }).join(", ");
  }
  Qd = y;
  const d = /^[^\0\t\n\f\r /<=>]+$/;
  function y(b, p, g) {
    if (b == null)
      return "";
    typeof b == "number" && (b = b.toString());
    let v = "", _ = "";
    function x(F, P) {
      const ne = this;
      this.tag = F, this.attribs = P || {}, this.tagPosition = v.length, this.text = "", this.mediaChildren = [], this.updateParentNodeText = function() {
        if (W.length) {
          const S = W[W.length - 1];
          S.text += ne.text;
        }
      }, this.updateParentNodeMediaChildren = function() {
        W.length && s.includes(this.tag) && W[W.length - 1].mediaChildren.push(this.tag);
      };
    }
    p = Object.assign({}, y.defaults, p), p.parser = Object.assign({}, m, p.parser);
    const T = function(F) {
      return p.allowedTags === !1 || (p.allowedTags || []).indexOf(F) > -1;
    };
    o.forEach(function(F) {
      T(F) && !p.allowVulnerableTags && console.warn(`

 Your \`allowedTags\` option includes, \`${F}\`, which is inherently
vulnerable to XSS attacks. Please remove it from \`allowedTags\`.
Or, to disable this warning, add the \`allowVulnerableTags\` option
and ensure you are accounting for this risk.

`);
    });
    const E = p.nonTextTags || [
      "script",
      "style",
      "textarea",
      "option"
    ];
    let U, D;
    p.allowedAttributes && (U = {}, D = {}, u(p.allowedAttributes, function(F, P) {
      U[P] = [];
      const ne = [];
      F.forEach(function(S) {
        typeof S == "string" && S.indexOf("*") >= 0 ? ne.push(e(S).replace(/\\\*/g, ".*")) : U[P].push(S);
      }), ne.length && (D[P] = new RegExp("^(" + ne.join("|") + ")$"));
    }));
    const L = {}, j = {}, C = {};
    u(p.allowedClasses, function(F, P) {
      if (U && (c(U, P) || (U[P] = []), U[P].push("class")), L[P] = F, Array.isArray(F)) {
        const ne = [];
        L[P] = [], C[P] = [], F.forEach(function(S) {
          typeof S == "string" && S.indexOf("*") >= 0 ? ne.push(e(S).replace(/\\\*/g, ".*")) : S instanceof RegExp ? C[P].push(S) : L[P].push(S);
        }), ne.length && (j[P] = new RegExp("^(" + ne.join("|") + ")$"));
      }
    });
    const k = {};
    let I;
    u(p.transformTags, function(F, P) {
      let ne;
      typeof F == "function" ? ne = F : typeof F == "string" && (ne = y.simpleTransform(F)), P === "*" ? I = ne : k[P] = ne;
    });
    let $, W, B, z, q, Y, H = !1;
    ie();
    const K = new n.Parser({
      onopentag: function(F, P) {
        if (p.enforceHtmlBoundary && F === "html" && ie(), q) {
          Y++;
          return;
        }
        const ne = new x(F, P);
        W.push(ne);
        let S = !1;
        const he = !!ne.text;
        let ae;
        if (c(k, F) && (ae = k[F](F, P), ne.attribs = P = ae.attribs, ae.text !== void 0 && (ne.innerText = ae.text), F !== ae.tagName && (ne.name = F = ae.tagName, z[$] = ae.tagName)), I && (ae = I(F, P), ne.attribs = P = ae.attribs, F !== ae.tagName && (ne.name = F = ae.tagName, z[$] = ae.tagName)), (!T(F) || p.disallowedTagsMode === "recursiveEscape" && !h(B) || p.nestingLimit != null && $ >= p.nestingLimit) && (S = !0, B[$] = !0, p.disallowedTagsMode === "discard" && E.indexOf(F) !== -1 && (q = !0, Y = 1), B[$] = !0), $++, S) {
          if (p.disallowedTagsMode === "discard")
            return;
          _ = v, v = "";
        }
        v += "<" + F, F === "script" && (p.allowedScriptHostnames || p.allowedScriptDomains) && (ne.innerText = ""), (!U || c(U, F) || U["*"]) && u(P, function(te, ee) {
          if (!d.test(ee)) {
            delete ne.attribs[ee];
            return;
          }
          if (te === "" && !p.allowedEmptyAttributes.includes(ee) && (p.nonBooleanAttributes.includes(ee) || p.nonBooleanAttributes.includes("*"))) {
            delete ne.attribs[ee];
            return;
          }
          let ve = !1;
          if (!U || c(U, F) && U[F].indexOf(ee) !== -1 || U["*"] && U["*"].indexOf(ee) !== -1 || c(D, F) && D[F].test(ee) || D["*"] && D["*"].test(ee))
            ve = !0;
          else if (U && U[F]) {
            for (const Ee of U[F])
              if (t(Ee) && Ee.name && Ee.name === ee) {
                ve = !0;
                let Se = "";
                if (Ee.multiple === !0) {
                  const xe = te.split(" ");
                  for (const le of xe)
                    Ee.values.indexOf(le) !== -1 && (Se === "" ? Se = le : Se += " " + le);
                } else Ee.values.indexOf(te) >= 0 && (Se = te);
                te = Se;
              }
          }
          if (ve) {
            if (p.allowedSchemesAppliedToAttributes.indexOf(ee) !== -1 && pe(F, te)) {
              delete ne.attribs[ee];
              return;
            }
            if (F === "script" && ee === "src") {
              let Ee = !0;
              try {
                const Se = ce(te);
                if (p.allowedScriptHostnames || p.allowedScriptDomains) {
                  const xe = (p.allowedScriptHostnames || []).find(function(ye) {
                    return ye === Se.url.hostname;
                  }), le = (p.allowedScriptDomains || []).find(function(ye) {
                    return Se.url.hostname === ye || Se.url.hostname.endsWith(`.${ye}`);
                  });
                  Ee = xe || le;
                }
              } catch {
                Ee = !1;
              }
              if (!Ee) {
                delete ne.attribs[ee];
                return;
              }
            }
            if (F === "iframe" && ee === "src") {
              let Ee = !0;
              try {
                const Se = ce(te);
                if (Se.isRelativeUrl)
                  Ee = c(p, "allowIframeRelativeUrls") ? p.allowIframeRelativeUrls : !p.allowedIframeHostnames && !p.allowedIframeDomains;
                else if (p.allowedIframeHostnames || p.allowedIframeDomains) {
                  const xe = (p.allowedIframeHostnames || []).find(function(ye) {
                    return ye === Se.url.hostname;
                  }), le = (p.allowedIframeDomains || []).find(function(ye) {
                    return Se.url.hostname === ye || Se.url.hostname.endsWith(`.${ye}`);
                  });
                  Ee = xe || le;
                }
              } catch {
                Ee = !1;
              }
              if (!Ee) {
                delete ne.attribs[ee];
                return;
              }
            }
            if (ee === "srcset")
              try {
                let Ee = r(te);
                if (Ee.forEach(function(Se) {
                  pe("srcset", Se.url) && (Se.evil = !0);
                }), Ee = l(Ee, function(Se) {
                  return !Se.evil;
                }), Ee.length)
                  te = f(l(Ee, function(Se) {
                    return !Se.evil;
                  })), ne.attribs[ee] = te;
                else {
                  delete ne.attribs[ee];
                  return;
                }
              } catch {
                delete ne.attribs[ee];
                return;
              }
            if (ee === "class") {
              const Ee = L[F], Se = L["*"], xe = j[F], le = C[F], ye = j["*"], we = [
                xe,
                ye
              ].concat(le).filter(function(Ue) {
                return Ue;
              });
              if (Ee && Se ? te = Me(te, i(Ee, Se), we) : te = Me(te, Ee || Se, we), !te.length) {
                delete ne.attribs[ee];
                return;
              }
            }
            if (ee === "style") {
              if (p.parseStyleAttributes)
                try {
                  const Ee = a(F + " {" + te + "}", { map: !1 }), Se = oe(Ee, p.allowedStyles);
                  if (te = De(Se), te.length === 0) {
                    delete ne.attribs[ee];
                    return;
                  }
                } catch {
                  typeof window < "u" && console.warn('Failed to parse "' + F + " {" + te + `}", If you're running this in a browser, we recommend to disable style parsing: options.parseStyleAttributes: false, since this only works in a node environment due to a postcss dependency, More info: https://github.com/apostrophecms/sanitize-html/issues/547`), delete ne.attribs[ee];
                  return;
                }
              else if (p.allowedStyles)
                throw new Error("allowedStyles option cannot be used together with parseStyleAttributes: false.");
            }
            v += " " + ee, te && te.length ? v += '="' + ge(te, !0) + '"' : p.allowedEmptyAttributes.includes(ee) && (v += '=""');
          } else
            delete ne.attribs[ee];
        }), p.selfClosing.indexOf(F) !== -1 ? v += " />" : (v += ">", ne.innerText && !he && !p.textFilter && (v += ge(ne.innerText), H = !0)), S && (v = _ + ge(v), _ = "");
      },
      ontext: function(F) {
        if (q)
          return;
        const P = W[W.length - 1];
        let ne;
        if (P && (ne = P.tag, F = P.innerText !== void 0 ? P.innerText : F), p.disallowedTagsMode === "discard" && (ne === "script" || ne === "style"))
          v += F;
        else {
          const S = ge(F, !1);
          p.textFilter && !H ? v += p.textFilter(S, ne) : H || (v += S);
        }
        if (W.length) {
          const S = W[W.length - 1];
          S.text += F;
        }
      },
      onclosetag: function(F, P) {
        if (q)
          if (Y--, !Y)
            q = !1;
          else
            return;
        const ne = W.pop();
        if (!ne)
          return;
        if (ne.tag !== F) {
          W.push(ne);
          return;
        }
        q = p.enforceHtmlBoundary ? F === "html" : !1, $--;
        const S = B[$];
        if (S) {
          if (delete B[$], p.disallowedTagsMode === "discard") {
            ne.updateParentNodeText();
            return;
          }
          _ = v, v = "";
        }
        if (z[$] && (F = z[$], delete z[$]), p.exclusiveFilter && p.exclusiveFilter(ne)) {
          v = v.substr(0, ne.tagPosition);
          return;
        }
        if (ne.updateParentNodeMediaChildren(), ne.updateParentNodeText(), // Already output />
        p.selfClosing.indexOf(F) !== -1 || // Escaped tag, closing tag is implied
        P && !T(F) && ["escape", "recursiveEscape"].indexOf(p.disallowedTagsMode) >= 0) {
          S && (v = _, _ = "");
          return;
        }
        v += "</" + F + ">", S && (v = _ + ge(v), _ = ""), H = !1;
      }
    }, p.parser);
    return K.write(b), K.end(), v;
    function ie() {
      v = "", $ = 0, W = [], B = {}, z = {}, q = !1, Y = 0;
    }
    function ge(F, P) {
      return typeof F != "string" && (F = F + ""), p.parser.decodeEntities && (F = F.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;"), P && (F = F.replace(/"/g, "&quot;"))), F = F.replace(/&(?![a-zA-Z0-9#]{1,20};)/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;"), P && (F = F.replace(/"/g, "&quot;")), F;
    }
    function pe(F, P) {
      for (P = P.replace(/[\x00-\x20]+/g, ""); ; ) {
        const he = P.indexOf("<!--");
        if (he === -1)
          break;
        const ae = P.indexOf("-->", he + 4);
        if (ae === -1)
          break;
        P = P.substring(0, he) + P.substring(ae + 3);
      }
      const ne = P.match(/^([a-zA-Z][a-zA-Z0-9.\-+]*):/);
      if (!ne)
        return P.match(/^[/\\]{2}/) ? !p.allowProtocolRelative : !1;
      const S = ne[1].toLowerCase();
      return c(p.allowedSchemesByTag, F) ? p.allowedSchemesByTag[F].indexOf(S) === -1 : !p.allowedSchemes || p.allowedSchemes.indexOf(S) === -1;
    }
    function ce(F) {
      if (F = F.replace(/^(\w+:)?\s*[\\/]\s*[\\/]/, "$1//"), F.startsWith("relative:"))
        throw new Error("relative: exploit attempt");
      let P = "relative://relative-site";
      for (let he = 0; he < 100; he++)
        P += `/${he}`;
      const ne = new URL(F, P);
      return {
        isRelativeUrl: ne && ne.hostname === "relative-site" && ne.protocol === "relative:",
        url: ne
      };
    }
    function oe(F, P) {
      if (!P)
        return F;
      const ne = F.nodes[0];
      let S;
      return P[ne.selector] && P["*"] ? S = i(
        P[ne.selector],
        P["*"]
      ) : S = P[ne.selector] || P["*"], S && (F.nodes[0].nodes = ne.nodes.reduce(Re(S), [])), F;
    }
    function De(F) {
      return F.nodes[0].nodes.reduce(function(P, ne) {
        return P.push(
          `${ne.prop}:${ne.value}${ne.important ? " !important" : ""}`
        ), P;
      }, []).join(";");
    }
    function Re(F) {
      return function(P, ne) {
        return c(F, ne.prop) && F[ne.prop].some(function(he) {
          return he.test(ne.value);
        }) && P.push(ne), P;
      };
    }
    function Me(F, P, ne) {
      return P ? (F = F.split(/\s+/), F.filter(function(S) {
        return P.indexOf(S) !== -1 || ne.some(function(he) {
          return he.test(S);
        });
      }).join(" ")) : F;
    }
  }
  const m = {
    decodeEntities: !0
  };
  return y.defaults = {
    allowedTags: [
      // Sections derived from MDN element categories and limited to the more
      // benign categories.
      // https://developer.mozilla.org/en-US/docs/Web/HTML/Element
      // Content sectioning
      "address",
      "article",
      "aside",
      "footer",
      "header",
      "h1",
      "h2",
      "h3",
      "h4",
      "h5",
      "h6",
      "hgroup",
      "main",
      "nav",
      "section",
      // Text content
      "blockquote",
      "dd",
      "div",
      "dl",
      "dt",
      "figcaption",
      "figure",
      "hr",
      "li",
      "main",
      "ol",
      "p",
      "pre",
      "ul",
      // Inline text semantics
      "a",
      "abbr",
      "b",
      "bdi",
      "bdo",
      "br",
      "cite",
      "code",
      "data",
      "dfn",
      "em",
      "i",
      "kbd",
      "mark",
      "q",
      "rb",
      "rp",
      "rt",
      "rtc",
      "ruby",
      "s",
      "samp",
      "small",
      "span",
      "strong",
      "sub",
      "sup",
      "time",
      "u",
      "var",
      "wbr",
      // Table content
      "caption",
      "col",
      "colgroup",
      "table",
      "tbody",
      "td",
      "tfoot",
      "th",
      "thead",
      "tr"
    ],
    // Tags that cannot be boolean
    nonBooleanAttributes: [
      "abbr",
      "accept",
      "accept-charset",
      "accesskey",
      "action",
      "allow",
      "alt",
      "as",
      "autocapitalize",
      "autocomplete",
      "blocking",
      "charset",
      "cite",
      "class",
      "color",
      "cols",
      "colspan",
      "content",
      "contenteditable",
      "coords",
      "crossorigin",
      "data",
      "datetime",
      "decoding",
      "dir",
      "dirname",
      "download",
      "draggable",
      "enctype",
      "enterkeyhint",
      "fetchpriority",
      "for",
      "form",
      "formaction",
      "formenctype",
      "formmethod",
      "formtarget",
      "headers",
      "height",
      "hidden",
      "high",
      "href",
      "hreflang",
      "http-equiv",
      "id",
      "imagesizes",
      "imagesrcset",
      "inputmode",
      "integrity",
      "is",
      "itemid",
      "itemprop",
      "itemref",
      "itemtype",
      "kind",
      "label",
      "lang",
      "list",
      "loading",
      "low",
      "max",
      "maxlength",
      "media",
      "method",
      "min",
      "minlength",
      "name",
      "nonce",
      "optimum",
      "pattern",
      "ping",
      "placeholder",
      "popover",
      "popovertarget",
      "popovertargetaction",
      "poster",
      "preload",
      "referrerpolicy",
      "rel",
      "rows",
      "rowspan",
      "sandbox",
      "scope",
      "shape",
      "size",
      "sizes",
      "slot",
      "span",
      "spellcheck",
      "src",
      "srcdoc",
      "srclang",
      "srcset",
      "start",
      "step",
      "style",
      "tabindex",
      "target",
      "title",
      "translate",
      "type",
      "usemap",
      "value",
      "width",
      "wrap",
      // Event handlers
      "onauxclick",
      "onafterprint",
      "onbeforematch",
      "onbeforeprint",
      "onbeforeunload",
      "onbeforetoggle",
      "onblur",
      "oncancel",
      "oncanplay",
      "oncanplaythrough",
      "onchange",
      "onclick",
      "onclose",
      "oncontextlost",
      "oncontextmenu",
      "oncontextrestored",
      "oncopy",
      "oncuechange",
      "oncut",
      "ondblclick",
      "ondrag",
      "ondragend",
      "ondragenter",
      "ondragleave",
      "ondragover",
      "ondragstart",
      "ondrop",
      "ondurationchange",
      "onemptied",
      "onended",
      "onerror",
      "onfocus",
      "onformdata",
      "onhashchange",
      "oninput",
      "oninvalid",
      "onkeydown",
      "onkeypress",
      "onkeyup",
      "onlanguagechange",
      "onload",
      "onloadeddata",
      "onloadedmetadata",
      "onloadstart",
      "onmessage",
      "onmessageerror",
      "onmousedown",
      "onmouseenter",
      "onmouseleave",
      "onmousemove",
      "onmouseout",
      "onmouseover",
      "onmouseup",
      "onoffline",
      "ononline",
      "onpagehide",
      "onpageshow",
      "onpaste",
      "onpause",
      "onplay",
      "onplaying",
      "onpopstate",
      "onprogress",
      "onratechange",
      "onreset",
      "onresize",
      "onrejectionhandled",
      "onscroll",
      "onscrollend",
      "onsecuritypolicyviolation",
      "onseeked",
      "onseeking",
      "onselect",
      "onslotchange",
      "onstalled",
      "onstorage",
      "onsubmit",
      "onsuspend",
      "ontimeupdate",
      "ontoggle",
      "onunhandledrejection",
      "onunload",
      "onvolumechange",
      "onwaiting",
      "onwheel"
    ],
    disallowedTagsMode: "discard",
    allowedAttributes: {
      a: ["href", "name", "target"],
      // We don't currently allow img itself by default, but
      // these attributes would make sense if we did.
      img: ["src", "srcset", "alt", "title", "width", "height", "loading"]
    },
    allowedEmptyAttributes: [
      "alt"
    ],
    // Lots of these won't come up by default because we don't allow them
    selfClosing: ["img", "br", "hr", "area", "base", "basefont", "input", "link", "meta"],
    // URL schemes we permit
    allowedSchemes: ["http", "https", "ftp", "mailto", "tel"],
    allowedSchemesByTag: {},
    allowedSchemesAppliedToAttributes: ["href", "src", "cite"],
    allowProtocolRelative: !0,
    enforceHtmlBoundary: !1,
    parseStyleAttributes: !0
  }, y.simpleTransform = function(b, p, g) {
    return g = g === void 0 ? !0 : g, p = p || {}, function(v, _) {
      let x;
      if (g)
        for (x in p)
          _[x] = p[x];
      else
        _ = p;
      return {
        tagName: b,
        attribs: _
      };
    };
  }, Qd;
}
var w4 = /* @__PURE__ */ T4();
const E4 = /* @__PURE__ */ Qt(w4);
var Vi = {}, ss = {}, tv;
function D4() {
  return tv || (tv = 1, Object.defineProperty(ss, "__esModule", { value: !0 }), ss.bodyRegExps = { xml: /&(?:#\d+|#[xX][\da-fA-F]+|[0-9a-zA-Z]+);?/g, html4: /&(?:nbsp|iexcl|cent|pound|curren|yen|brvbar|sect|uml|copy|ordf|laquo|not|shy|reg|macr|deg|plusmn|sup2|sup3|acute|micro|para|middot|cedil|sup1|ordm|raquo|frac14|frac12|frac34|iquest|Agrave|Aacute|Acirc|Atilde|Auml|Aring|AElig|Ccedil|Egrave|Eacute|Ecirc|Euml|Igrave|Iacute|Icirc|Iuml|ETH|Ntilde|Ograve|Oacute|Ocirc|Otilde|Ouml|times|Oslash|Ugrave|Uacute|Ucirc|Uuml|Yacute|THORN|szlig|agrave|aacute|acirc|atilde|auml|aring|aelig|ccedil|egrave|eacute|ecirc|euml|igrave|iacute|icirc|iuml|eth|ntilde|ograve|oacute|ocirc|otilde|ouml|divide|oslash|ugrave|uacute|ucirc|uuml|yacute|thorn|yuml|quot|amp|lt|gt|#\d+|#[xX][\da-fA-F]+|[0-9a-zA-Z]+);?/g, html5: /&(?:AElig|AMP|Aacute|Acirc|Agrave|Aring|Atilde|Auml|COPY|Ccedil|ETH|Eacute|Ecirc|Egrave|Euml|GT|Iacute|Icirc|Igrave|Iuml|LT|Ntilde|Oacute|Ocirc|Ograve|Oslash|Otilde|Ouml|QUOT|REG|THORN|Uacute|Ucirc|Ugrave|Uuml|Yacute|aacute|acirc|acute|aelig|agrave|amp|aring|atilde|auml|brvbar|ccedil|cedil|cent|copy|curren|deg|divide|eacute|ecirc|egrave|eth|euml|frac12|frac14|frac34|gt|iacute|icirc|iexcl|igrave|iquest|iuml|laquo|lt|macr|micro|middot|nbsp|not|ntilde|oacute|ocirc|ograve|ordf|ordm|oslash|otilde|ouml|para|plusmn|pound|quot|raquo|reg|sect|shy|sup1|sup2|sup3|szlig|thorn|times|uacute|ucirc|ugrave|uml|uuml|yacute|yen|yuml|#\d+|#[xX][\da-fA-F]+|[0-9a-zA-Z]+);?/g }, ss.namedReferences = { xml: { entities: { "&lt;": "<", "&gt;": ">", "&quot;": '"', "&apos;": "'", "&amp;": "&" }, characters: { "<": "&lt;", ">": "&gt;", '"': "&quot;", "'": "&apos;", "&": "&amp;" } }, html4: { entities: { "&apos;": "'", "&nbsp": "", "&nbsp;": "", "&iexcl": "", "&iexcl;": "", "&cent": "", "&cent;": "", "&pound": "", "&pound;": "", "&curren": "", "&curren;": "", "&yen": "", "&yen;": "", "&brvbar": "", "&brvbar;": "", "&sect": "", "&sect;": "", "&uml": "", "&uml;": "", "&copy": "", "&copy;": "", "&ordf": "", "&ordf;": "", "&laquo": "", "&laquo;": "", "&not": "", "&not;": "", "&shy": "", "&shy;": "", "&reg": "", "&reg;": "", "&macr": "", "&macr;": "", "&deg": "", "&deg;": "", "&plusmn": "", "&plusmn;": "", "&sup2": "", "&sup2;": "", "&sup3": "", "&sup3;": "", "&acute": "", "&acute;": "", "&micro": "", "&micro;": "", "&para": "", "&para;": "", "&middot": "", "&middot;": "", "&cedil": "", "&cedil;": "", "&sup1": "", "&sup1;": "", "&ordm": "", "&ordm;": "", "&raquo": "", "&raquo;": "", "&frac14": "", "&frac14;": "", "&frac12": "", "&frac12;": "", "&frac34": "", "&frac34;": "", "&iquest": "", "&iquest;": "", "&Agrave": "", "&Agrave;": "", "&Aacute": "", "&Aacute;": "", "&Acirc": "", "&Acirc;": "", "&Atilde": "", "&Atilde;": "", "&Auml": "", "&Auml;": "", "&Aring": "", "&Aring;": "", "&AElig": "", "&AElig;": "", "&Ccedil": "", "&Ccedil;": "", "&Egrave": "", "&Egrave;": "", "&Eacute": "", "&Eacute;": "", "&Ecirc": "", "&Ecirc;": "", "&Euml": "", "&Euml;": "", "&Igrave": "", "&Igrave;": "", "&Iacute": "", "&Iacute;": "", "&Icirc": "", "&Icirc;": "", "&Iuml": "", "&Iuml;": "", "&ETH": "", "&ETH;": "", "&Ntilde": "", "&Ntilde;": "", "&Ograve": "", "&Ograve;": "", "&Oacute": "", "&Oacute;": "", "&Ocirc": "", "&Ocirc;": "", "&Otilde": "", "&Otilde;": "", "&Ouml": "", "&Ouml;": "", "&times": "", "&times;": "", "&Oslash": "", "&Oslash;": "", "&Ugrave": "", "&Ugrave;": "", "&Uacute": "", "&Uacute;": "", "&Ucirc": "", "&Ucirc;": "", "&Uuml": "", "&Uuml;": "", "&Yacute": "", "&Yacute;": "", "&THORN": "", "&THORN;": "", "&szlig": "", "&szlig;": "", "&agrave": "", "&agrave;": "", "&aacute": "", "&aacute;": "", "&acirc": "", "&acirc;": "", "&atilde": "", "&atilde;": "", "&auml": "", "&auml;": "", "&aring": "", "&aring;": "", "&aelig": "", "&aelig;": "", "&ccedil": "", "&ccedil;": "", "&egrave": "", "&egrave;": "", "&eacute": "", "&eacute;": "", "&ecirc": "", "&ecirc;": "", "&euml": "", "&euml;": "", "&igrave": "", "&igrave;": "", "&iacute": "", "&iacute;": "", "&icirc": "", "&icirc;": "", "&iuml": "", "&iuml;": "", "&eth": "", "&eth;": "", "&ntilde": "", "&ntilde;": "", "&ograve": "", "&ograve;": "", "&oacute": "", "&oacute;": "", "&ocirc": "", "&ocirc;": "", "&otilde": "", "&otilde;": "", "&ouml": "", "&ouml;": "", "&divide": "", "&divide;": "", "&oslash": "", "&oslash;": "", "&ugrave": "", "&ugrave;": "", "&uacute": "", "&uacute;": "", "&ucirc": "", "&ucirc;": "", "&uuml": "", "&uuml;": "", "&yacute": "", "&yacute;": "", "&thorn": "", "&thorn;": "", "&yuml": "", "&yuml;": "", "&quot": '"', "&quot;": '"', "&amp": "&", "&amp;": "&", "&lt": "<", "&lt;": "<", "&gt": ">", "&gt;": ">", "&OElig;": "", "&oelig;": "", "&Scaron;": "", "&scaron;": "", "&Yuml;": "", "&circ;": "", "&tilde;": "", "&ensp;": "", "&emsp;": "", "&thinsp;": "", "&zwnj;": "", "&zwj;": "", "&lrm;": "", "&rlm;": "", "&ndash;": "", "&mdash;": "", "&lsquo;": "", "&rsquo;": "", "&sbquo;": "", "&ldquo;": "", "&rdquo;": "", "&bdquo;": "", "&dagger;": "", "&Dagger;": "", "&permil;": "", "&lsaquo;": "", "&rsaquo;": "", "&euro;": "", "&fnof;": "", "&Alpha;": "", "&Beta;": "", "&Gamma;": "", "&Delta;": "", "&Epsilon;": "", "&Zeta;": "", "&Eta;": "", "&Theta;": "", "&Iota;": "", "&Kappa;": "", "&Lambda;": "", "&Mu;": "", "&Nu;": "", "&Xi;": "", "&Omicron;": "", "&Pi;": "", "&Rho;": "", "&Sigma;": "", "&Tau;": "", "&Upsilon;": "", "&Phi;": "", "&Chi;": "", "&Psi;": "", "&Omega;": "", "&alpha;": "", "&beta;": "", "&gamma;": "", "&delta;": "", "&epsilon;": "", "&zeta;": "", "&eta;": "", "&theta;": "", "&iota;": "", "&kappa;": "", "&lambda;": "", "&mu;": "", "&nu;": "", "&xi;": "", "&omicron;": "", "&pi;": "", "&rho;": "", "&sigmaf;": "", "&sigma;": "", "&tau;": "", "&upsilon;": "", "&phi;": "", "&chi;": "", "&psi;": "", "&omega;": "", "&thetasym;": "", "&upsih;": "", "&piv;": "", "&bull;": "", "&hellip;": "", "&prime;": "", "&Prime;": "", "&oline;": "", "&frasl;": "", "&weierp;": "", "&image;": "", "&real;": "", "&trade;": "", "&alefsym;": "", "&larr;": "", "&uarr;": "", "&rarr;": "", "&darr;": "", "&harr;": "", "&crarr;": "", "&lArr;": "", "&uArr;": "", "&rArr;": "", "&dArr;": "", "&hArr;": "", "&forall;": "", "&part;": "", "&exist;": "", "&empty;": "", "&nabla;": "", "&isin;": "", "&notin;": "", "&ni;": "", "&prod;": "", "&sum;": "", "&minus;": "", "&lowast;": "", "&radic;": "", "&prop;": "", "&infin;": "", "&ang;": "", "&and;": "", "&or;": "", "&cap;": "", "&cup;": "", "&int;": "", "&there4;": "", "&sim;": "", "&cong;": "", "&asymp;": "", "&ne;": "", "&equiv;": "", "&le;": "", "&ge;": "", "&sub;": "", "&sup;": "", "&nsub;": "", "&sube;": "", "&supe;": "", "&oplus;": "", "&otimes;": "", "&perp;": "", "&sdot;": "", "&lceil;": "", "&rceil;": "", "&lfloor;": "", "&rfloor;": "", "&lang;": "", "&rang;": "", "&loz;": "", "&spades;": "", "&clubs;": "", "&hearts;": "", "&diams;": "" }, characters: { "'": "&apos;", "": "&nbsp;", "": "&iexcl;", "": "&cent;", "": "&pound;", "": "&curren;", "": "&yen;", "": "&brvbar;", "": "&sect;", "": "&uml;", "": "&copy;", : "&ordf;", "": "&laquo;", "": "&not;", "": "&shy;", "": "&reg;", "": "&macr;", "": "&deg;", "": "&plusmn;", "": "&sup2;", "": "&sup3;", "": "&acute;", : "&micro;", "": "&para;", "": "&middot;", "": "&cedil;", "": "&sup1;", : "&ordm;", "": "&raquo;", "": "&frac14;", "": "&frac12;", "": "&frac34;", "": "&iquest;", : "&Agrave;", : "&Aacute;", : "&Acirc;", : "&Atilde;", : "&Auml;", : "&Aring;", : "&AElig;", : "&Ccedil;", : "&Egrave;", : "&Eacute;", : "&Ecirc;", : "&Euml;", : "&Igrave;", : "&Iacute;", : "&Icirc;", : "&Iuml;", : "&ETH;", : "&Ntilde;", : "&Ograve;", : "&Oacute;", : "&Ocirc;", : "&Otilde;", : "&Ouml;", "": "&times;", : "&Oslash;", : "&Ugrave;", : "&Uacute;", : "&Ucirc;", : "&Uuml;", : "&Yacute;", : "&THORN;", : "&szlig;", : "&agrave;", : "&aacute;", : "&acirc;", : "&atilde;", : "&auml;", : "&aring;", : "&aelig;", : "&ccedil;", : "&egrave;", : "&eacute;", : "&ecirc;", : "&euml;", : "&igrave;", : "&iacute;", : "&icirc;", : "&iuml;", : "&eth;", : "&ntilde;", : "&ograve;", : "&oacute;", : "&ocirc;", : "&otilde;", : "&ouml;", "": "&divide;", : "&oslash;", : "&ugrave;", : "&uacute;", : "&ucirc;", : "&uuml;", : "&yacute;", : "&thorn;", : "&yuml;", '"': "&quot;", "&": "&amp;", "<": "&lt;", ">": "&gt;", : "&OElig;", : "&oelig;", : "&Scaron;", : "&scaron;", : "&Yuml;", "": "&circ;", "": "&tilde;", "": "&ensp;", "": "&emsp;", "": "&thinsp;", "": "&zwnj;", "": "&zwj;", "": "&lrm;", "": "&rlm;", "": "&ndash;", "": "&mdash;", "": "&lsquo;", "": "&rsquo;", "": "&sbquo;", "": "&ldquo;", "": "&rdquo;", "": "&bdquo;", "": "&dagger;", "": "&Dagger;", "": "&permil;", "": "&lsaquo;", "": "&rsaquo;", "": "&euro;", : "&fnof;", : "&Alpha;", : "&Beta;", : "&Gamma;", : "&Delta;", : "&Epsilon;", : "&Zeta;", : "&Eta;", : "&Theta;", : "&Iota;", : "&Kappa;", : "&Lambda;", : "&Mu;", : "&Nu;", : "&Xi;", : "&Omicron;", : "&Pi;", : "&Rho;", : "&Sigma;", : "&Tau;", : "&Upsilon;", : "&Phi;", : "&Chi;", : "&Psi;", : "&Omega;", : "&alpha;", : "&beta;", : "&gamma;", : "&delta;", : "&epsilon;", : "&zeta;", : "&eta;", : "&theta;", : "&iota;", : "&kappa;", : "&lambda;", : "&mu;", : "&nu;", : "&xi;", : "&omicron;", : "&pi;", : "&rho;", : "&sigmaf;", : "&sigma;", : "&tau;", : "&upsilon;", : "&phi;", : "&chi;", : "&psi;", : "&omega;", : "&thetasym;", : "&upsih;", : "&piv;", "": "&bull;", "": "&hellip;", "": "&prime;", "": "&Prime;", "": "&oline;", "": "&frasl;", "": "&weierp;", : "&image;", : "&real;", "": "&trade;", : "&alefsym;", "": "&larr;", "": "&uarr;", "": "&rarr;", "": "&darr;", "": "&harr;", "": "&crarr;", "": "&lArr;", "": "&uArr;", "": "&rArr;", "": "&dArr;", "": "&hArr;", "": "&forall;", "": "&part;", "": "&exist;", "": "&empty;", "": "&nabla;", "": "&isin;", "": "&notin;", "": "&ni;", "": "&prod;", "": "&sum;", "": "&minus;", "": "&lowast;", "": "&radic;", "": "&prop;", "": "&infin;", "": "&ang;", "": "&and;", "": "&or;", "": "&cap;", "": "&cup;", "": "&int;", "": "&there4;", "": "&sim;", "": "&cong;", "": "&asymp;", "": "&ne;", "": "&equiv;", "": "&le;", "": "&ge;", "": "&sub;", "": "&sup;", "": "&nsub;", "": "&sube;", "": "&supe;", "": "&oplus;", "": "&otimes;", "": "&perp;", "": "&sdot;", "": "&lceil;", "": "&rceil;", "": "&lfloor;", "": "&rfloor;", "": "&lang;", "": "&rang;", "": "&loz;", "": "&spades;", "": "&clubs;", "": "&hearts;", "": "&diams;" } }, html5: { entities: { "&AElig": "", "&AElig;": "", "&AMP": "&", "&AMP;": "&", "&Aacute": "", "&Aacute;": "", "&Abreve;": "", "&Acirc": "", "&Acirc;": "", "&Acy;": "", "&Afr;": "", "&Agrave": "", "&Agrave;": "", "&Alpha;": "", "&Amacr;": "", "&And;": "", "&Aogon;": "", "&Aopf;": "", "&ApplyFunction;": "", "&Aring": "", "&Aring;": "", "&Ascr;": "", "&Assign;": "", "&Atilde": "", "&Atilde;": "", "&Auml": "", "&Auml;": "", "&Backslash;": "", "&Barv;": "", "&Barwed;": "", "&Bcy;": "", "&Because;": "", "&Bernoullis;": "", "&Beta;": "", "&Bfr;": "", "&Bopf;": "", "&Breve;": "", "&Bscr;": "", "&Bumpeq;": "", "&CHcy;": "", "&COPY": "", "&COPY;": "", "&Cacute;": "", "&Cap;": "", "&CapitalDifferentialD;": "", "&Cayleys;": "", "&Ccaron;": "", "&Ccedil": "", "&Ccedil;": "", "&Ccirc;": "", "&Cconint;": "", "&Cdot;": "", "&Cedilla;": "", "&CenterDot;": "", "&Cfr;": "", "&Chi;": "", "&CircleDot;": "", "&CircleMinus;": "", "&CirclePlus;": "", "&CircleTimes;": "", "&ClockwiseContourIntegral;": "", "&CloseCurlyDoubleQuote;": "", "&CloseCurlyQuote;": "", "&Colon;": "", "&Colone;": "", "&Congruent;": "", "&Conint;": "", "&ContourIntegral;": "", "&Copf;": "", "&Coproduct;": "", "&CounterClockwiseContourIntegral;": "", "&Cross;": "", "&Cscr;": "", "&Cup;": "", "&CupCap;": "", "&DD;": "", "&DDotrahd;": "", "&DJcy;": "", "&DScy;": "", "&DZcy;": "", "&Dagger;": "", "&Darr;": "", "&Dashv;": "", "&Dcaron;": "", "&Dcy;": "", "&Del;": "", "&Delta;": "", "&Dfr;": "", "&DiacriticalAcute;": "", "&DiacriticalDot;": "", "&DiacriticalDoubleAcute;": "", "&DiacriticalGrave;": "`", "&DiacriticalTilde;": "", "&Diamond;": "", "&DifferentialD;": "", "&Dopf;": "", "&Dot;": "", "&DotDot;": "", "&DotEqual;": "", "&DoubleContourIntegral;": "", "&DoubleDot;": "", "&DoubleDownArrow;": "", "&DoubleLeftArrow;": "", "&DoubleLeftRightArrow;": "", "&DoubleLeftTee;": "", "&DoubleLongLeftArrow;": "", "&DoubleLongLeftRightArrow;": "", "&DoubleLongRightArrow;": "", "&DoubleRightArrow;": "", "&DoubleRightTee;": "", "&DoubleUpArrow;": "", "&DoubleUpDownArrow;": "", "&DoubleVerticalBar;": "", "&DownArrow;": "", "&DownArrowBar;": "", "&DownArrowUpArrow;": "", "&DownBreve;": "", "&DownLeftRightVector;": "", "&DownLeftTeeVector;": "", "&DownLeftVector;": "", "&DownLeftVectorBar;": "", "&DownRightTeeVector;": "", "&DownRightVector;": "", "&DownRightVectorBar;": "", "&DownTee;": "", "&DownTeeArrow;": "", "&Downarrow;": "", "&Dscr;": "", "&Dstrok;": "", "&ENG;": "", "&ETH": "", "&ETH;": "", "&Eacute": "", "&Eacute;": "", "&Ecaron;": "", "&Ecirc": "", "&Ecirc;": "", "&Ecy;": "", "&Edot;": "", "&Efr;": "", "&Egrave": "", "&Egrave;": "", "&Element;": "", "&Emacr;": "", "&EmptySmallSquare;": "", "&EmptyVerySmallSquare;": "", "&Eogon;": "", "&Eopf;": "", "&Epsilon;": "", "&Equal;": "", "&EqualTilde;": "", "&Equilibrium;": "", "&Escr;": "", "&Esim;": "", "&Eta;": "", "&Euml": "", "&Euml;": "", "&Exists;": "", "&ExponentialE;": "", "&Fcy;": "", "&Ffr;": "", "&FilledSmallSquare;": "", "&FilledVerySmallSquare;": "", "&Fopf;": "", "&ForAll;": "", "&Fouriertrf;": "", "&Fscr;": "", "&GJcy;": "", "&GT": ">", "&GT;": ">", "&Gamma;": "", "&Gammad;": "", "&Gbreve;": "", "&Gcedil;": "", "&Gcirc;": "", "&Gcy;": "", "&Gdot;": "", "&Gfr;": "", "&Gg;": "", "&Gopf;": "", "&GreaterEqual;": "", "&GreaterEqualLess;": "", "&GreaterFullEqual;": "", "&GreaterGreater;": "", "&GreaterLess;": "", "&GreaterSlantEqual;": "", "&GreaterTilde;": "", "&Gscr;": "", "&Gt;": "", "&HARDcy;": "", "&Hacek;": "", "&Hat;": "^", "&Hcirc;": "", "&Hfr;": "", "&HilbertSpace;": "", "&Hopf;": "", "&HorizontalLine;": "", "&Hscr;": "", "&Hstrok;": "", "&HumpDownHump;": "", "&HumpEqual;": "", "&IEcy;": "", "&IJlig;": "", "&IOcy;": "", "&Iacute": "", "&Iacute;": "", "&Icirc": "", "&Icirc;": "", "&Icy;": "", "&Idot;": "", "&Ifr;": "", "&Igrave": "", "&Igrave;": "", "&Im;": "", "&Imacr;": "", "&ImaginaryI;": "", "&Implies;": "", "&Int;": "", "&Integral;": "", "&Intersection;": "", "&InvisibleComma;": "", "&InvisibleTimes;": "", "&Iogon;": "", "&Iopf;": "", "&Iota;": "", "&Iscr;": "", "&Itilde;": "", "&Iukcy;": "", "&Iuml": "", "&Iuml;": "", "&Jcirc;": "", "&Jcy;": "", "&Jfr;": "", "&Jopf;": "", "&Jscr;": "", "&Jsercy;": "", "&Jukcy;": "", "&KHcy;": "", "&KJcy;": "", "&Kappa;": "", "&Kcedil;": "", "&Kcy;": "", "&Kfr;": "", "&Kopf;": "", "&Kscr;": "", "&LJcy;": "", "&LT": "<", "&LT;": "<", "&Lacute;": "", "&Lambda;": "", "&Lang;": "", "&Laplacetrf;": "", "&Larr;": "", "&Lcaron;": "", "&Lcedil;": "", "&Lcy;": "", "&LeftAngleBracket;": "", "&LeftArrow;": "", "&LeftArrowBar;": "", "&LeftArrowRightArrow;": "", "&LeftCeiling;": "", "&LeftDoubleBracket;": "", "&LeftDownTeeVector;": "", "&LeftDownVector;": "", "&LeftDownVectorBar;": "", "&LeftFloor;": "", "&LeftRightArrow;": "", "&LeftRightVector;": "", "&LeftTee;": "", "&LeftTeeArrow;": "", "&LeftTeeVector;": "", "&LeftTriangle;": "", "&LeftTriangleBar;": "", "&LeftTriangleEqual;": "", "&LeftUpDownVector;": "", "&LeftUpTeeVector;": "", "&LeftUpVector;": "", "&LeftUpVectorBar;": "", "&LeftVector;": "", "&LeftVectorBar;": "", "&Leftarrow;": "", "&Leftrightarrow;": "", "&LessEqualGreater;": "", "&LessFullEqual;": "", "&LessGreater;": "", "&LessLess;": "", "&LessSlantEqual;": "", "&LessTilde;": "", "&Lfr;": "", "&Ll;": "", "&Lleftarrow;": "", "&Lmidot;": "", "&LongLeftArrow;": "", "&LongLeftRightArrow;": "", "&LongRightArrow;": "", "&Longleftarrow;": "", "&Longleftrightarrow;": "", "&Longrightarrow;": "", "&Lopf;": "", "&LowerLeftArrow;": "", "&LowerRightArrow;": "", "&Lscr;": "", "&Lsh;": "", "&Lstrok;": "", "&Lt;": "", "&Map;": "", "&Mcy;": "", "&MediumSpace;": "", "&Mellintrf;": "", "&Mfr;": "", "&MinusPlus;": "", "&Mopf;": "", "&Mscr;": "", "&Mu;": "", "&NJcy;": "", "&Nacute;": "", "&Ncaron;": "", "&Ncedil;": "", "&Ncy;": "", "&NegativeMediumSpace;": "", "&NegativeThickSpace;": "", "&NegativeThinSpace;": "", "&NegativeVeryThinSpace;": "", "&NestedGreaterGreater;": "", "&NestedLessLess;": "", "&NewLine;": `
`, "&Nfr;": "", "&NoBreak;": "", "&NonBreakingSpace;": "", "&Nopf;": "", "&Not;": "", "&NotCongruent;": "", "&NotCupCap;": "", "&NotDoubleVerticalBar;": "", "&NotElement;": "", "&NotEqual;": "", "&NotEqualTilde;": "", "&NotExists;": "", "&NotGreater;": "", "&NotGreaterEqual;": "", "&NotGreaterFullEqual;": "", "&NotGreaterGreater;": "", "&NotGreaterLess;": "", "&NotGreaterSlantEqual;": "", "&NotGreaterTilde;": "", "&NotHumpDownHump;": "", "&NotHumpEqual;": "", "&NotLeftTriangle;": "", "&NotLeftTriangleBar;": "", "&NotLeftTriangleEqual;": "", "&NotLess;": "", "&NotLessEqual;": "", "&NotLessGreater;": "", "&NotLessLess;": "", "&NotLessSlantEqual;": "", "&NotLessTilde;": "", "&NotNestedGreaterGreater;": "", "&NotNestedLessLess;": "", "&NotPrecedes;": "", "&NotPrecedesEqual;": "", "&NotPrecedesSlantEqual;": "", "&NotReverseElement;": "", "&NotRightTriangle;": "", "&NotRightTriangleBar;": "", "&NotRightTriangleEqual;": "", "&NotSquareSubset;": "", "&NotSquareSubsetEqual;": "", "&NotSquareSuperset;": "", "&NotSquareSupersetEqual;": "", "&NotSubset;": "", "&NotSubsetEqual;": "", "&NotSucceeds;": "", "&NotSucceedsEqual;": "", "&NotSucceedsSlantEqual;": "", "&NotSucceedsTilde;": "", "&NotSuperset;": "", "&NotSupersetEqual;": "", "&NotTilde;": "", "&NotTildeEqual;": "", "&NotTildeFullEqual;": "", "&NotTildeTilde;": "", "&NotVerticalBar;": "", "&Nscr;": "", "&Ntilde": "", "&Ntilde;": "", "&Nu;": "", "&OElig;": "", "&Oacute": "", "&Oacute;": "", "&Ocirc": "", "&Ocirc;": "", "&Ocy;": "", "&Odblac;": "", "&Ofr;": "", "&Ograve": "", "&Ograve;": "", "&Omacr;": "", "&Omega;": "", "&Omicron;": "", "&Oopf;": "", "&OpenCurlyDoubleQuote;": "", "&OpenCurlyQuote;": "", "&Or;": "", "&Oscr;": "", "&Oslash": "", "&Oslash;": "", "&Otilde": "", "&Otilde;": "", "&Otimes;": "", "&Ouml": "", "&Ouml;": "", "&OverBar;": "", "&OverBrace;": "", "&OverBracket;": "", "&OverParenthesis;": "", "&PartialD;": "", "&Pcy;": "", "&Pfr;": "", "&Phi;": "", "&Pi;": "", "&PlusMinus;": "", "&Poincareplane;": "", "&Popf;": "", "&Pr;": "", "&Precedes;": "", "&PrecedesEqual;": "", "&PrecedesSlantEqual;": "", "&PrecedesTilde;": "", "&Prime;": "", "&Product;": "", "&Proportion;": "", "&Proportional;": "", "&Pscr;": "", "&Psi;": "", "&QUOT": '"', "&QUOT;": '"', "&Qfr;": "", "&Qopf;": "", "&Qscr;": "", "&RBarr;": "", "&REG": "", "&REG;": "", "&Racute;": "", "&Rang;": "", "&Rarr;": "", "&Rarrtl;": "", "&Rcaron;": "", "&Rcedil;": "", "&Rcy;": "", "&Re;": "", "&ReverseElement;": "", "&ReverseEquilibrium;": "", "&ReverseUpEquilibrium;": "", "&Rfr;": "", "&Rho;": "", "&RightAngleBracket;": "", "&RightArrow;": "", "&RightArrowBar;": "", "&RightArrowLeftArrow;": "", "&RightCeiling;": "", "&RightDoubleBracket;": "", "&RightDownTeeVector;": "", "&RightDownVector;": "", "&RightDownVectorBar;": "", "&RightFloor;": "", "&RightTee;": "", "&RightTeeArrow;": "", "&RightTeeVector;": "", "&RightTriangle;": "", "&RightTriangleBar;": "", "&RightTriangleEqual;": "", "&RightUpDownVector;": "", "&RightUpTeeVector;": "", "&RightUpVector;": "", "&RightUpVectorBar;": "", "&RightVector;": "", "&RightVectorBar;": "", "&Rightarrow;": "", "&Ropf;": "", "&RoundImplies;": "", "&Rrightarrow;": "", "&Rscr;": "", "&Rsh;": "", "&RuleDelayed;": "", "&SHCHcy;": "", "&SHcy;": "", "&SOFTcy;": "", "&Sacute;": "", "&Sc;": "", "&Scaron;": "", "&Scedil;": "", "&Scirc;": "", "&Scy;": "", "&Sfr;": "", "&ShortDownArrow;": "", "&ShortLeftArrow;": "", "&ShortRightArrow;": "", "&ShortUpArrow;": "", "&Sigma;": "", "&SmallCircle;": "", "&Sopf;": "", "&Sqrt;": "", "&Square;": "", "&SquareIntersection;": "", "&SquareSubset;": "", "&SquareSubsetEqual;": "", "&SquareSuperset;": "", "&SquareSupersetEqual;": "", "&SquareUnion;": "", "&Sscr;": "", "&Star;": "", "&Sub;": "", "&Subset;": "", "&SubsetEqual;": "", "&Succeeds;": "", "&SucceedsEqual;": "", "&SucceedsSlantEqual;": "", "&SucceedsTilde;": "", "&SuchThat;": "", "&Sum;": "", "&Sup;": "", "&Superset;": "", "&SupersetEqual;": "", "&Supset;": "", "&THORN": "", "&THORN;": "", "&TRADE;": "", "&TSHcy;": "", "&TScy;": "", "&Tab;": "	", "&Tau;": "", "&Tcaron;": "", "&Tcedil;": "", "&Tcy;": "", "&Tfr;": "", "&Therefore;": "", "&Theta;": "", "&ThickSpace;": "", "&ThinSpace;": "", "&Tilde;": "", "&TildeEqual;": "", "&TildeFullEqual;": "", "&TildeTilde;": "", "&Topf;": "", "&TripleDot;": "", "&Tscr;": "", "&Tstrok;": "", "&Uacute": "", "&Uacute;": "", "&Uarr;": "", "&Uarrocir;": "", "&Ubrcy;": "", "&Ubreve;": "", "&Ucirc": "", "&Ucirc;": "", "&Ucy;": "", "&Udblac;": "", "&Ufr;": "", "&Ugrave": "", "&Ugrave;": "", "&Umacr;": "", "&UnderBar;": "_", "&UnderBrace;": "", "&UnderBracket;": "", "&UnderParenthesis;": "", "&Union;": "", "&UnionPlus;": "", "&Uogon;": "", "&Uopf;": "", "&UpArrow;": "", "&UpArrowBar;": "", "&UpArrowDownArrow;": "", "&UpDownArrow;": "", "&UpEquilibrium;": "", "&UpTee;": "", "&UpTeeArrow;": "", "&Uparrow;": "", "&Updownarrow;": "", "&UpperLeftArrow;": "", "&UpperRightArrow;": "", "&Upsi;": "", "&Upsilon;": "", "&Uring;": "", "&Uscr;": "", "&Utilde;": "", "&Uuml": "", "&Uuml;": "", "&VDash;": "", "&Vbar;": "", "&Vcy;": "", "&Vdash;": "", "&Vdashl;": "", "&Vee;": "", "&Verbar;": "", "&Vert;": "", "&VerticalBar;": "", "&VerticalLine;": "|", "&VerticalSeparator;": "", "&VerticalTilde;": "", "&VeryThinSpace;": "", "&Vfr;": "", "&Vopf;": "", "&Vscr;": "", "&Vvdash;": "", "&Wcirc;": "", "&Wedge;": "", "&Wfr;": "", "&Wopf;": "", "&Wscr;": "", "&Xfr;": "", "&Xi;": "", "&Xopf;": "", "&Xscr;": "", "&YAcy;": "", "&YIcy;": "", "&YUcy;": "", "&Yacute": "", "&Yacute;": "", "&Ycirc;": "", "&Ycy;": "", "&Yfr;": "", "&Yopf;": "", "&Yscr;": "", "&Yuml;": "", "&ZHcy;": "", "&Zacute;": "", "&Zcaron;": "", "&Zcy;": "", "&Zdot;": "", "&ZeroWidthSpace;": "", "&Zeta;": "", "&Zfr;": "", "&Zopf;": "", "&Zscr;": "", "&aacute": "", "&aacute;": "", "&abreve;": "", "&ac;": "", "&acE;": "", "&acd;": "", "&acirc": "", "&acirc;": "", "&acute": "", "&acute;": "", "&acy;": "", "&aelig": "", "&aelig;": "", "&af;": "", "&afr;": "", "&agrave": "", "&agrave;": "", "&alefsym;": "", "&aleph;": "", "&alpha;": "", "&amacr;": "", "&amalg;": "", "&amp": "&", "&amp;": "&", "&and;": "", "&andand;": "", "&andd;": "", "&andslope;": "", "&andv;": "", "&ang;": "", "&ange;": "", "&angle;": "", "&angmsd;": "", "&angmsdaa;": "", "&angmsdab;": "", "&angmsdac;": "", "&angmsdad;": "", "&angmsdae;": "", "&angmsdaf;": "", "&angmsdag;": "", "&angmsdah;": "", "&angrt;": "", "&angrtvb;": "", "&angrtvbd;": "", "&angsph;": "", "&angst;": "", "&angzarr;": "", "&aogon;": "", "&aopf;": "", "&ap;": "", "&apE;": "", "&apacir;": "", "&ape;": "", "&apid;": "", "&apos;": "'", "&approx;": "", "&approxeq;": "", "&aring": "", "&aring;": "", "&ascr;": "", "&ast;": "*", "&asymp;": "", "&asympeq;": "", "&atilde": "", "&atilde;": "", "&auml": "", "&auml;": "", "&awconint;": "", "&awint;": "", "&bNot;": "", "&backcong;": "", "&backepsilon;": "", "&backprime;": "", "&backsim;": "", "&backsimeq;": "", "&barvee;": "", "&barwed;": "", "&barwedge;": "", "&bbrk;": "", "&bbrktbrk;": "", "&bcong;": "", "&bcy;": "", "&bdquo;": "", "&becaus;": "", "&because;": "", "&bemptyv;": "", "&bepsi;": "", "&bernou;": "", "&beta;": "", "&beth;": "", "&between;": "", "&bfr;": "", "&bigcap;": "", "&bigcirc;": "", "&bigcup;": "", "&bigodot;": "", "&bigoplus;": "", "&bigotimes;": "", "&bigsqcup;": "", "&bigstar;": "", "&bigtriangledown;": "", "&bigtriangleup;": "", "&biguplus;": "", "&bigvee;": "", "&bigwedge;": "", "&bkarow;": "", "&blacklozenge;": "", "&blacksquare;": "", "&blacktriangle;": "", "&blacktriangledown;": "", "&blacktriangleleft;": "", "&blacktriangleright;": "", "&blank;": "", "&blk12;": "", "&blk14;": "", "&blk34;": "", "&block;": "", "&bne;": "=", "&bnequiv;": "", "&bnot;": "", "&bopf;": "", "&bot;": "", "&bottom;": "", "&bowtie;": "", "&boxDL;": "", "&boxDR;": "", "&boxDl;": "", "&boxDr;": "", "&boxH;": "", "&boxHD;": "", "&boxHU;": "", "&boxHd;": "", "&boxHu;": "", "&boxUL;": "", "&boxUR;": "", "&boxUl;": "", "&boxUr;": "", "&boxV;": "", "&boxVH;": "", "&boxVL;": "", "&boxVR;": "", "&boxVh;": "", "&boxVl;": "", "&boxVr;": "", "&boxbox;": "", "&boxdL;": "", "&boxdR;": "", "&boxdl;": "", "&boxdr;": "", "&boxh;": "", "&boxhD;": "", "&boxhU;": "", "&boxhd;": "", "&boxhu;": "", "&boxminus;": "", "&boxplus;": "", "&boxtimes;": "", "&boxuL;": "", "&boxuR;": "", "&boxul;": "", "&boxur;": "", "&boxv;": "", "&boxvH;": "", "&boxvL;": "", "&boxvR;": "", "&boxvh;": "", "&boxvl;": "", "&boxvr;": "", "&bprime;": "", "&breve;": "", "&brvbar": "", "&brvbar;": "", "&bscr;": "", "&bsemi;": "", "&bsim;": "", "&bsime;": "", "&bsol;": "\\", "&bsolb;": "", "&bsolhsub;": "", "&bull;": "", "&bullet;": "", "&bump;": "", "&bumpE;": "", "&bumpe;": "", "&bumpeq;": "", "&cacute;": "", "&cap;": "", "&capand;": "", "&capbrcup;": "", "&capcap;": "", "&capcup;": "", "&capdot;": "", "&caps;": "", "&caret;": "", "&caron;": "", "&ccaps;": "", "&ccaron;": "", "&ccedil": "", "&ccedil;": "", "&ccirc;": "", "&ccups;": "", "&ccupssm;": "", "&cdot;": "", "&cedil": "", "&cedil;": "", "&cemptyv;": "", "&cent": "", "&cent;": "", "&centerdot;": "", "&cfr;": "", "&chcy;": "", "&check;": "", "&checkmark;": "", "&chi;": "", "&cir;": "", "&cirE;": "", "&circ;": "", "&circeq;": "", "&circlearrowleft;": "", "&circlearrowright;": "", "&circledR;": "", "&circledS;": "", "&circledast;": "", "&circledcirc;": "", "&circleddash;": "", "&cire;": "", "&cirfnint;": "", "&cirmid;": "", "&cirscir;": "", "&clubs;": "", "&clubsuit;": "", "&colon;": ":", "&colone;": "", "&coloneq;": "", "&comma;": ",", "&commat;": "@", "&comp;": "", "&compfn;": "", "&complement;": "", "&complexes;": "", "&cong;": "", "&congdot;": "", "&conint;": "", "&copf;": "", "&coprod;": "", "&copy": "", "&copy;": "", "&copysr;": "", "&crarr;": "", "&cross;": "", "&cscr;": "", "&csub;": "", "&csube;": "", "&csup;": "", "&csupe;": "", "&ctdot;": "", "&cudarrl;": "", "&cudarrr;": "", "&cuepr;": "", "&cuesc;": "", "&cularr;": "", "&cularrp;": "", "&cup;": "", "&cupbrcap;": "", "&cupcap;": "", "&cupcup;": "", "&cupdot;": "", "&cupor;": "", "&cups;": "", "&curarr;": "", "&curarrm;": "", "&curlyeqprec;": "", "&curlyeqsucc;": "", "&curlyvee;": "", "&curlywedge;": "", "&curren": "", "&curren;": "", "&curvearrowleft;": "", "&curvearrowright;": "", "&cuvee;": "", "&cuwed;": "", "&cwconint;": "", "&cwint;": "", "&cylcty;": "", "&dArr;": "", "&dHar;": "", "&dagger;": "", "&daleth;": "", "&darr;": "", "&dash;": "", "&dashv;": "", "&dbkarow;": "", "&dblac;": "", "&dcaron;": "", "&dcy;": "", "&dd;": "", "&ddagger;": "", "&ddarr;": "", "&ddotseq;": "", "&deg": "", "&deg;": "", "&delta;": "", "&demptyv;": "", "&dfisht;": "", "&dfr;": "", "&dharl;": "", "&dharr;": "", "&diam;": "", "&diamond;": "", "&diamondsuit;": "", "&diams;": "", "&die;": "", "&digamma;": "", "&disin;": "", "&div;": "", "&divide": "", "&divide;": "", "&divideontimes;": "", "&divonx;": "", "&djcy;": "", "&dlcorn;": "", "&dlcrop;": "", "&dollar;": "$", "&dopf;": "", "&dot;": "", "&doteq;": "", "&doteqdot;": "", "&dotminus;": "", "&dotplus;": "", "&dotsquare;": "", "&doublebarwedge;": "", "&downarrow;": "", "&downdownarrows;": "", "&downharpoonleft;": "", "&downharpoonright;": "", "&drbkarow;": "", "&drcorn;": "", "&drcrop;": "", "&dscr;": "", "&dscy;": "", "&dsol;": "", "&dstrok;": "", "&dtdot;": "", "&dtri;": "", "&dtrif;": "", "&duarr;": "", "&duhar;": "", "&dwangle;": "", "&dzcy;": "", "&dzigrarr;": "", "&eDDot;": "", "&eDot;": "", "&eacute": "", "&eacute;": "", "&easter;": "", "&ecaron;": "", "&ecir;": "", "&ecirc": "", "&ecirc;": "", "&ecolon;": "", "&ecy;": "", "&edot;": "", "&ee;": "", "&efDot;": "", "&efr;": "", "&eg;": "", "&egrave": "", "&egrave;": "", "&egs;": "", "&egsdot;": "", "&el;": "", "&elinters;": "", "&ell;": "", "&els;": "", "&elsdot;": "", "&emacr;": "", "&empty;": "", "&emptyset;": "", "&emptyv;": "", "&emsp13;": "", "&emsp14;": "", "&emsp;": "", "&eng;": "", "&ensp;": "", "&eogon;": "", "&eopf;": "", "&epar;": "", "&eparsl;": "", "&eplus;": "", "&epsi;": "", "&epsilon;": "", "&epsiv;": "", "&eqcirc;": "", "&eqcolon;": "", "&eqsim;": "", "&eqslantgtr;": "", "&eqslantless;": "", "&equals;": "=", "&equest;": "", "&equiv;": "", "&equivDD;": "", "&eqvparsl;": "", "&erDot;": "", "&erarr;": "", "&escr;": "", "&esdot;": "", "&esim;": "", "&eta;": "", "&eth": "", "&eth;": "", "&euml": "", "&euml;": "", "&euro;": "", "&excl;": "!", "&exist;": "", "&expectation;": "", "&exponentiale;": "", "&fallingdotseq;": "", "&fcy;": "", "&female;": "", "&ffilig;": "", "&fflig;": "", "&ffllig;": "", "&ffr;": "", "&filig;": "", "&fjlig;": "fj", "&flat;": "", "&fllig;": "", "&fltns;": "", "&fnof;": "", "&fopf;": "", "&forall;": "", "&fork;": "", "&forkv;": "", "&fpartint;": "", "&frac12": "", "&frac12;": "", "&frac13;": "", "&frac14": "", "&frac14;": "", "&frac15;": "", "&frac16;": "", "&frac18;": "", "&frac23;": "", "&frac25;": "", "&frac34": "", "&frac34;": "", "&frac35;": "", "&frac38;": "", "&frac45;": "", "&frac56;": "", "&frac58;": "", "&frac78;": "", "&frasl;": "", "&frown;": "", "&fscr;": "", "&gE;": "", "&gEl;": "", "&gacute;": "", "&gamma;": "", "&gammad;": "", "&gap;": "", "&gbreve;": "", "&gcirc;": "", "&gcy;": "", "&gdot;": "", "&ge;": "", "&gel;": "", "&geq;": "", "&geqq;": "", "&geqslant;": "", "&ges;": "", "&gescc;": "", "&gesdot;": "", "&gesdoto;": "", "&gesdotol;": "", "&gesl;": "", "&gesles;": "", "&gfr;": "", "&gg;": "", "&ggg;": "", "&gimel;": "", "&gjcy;": "", "&gl;": "", "&glE;": "", "&gla;": "", "&glj;": "", "&gnE;": "", "&gnap;": "", "&gnapprox;": "", "&gne;": "", "&gneq;": "", "&gneqq;": "", "&gnsim;": "", "&gopf;": "", "&grave;": "`", "&gscr;": "", "&gsim;": "", "&gsime;": "", "&gsiml;": "", "&gt": ">", "&gt;": ">", "&gtcc;": "", "&gtcir;": "", "&gtdot;": "", "&gtlPar;": "", "&gtquest;": "", "&gtrapprox;": "", "&gtrarr;": "", "&gtrdot;": "", "&gtreqless;": "", "&gtreqqless;": "", "&gtrless;": "", "&gtrsim;": "", "&gvertneqq;": "", "&gvnE;": "", "&hArr;": "", "&hairsp;": "", "&half;": "", "&hamilt;": "", "&hardcy;": "", "&harr;": "", "&harrcir;": "", "&harrw;": "", "&hbar;": "", "&hcirc;": "", "&hearts;": "", "&heartsuit;": "", "&hellip;": "", "&hercon;": "", "&hfr;": "", "&hksearow;": "", "&hkswarow;": "", "&hoarr;": "", "&homtht;": "", "&hookleftarrow;": "", "&hookrightarrow;": "", "&hopf;": "", "&horbar;": "", "&hscr;": "", "&hslash;": "", "&hstrok;": "", "&hybull;": "", "&hyphen;": "", "&iacute": "", "&iacute;": "", "&ic;": "", "&icirc": "", "&icirc;": "", "&icy;": "", "&iecy;": "", "&iexcl": "", "&iexcl;": "", "&iff;": "", "&ifr;": "", "&igrave": "", "&igrave;": "", "&ii;": "", "&iiiint;": "", "&iiint;": "", "&iinfin;": "", "&iiota;": "", "&ijlig;": "", "&imacr;": "", "&image;": "", "&imagline;": "", "&imagpart;": "", "&imath;": "", "&imof;": "", "&imped;": "", "&in;": "", "&incare;": "", "&infin;": "", "&infintie;": "", "&inodot;": "", "&int;": "", "&intcal;": "", "&integers;": "", "&intercal;": "", "&intlarhk;": "", "&intprod;": "", "&iocy;": "", "&iogon;": "", "&iopf;": "", "&iota;": "", "&iprod;": "", "&iquest": "", "&iquest;": "", "&iscr;": "", "&isin;": "", "&isinE;": "", "&isindot;": "", "&isins;": "", "&isinsv;": "", "&isinv;": "", "&it;": "", "&itilde;": "", "&iukcy;": "", "&iuml": "", "&iuml;": "", "&jcirc;": "", "&jcy;": "", "&jfr;": "", "&jmath;": "", "&jopf;": "", "&jscr;": "", "&jsercy;": "", "&jukcy;": "", "&kappa;": "", "&kappav;": "", "&kcedil;": "", "&kcy;": "", "&kfr;": "", "&kgreen;": "", "&khcy;": "", "&kjcy;": "", "&kopf;": "", "&kscr;": "", "&lAarr;": "", "&lArr;": "", "&lAtail;": "", "&lBarr;": "", "&lE;": "", "&lEg;": "", "&lHar;": "", "&lacute;": "", "&laemptyv;": "", "&lagran;": "", "&lambda;": "", "&lang;": "", "&langd;": "", "&langle;": "", "&lap;": "", "&laquo": "", "&laquo;": "", "&larr;": "", "&larrb;": "", "&larrbfs;": "", "&larrfs;": "", "&larrhk;": "", "&larrlp;": "", "&larrpl;": "", "&larrsim;": "", "&larrtl;": "", "&lat;": "", "&latail;": "", "&late;": "", "&lates;": "", "&lbarr;": "", "&lbbrk;": "", "&lbrace;": "{", "&lbrack;": "[", "&lbrke;": "", "&lbrksld;": "", "&lbrkslu;": "", "&lcaron;": "", "&lcedil;": "", "&lceil;": "", "&lcub;": "{", "&lcy;": "", "&ldca;": "", "&ldquo;": "", "&ldquor;": "", "&ldrdhar;": "", "&ldrushar;": "", "&ldsh;": "", "&le;": "", "&leftarrow;": "", "&leftarrowtail;": "", "&leftharpoondown;": "", "&leftharpoonup;": "", "&leftleftarrows;": "", "&leftrightarrow;": "", "&leftrightarrows;": "", "&leftrightharpoons;": "", "&leftrightsquigarrow;": "", "&leftthreetimes;": "", "&leg;": "", "&leq;": "", "&leqq;": "", "&leqslant;": "", "&les;": "", "&lescc;": "", "&lesdot;": "", "&lesdoto;": "", "&lesdotor;": "", "&lesg;": "", "&lesges;": "", "&lessapprox;": "", "&lessdot;": "", "&lesseqgtr;": "", "&lesseqqgtr;": "", "&lessgtr;": "", "&lesssim;": "", "&lfisht;": "", "&lfloor;": "", "&lfr;": "", "&lg;": "", "&lgE;": "", "&lhard;": "", "&lharu;": "", "&lharul;": "", "&lhblk;": "", "&ljcy;": "", "&ll;": "", "&llarr;": "", "&llcorner;": "", "&llhard;": "", "&lltri;": "", "&lmidot;": "", "&lmoust;": "", "&lmoustache;": "", "&lnE;": "", "&lnap;": "", "&lnapprox;": "", "&lne;": "", "&lneq;": "", "&lneqq;": "", "&lnsim;": "", "&loang;": "", "&loarr;": "", "&lobrk;": "", "&longleftarrow;": "", "&longleftrightarrow;": "", "&longmapsto;": "", "&longrightarrow;": "", "&looparrowleft;": "", "&looparrowright;": "", "&lopar;": "", "&lopf;": "", "&loplus;": "", "&lotimes;": "", "&lowast;": "", "&lowbar;": "_", "&loz;": "", "&lozenge;": "", "&lozf;": "", "&lpar;": "(", "&lparlt;": "", "&lrarr;": "", "&lrcorner;": "", "&lrhar;": "", "&lrhard;": "", "&lrm;": "", "&lrtri;": "", "&lsaquo;": "", "&lscr;": "", "&lsh;": "", "&lsim;": "", "&lsime;": "", "&lsimg;": "", "&lsqb;": "[", "&lsquo;": "", "&lsquor;": "", "&lstrok;": "", "&lt": "<", "&lt;": "<", "&ltcc;": "", "&ltcir;": "", "&ltdot;": "", "&lthree;": "", "&ltimes;": "", "&ltlarr;": "", "&ltquest;": "", "&ltrPar;": "", "&ltri;": "", "&ltrie;": "", "&ltrif;": "", "&lurdshar;": "", "&luruhar;": "", "&lvertneqq;": "", "&lvnE;": "", "&mDDot;": "", "&macr": "", "&macr;": "", "&male;": "", "&malt;": "", "&maltese;": "", "&map;": "", "&mapsto;": "", "&mapstodown;": "", "&mapstoleft;": "", "&mapstoup;": "", "&marker;": "", "&mcomma;": "", "&mcy;": "", "&mdash;": "", "&measuredangle;": "", "&mfr;": "", "&mho;": "", "&micro": "", "&micro;": "", "&mid;": "", "&midast;": "*", "&midcir;": "", "&middot": "", "&middot;": "", "&minus;": "", "&minusb;": "", "&minusd;": "", "&minusdu;": "", "&mlcp;": "", "&mldr;": "", "&mnplus;": "", "&models;": "", "&mopf;": "", "&mp;": "", "&mscr;": "", "&mstpos;": "", "&mu;": "", "&multimap;": "", "&mumap;": "", "&nGg;": "", "&nGt;": "", "&nGtv;": "", "&nLeftarrow;": "", "&nLeftrightarrow;": "", "&nLl;": "", "&nLt;": "", "&nLtv;": "", "&nRightarrow;": "", "&nVDash;": "", "&nVdash;": "", "&nabla;": "", "&nacute;": "", "&nang;": "", "&nap;": "", "&napE;": "", "&napid;": "", "&napos;": "", "&napprox;": "", "&natur;": "", "&natural;": "", "&naturals;": "", "&nbsp": "", "&nbsp;": "", "&nbump;": "", "&nbumpe;": "", "&ncap;": "", "&ncaron;": "", "&ncedil;": "", "&ncong;": "", "&ncongdot;": "", "&ncup;": "", "&ncy;": "", "&ndash;": "", "&ne;": "", "&neArr;": "", "&nearhk;": "", "&nearr;": "", "&nearrow;": "", "&nedot;": "", "&nequiv;": "", "&nesear;": "", "&nesim;": "", "&nexist;": "", "&nexists;": "", "&nfr;": "", "&ngE;": "", "&nge;": "", "&ngeq;": "", "&ngeqq;": "", "&ngeqslant;": "", "&nges;": "", "&ngsim;": "", "&ngt;": "", "&ngtr;": "", "&nhArr;": "", "&nharr;": "", "&nhpar;": "", "&ni;": "", "&nis;": "", "&nisd;": "", "&niv;": "", "&njcy;": "", "&nlArr;": "", "&nlE;": "", "&nlarr;": "", "&nldr;": "", "&nle;": "", "&nleftarrow;": "", "&nleftrightarrow;": "", "&nleq;": "", "&nleqq;": "", "&nleqslant;": "", "&nles;": "", "&nless;": "", "&nlsim;": "", "&nlt;": "", "&nltri;": "", "&nltrie;": "", "&nmid;": "", "&nopf;": "", "&not": "", "&not;": "", "&notin;": "", "&notinE;": "", "&notindot;": "", "&notinva;": "", "&notinvb;": "", "&notinvc;": "", "&notni;": "", "&notniva;": "", "&notnivb;": "", "&notnivc;": "", "&npar;": "", "&nparallel;": "", "&nparsl;": "", "&npart;": "", "&npolint;": "", "&npr;": "", "&nprcue;": "", "&npre;": "", "&nprec;": "", "&npreceq;": "", "&nrArr;": "", "&nrarr;": "", "&nrarrc;": "", "&nrarrw;": "", "&nrightarrow;": "", "&nrtri;": "", "&nrtrie;": "", "&nsc;": "", "&nsccue;": "", "&nsce;": "", "&nscr;": "", "&nshortmid;": "", "&nshortparallel;": "", "&nsim;": "", "&nsime;": "", "&nsimeq;": "", "&nsmid;": "", "&nspar;": "", "&nsqsube;": "", "&nsqsupe;": "", "&nsub;": "", "&nsubE;": "", "&nsube;": "", "&nsubset;": "", "&nsubseteq;": "", "&nsubseteqq;": "", "&nsucc;": "", "&nsucceq;": "", "&nsup;": "", "&nsupE;": "", "&nsupe;": "", "&nsupset;": "", "&nsupseteq;": "", "&nsupseteqq;": "", "&ntgl;": "", "&ntilde": "", "&ntilde;": "", "&ntlg;": "", "&ntriangleleft;": "", "&ntrianglelefteq;": "", "&ntriangleright;": "", "&ntrianglerighteq;": "", "&nu;": "", "&num;": "#", "&numero;": "", "&numsp;": "", "&nvDash;": "", "&nvHarr;": "", "&nvap;": "", "&nvdash;": "", "&nvge;": "", "&nvgt;": ">", "&nvinfin;": "", "&nvlArr;": "", "&nvle;": "", "&nvlt;": "<", "&nvltrie;": "", "&nvrArr;": "", "&nvrtrie;": "", "&nvsim;": "", "&nwArr;": "", "&nwarhk;": "", "&nwarr;": "", "&nwarrow;": "", "&nwnear;": "", "&oS;": "", "&oacute": "", "&oacute;": "", "&oast;": "", "&ocir;": "", "&ocirc": "", "&ocirc;": "", "&ocy;": "", "&odash;": "", "&odblac;": "", "&odiv;": "", "&odot;": "", "&odsold;": "", "&oelig;": "", "&ofcir;": "", "&ofr;": "", "&ogon;": "", "&ograve": "", "&ograve;": "", "&ogt;": "", "&ohbar;": "", "&ohm;": "", "&oint;": "", "&olarr;": "", "&olcir;": "", "&olcross;": "", "&oline;": "", "&olt;": "", "&omacr;": "", "&omega;": "", "&omicron;": "", "&omid;": "", "&ominus;": "", "&oopf;": "", "&opar;": "", "&operp;": "", "&oplus;": "", "&or;": "", "&orarr;": "", "&ord;": "", "&order;": "", "&orderof;": "", "&ordf": "", "&ordf;": "", "&ordm": "", "&ordm;": "", "&origof;": "", "&oror;": "", "&orslope;": "", "&orv;": "", "&oscr;": "", "&oslash": "", "&oslash;": "", "&osol;": "", "&otilde": "", "&otilde;": "", "&otimes;": "", "&otimesas;": "", "&ouml": "", "&ouml;": "", "&ovbar;": "", "&par;": "", "&para": "", "&para;": "", "&parallel;": "", "&parsim;": "", "&parsl;": "", "&part;": "", "&pcy;": "", "&percnt;": "%", "&period;": ".", "&permil;": "", "&perp;": "", "&pertenk;": "", "&pfr;": "", "&phi;": "", "&phiv;": "", "&phmmat;": "", "&phone;": "", "&pi;": "", "&pitchfork;": "", "&piv;": "", "&planck;": "", "&planckh;": "", "&plankv;": "", "&plus;": "+", "&plusacir;": "", "&plusb;": "", "&pluscir;": "", "&plusdo;": "", "&plusdu;": "", "&pluse;": "", "&plusmn": "", "&plusmn;": "", "&plussim;": "", "&plustwo;": "", "&pm;": "", "&pointint;": "", "&popf;": "", "&pound": "", "&pound;": "", "&pr;": "", "&prE;": "", "&prap;": "", "&prcue;": "", "&pre;": "", "&prec;": "", "&precapprox;": "", "&preccurlyeq;": "", "&preceq;": "", "&precnapprox;": "", "&precneqq;": "", "&precnsim;": "", "&precsim;": "", "&prime;": "", "&primes;": "", "&prnE;": "", "&prnap;": "", "&prnsim;": "", "&prod;": "", "&profalar;": "", "&profline;": "", "&profsurf;": "", "&prop;": "", "&propto;": "", "&prsim;": "", "&prurel;": "", "&pscr;": "", "&psi;": "", "&puncsp;": "", "&qfr;": "", "&qint;": "", "&qopf;": "", "&qprime;": "", "&qscr;": "", "&quaternions;": "", "&quatint;": "", "&quest;": "?", "&questeq;": "", "&quot": '"', "&quot;": '"', "&rAarr;": "", "&rArr;": "", "&rAtail;": "", "&rBarr;": "", "&rHar;": "", "&race;": "", "&racute;": "", "&radic;": "", "&raemptyv;": "", "&rang;": "", "&rangd;": "", "&range;": "", "&rangle;": "", "&raquo": "", "&raquo;": "", "&rarr;": "", "&rarrap;": "", "&rarrb;": "", "&rarrbfs;": "", "&rarrc;": "", "&rarrfs;": "", "&rarrhk;": "", "&rarrlp;": "", "&rarrpl;": "", "&rarrsim;": "", "&rarrtl;": "", "&rarrw;": "", "&ratail;": "", "&ratio;": "", "&rationals;": "", "&rbarr;": "", "&rbbrk;": "", "&rbrace;": "}", "&rbrack;": "]", "&rbrke;": "", "&rbrksld;": "", "&rbrkslu;": "", "&rcaron;": "", "&rcedil;": "", "&rceil;": "", "&rcub;": "}", "&rcy;": "", "&rdca;": "", "&rdldhar;": "", "&rdquo;": "", "&rdquor;": "", "&rdsh;": "", "&real;": "", "&realine;": "", "&realpart;": "", "&reals;": "", "&rect;": "", "&reg": "", "&reg;": "", "&rfisht;": "", "&rfloor;": "", "&rfr;": "", "&rhard;": "", "&rharu;": "", "&rharul;": "", "&rho;": "", "&rhov;": "", "&rightarrow;": "", "&rightarrowtail;": "", "&rightharpoondown;": "", "&rightharpoonup;": "", "&rightleftarrows;": "", "&rightleftharpoons;": "", "&rightrightarrows;": "", "&rightsquigarrow;": "", "&rightthreetimes;": "", "&ring;": "", "&risingdotseq;": "", "&rlarr;": "", "&rlhar;": "", "&rlm;": "", "&rmoust;": "", "&rmoustache;": "", "&rnmid;": "", "&roang;": "", "&roarr;": "", "&robrk;": "", "&ropar;": "", "&ropf;": "", "&roplus;": "", "&rotimes;": "", "&rpar;": ")", "&rpargt;": "", "&rppolint;": "", "&rrarr;": "", "&rsaquo;": "", "&rscr;": "", "&rsh;": "", "&rsqb;": "]", "&rsquo;": "", "&rsquor;": "", "&rthree;": "", "&rtimes;": "", "&rtri;": "", "&rtrie;": "", "&rtrif;": "", "&rtriltri;": "", "&ruluhar;": "", "&rx;": "", "&sacute;": "", "&sbquo;": "", "&sc;": "", "&scE;": "", "&scap;": "", "&scaron;": "", "&sccue;": "", "&sce;": "", "&scedil;": "", "&scirc;": "", "&scnE;": "", "&scnap;": "", "&scnsim;": "", "&scpolint;": "", "&scsim;": "", "&scy;": "", "&sdot;": "", "&sdotb;": "", "&sdote;": "", "&seArr;": "", "&searhk;": "", "&searr;": "", "&searrow;": "", "&sect": "", "&sect;": "", "&semi;": ";", "&seswar;": "", "&setminus;": "", "&setmn;": "", "&sext;": "", "&sfr;": "", "&sfrown;": "", "&sharp;": "", "&shchcy;": "", "&shcy;": "", "&shortmid;": "", "&shortparallel;": "", "&shy": "", "&shy;": "", "&sigma;": "", "&sigmaf;": "", "&sigmav;": "", "&sim;": "", "&simdot;": "", "&sime;": "", "&simeq;": "", "&simg;": "", "&simgE;": "", "&siml;": "", "&simlE;": "", "&simne;": "", "&simplus;": "", "&simrarr;": "", "&slarr;": "", "&smallsetminus;": "", "&smashp;": "", "&smeparsl;": "", "&smid;": "", "&smile;": "", "&smt;": "", "&smte;": "", "&smtes;": "", "&softcy;": "", "&sol;": "/", "&solb;": "", "&solbar;": "", "&sopf;": "", "&spades;": "", "&spadesuit;": "", "&spar;": "", "&sqcap;": "", "&sqcaps;": "", "&sqcup;": "", "&sqcups;": "", "&sqsub;": "", "&sqsube;": "", "&sqsubset;": "", "&sqsubseteq;": "", "&sqsup;": "", "&sqsupe;": "", "&sqsupset;": "", "&sqsupseteq;": "", "&squ;": "", "&square;": "", "&squarf;": "", "&squf;": "", "&srarr;": "", "&sscr;": "", "&ssetmn;": "", "&ssmile;": "", "&sstarf;": "", "&star;": "", "&starf;": "", "&straightepsilon;": "", "&straightphi;": "", "&strns;": "", "&sub;": "", "&subE;": "", "&subdot;": "", "&sube;": "", "&subedot;": "", "&submult;": "", "&subnE;": "", "&subne;": "", "&subplus;": "", "&subrarr;": "", "&subset;": "", "&subseteq;": "", "&subseteqq;": "", "&subsetneq;": "", "&subsetneqq;": "", "&subsim;": "", "&subsub;": "", "&subsup;": "", "&succ;": "", "&succapprox;": "", "&succcurlyeq;": "", "&succeq;": "", "&succnapprox;": "", "&succneqq;": "", "&succnsim;": "", "&succsim;": "", "&sum;": "", "&sung;": "", "&sup1": "", "&sup1;": "", "&sup2": "", "&sup2;": "", "&sup3": "", "&sup3;": "", "&sup;": "", "&supE;": "", "&supdot;": "", "&supdsub;": "", "&supe;": "", "&supedot;": "", "&suphsol;": "", "&suphsub;": "", "&suplarr;": "", "&supmult;": "", "&supnE;": "", "&supne;": "", "&supplus;": "", "&supset;": "", "&supseteq;": "", "&supseteqq;": "", "&supsetneq;": "", "&supsetneqq;": "", "&supsim;": "", "&supsub;": "", "&supsup;": "", "&swArr;": "", "&swarhk;": "", "&swarr;": "", "&swarrow;": "", "&swnwar;": "", "&szlig": "", "&szlig;": "", "&target;": "", "&tau;": "", "&tbrk;": "", "&tcaron;": "", "&tcedil;": "", "&tcy;": "", "&tdot;": "", "&telrec;": "", "&tfr;": "", "&there4;": "", "&therefore;": "", "&theta;": "", "&thetasym;": "", "&thetav;": "", "&thickapprox;": "", "&thicksim;": "", "&thinsp;": "", "&thkap;": "", "&thksim;": "", "&thorn": "", "&thorn;": "", "&tilde;": "", "&times": "", "&times;": "", "&timesb;": "", "&timesbar;": "", "&timesd;": "", "&tint;": "", "&toea;": "", "&top;": "", "&topbot;": "", "&topcir;": "", "&topf;": "", "&topfork;": "", "&tosa;": "", "&tprime;": "", "&trade;": "", "&triangle;": "", "&triangledown;": "", "&triangleleft;": "", "&trianglelefteq;": "", "&triangleq;": "", "&triangleright;": "", "&trianglerighteq;": "", "&tridot;": "", "&trie;": "", "&triminus;": "", "&triplus;": "", "&trisb;": "", "&tritime;": "", "&trpezium;": "", "&tscr;": "", "&tscy;": "", "&tshcy;": "", "&tstrok;": "", "&twixt;": "", "&twoheadleftarrow;": "", "&twoheadrightarrow;": "", "&uArr;": "", "&uHar;": "", "&uacute": "", "&uacute;": "", "&uarr;": "", "&ubrcy;": "", "&ubreve;": "", "&ucirc": "", "&ucirc;": "", "&ucy;": "", "&udarr;": "", "&udblac;": "", "&udhar;": "", "&ufisht;": "", "&ufr;": "", "&ugrave": "", "&ugrave;": "", "&uharl;": "", "&uharr;": "", "&uhblk;": "", "&ulcorn;": "", "&ulcorner;": "", "&ulcrop;": "", "&ultri;": "", "&umacr;": "", "&uml": "", "&uml;": "", "&uogon;": "", "&uopf;": "", "&uparrow;": "", "&updownarrow;": "", "&upharpoonleft;": "", "&upharpoonright;": "", "&uplus;": "", "&upsi;": "", "&upsih;": "", "&upsilon;": "", "&upuparrows;": "", "&urcorn;": "", "&urcorner;": "", "&urcrop;": "", "&uring;": "", "&urtri;": "", "&uscr;": "", "&utdot;": "", "&utilde;": "", "&utri;": "", "&utrif;": "", "&uuarr;": "", "&uuml": "", "&uuml;": "", "&uwangle;": "", "&vArr;": "", "&vBar;": "", "&vBarv;": "", "&vDash;": "", "&vangrt;": "", "&varepsilon;": "", "&varkappa;": "", "&varnothing;": "", "&varphi;": "", "&varpi;": "", "&varpropto;": "", "&varr;": "", "&varrho;": "", "&varsigma;": "", "&varsubsetneq;": "", "&varsubsetneqq;": "", "&varsupsetneq;": "", "&varsupsetneqq;": "", "&vartheta;": "", "&vartriangleleft;": "", "&vartriangleright;": "", "&vcy;": "", "&vdash;": "", "&vee;": "", "&veebar;": "", "&veeeq;": "", "&vellip;": "", "&verbar;": "|", "&vert;": "|", "&vfr;": "", "&vltri;": "", "&vnsub;": "", "&vnsup;": "", "&vopf;": "", "&vprop;": "", "&vrtri;": "", "&vscr;": "", "&vsubnE;": "", "&vsubne;": "", "&vsupnE;": "", "&vsupne;": "", "&vzigzag;": "", "&wcirc;": "", "&wedbar;": "", "&wedge;": "", "&wedgeq;": "", "&weierp;": "", "&wfr;": "", "&wopf;": "", "&wp;": "", "&wr;": "", "&wreath;": "", "&wscr;": "", "&xcap;": "", "&xcirc;": "", "&xcup;": "", "&xdtri;": "", "&xfr;": "", "&xhArr;": "", "&xharr;": "", "&xi;": "", "&xlArr;": "", "&xlarr;": "", "&xmap;": "", "&xnis;": "", "&xodot;": "", "&xopf;": "", "&xoplus;": "", "&xotime;": "", "&xrArr;": "", "&xrarr;": "", "&xscr;": "", "&xsqcup;": "", "&xuplus;": "", "&xutri;": "", "&xvee;": "", "&xwedge;": "", "&yacute": "", "&yacute;": "", "&yacy;": "", "&ycirc;": "", "&ycy;": "", "&yen": "", "&yen;": "", "&yfr;": "", "&yicy;": "", "&yopf;": "", "&yscr;": "", "&yucy;": "", "&yuml": "", "&yuml;": "", "&zacute;": "", "&zcaron;": "", "&zcy;": "", "&zdot;": "", "&zeetrf;": "", "&zeta;": "", "&zfr;": "", "&zhcy;": "", "&zigrarr;": "", "&zopf;": "", "&zscr;": "", "&zwj;": "", "&zwnj;": "" }, characters: { : "&AElig;", "&": "&amp;", : "&Aacute;", : "&Abreve;", : "&Acirc;", : "&Acy;", "": "&Afr;", : "&Agrave;", : "&Alpha;", : "&Amacr;", "": "&And;", : "&Aogon;", "": "&Aopf;", "": "&af;", : "&angst;", "": "&Ascr;", "": "&coloneq;", : "&Atilde;", : "&Auml;", "": "&ssetmn;", "": "&Barv;", "": "&doublebarwedge;", : "&Bcy;", "": "&because;", : "&bernou;", : "&Beta;", "": "&Bfr;", "": "&Bopf;", "": "&breve;", "": "&bump;", : "&CHcy;", "": "&copy;", : "&Cacute;", "": "&Cap;", "": "&DD;", : "&Cfr;", : "&Ccaron;", : "&Ccedil;", : "&Ccirc;", "": "&Cconint;", : "&Cdot;", "": "&cedil;", "": "&middot;", : "&Chi;", "": "&odot;", "": "&ominus;", "": "&oplus;", "": "&otimes;", "": "&cwconint;", "": "&rdquor;", "": "&rsquor;", "": "&Proportion;", "": "&Colone;", "": "&equiv;", "": "&DoubleContourIntegral;", "": "&oint;", : "&complexes;", "": "&coprod;", "": "&awconint;", "": "&Cross;", "": "&Cscr;", "": "&Cup;", "": "&asympeq;", "": "&DDotrahd;", : "&DJcy;", : "&DScy;", : "&DZcy;", "": "&ddagger;", "": "&Darr;", "": "&DoubleLeftTee;", : "&Dcaron;", : "&Dcy;", "": "&nabla;", : "&Delta;", "": "&Dfr;", "": "&acute;", "": "&dot;", "": "&dblac;", "`": "&grave;", "": "&tilde;", "": "&diamond;", "": "&dd;", "": "&Dopf;", "": "&uml;", "": "&DotDot;", "": "&esdot;", "": "&dArr;", "": "&lArr;", "": "&iff;", "": "&xlArr;", "": "&xhArr;", "": "&xrArr;", "": "&rArr;", "": "&vDash;", "": "&uArr;", "": "&vArr;", "": "&spar;", "": "&downarrow;", "": "&DownArrowBar;", "": "&duarr;", "": "&DownBreve;", "": "&DownLeftRightVector;", "": "&DownLeftTeeVector;", "": "&lhard;", "": "&DownLeftVectorBar;", "": "&DownRightTeeVector;", "": "&rightharpoondown;", "": "&DownRightVectorBar;", "": "&top;", "": "&mapstodown;", "": "&Dscr;", : "&Dstrok;", : "&ENG;", : "&ETH;", : "&Eacute;", : "&Ecaron;", : "&Ecirc;", : "&Ecy;", : "&Edot;", "": "&Efr;", : "&Egrave;", "": "&isinv;", : "&Emacr;", "": "&EmptySmallSquare;", "": "&EmptyVerySmallSquare;", : "&Eogon;", "": "&Eopf;", : "&Epsilon;", "": "&Equal;", "": "&esim;", "": "&rlhar;", : "&expectation;", "": "&Esim;", : "&Eta;", : "&Euml;", "": "&exist;", "": "&exponentiale;", : "&Fcy;", "": "&Ffr;", "": "&FilledSmallSquare;", "": "&squf;", "": "&Fopf;", "": "&forall;", : "&Fscr;", : "&GJcy;", ">": "&gt;", : "&Gamma;", : "&Gammad;", : "&Gbreve;", : "&Gcedil;", : "&Gcirc;", : "&Gcy;", : "&Gdot;", "": "&Gfr;", "": "&ggg;", "": "&Gopf;", "": "&geq;", "": "&gtreqless;", "": "&geqq;", "": "&GreaterGreater;", "": "&gtrless;", "": "&ges;", "": "&gtrsim;", "": "&Gscr;", "": "&gg;", : "&HARDcy;", "": "&caron;", "^": "&Hat;", : "&Hcirc;", : "&Poincareplane;", : "&hamilt;", : "&quaternions;", "": "&boxh;", : "&Hstrok;", "": "&bumpeq;", : "&IEcy;", : "&IJlig;", : "&IOcy;", : "&Iacute;", : "&Icirc;", : "&Icy;", : "&Idot;", : "&imagpart;", : "&Igrave;", : "&Imacr;", "": "&ii;", "": "&Int;", "": "&int;", "": "&xcap;", "": "&ic;", "": "&it;", : "&Iogon;", "": "&Iopf;", : "&Iota;", : "&imagline;", : "&Itilde;", : "&Iukcy;", : "&Iuml;", : "&Jcirc;", : "&Jcy;", "": "&Jfr;", "": "&Jopf;", "": "&Jscr;", : "&Jsercy;", : "&Jukcy;", : "&KHcy;", : "&KJcy;", : "&Kappa;", : "&Kcedil;", : "&Kcy;", "": "&Kfr;", "": "&Kopf;", "": "&Kscr;", : "&LJcy;", "<": "&lt;", : "&Lacute;", : "&Lambda;", "": "&Lang;", : "&lagran;", "": "&twoheadleftarrow;", : "&Lcaron;", : "&Lcedil;", : "&Lcy;", "": "&langle;", "": "&slarr;", "": "&larrb;", "": "&lrarr;", "": "&lceil;", "": "&lobrk;", "": "&LeftDownTeeVector;", "": "&downharpoonleft;", "": "&LeftDownVectorBar;", "": "&lfloor;", "": "&leftrightarrow;", "": "&LeftRightVector;", "": "&dashv;", "": "&mapstoleft;", "": "&LeftTeeVector;", "": "&vltri;", "": "&LeftTriangleBar;", "": "&trianglelefteq;", "": "&LeftUpDownVector;", "": "&LeftUpTeeVector;", "": "&upharpoonleft;", "": "&LeftUpVectorBar;", "": "&lharu;", "": "&LeftVectorBar;", "": "&lesseqgtr;", "": "&leqq;", "": "&lg;", "": "&LessLess;", "": "&les;", "": "&lsim;", "": "&Lfr;", "": "&Ll;", "": "&lAarr;", : "&Lmidot;", "": "&xlarr;", "": "&xharr;", "": "&xrarr;", "": "&Lopf;", "": "&swarrow;", "": "&searrow;", "": "&lsh;", : "&Lstrok;", "": "&ll;", "": "&Map;", : "&Mcy;", "": "&MediumSpace;", : "&phmmat;", "": "&Mfr;", "": "&mp;", "": "&Mopf;", : "&Mu;", : "&NJcy;", : "&Nacute;", : "&Ncaron;", : "&Ncedil;", : "&Ncy;", "": "&ZeroWidthSpace;", "\n": "&NewLine;", "": "&Nfr;", "": "&NoBreak;", "": "&nbsp;", : "&naturals;", "": "&Not;", "": "&nequiv;", "": "&NotCupCap;", "": "&nspar;", "": "&notinva;", "": "&ne;", "": "&nesim;", "": "&nexists;", "": "&ngtr;", "": "&ngeq;", "": "&ngeqq;", "": "&nGtv;", "": "&ntgl;", "": "&nges;", "": "&ngsim;", "": "&nbump;", "": "&nbumpe;", "": "&ntriangleleft;", "": "&NotLeftTriangleBar;", "": "&ntrianglelefteq;", "": "&nlt;", "": "&nleq;", "": "&ntlg;", "": "&nLtv;", "": "&nles;", "": "&nlsim;", "": "&NotNestedGreaterGreater;", "": "&NotNestedLessLess;", "": "&nprec;", "": "&npreceq;", "": "&nprcue;", "": "&notniva;", "": "&ntriangleright;", "": "&NotRightTriangleBar;", "": "&ntrianglerighteq;", "": "&NotSquareSubset;", "": "&nsqsube;", "": "&NotSquareSuperset;", "": "&nsqsupe;", "": "&vnsub;", "": "&nsubseteq;", "": "&nsucc;", "": "&nsucceq;", "": "&nsccue;", "": "&NotSucceedsTilde;", "": "&vnsup;", "": "&nsupseteq;", "": "&nsim;", "": "&nsimeq;", "": "&ncong;", "": "&napprox;", "": "&nsmid;", "": "&Nscr;", : "&Ntilde;", : "&Nu;", : "&OElig;", : "&Oacute;", : "&Ocirc;", : "&Ocy;", : "&Odblac;", "": "&Ofr;", : "&Ograve;", : "&Omacr;", : "&ohm;", : "&Omicron;", "": "&Oopf;", "": "&ldquo;", "": "&lsquo;", "": "&Or;", "": "&Oscr;", : "&Oslash;", : "&Otilde;", "": "&Otimes;", : "&Ouml;", "": "&oline;", "": "&OverBrace;", "": "&tbrk;", "": "&OverParenthesis;", "": "&part;", : "&Pcy;", "": "&Pfr;", : "&Phi;", : "&Pi;", "": "&pm;", : "&primes;", "": "&Pr;", "": "&prec;", "": "&preceq;", "": "&preccurlyeq;", "": "&prsim;", "": "&Prime;", "": "&prod;", "": "&vprop;", "": "&Pscr;", : "&Psi;", '"': "&quot;", "": "&Qfr;", : "&rationals;", "": "&Qscr;", "": "&drbkarow;", "": "&reg;", : "&Racute;", "": "&Rang;", "": "&twoheadrightarrow;", "": "&Rarrtl;", : "&Rcaron;", : "&Rcedil;", : "&Rcy;", : "&realpart;", "": "&niv;", "": "&lrhar;", "": "&duhar;", : "&Rho;", "": "&rangle;", "": "&srarr;", "": "&rarrb;", "": "&rlarr;", "": "&rceil;", "": "&robrk;", "": "&RightDownTeeVector;", "": "&downharpoonright;", "": "&RightDownVectorBar;", "": "&rfloor;", "": "&vdash;", "": "&mapsto;", "": "&RightTeeVector;", "": "&vrtri;", "": "&RightTriangleBar;", "": "&trianglerighteq;", "": "&RightUpDownVector;", "": "&RightUpTeeVector;", "": "&upharpoonright;", "": "&RightUpVectorBar;", "": "&rightharpoonup;", "": "&RightVectorBar;", : "&reals;", "": "&RoundImplies;", "": "&rAarr;", : "&realine;", "": "&rsh;", "": "&RuleDelayed;", : "&SHCHcy;", : "&SHcy;", : "&SOFTcy;", : "&Sacute;", "": "&Sc;", : "&Scaron;", : "&Scedil;", : "&Scirc;", : "&Scy;", "": "&Sfr;", "": "&uparrow;", : "&Sigma;", "": "&compfn;", "": "&Sopf;", "": "&radic;", "": "&square;", "": "&sqcap;", "": "&sqsubset;", "": "&sqsubseteq;", "": "&sqsupset;", "": "&sqsupseteq;", "": "&sqcup;", "": "&Sscr;", "": "&sstarf;", "": "&Subset;", "": "&subseteq;", "": "&succ;", "": "&succeq;", "": "&succcurlyeq;", "": "&succsim;", "": "&sum;", "": "&Supset;", "": "&supset;", "": "&supseteq;", : "&THORN;", "": "&trade;", : "&TSHcy;", : "&TScy;", "	": "&Tab;", : "&Tau;", : "&Tcaron;", : "&Tcedil;", : "&Tcy;", "": "&Tfr;", "": "&therefore;", : "&Theta;", "": "&ThickSpace;", "": "&thinsp;", "": "&thksim;", "": "&simeq;", "": "&cong;", "": "&thkap;", "": "&Topf;", "": "&tdot;", "": "&Tscr;", : "&Tstrok;", : "&Uacute;", "": "&Uarr;", "": "&Uarrocir;", : "&Ubrcy;", : "&Ubreve;", : "&Ucirc;", : "&Ucy;", : "&Udblac;", "": "&Ufr;", : "&Ugrave;", : "&Umacr;", _: "&lowbar;", "": "&UnderBrace;", "": "&bbrk;", "": "&UnderParenthesis;", "": "&xcup;", "": "&uplus;", : "&Uogon;", "": "&Uopf;", "": "&UpArrowBar;", "": "&udarr;", "": "&varr;", "": "&udhar;", "": "&perp;", "": "&mapstoup;", "": "&nwarrow;", "": "&nearrow;", : "&upsih;", : "&Upsilon;", : "&Uring;", "": "&Uscr;", : "&Utilde;", : "&Uuml;", "": "&VDash;", "": "&Vbar;", : "&Vcy;", "": "&Vdash;", "": "&Vdashl;", "": "&xvee;", "": "&Vert;", "": "&smid;", "|": "&vert;", "": "&VerticalSeparator;", "": "&wreath;", "": "&hairsp;", "": "&Vfr;", "": "&Vopf;", "": "&Vscr;", "": "&Vvdash;", : "&Wcirc;", "": "&xwedge;", "": "&Wfr;", "": "&Wopf;", "": "&Wscr;", "": "&Xfr;", : "&Xi;", "": "&Xopf;", "": "&Xscr;", : "&YAcy;", : "&YIcy;", : "&YUcy;", : "&Yacute;", : "&Ycirc;", : "&Ycy;", "": "&Yfr;", "": "&Yopf;", "": "&Yscr;", : "&Yuml;", : "&ZHcy;", : "&Zacute;", : "&Zcaron;", : "&Zcy;", : "&Zdot;", : "&Zeta;", : "&zeetrf;", : "&integers;", "": "&Zscr;", : "&aacute;", : "&abreve;", "": "&mstpos;", "": "&acE;", "": "&acd;", : "&acirc;", : "&acy;", : "&aelig;", "": "&afr;", : "&agrave;", : "&aleph;", : "&alpha;", : "&amacr;", "": "&amalg;", "": "&wedge;", "": "&andand;", "": "&andd;", "": "&andslope;", "": "&andv;", "": "&angle;", "": "&ange;", "": "&measuredangle;", "": "&angmsdaa;", "": "&angmsdab;", "": "&angmsdac;", "": "&angmsdad;", "": "&angmsdae;", "": "&angmsdaf;", "": "&angmsdag;", "": "&angmsdah;", "": "&angrt;", "": "&angrtvb;", "": "&angrtvbd;", "": "&angsph;", "": "&angzarr;", : "&aogon;", "": "&aopf;", "": "&apE;", "": "&apacir;", "": "&approxeq;", "": "&apid;", "'": "&apos;", : "&aring;", "": "&ascr;", "*": "&midast;", : "&atilde;", : "&auml;", "": "&awint;", "": "&bNot;", "": "&bcong;", "": "&bepsi;", "": "&bprime;", "": "&bsim;", "": "&bsime;", "": "&barvee;", "": "&barwedge;", "": "&bbrktbrk;", : "&bcy;", "": "&ldquor;", "": "&bemptyv;", : "&beta;", : "&beth;", "": "&twixt;", "": "&bfr;", "": "&xcirc;", "": "&xodot;", "": "&xoplus;", "": "&xotime;", "": "&xsqcup;", "": "&starf;", "": "&xdtri;", "": "&xutri;", "": "&xuplus;", "": "&rbarr;", "": "&lozf;", "": "&utrif;", "": "&dtrif;", "": "&ltrif;", "": "&rtrif;", "": "&blank;", "": "&blk12;", "": "&blk14;", "": "&blk34;", "": "&block;", "=": "&bne;", "": "&bnequiv;", "": "&bnot;", "": "&bopf;", "": "&bowtie;", "": "&boxDL;", "": "&boxDR;", "": "&boxDl;", "": "&boxDr;", "": "&boxH;", "": "&boxHD;", "": "&boxHU;", "": "&boxHd;", "": "&boxHu;", "": "&boxUL;", "": "&boxUR;", "": "&boxUl;", "": "&boxUr;", "": "&boxV;", "": "&boxVH;", "": "&boxVL;", "": "&boxVR;", "": "&boxVh;", "": "&boxVl;", "": "&boxVr;", "": "&boxbox;", "": "&boxdL;", "": "&boxdR;", "": "&boxdl;", "": "&boxdr;", "": "&boxhD;", "": "&boxhU;", "": "&boxhd;", "": "&boxhu;", "": "&minusb;", "": "&plusb;", "": "&timesb;", "": "&boxuL;", "": "&boxuR;", "": "&boxul;", "": "&boxur;", "": "&boxv;", "": "&boxvH;", "": "&boxvL;", "": "&boxvR;", "": "&boxvh;", "": "&boxvl;", "": "&boxvr;", "": "&brvbar;", "": "&bscr;", "": "&bsemi;", "\\": "&bsol;", "": "&bsolb;", "": "&bsolhsub;", "": "&bullet;", "": "&bumpE;", : "&cacute;", "": "&cap;", "": "&capand;", "": "&capbrcup;", "": "&capcap;", "": "&capcup;", "": "&capdot;", "": "&caps;", "": "&caret;", "": "&ccaps;", : "&ccaron;", : "&ccedil;", : "&ccirc;", "": "&ccups;", "": "&ccupssm;", : "&cdot;", "": "&cemptyv;", "": "&cent;", "": "&cfr;", : "&chcy;", "": "&checkmark;", : "&chi;", "": "&cir;", "": "&cirE;", "": "&circ;", "": "&cire;", "": "&olarr;", "": "&orarr;", "": "&oS;", "": "&oast;", "": "&ocir;", "": "&odash;", "": "&cirfnint;", "": "&cirmid;", "": "&cirscir;", "": "&clubsuit;", ":": "&colon;", ",": "&comma;", "@": "&commat;", "": "&complement;", "": "&congdot;", "": "&copf;", "": "&copysr;", "": "&crarr;", "": "&cross;", "": "&cscr;", "": "&csub;", "": "&csube;", "": "&csup;", "": "&csupe;", "": "&ctdot;", "": "&cudarrl;", "": "&cudarrr;", "": "&curlyeqprec;", "": "&curlyeqsucc;", "": "&curvearrowleft;", "": "&cularrp;", "": "&cup;", "": "&cupbrcap;", "": "&cupcap;", "": "&cupcup;", "": "&cupdot;", "": "&cupor;", "": "&cups;", "": "&curvearrowright;", "": "&curarrm;", "": "&cuvee;", "": "&cuwed;", "": "&curren;", "": "&cwint;", "": "&cylcty;", "": "&dHar;", "": "&dagger;", : "&daleth;", "": "&hyphen;", "": "&rBarr;", : "&dcaron;", : "&dcy;", "": "&downdownarrows;", "": "&eDDot;", "": "&deg;", : "&delta;", "": "&demptyv;", "": "&dfisht;", "": "&dfr;", "": "&diams;", : "&gammad;", "": "&disin;", "": "&divide;", "": "&divonx;", : "&djcy;", "": "&llcorner;", "": "&dlcrop;", $: "&dollar;", "": "&dopf;", "": "&eDot;", "": "&minusd;", "": "&plusdo;", "": "&sdotb;", "": "&lrcorner;", "": "&drcrop;", "": "&dscr;", : "&dscy;", "": "&dsol;", : "&dstrok;", "": "&dtdot;", "": "&triangledown;", "": "&dwangle;", : "&dzcy;", "": "&dzigrarr;", : "&eacute;", "": "&easter;", : "&ecaron;", "": "&eqcirc;", : "&ecirc;", "": "&eqcolon;", : "&ecy;", : "&edot;", "": "&fallingdotseq;", "": "&efr;", "": "&eg;", : "&egrave;", "": "&eqslantgtr;", "": "&egsdot;", "": "&el;", "": "&elinters;", : "&ell;", "": "&eqslantless;", "": "&elsdot;", : "&emacr;", "": "&varnothing;", "": "&emsp13;", "": "&emsp14;", "": "&emsp;", : "&eng;", "": "&ensp;", : "&eogon;", "": "&eopf;", "": "&epar;", "": "&eparsl;", "": "&eplus;", : "&epsilon;", "": "&varepsilon;", "=": "&equals;", "": "&questeq;", "": "&equivDD;", "": "&eqvparsl;", "": "&risingdotseq;", "": "&erarr;", : "&escr;", : "&eta;", : "&eth;", : "&euml;", "": "&euro;", "!": "&excl;", : "&fcy;", "": "&female;", : "&ffilig;", : "&fflig;", : "&ffllig;", "": "&ffr;", : "&filig;", fj: "&fjlig;", "": "&flat;", : "&fllig;", "": "&fltns;", : "&fnof;", "": "&fopf;", "": "&pitchfork;", "": "&forkv;", "": "&fpartint;", "": "&half;", "": "&frac13;", "": "&frac14;", "": "&frac15;", "": "&frac16;", "": "&frac18;", "": "&frac23;", "": "&frac25;", "": "&frac34;", "": "&frac35;", "": "&frac38;", "": "&frac45;", "": "&frac56;", "": "&frac58;", "": "&frac78;", "": "&frasl;", "": "&sfrown;", "": "&fscr;", "": "&gtreqqless;", : "&gacute;", : "&gamma;", "": "&gtrapprox;", : "&gbreve;", : "&gcirc;", : "&gcy;", : "&gdot;", "": "&gescc;", "": "&gesdot;", "": "&gesdoto;", "": "&gesdotol;", "": "&gesl;", "": "&gesles;", "": "&gfr;", : "&gimel;", : "&gjcy;", "": "&glE;", "": "&gla;", "": "&glj;", "": "&gneqq;", "": "&gnapprox;", "": "&gneq;", "": "&gnsim;", "": "&gopf;", : "&gscr;", "": "&gsime;", "": "&gsiml;", "": "&gtcc;", "": "&gtcir;", "": "&gtrdot;", "": "&gtlPar;", "": "&gtquest;", "": "&gtrarr;", "": "&gvnE;", : "&hardcy;", "": "&harrcir;", "": "&leftrightsquigarrow;", : "&plankv;", : "&hcirc;", "": "&heartsuit;", "": "&mldr;", "": "&hercon;", "": "&hfr;", "": "&searhk;", "": "&swarhk;", "": "&hoarr;", "": "&homtht;", "": "&larrhk;", "": "&rarrhk;", "": "&hopf;", "": "&horbar;", "": "&hscr;", : "&hstrok;", "": "&hybull;", : "&iacute;", : "&icirc;", : "&icy;", : "&iecy;", "": "&iexcl;", "": "&ifr;", : "&igrave;", "": "&qint;", "": "&tint;", "": "&iinfin;", "": "&iiota;", : "&ijlig;", : "&imacr;", : "&inodot;", "": "&imof;", : "&imped;", "": "&incare;", "": "&infin;", "": "&infintie;", "": "&intercal;", "": "&intlarhk;", "": "&iprod;", : "&iocy;", : "&iogon;", "": "&iopf;", : "&iota;", "": "&iquest;", "": "&iscr;", "": "&isinE;", "": "&isindot;", "": "&isins;", "": "&isinsv;", : "&itilde;", : "&iukcy;", : "&iuml;", : "&jcirc;", : "&jcy;", "": "&jfr;", "": "&jmath;", "": "&jopf;", "": "&jscr;", : "&jsercy;", : "&jukcy;", : "&kappa;", : "&varkappa;", : "&kcedil;", : "&kcy;", "": "&kfr;", : "&kgreen;", : "&khcy;", : "&kjcy;", "": "&kopf;", "": "&kscr;", "": "&lAtail;", "": "&lBarr;", "": "&lesseqqgtr;", "": "&lHar;", : "&lacute;", "": "&laemptyv;", : "&lambda;", "": "&langd;", "": "&lessapprox;", "": "&laquo;", "": "&larrbfs;", "": "&larrfs;", "": "&looparrowleft;", "": "&larrpl;", "": "&larrsim;", "": "&leftarrowtail;", "": "&lat;", "": "&latail;", "": "&late;", "": "&lates;", "": "&lbarr;", "": "&lbbrk;", "{": "&lcub;", "[": "&lsqb;", "": "&lbrke;", "": "&lbrksld;", "": "&lbrkslu;", : "&lcaron;", : "&lcedil;", : "&lcy;", "": "&ldca;", "": "&ldrdhar;", "": "&ldrushar;", "": "&ldsh;", "": "&leq;", "": "&llarr;", "": "&lthree;", "": "&lescc;", "": "&lesdot;", "": "&lesdoto;", "": "&lesdotor;", "": "&lesg;", "": "&lesges;", "": "&ltdot;", "": "&lfisht;", "": "&lfr;", "": "&lgE;", "": "&lharul;", "": "&lhblk;", : "&ljcy;", "": "&llhard;", "": "&lltri;", : "&lmidot;", "": "&lmoustache;", "": "&lneqq;", "": "&lnapprox;", "": "&lneq;", "": "&lnsim;", "": "&loang;", "": "&loarr;", "": "&xmap;", "": "&rarrlp;", "": "&lopar;", "": "&lopf;", "": "&loplus;", "": "&lotimes;", "": "&lowast;", "": "&lozenge;", "(": "&lpar;", "": "&lparlt;", "": "&lrhard;", "": "&lrm;", "": "&lrtri;", "": "&lsaquo;", "": "&lscr;", "": "&lsime;", "": "&lsimg;", "": "&sbquo;", : "&lstrok;", "": "&ltcc;", "": "&ltcir;", "": "&ltimes;", "": "&ltlarr;", "": "&ltquest;", "": "&ltrPar;", "": "&triangleleft;", "": "&lurdshar;", "": "&luruhar;", "": "&lvnE;", "": "&mDDot;", "": "&strns;", "": "&male;", "": "&maltese;", "": "&marker;", "": "&mcomma;", : "&mcy;", "": "&mdash;", "": "&mfr;", "": "&mho;", : "&micro;", "": "&midcir;", "": "&minus;", "": "&minusdu;", "": "&mlcp;", "": "&models;", "": "&mopf;", "": "&mscr;", : "&mu;", "": "&mumap;", "": "&nGg;", "": "&nGt;", "": "&nlArr;", "": "&nhArr;", "": "&nLl;", "": "&nLt;", "": "&nrArr;", "": "&nVDash;", "": "&nVdash;", : "&nacute;", "": "&nang;", "": "&napE;", "": "&napid;", : "&napos;", "": "&natural;", "": "&ncap;", : "&ncaron;", : "&ncedil;", "": "&ncongdot;", "": "&ncup;", : "&ncy;", "": "&ndash;", "": "&neArr;", "": "&nearhk;", "": "&nedot;", "": "&toea;", "": "&nfr;", "": "&nleftrightarrow;", "": "&nhpar;", "": "&nis;", "": "&nisd;", : "&njcy;", "": "&nleqq;", "": "&nleftarrow;", "": "&nldr;", "": "&nopf;", "": "&not;", "": "&notinE;", "": "&notindot;", "": "&notinvb;", "": "&notinvc;", "": "&notnivb;", "": "&notnivc;", "": "&nparsl;", "": "&npart;", "": "&npolint;", "": "&nrightarrow;", "": "&nrarrc;", "": "&nrarrw;", "": "&nscr;", "": "&nsub;", "": "&nsubseteqq;", "": "&nsup;", "": "&nsupseteqq;", : "&ntilde;", : "&nu;", "#": "&num;", "": "&numero;", "": "&numsp;", "": "&nvDash;", "": "&nvHarr;", "": "&nvap;", "": "&nvdash;", "": "&nvge;", ">": "&nvgt;", "": "&nvinfin;", "": "&nvlArr;", "": "&nvle;", "<": "&nvlt;", "": "&nvltrie;", "": "&nvrArr;", "": "&nvrtrie;", "": "&nvsim;", "": "&nwArr;", "": "&nwarhk;", "": "&nwnear;", : "&oacute;", : "&ocirc;", : "&ocy;", : "&odblac;", "": "&odiv;", "": "&odsold;", : "&oelig;", "": "&ofcir;", "": "&ofr;", "": "&ogon;", : "&ograve;", "": "&ogt;", "": "&ohbar;", "": "&olcir;", "": "&olcross;", "": "&olt;", : "&omacr;", : "&omega;", : "&omicron;", "": "&omid;", "": "&oopf;", "": "&opar;", "": "&operp;", "": "&vee;", "": "&ord;", : "&oscr;", : "&ordf;", : "&ordm;", "": "&origof;", "": "&oror;", "": "&orslope;", "": "&orv;", : "&oslash;", "": "&osol;", : "&otilde;", "": "&otimesas;", : "&ouml;", "": "&ovbar;", "": "&para;", "": "&parsim;", "": "&parsl;", : "&pcy;", "%": "&percnt;", ".": "&period;", "": "&permil;", "": "&pertenk;", "": "&pfr;", : "&phi;", : "&varphi;", "": "&phone;", : "&pi;", : "&varpi;", : "&planckh;", "+": "&plus;", "": "&plusacir;", "": "&pluscir;", "": "&plusdu;", "": "&pluse;", "": "&plussim;", "": "&plustwo;", "": "&pointint;", "": "&popf;", "": "&pound;", "": "&prE;", "": "&precapprox;", "": "&prnap;", "": "&prnE;", "": "&prnsim;", "": "&prime;", "": "&profalar;", "": "&profline;", "": "&profsurf;", "": "&prurel;", "": "&pscr;", : "&psi;", "": "&puncsp;", "": "&qfr;", "": "&qopf;", "": "&qprime;", "": "&qscr;", "": "&quatint;", "?": "&quest;", "": "&rAtail;", "": "&rHar;", "": "&race;", : "&racute;", "": "&raemptyv;", "": "&rangd;", "": "&range;", "": "&raquo;", "": "&rarrap;", "": "&rarrbfs;", "": "&rarrc;", "": "&rarrfs;", "": "&rarrpl;", "": "&rarrsim;", "": "&rightarrowtail;", "": "&rightsquigarrow;", "": "&ratail;", "": "&ratio;", "": "&rbbrk;", "}": "&rcub;", "]": "&rsqb;", "": "&rbrke;", "": "&rbrksld;", "": "&rbrkslu;", : "&rcaron;", : "&rcedil;", : "&rcy;", "": "&rdca;", "": "&rdldhar;", "": "&rdsh;", "": "&rect;", "": "&rfisht;", "": "&rfr;", "": "&rharul;", : "&rho;", : "&varrho;", "": "&rrarr;", "": "&rthree;", "": "&ring;", "": "&rlm;", "": "&rmoustache;", "": "&rnmid;", "": "&roang;", "": "&roarr;", "": "&ropar;", "": "&ropf;", "": "&roplus;", "": "&rotimes;", ")": "&rpar;", "": "&rpargt;", "": "&rppolint;", "": "&rsaquo;", "": "&rscr;", "": "&rtimes;", "": "&triangleright;", "": "&rtriltri;", "": "&ruluhar;", "": "&rx;", : "&sacute;", "": "&scE;", "": "&succapprox;", : "&scaron;", : "&scedil;", : "&scirc;", "": "&succneqq;", "": "&succnapprox;", "": "&succnsim;", "": "&scpolint;", : "&scy;", "": "&sdot;", "": "&sdote;", "": "&seArr;", "": "&sect;", ";": "&semi;", "": "&tosa;", "": "&sext;", "": "&sfr;", "": "&sharp;", : "&shchcy;", : "&shcy;", "": "&shy;", : "&sigma;", : "&varsigma;", "": "&simdot;", "": "&simg;", "": "&simgE;", "": "&siml;", "": "&simlE;", "": "&simne;", "": "&simplus;", "": "&simrarr;", "": "&smashp;", "": "&smeparsl;", "": "&ssmile;", "": "&smt;", "": "&smte;", "": "&smtes;", : "&softcy;", "/": "&sol;", "": "&solb;", "": "&solbar;", "": "&sopf;", "": "&spadesuit;", "": "&sqcaps;", "": "&sqcups;", "": "&sscr;", "": "&star;", "": "&subset;", "": "&subseteqq;", "": "&subdot;", "": "&subedot;", "": "&submult;", "": "&subsetneqq;", "": "&subsetneq;", "": "&subplus;", "": "&subrarr;", "": "&subsim;", "": "&subsub;", "": "&subsup;", "": "&sung;", "": "&sup1;", "": "&sup2;", "": "&sup3;", "": "&supseteqq;", "": "&supdot;", "": "&supdsub;", "": "&supedot;", "": "&suphsol;", "": "&suphsub;", "": "&suplarr;", "": "&supmult;", "": "&supsetneqq;", "": "&supsetneq;", "": "&supplus;", "": "&supsim;", "": "&supsub;", "": "&supsup;", "": "&swArr;", "": "&swnwar;", : "&szlig;", "": "&target;", : "&tau;", : "&tcaron;", : "&tcedil;", : "&tcy;", "": "&telrec;", "": "&tfr;", : "&theta;", : "&vartheta;", : "&thorn;", "": "&times;", "": "&timesbar;", "": "&timesd;", "": "&topbot;", "": "&topcir;", "": "&topf;", "": "&topfork;", "": "&tprime;", "": "&utri;", "": "&trie;", "": "&tridot;", "": "&triminus;", "": "&triplus;", "": "&trisb;", "": "&tritime;", "": "&trpezium;", "": "&tscr;", : "&tscy;", : "&tshcy;", : "&tstrok;", "": "&uHar;", : "&uacute;", : "&ubrcy;", : "&ubreve;", : "&ucirc;", : "&ucy;", : "&udblac;", "": "&ufisht;", "": "&ufr;", : "&ugrave;", "": "&uhblk;", "": "&ulcorner;", "": "&ulcrop;", "": "&ultri;", : "&umacr;", : "&uogon;", "": "&uopf;", : "&upsilon;", "": "&uuarr;", "": "&urcorner;", "": "&urcrop;", : "&uring;", "": "&urtri;", "": "&uscr;", "": "&utdot;", : "&utilde;", : "&uuml;", "": "&uwangle;", "": "&vBar;", "": "&vBarv;", "": "&vangrt;", "": "&vsubne;", "": "&vsubnE;", "": "&vsupne;", "": "&vsupnE;", : "&vcy;", "": "&veebar;", "": "&veeeq;", "": "&vellip;", "": "&vfr;", "": "&vopf;", "": "&vscr;", "": "&vzigzag;", : "&wcirc;", "": "&wedbar;", "": "&wedgeq;", "": "&wp;", "": "&wfr;", "": "&wopf;", "": "&wscr;", "": "&xfr;", : "&xi;", "": "&xnis;", "": "&xopf;", "": "&xscr;", : "&yacute;", : "&yacy;", : "&ycirc;", : "&ycy;", "": "&yen;", "": "&yfr;", : "&yicy;", "": "&yopf;", "": "&yscr;", : "&yucy;", : "&yuml;", : "&zacute;", : "&zcaron;", : "&zcy;", : "&zdot;", : "&zeta;", "": "&zfr;", : "&zhcy;", "": "&zigrarr;", "": "&zopf;", "": "&zscr;", "": "&zwj;", "": "&zwnj;" } } }), ss;
}
var Zo = {}, nv;
function S4() {
  return nv || (nv = 1, Object.defineProperty(Zo, "__esModule", { value: !0 }), Zo.numericUnicodeMap = { 0: 65533, 128: 8364, 130: 8218, 131: 402, 132: 8222, 133: 8230, 134: 8224, 135: 8225, 136: 710, 137: 8240, 138: 352, 139: 8249, 140: 338, 142: 381, 145: 8216, 146: 8217, 147: 8220, 148: 8221, 149: 8226, 150: 8211, 151: 8212, 152: 732, 153: 8482, 154: 353, 155: 8250, 156: 339, 158: 382, 159: 376 }), Zo;
}
var yr = {}, iv;
function C4() {
  return iv || (iv = 1, Object.defineProperty(yr, "__esModule", { value: !0 }), yr.fromCodePoint = String.fromCodePoint || function(n) {
    return String.fromCharCode(Math.floor((n - 65536) / 1024) + 55296, (n - 65536) % 1024 + 56320);
  }, yr.getCodePoint = String.prototype.codePointAt ? function(n, e) {
    return n.codePointAt(e);
  } : function(n, e) {
    return (n.charCodeAt(e) - 55296) * 1024 + n.charCodeAt(e + 1) - 56320 + 65536;
  }, yr.highSurrogateFrom = 55296, yr.highSurrogateTo = 56319), yr;
}
var rv;
function A4() {
  if (rv) return Vi;
  rv = 1;
  var n = Vi && Vi.__assign || function() {
    return n = Object.assign || function(g) {
      for (var v, _ = 1, x = arguments.length; _ < x; _++) {
        v = arguments[_];
        for (var T in v) Object.prototype.hasOwnProperty.call(v, T) && (g[T] = v[T]);
      }
      return g;
    }, n.apply(this, arguments);
  };
  Object.defineProperty(Vi, "__esModule", { value: !0 });
  var e = /* @__PURE__ */ D4(), t = /* @__PURE__ */ S4(), i = /* @__PURE__ */ C4(), r = n(n({}, e.namedReferences), { all: e.namedReferences.html5 }), a = {
    specialChars: /[<>'"&]/g,
    nonAscii: /(?:[<>'"&\u0080-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])/g,
    nonAsciiPrintable: /(?:[<>'"&\x01-\x08\x11-\x15\x17-\x1F\x7f-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])/g,
    extensive: /(?:[\x01-\x0c\x0e-\x1f\x21-\x2c\x2e-\x2f\x3a-\x40\x5b-\x60\x7b-\x7d\x7f-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])/g
  }, s = {
    mode: "specialChars",
    level: "all",
    numeric: "decimal"
  };
  function o(g, v) {
    var C = v === void 0 ? s : v, k = C.mode, _ = k === void 0 ? "specialChars" : k, x = C.numeric, T = x === void 0 ? "decimal" : x, E = C.level, U = E === void 0 ? "all" : E;
    if (!g)
      return "";
    var D = a[_], L = r[U].characters, j = T === "hexadecimal";
    D.lastIndex = 0;
    var C = D.exec(g), k;
    if (C) {
      k = "";
      var x = 0;
      do {
        x !== C.index && (k += g.substring(x, C.index));
        var E = C[0], I = L[E];
        if (!I) {
          var $ = E.length > 1 ? i.getCodePoint(E, 0) : E.charCodeAt(0);
          I = (j ? "&#x" + $.toString(16) : "&#" + $) + ";";
        }
        k += I, x = C.index + E.length;
      } while (C = D.exec(g));
      x !== g.length && (k += g.substring(x));
    } else
      k = g;
    return k;
  }
  Vi.encode = o;
  var u = {
    scope: "body",
    level: "all"
  }, c = /&(?:#\d+|#[xX][\da-fA-F]+|[0-9a-zA-Z]+);/g, l = /&(?:#\d+|#[xX][\da-fA-F]+|[0-9a-zA-Z]+)[;=]?/g, h = {
    xml: {
      strict: c,
      attribute: l,
      body: e.bodyRegExps.xml
    },
    html4: {
      strict: c,
      attribute: l,
      body: e.bodyRegExps.html4
    },
    html5: {
      strict: c,
      attribute: l,
      body: e.bodyRegExps.html5
    }
  }, f = n(n({}, h), { all: h.html5 }), d = String.fromCharCode, y = d(65533), m = {
    level: "all"
  };
  function b(g, v) {
    var x = (v === void 0 ? m : v).level, _ = x === void 0 ? "all" : x;
    if (!g)
      return "";
    var x = g;
    g[g.length - 1];
    {
      var T = r[_].entities[g];
      if (T)
        x = T;
      else if (g[0] === "&" && g[1] === "#") {
        var E = g[2], U = E == "x" || E == "X" ? parseInt(g.substr(3), 16) : parseInt(g.substr(2));
        x = U >= 1114111 ? y : U > 65535 ? i.fromCodePoint(U) : d(t.numericUnicodeMap[U] || U);
      }
    }
    return x;
  }
  Vi.decodeEntity = b;
  function p(g, v) {
    var _ = v === void 0 ? u : v, x = _.level, T = x === void 0 ? "all" : x, E = _.scope, U = E === void 0 ? T === "xml" ? "strict" : "body" : E;
    if (!g)
      return "";
    var D = f[T][U], L = r[T].entities, j = U === "attribute", C = U === "strict";
    D.lastIndex = 0;
    var k = D.exec(g), I;
    if (k) {
      I = "";
      var $ = 0;
      do {
        $ !== k.index && (I += g.substring($, k.index));
        var W = k[0], B = W, z = W[W.length - 1];
        if (j && z === "=")
          B = W;
        else if (C && z !== ";")
          B = W;
        else {
          var q = L[W];
          if (q)
            B = q;
          else if (W[0] === "&" && W[1] === "#") {
            var Y = W[2], H = Y == "x" || Y == "X" ? parseInt(W.substr(3), 16) : parseInt(W.substr(2));
            B = H >= 1114111 ? y : H > 65535 ? i.fromCodePoint(H) : d(t.numericUnicodeMap[H] || H);
          }
        }
        I += B, $ = k.index + W.length;
      } while (k = D.exec(g));
      $ !== g.length && (I += g.substring($));
    } else
      I = g;
    return I;
  }
  return Vi.decode = p, Vi;
}
var Qp = /* @__PURE__ */ A4(), Zd, av;
function jT() {
  if (av) return Zd;
  av = 1;
  var n = Object.prototype;
  function e(t) {
    var i = t && t.constructor, r = typeof i == "function" && i.prototype || n;
    return t === r;
  }
  return Zd = e, Zd;
}
var Jd, sv;
function k4() {
  if (sv) return Jd;
  sv = 1;
  function n(e, t) {
    return function(i) {
      return e(t(i));
    };
  }
  return Jd = n, Jd;
}
var ef, ov;
function I4() {
  if (ov) return ef;
  ov = 1;
  var n = k4(), e = n(Object.keys, Object);
  return ef = e, ef;
}
var tf, uv;
function U4() {
  if (uv) return tf;
  uv = 1;
  var n = jT(), e = I4(), t = Object.prototype, i = t.hasOwnProperty;
  function r(a) {
    if (!n(a))
      return e(a);
    var s = [];
    for (var o in Object(a))
      i.call(a, o) && o != "constructor" && s.push(o);
    return s;
  }
  return tf = r, tf;
}
var nf, cv;
function ao() {
  if (cv) return nf;
  cv = 1;
  function n(e) {
    var t = typeof e;
    return e != null && (t == "object" || t == "function");
  }
  return nf = n, nf;
}
var rf, lv;
function qT() {
  if (lv) return rf;
  lv = 1;
  var n = no(), e = ao(), t = "[object AsyncFunction]", i = "[object Function]", r = "[object GeneratorFunction]", a = "[object Proxy]";
  function s(o) {
    if (!e(o))
      return !1;
    var u = n(o);
    return u == i || u == r || u == t || u == a;
  }
  return rf = s, rf;
}
var af, dv;
function R4() {
  if (dv) return af;
  dv = 1;
  var n = Mi(), e = n["__core-js_shared__"];
  return af = e, af;
}
var sf, fv;
function O4() {
  if (fv) return sf;
  fv = 1;
  var n = R4(), e = (function() {
    var i = /[^.]+$/.exec(n && n.keys && n.keys.IE_PROTO || "");
    return i ? "Symbol(src)_1." + i : "";
  })();
  function t(i) {
    return !!e && e in i;
  }
  return sf = t, sf;
}
var of, hv;
function WT() {
  if (hv) return of;
  hv = 1;
  var n = Function.prototype, e = n.toString;
  function t(i) {
    if (i != null) {
      try {
        return e.call(i);
      } catch {
      }
      try {
        return i + "";
      } catch {
      }
    }
    return "";
  }
  return of = t, of;
}
var uf, pv;
function L4() {
  if (pv) return uf;
  pv = 1;
  var n = qT(), e = O4(), t = ao(), i = WT(), r = /[\\^$.*+?()[\]{}|]/g, a = /^\[object .+?Constructor\]$/, s = Function.prototype, o = Object.prototype, u = s.toString, c = o.hasOwnProperty, l = RegExp(
    "^" + u.call(c).replace(r, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
  );
  function h(f) {
    if (!t(f) || e(f))
      return !1;
    var d = n(f) ? l : a;
    return d.test(i(f));
  }
  return uf = h, uf;
}
var cf, mv;
function P4() {
  if (mv) return cf;
  mv = 1;
  function n(e, t) {
    return e?.[t];
  }
  return cf = n, cf;
}
var lf, gv;
function so() {
  if (gv) return lf;
  gv = 1;
  var n = L4(), e = P4();
  function t(i, r) {
    var a = e(i, r);
    return n(a) ? a : void 0;
  }
  return lf = t, lf;
}
var df, bv;
function F4() {
  if (bv) return df;
  bv = 1;
  var n = so(), e = Mi(), t = n(e, "DataView");
  return df = t, df;
}
var ff, yv;
function N4() {
  if (yv) return ff;
  yv = 1;
  var n = so(), e = Mi(), t = n(e, "Map");
  return ff = t, ff;
}
var hf, vv;
function M4() {
  if (vv) return hf;
  vv = 1;
  var n = so(), e = Mi(), t = n(e, "Promise");
  return hf = t, hf;
}
var pf, xv;
function B4() {
  if (xv) return pf;
  xv = 1;
  var n = so(), e = Mi(), t = n(e, "Set");
  return pf = t, pf;
}
var mf, _v;
function j4() {
  if (_v) return mf;
  _v = 1;
  var n = so(), e = Mi(), t = n(e, "WeakMap");
  return mf = t, mf;
}
var gf, Tv;
function q4() {
  if (Tv) return gf;
  Tv = 1;
  var n = F4(), e = N4(), t = M4(), i = B4(), r = j4(), a = no(), s = WT(), o = "[object Map]", u = "[object Object]", c = "[object Promise]", l = "[object Set]", h = "[object WeakMap]", f = "[object DataView]", d = s(n), y = s(e), m = s(t), b = s(i), p = s(r), g = a;
  return (n && g(new n(new ArrayBuffer(1))) != f || e && g(new e()) != o || t && g(t.resolve()) != c || i && g(new i()) != l || r && g(new r()) != h) && (g = function(v) {
    var _ = a(v), x = _ == u ? v.constructor : void 0, T = x ? s(x) : "";
    if (T)
      switch (T) {
        case d:
          return f;
        case y:
          return o;
        case m:
          return c;
        case b:
          return l;
        case p:
          return h;
      }
    return _;
  }), gf = g, gf;
}
var bf, wv;
function VT() {
  if (wv) return bf;
  wv = 1;
  var n = 9007199254740991;
  function e(t) {
    return typeof t == "number" && t > -1 && t % 1 == 0 && t <= n;
  }
  return bf = e, bf;
}
var yf, Ev;
function W4() {
  if (Ev) return yf;
  Ev = 1;
  var n = qT(), e = VT();
  function t(i) {
    return i != null && e(i.length) && !n(i);
  }
  return yf = t, yf;
}
var _s = { exports: {} }, vf, Dv;
function V4() {
  if (Dv) return vf;
  Dv = 1;
  function n() {
    return !1;
  }
  return vf = n, vf;
}
_s.exports;
var Sv;
function H4() {
  return Sv || (Sv = 1, (function(n, e) {
    var t = Mi(), i = V4(), r = e && !e.nodeType && e, a = r && !0 && n && !n.nodeType && n, s = a && a.exports === r, o = s ? t.Buffer : void 0, u = o ? o.isBuffer : void 0, c = u || i;
    n.exports = c;
  })(_s, _s.exports)), _s.exports;
}
var xf, Cv;
function z4() {
  if (Cv) return xf;
  Cv = 1;
  var n = no(), e = VT(), t = Ic(), i = "[object Arguments]", r = "[object Array]", a = "[object Boolean]", s = "[object Date]", o = "[object Error]", u = "[object Function]", c = "[object Map]", l = "[object Number]", h = "[object Object]", f = "[object RegExp]", d = "[object Set]", y = "[object String]", m = "[object WeakMap]", b = "[object ArrayBuffer]", p = "[object DataView]", g = "[object Float32Array]", v = "[object Float64Array]", _ = "[object Int8Array]", x = "[object Int16Array]", T = "[object Int32Array]", E = "[object Uint8Array]", U = "[object Uint8ClampedArray]", D = "[object Uint16Array]", L = "[object Uint32Array]", j = {};
  j[g] = j[v] = j[_] = j[x] = j[T] = j[E] = j[U] = j[D] = j[L] = !0, j[i] = j[r] = j[b] = j[a] = j[p] = j[s] = j[o] = j[u] = j[c] = j[l] = j[h] = j[f] = j[d] = j[y] = j[m] = !1;
  function C(k) {
    return t(k) && e(k.length) && !!j[n(k)];
  }
  return xf = C, xf;
}
var _f, Av;
function $4() {
  if (Av) return _f;
  Av = 1;
  function n(e) {
    return function(t) {
      return e(t);
    };
  }
  return _f = n, _f;
}
var Ts = { exports: {} };
Ts.exports;
var kv;
function G4() {
  return kv || (kv = 1, (function(n, e) {
    var t = DT(), i = e && !e.nodeType && e, r = i && !0 && n && !n.nodeType && n, a = r && r.exports === i, s = a && t.process, o = (function() {
      try {
        var u = r && r.require && r.require("util").types;
        return u || s && s.binding && s.binding("util");
      } catch {
      }
    })();
    n.exports = o;
  })(Ts, Ts.exports)), Ts.exports;
}
var Tf, Iv;
function X4() {
  if (Iv) return Tf;
  Iv = 1;
  var n = z4(), e = $4(), t = G4(), i = t && t.isTypedArray, r = i ? e(i) : n;
  return Tf = r, Tf;
}
var wf, Uv;
function K4() {
  if (Uv) return wf;
  Uv = 1;
  var n = U4(), e = q4(), t = ST(), i = CT(), r = W4(), a = H4(), s = jT(), o = X4(), u = "[object Map]", c = "[object Set]", l = Object.prototype, h = l.hasOwnProperty;
  function f(d) {
    if (d == null)
      return !0;
    if (r(d) && (i(d) || typeof d == "string" || typeof d.splice == "function" || a(d) || o(d) || t(d)))
      return !d.length;
    var y = e(d);
    if (y == u || y == c)
      return !d.size;
    if (s(d))
      return !n(d).length;
    for (var m in d)
      if (h.call(d, m))
        return !1;
    return !0;
  }
  return wf = f, wf;
}
var Y4 = K4();
const Q4 = /* @__PURE__ */ Qt(Y4), Is = {
  transcript: 1,
  caption: 2,
  both: 3
}, Z4 = 1e3, Qn = {
  pause: "paused",
  play: "playing",
  enterFullscreen: "isFullscreen",
  exitFullscreen: "notFullscreen",
  upArrow: "volumeUp",
  downArrow: "volumeDown",
  mute: "muted",
  unmute: "unmuted",
  leftArrow: "jumpBackward",
  rightArrow: "jumpForward"
}, HT = "Error encountered. Please check your Manifest.";
let ka = HT;
const zT = "No media resource(s). Please check your Manifest.";
let $T = zT;
const GT = 1e4;
let Us = GT;
function J4(n) {
  Us = n || GT;
}
function e6(n) {
  ka = n || HT;
}
function t6(n) {
  $T = n || zT;
}
function wn(n, e = !1, t = !1) {
  if (isNaN(n))
    return "";
  let i = Math.floor(n / 3600), r = Math.floor(n % 3600 / 60), a = n - r * 60 - i * 3600, s = "", o = i < 10 ? `0${i}` : `${i}`;
  s = e || i > 0 ? s + `${o}:` : s;
  let u = r < 10 ? `0${r}` : `${r}`;
  s = s + `${u}:`;
  let c = t ? a.toFixed(3) : parseInt(a);
  return c = a < 10 ? `0${c}` : `${c}`, s = s + `${c}`, s;
}
function n6(n) {
  const e = wn(n, !0, !0), t = (i, r) => i === 1 ? `${i} ${r}` : `${i} ${r}s`;
  if (e != "") {
    const [i, r, a] = e.split(":").map((o) => parseFloat(o));
    let s = i > 0 ? `${t(i, "hour")} ` : "";
    return s += i > 0 || r > 0 ? `${t(r, "minute")} ` : "", s += t(parseInt(a), "second"), s;
  } else
    return "";
}
function Zp(n) {
  const e = document.createElement("div");
  return e.innerHTML = n, e.textContent || e.innerText || "";
}
function Ri(n) {
  let [e, t, i] = n.split(":").reverse(), r = i != null ? parseInt(i) * 3600 : 0, a = t != null ? parseInt(t) * 60 : 0, s = e === "" ? 0 : parseFloat(e.replace(",", "."));
  return s = tc(s), r + a + s;
}
function XT(n) {
  if (n.status == 404)
    throw new Error("Cannot find the linked resource.");
  if (!n.ok)
    throw new Error(ka);
  return n;
}
function Jp(n, e) {
  return n === void 0 ? !1 : e === void 0 ? !0 : !(n.start > e.end && n.end > e.end);
}
function i6(n, e, t) {
  let i, r;
  return n.map((a, s) => {
    let o = s > 0 ? n[s].altStart : 0;
    isNaN(c) && (c = t);
    let {
      start: u,
      end: c
    } = a, l = o + u, h = o + c;
    e.start >= l && e.start < h && (i = s, r = e.start - o);
  }), {
    srcIndex: i,
    fragmentStart: r
  };
}
function KT(n, e, t = "", i = !1) {
  let r = t === "" ? e.split(".").reverse()[0] : t;
  (r.length > 4 || r.length < 3 || r === e) && (r = n.split(".").reverse()[0]);
  const a = r.length > 4 || r.length < 3 ? "" : r;
  let s = e.endsWith(a) ? e.split(`.${a}`)[0] : e;
  i && (s = `${s} (machine generated)`);
  let o = a != "" ? `${s}.${a}` : s;
  if (n.endsWith(r))
    fetch(n).then((u) => {
      u.blob().then((c) => {
        let l = window.URL.createObjectURL(c), h = document.createElement("a");
        h.href = l, h.download = `${o}`, h.click();
      });
    }).catch((u) => {
      console.log(u);
    });
  else {
    const u = document.createElement("a");
    u.setAttribute("href", n), u.setAttribute("download", `${o}`), u.style.display = "none", document.body.appendChild(u), u.click(), document.body.removeChild(u);
  }
}
function rr(n, e = 0) {
  if (n !== void 0) {
    const t = n.split("#t=")[1];
    return em(t, e);
  } else
    return;
}
function em(n, e = 0) {
  if (n !== void 0) {
    let t, i;
    const r = /([0-9]*:){1,2}([0-9]{2})(?:((\.|\,)[0-9]{2,3})?)/g;
    if (n.includes(":") && [...n.matchAll(/\,/g)].length > 1) {
      const a = [...n.matchAll(r)];
      [t, i] = a?.length == 2 ? [a[0][0], a[1][0]] : [0, 0];
    } else
      [t, i] = n.split(",");
    return i === void 0 && (i = e.toString()), {
      start: t.match(r) ? Ri(t) : tc(Number(t)),
      end: i.match(r) ? Ri(i) : tc(Number(i))
    };
  } else
    return;
}
function tm(n, e = "") {
  let t = [];
  return n && (n.type === "Canvas" ? t = n.items[0].items : Array.isArray(n) && n?.length > 0 && (t = n[0].items), t && e != "" && (t = t.filter((r) => r.motivation === e))), t;
}
function Rv(n, e, t, i = 0, r = !1) {
  let a = [], s = [], o = !1, u = "", c = "No resources found in Canvas";
  const l = (h) => {
    h = h?.length > 0 ? h : [h], h.map((f) => {
      const d = r6(f, i, e, t);
      d && d.src && a.push(d);
    });
  };
  if (n && n != null) {
    const h = tm(n);
    if (!h)
      return {
        resources: a,
        canvasTargets: s,
        error: c
      };
    if (h.length === 0)
      return {
        resources: a,
        canvasTargets: s,
        isMultiSource: o,
        poster: Df(n)
      };
    if (h?.length > 1)
      h.map((f, d) => {
        if (f.motivation === t && (l(f.body), t === "painting")) {
          o = !0;
          const y = a6(f, e, d);
          s.push(y);
        }
      });
    else if (h[0].body.items?.length > 0 && h[0]?.motivation === t)
      h[0].body.items.map((f) => {
        l(f);
      });
    else if (!Q4(h[0].body) && h[0].body?.id != "" && h[0]?.motivation === t)
      l(h[0].body);
    else if (t === "painting")
      return {
        resources: a,
        error: c,
        poster: Df(n),
        canvasTargets: s
      };
    if (!o && a?.length > 0 && t === "painting") {
      let f = rr(a[0].src, e);
      f === void 0 && (f = {
        start: 0,
        end: e
      }), f.altStart = f.start, f.duration = e, r || (f = {
        ...f,
        customStart: f.start,
        start: 0,
        altStart: 0
      }), s.push(f);
    }
    return u = Df(n, !0), {
      canvasTargets: s,
      isMultiSource: o,
      resources: a,
      poster: u
    };
  } else
    return {
      canvasTargets: s,
      isMultiSource: o,
      resources: a,
      poster: u,
      error: c
    };
}
function r6(n, e, t, i) {
  let r = null, a = Is.both, s = Mt(n.label);
  return i === "supplementing" && (a = Ym(n.id)), a != Is.transcript && (r = {
    src: e > 0 ? `${n.id}#t=${e},${t}` : n.id,
    key: n.id,
    type: n.format,
    kind: n.type,
    label: s || "auto"
  }, i === "supplementing" && (r.srclang = n.language ?? "en", r.kind = n.format.toLowerCase().includes("text/vtt") ? "subtitles" : "metadata")), r;
}
function a6(n, e, t) {
  const i = rr(n.target, e);
  if (i != null || !i)
    return i.id = n.id, isNaN(i.end) && (i.end = e), i.end = Number((i.end - i.start).toFixed(2)), i.duration = i.end, i.altStart = i.start, i.start = 0, i.sIndex = t, i;
}
function Vs(n) {
  const e = /(\(machine(\s|\-)generated\))/gi, t = e.test(n), i = n.replace(e, "").trim();
  return {
    isMachineGen: t,
    labelText: i
  };
}
function Ym(n) {
  if (!n)
    return;
  let e = n.split("/").reverse()[0];
  return e === "transcripts" ? Is.transcript : e === "captions" ? Is.caption : Is.both;
}
function Mt(n, e = !1) {
  if (n && typeof n == "object") {
    const t = Object.keys(n);
    if (t && t.length > 0) {
      const i = t[0], r = e ? n[i].join(`
`) : n[i][0] ?? "";
      return Qp.decode(r);
    }
  } else if (typeof n == "string")
    return Qp.decode(n);
  return "";
}
function YT(n) {
  return /^(([0-1][0-9])|([2][0-3])):([0-5][0-9])(:[0-5][0-9](?:[.]\d{1,3})?)?$/.test(n);
}
function Pn(n, e, t = !1) {
  if (n) {
    let i = n.offsetTop - e.current.offsetTop;
    if (t)
      e.current.scrollTop = i;
    else {
      let r = e.current.clientHeight - n.clientHeight;
      i > r ? e.current.scrollTop = i - e.current.clientHeight / 2 : r / 2 > i ? e.current.scrollTop = 0 : e.current.scrollTop = i / 2;
    }
  }
}
function nm(n, e, t = !1) {
  let i = e?.player(), r = "", a = ["input", "textarea", "select"], s = document.activeElement, o = s.className.includes("vjs") || s.className.includes("videojs"), u = n.which, c = n.ctrlKey || n.metaKey || n.altKey || n.shiftKey, l = ["ramp--transcript_time", "ramp--structured-nav__section-title", "ramp--structured-nav__item-link", "ramp--structured-nav__collapse-all-btn", "ramp--annotations__multi-select-header", "ramp--annotations__show-more-tags", "ramp--annotations__show-more-less", "ramp--annotations__annotation-row-time-tags", "ramp--transcript__show-more-less"], h = !1;
  if (s.tagName == "A") {
    let d = ["ramp--annotations__annotation-text", "ramp--transcript_text"];
    const y = s.parentElement?.className;
    h = d.includes(y);
  }
  let f = h || s?.role === "button" && (l.some((d) => s?.classList?.contains(d)) && (u === 38 || u === 40 || u === 32 || u === 13) || (s?.classList?.contains("ramp--structured-nav__section-title") || s?.classList?.contains("ramp--structured-nav__collapse-all-btn")) && (u === 37 || u === 39)) || s?.role === "button" && s?.classList?.contains("ramp--annotations__multi-select-header") || s?.role === "option" && s?.classList?.contains("annotations-dropdown-item");
  if (!(s && (a.indexOf(s.tagName.toLowerCase()) !== -1 || s.role === "tab" && (u === 37 || u === 39) || s.role === "switch" && (u === 13 || u === 32) || s?.classList?.contains("transcript_content") && (u === 38 || u === 40) || s?.classList?.contains("ramp--transcript_item") && (u === 38 || u === 40) || f) && !o || c || t)) {
    if (i == null)
      return;
    switch (u) {
      // Space and k toggle play/pause
      case 32:
      case 75:
        n.preventDefault(), i.paused() ? (r = Qn.play, i.play()) : (r = Qn.pause, i.pause());
        break;
      // f toggles fullscreen
      case 70:
        n.preventDefault(), i.audioOnlyMode() || (i.isFullscreen() ? (r = Qn.exitFullscreen, i.exitFullscreen()) : (r = Qn.enterFullscreen, i.requestFullscreen()));
        break;
      // Adapted from https://github.com/videojs/video.js/blob/bad086dad68d3ff16dbe12e434c15e1ee7ac2875/src/js/control-bar/mute-toggle.js#L56
      // m toggles mute
      case 77:
        n.preventDefault();
        const d = i.volume(), y = i.lastVolume_();
        if (d === 0) {
          const m = y < 0.1 ? 0.1 : y;
          i.volume(m), r = Qn.unmute, i.muted(!1);
        } else
          r = Qn.mute, i.muted(!i.muted());
        break;
      // Left arrow seeks 5 seconds back
      case 37:
        n.preventDefault(), r = Qn.leftArrow, i.currentTime(i.currentTime() - 5);
        break;
      // Right arrow seeks 5 seconds ahead
      case 39:
        n.preventDefault(), r = Qn.rightArrow, i.currentTime(i.currentTime() + 5);
        break;
      // Up arrow raises volume by 0.1
      case 38:
        n.preventDefault(), i.muted() && i.muted(!1), r = Qn.upArrow, i.volume(i.volume() + 0.1);
        break;
      // Down arrow lowers volume by 0.1
      case 40:
        n.preventDefault(), r = Qn.downArrow, i.volume(i.volume() - 0.1);
        break;
      default:
        return;
    }
    return n.stopPropagation(), r;
  }
}
const s6 = (n, e) => n.reduce(function(t, i) {
  return (t[i[e]] = t[i[e]] || []).push(i), t;
}, {}), tc = (n, e = Z4) => typeof n != "number" || isNaN(n) ? n : Math.round(n * e) / e, QT = (n) => n.sort((e, t) => e.time?.start - t.time?.start), o6 = (n, e) => {
  if (n.length <= e)
    return {
      truncated: n,
      isTruncated: !1
    };
  const i = document.createElement("div");
  if (i.innerHTML = n, ZT(i) <= e + 3)
    return {
      truncated: n,
      isTruncated: !1
    };
  {
    e > 0 && JT(i, e);
    const a = ew(i);
    return a && (a.textContent += "..."), {
      truncated: i.innerHTML,
      isTruncated: !0
    };
  }
}, ZT = (n) => {
  if (n.nodeType === Node.TEXT_NODE)
    return n.textContent.length;
  let e = 0;
  for (const t of n.childNodes)
    e += ZT(t);
  return e;
}, JT = (n, e) => {
  if (n.nodeType === Node.TEXT_NODE) {
    if (n.textContent.trim() === "") return 0;
    if (n.textContent.length <= e)
      return n.textContent.length;
    {
      const r = n.textContent.substring(0, e).lastIndexOf(" "), a = r === -1 ? e : r;
      return n.textContent = n.textContent.substring(0, a), e;
    }
  }
  let t = e;
  const i = Array.from(n.childNodes);
  for (let r = 0; r < i.length; r++) {
    const a = JT(i[r], t);
    if (t -= a, t <= 0) {
      for (let s = i.length - 1; s > r; s--)
        i[s].parentNode && i[s].parentNode.removeChild(i[s]);
      break;
    }
  }
  return e - t;
}, ew = (n) => {
  if (n.nodeType === Node.TEXT_NODE && n.textContent.trim() !== "")
    return n;
  for (let e = n.childNodes.length - 1; e >= 0; e--) {
    const t = ew(n.childNodes[e]);
    if (t)
      return t;
  }
  return null;
}, u6 = {
  allowedTags: ["a", "b", "br", "i", "img", "p", "small", "span", "sub", "sup"],
  allowedAttributes: {
    a: ["href"],
    img: ["src", "alt"]
  },
  allowedSchemesByTag: {
    a: ["http", "https", "mailto"]
  }
}, Ef = ["no-nav", "thumbnail-nav"];
function tw(n) {
  let e = [];
  try {
    if (n?.items)
      return n.items.map((i, r) => {
        let a;
        i.summary && i.summary != null && (a = Jn.parse(i.summary).getValue());
        let s;
        i.homepage && i.homepage.length > 0 && (s = i.homepage[0].id);
        try {
          let o = !0;
          const u = i.items[0]?.items;
          let c = "";
          if (u?.length > 0) {
            const d = u[0].body;
            d.items?.length > 0 ? c = d.items[0].id : Object.keys(d)?.length != 0 && d.id && (c = d.id);
          }
          const l = Number(i.duration);
          let h;
          c != "" && (h = rr(c, l), o = !1);
          const f = Mt(i.label) || `Section ${r + 1}`;
          e.push({
            canvasIndex: r,
            canvasId: i.id,
            canvasURL: i.id.split("#t=")[0],
            duration: l,
            range: h === void 0 ? {
              start: 0,
              end: l
            } : h,
            isEmpty: o,
            summary: a,
            homepage: s || "",
            label: f,
            searchService: rm(i)
          });
        } catch {
          e.push({
            canvasIndex: r,
            canvasId: i.id,
            canvasURL: i.id.split("#t=")[0],
            duration: i.duration || 0,
            range: void 0,
            // set range to undefined, use this check to set duration in UI
            isEmpty: !0,
            summary: a,
            homepage: s || "",
            label: Mt(i.label) || `Section ${r + 1}`,
            searchService: rm(i)
          });
        }
      }), e;
    throw console.error("iiif-parser -> canvasesInManifest() -> no canvases were found in Manifest"), new Error(ka);
  } catch (t) {
    throw t;
  }
}
function c6({
  manifest: n,
  canvasIndex: e,
  startTime: t,
  srcIndex: i = 0,
  isPlaylist: r = !1
}) {
  let a = null, s, o = [], u = {
    sources: [],
    tracks: [],
    canvasTargets: []
  };
  if (e === void 0 || e < 0)
    return {
      ...u,
      error: "Error fetching content"
    };
  const c = n.items;
  if (c?.length == 0)
    return {
      ...u,
      poster: $T
    };
  try {
    a = c[e];
    const l = a.annotations;
    if (a === void 0)
      throw console.error("iiif-parser -> getMediaInfo() -> canvas undefined  -> ", e), new Error(ka);
    const h = Number(a.duration), {
      resources: f,
      canvasTargets: d,
      isMultiSource: y,
      error: m,
      poster: b
    } = Rv(a, h, "painting", t, r);
    s = l6(f, y, i);
    const p = Rv(l, h, "supplementing");
    o = p ? p.resources : [];
    const g = {
      sources: s,
      tracks: o,
      canvasTargets: d,
      isMultiSource: y,
      error: m,
      poster: b
    };
    if (g.error)
      return {
        ...g
      };
    {
      let v = g.sources.map((x) => x.kind);
      const _ = d6(v);
      return {
        ...g,
        error: null,
        mediaType: _
      };
    }
  } catch (l) {
    throw l;
  }
}
function l6(n, e, t) {
  let i = !1;
  if (n.length === 0)
    return [];
  if (e)
    n[t].selected = !0;
  else {
    for (let r of n)
      r.label == "auto" && !i && (i = !0, r.selected = !0);
    i || (n[0].selected = !0);
  }
  return n;
}
function d6(n) {
  let e = n.filter((i, r) => n.indexOf(i) === r);
  return e.length === 1 ? e[0].toLowerCase() : "video";
}
function Nc(n) {
  if (n)
    return n.split("#t=")[0];
}
function Df(n, e = !1) {
  let t;
  try {
    let i = n.placeholderCanvas;
    if (i && i != null) {
      let r = i.items[0].items;
      if (r?.length > 0 && r[0].body != null && r[0].motivation === "painting") {
        const a = r[0].body;
        return e ? t = a.id : (t = Mt(a.label) || "This item cannot be played.", J4(i.duration)), t;
      }
    } else return e ? null : (console.error("iiif-parser -> getPlaceholderCanvas() -> placeholderCanvas property not defined"), "This item cannot be played.");
  } catch (i) {
    throw i;
  }
}
function f6(n, e, t) {
  let i = n.start, r = {}, a = 0;
  if (!i && e === void 0 && t === void 0)
    return {
      type: "C",
      canvas: a,
      time: 0
    };
  e != null || t != null ? (r = {
    id: e,
    selector: {
      type: "PointSelector",
      t: t === void 0 ? 0 : t
    },
    type: t === void 0 ? "Canvas" : "SpecificResource"
  }, t != null && (r.source = e)) : i && (r = i);
  const s = tw(n);
  let o = (u, c, l) => {
    let h = l, f = 0;
    if (s && s?.length > 0) {
      if (u)
        if (f = s.findIndex((d) => d.canvasId === u), f === void 0 || f < 0)
          console.warn("Given Canvas was not found in Manifest, ", e), h = 0, f = 0;
        else {
          const d = s[f];
          if (d.range != null && c === "SpecificResource") {
            const {
              start: y,
              end: m
            } = d.range;
            l >= y && l <= m || (console.warn("Given start time is not within Canvas duration, ", t), h = 0);
          }
        }
    } else
      console.warn("No Canvases in given Manifest"), h = 0;
    return {
      currentIndex: f,
      startTime: h
    };
  };
  if (r != null)
    switch (r.type) {
      case "Canvas":
        let u = o(r.id, r.type, 0);
        return {
          type: "C",
          canvas: u.currentIndex,
          time: u.startTime
        };
      case "SpecificResource":
        let c = r.selector.t;
        return u = o(r.source, r.type, c), {
          type: "SR",
          canvas: u.currentIndex,
          time: u.startTime
        };
    }
}
function Ov(n, e, t) {
  n = n === "text/srt" ? "application/x-subrip" : n;
  const i = K8[n], r = i ? i.extensions[0] : n;
  let a = Mt(e) || "Untitled", s = a;
  Object.keys(e).length > 1 && (a = e[Object.keys(e)[0]][0], s = e.none[0]);
  const {
    isMachineGen: o
  } = Vs(a);
  return {
    id: t,
    label: `${a} (.${r})`,
    filename: s,
    fileExt: r,
    isMachineGen: o
  };
}
function h6(n) {
  let e = [], t = [], i = n.rendering;
  const r = n.items;
  return i && i.map((a) => {
    const s = Ov(a.format, a.label, a.id);
    e.push(s);
  }), r && r.map((a, s) => {
    let o = a.rendering, u = [];
    o && o.map((c) => {
      const l = Ov(c.format, c.label, c.id);
      u.push(l);
    }), t.push({
      label: Mt(a.label) || `Section ${s + 1}`,
      files: u
    });
  }), {
    manifest: e,
    canvas: t
  };
}
function p6(n, e) {
  let t = [], i = {
    canvasMetadata: t,
    manifestMetadata: [],
    rights: []
  }, r = n.items;
  if (e && r) {
    for (const u in r) {
      let c = parseInt(u);
      const l = Lv(r[c], "Canvas");
      t.push({
        canvasindex: c,
        metadata: im(r[c].metadata, "Canvas"),
        rights: l
      });
    }
    i.canvasMetadata = t;
  }
  const a = n.metadata, s = im(a, "Manifest");
  i.manifestMetadata = s;
  const o = Lv(n, "Manifest");
  return i.rights = o, i;
}
function im(n, e) {
  let t = [];
  return n && n?.length > 0 ? (n.map((i) => {
    let r = Mt(i.value, !0)?.replace(/\n/g, "<br />"), a = E4(r, {
      ...u6
    });
    t.push({
      label: Mt(i.label),
      value: a
    });
  }), t) : (console.log("iiif-parser -> parseMetadata() -> no metadata in ", e), t);
}
function Lv(n, e) {
  let t = [];
  const i = n.requiredStatement;
  i && (t = im([i], e));
  const r = n.rights;
  if (r) {
    const a = /^(https?:\/\/[^\s]+)|(www\.[^\s]+)/.test(r);
    t.push({
      label: "License",
      value: a ? `<a href=${r}>${r}</a>` : r
    });
  }
  return t;
}
function m6(n) {
  return n ? n?.includes("auto-advance") : !1;
}
function g6(n, e, t = !1) {
  let i = [], r = 0, a = !1, s = 0, o = !1, u = 0, c = (l, h) => {
    let f = l.getBehavior();
    if (!Ef.includes(f)) {
      let d = Mt(l.getLabel().getValue()), y = l.getCanvasIds(), m = r, b = r, p = h == l && s == 0, g, v = !1, _ = !1, x, T, E;
      a ? (g = p || e.length > 1 && h == l.parentRange, e.length > 1 && h == l.parentRange ? s = s + 1 : e.length == 1 && (s = 1)) : g = h == l.parentRange && e[s - 1] != null, l.getRanges()?.length > 0 && !p && g && (o = !0);
      let U = l.getDuration();
      if (U != null && !p) {
        let {
          start: j,
          end: C
        } = U;
        m = C - j, g && (b = m);
      }
      if (y.length > 0 && e?.length > 0) {
        let j = e.filter((C) => C.canvasId === Nc(y[0]))[0];
        if (_ = j.isEmpty, x = j.summary, T = j.homepage, v = !0, j.range != null) {
          const {
            start: C,
            end: k
          } = j.range;
          b = k - C, g && (m = k - C);
        }
      }
      if (!g && y.length > 0 && u++, y.length > 0)
        if (g) {
          const [j, C] = y[0].split("#");
          C ? E = `${y[0].split(",")[0]},` : E = `${j}#t=0,`;
        } else
          E = y[0];
      let D = E ? rr(E, b) : {
        start: 0,
        end: 0
      }, L = {
        label: d,
        summary: x,
        isRoot: p,
        homepage: T,
        canvasDuration: b,
        id: E,
        times: D,
        isTitle: y.length === 0,
        rangeId: l.id,
        isEmpty: _,
        isCanvas: g,
        itemIndex: g ? s : u,
        canvasIndex: s,
        items: l.getRanges()?.length > 0 ? l.getRanges().map((j) => c(j, h)) : [],
        duration: wn(m),
        isClickable: v
      };
      return y.length > 0 && i.push(L), L;
    }
  };
  try {
    const l = z8(n).getAllRanges();
    if (l?.length === 0)
      return {
        structures: [],
        timespans: [],
        markRoot: !1,
        hasCollapsibleStructure: o
      };
    {
      const h = l[0];
      let f = [];
      const d = h.getBehavior();
      if (d && Ef.includes(d))
        return {
          structures: [],
          timespans: [],
          hasCollapsibleStructure: o
        };
      if (t || d === "top") {
        let m = h.getRanges();
        m?.length > 0 && m.map((b, p) => {
          const g = b.getBehavior();
          Ef.includes(g) || (u = 0, s = p + 1, f.push(c(b, h)));
        });
      } else
        a = !0, r = e.reduce((m, b) => m + b.range.end, 0), f.push(c(h, h, s));
      const y = a && e?.length > 1;
      return {
        structures: f,
        timespans: i,
        markRoot: y,
        hasCollapsibleStructure: o
      };
    }
  } catch {
    throw console.error("iiif-parser -> getStructureRanges() -> error parsing structures"), new Error(ka);
  }
}
function rm(n) {
  let e = null;
  if (n) {
    const t = n.service;
    if (t && t.length > 0) {
      const i = t.filter((r) => r.type === "SearchService2");
      e = i?.length > 0 ? i[0].id : null;
    }
  }
  return e;
}
var Rn = {}, Qm = "1.13.6", Pv = typeof self == "object" && self.self === self && self || typeof global == "object" && global.global === global && global || Function("return this")() || {}, Mc = Array.prototype, Zm = Object.prototype, Fv = typeof Symbol < "u" ? Symbol.prototype : null, b6 = Mc.push, oo = Mc.slice, Hs = Zm.toString, y6 = Zm.hasOwnProperty, nw = typeof ArrayBuffer < "u", v6 = typeof DataView < "u", x6 = Array.isArray, Nv = Object.keys, Mv = Object.create, Bv = nw && ArrayBuffer.isView, _6 = isNaN, T6 = isFinite, iw = !{ toString: null }.propertyIsEnumerable("toString"), jv = [
  "valueOf",
  "isPrototypeOf",
  "toString",
  "propertyIsEnumerable",
  "hasOwnProperty",
  "toLocaleString"
], w6 = Math.pow(2, 53) - 1;
function ln(n, e) {
  return e = e == null ? n.length - 1 : +e, function() {
    for (var t = Math.max(arguments.length - e, 0), i = Array(t), r = 0; r < t; r++)
      i[r] = arguments[r + e];
    switch (e) {
      case 0:
        return n.call(this, i);
      case 1:
        return n.call(this, arguments[0], i);
      case 2:
        return n.call(this, arguments[0], arguments[1], i);
    }
    var a = Array(e + 1);
    for (r = 0; r < e; r++)
      a[r] = arguments[r];
    return a[e] = i, n.apply(this, a);
  };
}
function ar(n) {
  var e = typeof n;
  return e === "function" || e === "object" && !!n;
}
function rw(n) {
  return n === null;
}
function Jm(n) {
  return n === void 0;
}
function eg(n) {
  return n === !0 || n === !1 || Hs.call(n) === "[object Boolean]";
}
function aw(n) {
  return !!(n && n.nodeType === 1);
}
function Zt(n) {
  var e = "[object " + n + "]";
  return function(t) {
    return Hs.call(t) === e;
  };
}
const Bc = Zt("String"), tg = Zt("Number"), sw = Zt("Date"), ow = Zt("RegExp"), uw = Zt("Error"), ng = Zt("Symbol"), ig = Zt("ArrayBuffer");
var cw = Zt("Function"), E6 = Pv.document && Pv.document.childNodes;
typeof /./ != "function" && typeof Int8Array != "object" && typeof E6 != "function" && (cw = function(n) {
  return typeof n == "function" || !1;
});
const Yt = cw, lw = Zt("Object");
var dw = v6 && lw(new DataView(new ArrayBuffer(8))), rg = typeof Map < "u" && lw(/* @__PURE__ */ new Map()), D6 = Zt("DataView");
function S6(n) {
  return n != null && Yt(n.getInt8) && ig(n.buffer);
}
const zs = dw ? S6 : D6, sr = x6 || Zt("Array");
function or(n, e) {
  return n != null && y6.call(n, e);
}
var am = Zt("Arguments");
(function() {
  am(arguments) || (am = function(n) {
    return or(n, "callee");
  });
})();
const jc = am;
function fw(n) {
  return !ng(n) && T6(n) && !isNaN(parseFloat(n));
}
function ag(n) {
  return tg(n) && _6(n);
}
function sg(n) {
  return function() {
    return n;
  };
}
function hw(n) {
  return function(e) {
    var t = n(e);
    return typeof t == "number" && t >= 0 && t <= w6;
  };
}
function pw(n) {
  return function(e) {
    return e?.[n];
  };
}
const nc = pw("byteLength"), C6 = hw(nc);
var A6 = /\[object ((I|Ui)nt(8|16|32)|Float(32|64)|Uint8Clamped|Big(I|Ui)nt64)Array\]/;
function k6(n) {
  return Bv ? Bv(n) && !zs(n) : C6(n) && A6.test(Hs.call(n));
}
const og = nw ? k6 : sg(!1), gn = pw("length");
function I6(n) {
  for (var e = {}, t = n.length, i = 0; i < t; ++i) e[n[i]] = !0;
  return {
    contains: function(r) {
      return e[r] === !0;
    },
    push: function(r) {
      return e[r] = !0, n.push(r);
    }
  };
}
function mw(n, e) {
  e = I6(e);
  var t = jv.length, i = n.constructor, r = Yt(i) && i.prototype || Zm, a = "constructor";
  for (or(n, a) && !e.contains(a) && e.push(a); t--; )
    a = jv[t], a in n && n[a] !== r[a] && !e.contains(a) && e.push(a);
}
function Bt(n) {
  if (!ar(n)) return [];
  if (Nv) return Nv(n);
  var e = [];
  for (var t in n) or(n, t) && e.push(t);
  return iw && mw(n, e), e;
}
function gw(n) {
  if (n == null) return !0;
  var e = gn(n);
  return typeof e == "number" && (sr(n) || Bc(n) || jc(n)) ? e === 0 : gn(Bt(n)) === 0;
}
function ug(n, e) {
  var t = Bt(e), i = t.length;
  if (n == null) return !i;
  for (var r = Object(n), a = 0; a < i; a++) {
    var s = t[a];
    if (e[s] !== r[s] || !(s in r)) return !1;
  }
  return !0;
}
function ht(n) {
  if (n instanceof ht) return n;
  if (!(this instanceof ht)) return new ht(n);
  this._wrapped = n;
}
ht.VERSION = Qm;
ht.prototype.value = function() {
  return this._wrapped;
};
ht.prototype.valueOf = ht.prototype.toJSON = ht.prototype.value;
ht.prototype.toString = function() {
  return String(this._wrapped);
};
function qv(n) {
  return new Uint8Array(
    n.buffer || n,
    n.byteOffset || 0,
    nc(n)
  );
}
var Wv = "[object DataView]";
function sm(n, e, t, i) {
  if (n === e) return n !== 0 || 1 / n === 1 / e;
  if (n == null || e == null) return !1;
  if (n !== n) return e !== e;
  var r = typeof n;
  return r !== "function" && r !== "object" && typeof e != "object" ? !1 : bw(n, e, t, i);
}
function bw(n, e, t, i) {
  n instanceof ht && (n = n._wrapped), e instanceof ht && (e = e._wrapped);
  var r = Hs.call(n);
  if (r !== Hs.call(e)) return !1;
  if (dw && r == "[object Object]" && zs(n)) {
    if (!zs(e)) return !1;
    r = Wv;
  }
  switch (r) {
    // These types are compared by value.
    case "[object RegExp]":
    // RegExps are coerced to strings for comparison (Note: '' + /a/i === '/a/i')
    case "[object String]":
      return "" + n == "" + e;
    case "[object Number]":
      return +n != +n ? +e != +e : +n == 0 ? 1 / +n === 1 / e : +n == +e;
    case "[object Date]":
    case "[object Boolean]":
      return +n == +e;
    case "[object Symbol]":
      return Fv.valueOf.call(n) === Fv.valueOf.call(e);
    case "[object ArrayBuffer]":
    case Wv:
      return bw(qv(n), qv(e), t, i);
  }
  var a = r === "[object Array]";
  if (!a && og(n)) {
    var s = nc(n);
    if (s !== nc(e)) return !1;
    if (n.buffer === e.buffer && n.byteOffset === e.byteOffset) return !0;
    a = !0;
  }
  if (!a) {
    if (typeof n != "object" || typeof e != "object") return !1;
    var o = n.constructor, u = e.constructor;
    if (o !== u && !(Yt(o) && o instanceof o && Yt(u) && u instanceof u) && "constructor" in n && "constructor" in e)
      return !1;
  }
  t = t || [], i = i || [];
  for (var c = t.length; c--; )
    if (t[c] === n) return i[c] === e;
  if (t.push(n), i.push(e), a) {
    if (c = n.length, c !== e.length) return !1;
    for (; c--; )
      if (!sm(n[c], e[c], t, i)) return !1;
  } else {
    var l = Bt(n), h;
    if (c = l.length, Bt(e).length !== c) return !1;
    for (; c--; )
      if (h = l[c], !(or(e, h) && sm(n[h], e[h], t, i))) return !1;
  }
  return t.pop(), i.pop(), !0;
}
function yw(n, e) {
  return sm(n, e);
}
function Ia(n) {
  if (!ar(n)) return [];
  var e = [];
  for (var t in n) e.push(t);
  return iw && mw(n, e), e;
}
function cg(n) {
  var e = gn(n);
  return function(t) {
    if (t == null) return !1;
    var i = Ia(t);
    if (gn(i)) return !1;
    for (var r = 0; r < e; r++)
      if (!Yt(t[n[r]])) return !1;
    return n !== _w || !Yt(t[lg]);
  };
}
var lg = "forEach", vw = "has", dg = ["clear", "delete"], xw = ["get", vw, "set"], U6 = dg.concat(lg, xw), _w = dg.concat(xw), R6 = ["add"].concat(dg, lg, vw);
const Tw = rg ? cg(U6) : Zt("Map"), ww = rg ? cg(_w) : Zt("WeakMap"), Ew = rg ? cg(R6) : Zt("Set"), Dw = Zt("WeakSet");
function jr(n) {
  for (var e = Bt(n), t = e.length, i = Array(t), r = 0; r < t; r++)
    i[r] = n[e[r]];
  return i;
}
function Sw(n) {
  for (var e = Bt(n), t = e.length, i = Array(t), r = 0; r < t; r++)
    i[r] = [e[r], n[e[r]]];
  return i;
}
function fg(n) {
  for (var e = {}, t = Bt(n), i = 0, r = t.length; i < r; i++)
    e[n[t[i]]] = t[i];
  return e;
}
function $s(n) {
  var e = [];
  for (var t in n)
    Yt(n[t]) && e.push(t);
  return e.sort();
}
function hg(n, e) {
  return function(t) {
    var i = arguments.length;
    if (e && (t = Object(t)), i < 2 || t == null) return t;
    for (var r = 1; r < i; r++)
      for (var a = arguments[r], s = n(a), o = s.length, u = 0; u < o; u++) {
        var c = s[u];
        (!e || t[c] === void 0) && (t[c] = a[c]);
      }
    return t;
  };
}
const pg = hg(Ia), ba = hg(Bt), mg = hg(Ia, !0);
function O6() {
  return function() {
  };
}
function Cw(n) {
  if (!ar(n)) return {};
  if (Mv) return Mv(n);
  var e = O6();
  e.prototype = n;
  var t = new e();
  return e.prototype = null, t;
}
function Aw(n, e) {
  var t = Cw(n);
  return e && ba(t, e), t;
}
function kw(n) {
  return ar(n) ? sr(n) ? n.slice() : pg({}, n) : n;
}
function Iw(n, e) {
  return e(n), n;
}
function gg(n) {
  return sr(n) ? n : [n];
}
ht.toPath = gg;
function uo(n) {
  return ht.toPath(n);
}
function bg(n, e) {
  for (var t = e.length, i = 0; i < t; i++) {
    if (n == null) return;
    n = n[e[i]];
  }
  return t ? n : void 0;
}
function yg(n, e, t) {
  var i = bg(n, uo(e));
  return Jm(i) ? t : i;
}
function Uw(n, e) {
  e = uo(e);
  for (var t = e.length, i = 0; i < t; i++) {
    var r = e[i];
    if (!or(n, r)) return !1;
    n = n[r];
  }
  return !!t;
}
function qc(n) {
  return n;
}
function Fr(n) {
  return n = ba({}, n), function(e) {
    return ug(e, n);
  };
}
function Wc(n) {
  return n = uo(n), function(e) {
    return bg(e, n);
  };
}
function co(n, e, t) {
  if (e === void 0) return n;
  switch (t ?? 3) {
    case 1:
      return function(i) {
        return n.call(e, i);
      };
    // The 2-argument case is omitted because were not using it.
    case 3:
      return function(i, r, a) {
        return n.call(e, i, r, a);
      };
    case 4:
      return function(i, r, a, s) {
        return n.call(e, i, r, a, s);
      };
  }
  return function() {
    return n.apply(e, arguments);
  };
}
function Rw(n, e, t) {
  return n == null ? qc : Yt(n) ? co(n, e, t) : ar(n) && !sr(n) ? Fr(n) : Wc(n);
}
function Vc(n, e) {
  return Rw(n, e, 1 / 0);
}
ht.iteratee = Vc;
function bn(n, e, t) {
  return ht.iteratee !== Vc ? ht.iteratee(n, e) : Rw(n, e, t);
}
function Ow(n, e, t) {
  e = bn(e, t);
  for (var i = Bt(n), r = i.length, a = {}, s = 0; s < r; s++) {
    var o = i[s];
    a[o] = e(n[o], o, n);
  }
  return a;
}
function vg() {
}
function Lw(n) {
  return n == null ? vg : function(e) {
    return yg(n, e);
  };
}
function Pw(n, e, t) {
  var i = Array(Math.max(0, n));
  e = co(e, t, 1);
  for (var r = 0; r < n; r++) i[r] = e(r);
  return i;
}
function ic(n, e) {
  return e == null && (e = n, n = 0), n + Math.floor(Math.random() * (e - n + 1));
}
const ya = Date.now || function() {
  return (/* @__PURE__ */ new Date()).getTime();
};
function Fw(n) {
  var e = function(a) {
    return n[a];
  }, t = "(?:" + Bt(n).join("|") + ")", i = RegExp(t), r = RegExp(t, "g");
  return function(a) {
    return a = a == null ? "" : "" + a, i.test(a) ? a.replace(r, e) : a;
  };
}
const Nw = {
  "&": "&amp;",
  "<": "&lt;",
  ">": "&gt;",
  '"': "&quot;",
  "'": "&#x27;",
  "`": "&#x60;"
}, Mw = Fw(Nw), L6 = fg(Nw), Bw = Fw(L6), jw = ht.templateSettings = {
  evaluate: /<%([\s\S]+?)%>/g,
  interpolate: /<%=([\s\S]+?)%>/g,
  escape: /<%-([\s\S]+?)%>/g
};
var Sf = /(.)^/, P6 = {
  "'": "'",
  "\\": "\\",
  "\r": "r",
  "\n": "n",
  "\u2028": "u2028",
  "\u2029": "u2029"
}, F6 = /\\|'|\r|\n|\u2028|\u2029/g;
function N6(n) {
  return "\\" + P6[n];
}
var M6 = /^\s*(\w|\$)+\s*$/;
function qw(n, e, t) {
  !e && t && (e = t), e = mg({}, e, ht.templateSettings);
  var i = RegExp([
    (e.escape || Sf).source,
    (e.interpolate || Sf).source,
    (e.evaluate || Sf).source
  ].join("|") + "|$", "g"), r = 0, a = "__p+='";
  n.replace(i, function(c, l, h, f, d) {
    return a += n.slice(r, d).replace(F6, N6), r = d + c.length, l ? a += `'+
((__t=(` + l + `))==null?'':_.escape(__t))+
'` : h ? a += `'+
((__t=(` + h + `))==null?'':__t)+
'` : f && (a += `';
` + f + `
__p+='`), c;
  }), a += `';
`;
  var s = e.variable;
  if (s) {
    if (!M6.test(s)) throw new Error(
      "variable is not a bare identifier: " + s
    );
  } else
    a = `with(obj||{}){
` + a + `}
`, s = "obj";
  a = `var __t,__p='',__j=Array.prototype.join,print=function(){__p+=__j.call(arguments,'');};
` + a + `return __p;
`;
  var o;
  try {
    o = new Function(s, "_", a);
  } catch (c) {
    throw c.source = a, c;
  }
  var u = function(c) {
    return o.call(this, c, ht);
  };
  return u.source = "function(" + s + `){
` + a + "}", u;
}
function Ww(n, e, t) {
  e = uo(e);
  var i = e.length;
  if (!i)
    return Yt(t) ? t.call(n) : t;
  for (var r = 0; r < i; r++) {
    var a = n?.[e[r]];
    a === void 0 && (a = t, r = i), n = Yt(a) ? a.call(n) : a;
  }
  return n;
}
var B6 = 0;
function Vw(n) {
  var e = ++B6 + "";
  return n ? n + e : e;
}
function Hw(n) {
  var e = ht(n);
  return e._chain = !0, e;
}
function zw(n, e, t, i, r) {
  if (!(i instanceof e)) return n.apply(t, r);
  var a = Cw(n.prototype), s = n.apply(a, r);
  return ar(s) ? s : a;
}
var qr = ln(function(n, e) {
  var t = qr.placeholder, i = function() {
    for (var r = 0, a = e.length, s = Array(a), o = 0; o < a; o++)
      s[o] = e[o] === t ? arguments[r++] : e[o];
    for (; r < arguments.length; ) s.push(arguments[r++]);
    return zw(n, i, this, this, s);
  };
  return i;
});
qr.placeholder = ht;
const xg = ln(function(n, e, t) {
  if (!Yt(n)) throw new TypeError("Bind must be called on a function");
  var i = ln(function(r) {
    return zw(n, i, e, this, t.concat(r));
  });
  return i;
}), Sn = hw(gn);
function Wr(n, e, t, i) {
  if (i = i || [], !e && e !== 0)
    e = 1 / 0;
  else if (e <= 0)
    return i.concat(n);
  for (var r = i.length, a = 0, s = gn(n); a < s; a++) {
    var o = n[a];
    if (Sn(o) && (sr(o) || jc(o)))
      if (e > 1)
        Wr(o, e - 1, t, i), r = i.length;
      else
        for (var u = 0, c = o.length; u < c; ) i[r++] = o[u++];
    else t || (i[r++] = o);
  }
  return i;
}
const $w = ln(function(n, e) {
  e = Wr(e, !1, !1);
  var t = e.length;
  if (t < 1) throw new Error("bindAll must be passed function names");
  for (; t--; ) {
    var i = e[t];
    n[i] = xg(n[i], n);
  }
  return n;
});
function Gw(n, e) {
  var t = function(i) {
    var r = t.cache, a = "" + (e ? e.apply(this, arguments) : i);
    return or(r, a) || (r[a] = n.apply(this, arguments)), r[a];
  };
  return t.cache = {}, t;
}
const _g = ln(function(n, e, t) {
  return setTimeout(function() {
    return n.apply(null, t);
  }, e);
}), Xw = qr(_g, ht, 1);
function Kw(n, e, t) {
  var i, r, a, s, o = 0;
  t || (t = {});
  var u = function() {
    o = t.leading === !1 ? 0 : ya(), i = null, s = n.apply(r, a), i || (r = a = null);
  }, c = function() {
    var l = ya();
    !o && t.leading === !1 && (o = l);
    var h = e - (l - o);
    return r = this, a = arguments, h <= 0 || h > e ? (i && (clearTimeout(i), i = null), o = l, s = n.apply(r, a), i || (r = a = null)) : !i && t.trailing !== !1 && (i = setTimeout(u, h)), s;
  };
  return c.cancel = function() {
    clearTimeout(i), o = 0, i = r = a = null;
  }, c;
}
function Yw(n, e, t) {
  var i, r, a, s, o, u = function() {
    var l = ya() - r;
    e > l ? i = setTimeout(u, e - l) : (i = null, t || (s = n.apply(o, a)), i || (a = o = null));
  }, c = ln(function(l) {
    return o = this, a = l, r = ya(), i || (i = setTimeout(u, e), t && (s = n.apply(o, a))), s;
  });
  return c.cancel = function() {
    clearTimeout(i), i = a = o = null;
  }, c;
}
function Qw(n, e) {
  return qr(e, n);
}
function Hc(n) {
  return function() {
    return !n.apply(this, arguments);
  };
}
function Zw() {
  var n = arguments, e = n.length - 1;
  return function() {
    for (var t = e, i = n[e].apply(this, arguments); t--; ) i = n[t].call(this, i);
    return i;
  };
}
function Jw(n, e) {
  return function() {
    if (--n < 1)
      return e.apply(this, arguments);
  };
}
function Tg(n, e) {
  var t;
  return function() {
    return --n > 0 && (t = e.apply(this, arguments)), n <= 1 && (e = null), t;
  };
}
const eE = qr(Tg, 2);
function wg(n, e, t) {
  e = bn(e, t);
  for (var i = Bt(n), r, a = 0, s = i.length; a < s; a++)
    if (r = i[a], e(n[r], r, n)) return r;
}
function tE(n) {
  return function(e, t, i) {
    t = bn(t, i);
    for (var r = gn(e), a = n > 0 ? 0 : r - 1; a >= 0 && a < r; a += n)
      if (t(e[a], a, e)) return a;
    return -1;
  };
}
const zc = tE(1), Eg = tE(-1);
function Dg(n, e, t, i) {
  t = bn(t, i, 1);
  for (var r = t(e), a = 0, s = gn(n); a < s; ) {
    var o = Math.floor((a + s) / 2);
    t(n[o]) < r ? a = o + 1 : s = o;
  }
  return a;
}
function nE(n, e, t) {
  return function(i, r, a) {
    var s = 0, o = gn(i);
    if (typeof a == "number")
      n > 0 ? s = a >= 0 ? a : Math.max(a + o, s) : o = a >= 0 ? Math.min(a + 1, o) : a + o + 1;
    else if (t && a && o)
      return a = t(i, r), i[a] === r ? a : -1;
    if (r !== r)
      return a = e(oo.call(i, s, o), ag), a >= 0 ? a + s : -1;
    for (a = n > 0 ? s : o - 1; a >= 0 && a < o; a += n)
      if (i[a] === r) return a;
    return -1;
  };
}
const Sg = nE(1, zc, Dg), iE = nE(-1, Eg);
function Gs(n, e, t) {
  var i = Sn(n) ? zc : wg, r = i(n, e, t);
  if (r !== void 0 && r !== -1) return n[r];
}
function rE(n, e) {
  return Gs(n, Fr(e));
}
function ri(n, e, t) {
  e = co(e, t);
  var i, r;
  if (Sn(n))
    for (i = 0, r = n.length; i < r; i++)
      e(n[i], i, n);
  else {
    var a = Bt(n);
    for (i = 0, r = a.length; i < r; i++)
      e(n[a[i]], a[i], n);
  }
  return n;
}
function Li(n, e, t) {
  e = bn(e, t);
  for (var i = !Sn(n) && Bt(n), r = (i || n).length, a = Array(r), s = 0; s < r; s++) {
    var o = i ? i[s] : s;
    a[s] = e(n[o], o, n);
  }
  return a;
}
function aE(n) {
  var e = function(t, i, r, a) {
    var s = !Sn(t) && Bt(t), o = (s || t).length, u = n > 0 ? 0 : o - 1;
    for (a || (r = t[s ? s[u] : u], u += n); u >= 0 && u < o; u += n) {
      var c = s ? s[u] : u;
      r = i(r, t[c], c, t);
    }
    return r;
  };
  return function(t, i, r, a) {
    var s = arguments.length >= 3;
    return e(t, co(i, a, 4), r, s);
  };
}
const sa = aE(1), rc = aE(-1);
function Ji(n, e, t) {
  var i = [];
  return e = bn(e, t), ri(n, function(r, a, s) {
    e(r, a, s) && i.push(r);
  }), i;
}
function sE(n, e, t) {
  return Ji(n, Hc(bn(e)), t);
}
function ac(n, e, t) {
  e = bn(e, t);
  for (var i = !Sn(n) && Bt(n), r = (i || n).length, a = 0; a < r; a++) {
    var s = i ? i[a] : a;
    if (!e(n[s], s, n)) return !1;
  }
  return !0;
}
function sc(n, e, t) {
  e = bn(e, t);
  for (var i = !Sn(n) && Bt(n), r = (i || n).length, a = 0; a < r; a++) {
    var s = i ? i[a] : a;
    if (e(n[s], s, n)) return !0;
  }
  return !1;
}
function Fn(n, e, t, i) {
  return Sn(n) || (n = jr(n)), (typeof t != "number" || i) && (t = 0), Sg(n, e, t) >= 0;
}
const oE = ln(function(n, e, t) {
  var i, r;
  return Yt(e) ? r = e : (e = uo(e), i = e.slice(0, -1), e = e[e.length - 1]), Li(n, function(a) {
    var s = r;
    if (!s) {
      if (i && i.length && (a = bg(a, i)), a == null) return;
      s = a[e];
    }
    return s == null ? s : s.apply(a, t);
  });
});
function $c(n, e) {
  return Li(n, Wc(e));
}
function uE(n, e) {
  return Ji(n, Fr(e));
}
function Cg(n, e, t) {
  var i = -1 / 0, r = -1 / 0, a, s;
  if (e == null || typeof e == "number" && typeof n[0] != "object" && n != null) {
    n = Sn(n) ? n : jr(n);
    for (var o = 0, u = n.length; o < u; o++)
      a = n[o], a != null && a > i && (i = a);
  } else
    e = bn(e, t), ri(n, function(c, l, h) {
      s = e(c, l, h), (s > r || s === -1 / 0 && i === -1 / 0) && (i = c, r = s);
    });
  return i;
}
function cE(n, e, t) {
  var i = 1 / 0, r = 1 / 0, a, s;
  if (e == null || typeof e == "number" && typeof n[0] != "object" && n != null) {
    n = Sn(n) ? n : jr(n);
    for (var o = 0, u = n.length; o < u; o++)
      a = n[o], a != null && a < i && (i = a);
  } else
    e = bn(e, t), ri(n, function(c, l, h) {
      s = e(c, l, h), (s < r || s === 1 / 0 && i === 1 / 0) && (i = c, r = s);
    });
  return i;
}
var j6 = /[^\ud800-\udfff]|[\ud800-\udbff][\udc00-\udfff]|[\ud800-\udfff]/g;
function Ag(n) {
  return n ? sr(n) ? oo.call(n) : Bc(n) ? n.match(j6) : Sn(n) ? Li(n, qc) : jr(n) : [];
}
function kg(n, e, t) {
  if (e == null || t)
    return Sn(n) || (n = jr(n)), n[ic(n.length - 1)];
  var i = Ag(n), r = gn(i);
  e = Math.max(Math.min(e, r), 0);
  for (var a = r - 1, s = 0; s < e; s++) {
    var o = ic(s, a), u = i[s];
    i[s] = i[o], i[o] = u;
  }
  return i.slice(0, e);
}
function lE(n) {
  return kg(n, 1 / 0);
}
function dE(n, e, t) {
  var i = 0;
  return e = bn(e, t), $c(Li(n, function(r, a, s) {
    return {
      value: r,
      index: i++,
      criteria: e(r, a, s)
    };
  }).sort(function(r, a) {
    var s = r.criteria, o = a.criteria;
    if (s !== o) {
      if (s > o || s === void 0) return 1;
      if (s < o || o === void 0) return -1;
    }
    return r.index - a.index;
  }), "value");
}
function Gc(n, e) {
  return function(t, i, r) {
    var a = e ? [[], []] : {};
    return i = bn(i, r), ri(t, function(s, o) {
      var u = i(s, o, t);
      n(a, s, u);
    }), a;
  };
}
const fE = Gc(function(n, e, t) {
  or(n, t) ? n[t].push(e) : n[t] = [e];
}), hE = Gc(function(n, e, t) {
  n[t] = e;
}), pE = Gc(function(n, e, t) {
  or(n, t) ? n[t]++ : n[t] = 1;
}), mE = Gc(function(n, e, t) {
  n[t ? 0 : 1].push(e);
}, !0);
function gE(n) {
  return n == null ? 0 : Sn(n) ? n.length : Bt(n).length;
}
function q6(n, e, t) {
  return e in t;
}
const Ig = ln(function(n, e) {
  var t = {}, i = e[0];
  if (n == null) return t;
  Yt(i) ? (e.length > 1 && (i = co(i, e[1])), e = Ia(n)) : (i = q6, e = Wr(e, !1, !1), n = Object(n));
  for (var r = 0, a = e.length; r < a; r++) {
    var s = e[r], o = n[s];
    i(o, s, n) && (t[s] = o);
  }
  return t;
}), bE = ln(function(n, e) {
  var t = e[0], i;
  return Yt(t) ? (t = Hc(t), e.length > 1 && (i = e[1])) : (e = Li(Wr(e, !1, !1), String), t = function(r, a) {
    return !Fn(e, a);
  }), Ig(n, t, i);
});
function Ug(n, e, t) {
  return oo.call(n, 0, Math.max(0, n.length - (e == null || t ? 1 : e)));
}
function oa(n, e, t) {
  return n == null || n.length < 1 ? e == null || t ? void 0 : [] : e == null || t ? n[0] : Ug(n, n.length - e);
}
function Ir(n, e, t) {
  return oo.call(n, e == null || t ? 1 : e);
}
function yE(n, e, t) {
  return n == null || n.length < 1 ? e == null || t ? void 0 : [] : e == null || t ? n[n.length - 1] : Ir(n, Math.max(0, n.length - e));
}
function vE(n) {
  return Ji(n, Boolean);
}
function xE(n, e) {
  return Wr(n, e, !1);
}
const Rg = ln(function(n, e) {
  return e = Wr(e, !0, !0), Ji(n, function(t) {
    return !Fn(e, t);
  });
}), _E = ln(function(n, e) {
  return Rg(n, e);
});
function Xs(n, e, t, i) {
  eg(e) || (i = t, t = e, e = !1), t != null && (t = bn(t, i));
  for (var r = [], a = [], s = 0, o = gn(n); s < o; s++) {
    var u = n[s], c = t ? t(u, s, n) : u;
    e && !t ? ((!s || a !== c) && r.push(u), a = c) : t ? Fn(a, c) || (a.push(c), r.push(u)) : Fn(r, u) || r.push(u);
  }
  return r;
}
const TE = ln(function(n) {
  return Xs(Wr(n, !0, !0));
});
function wE(n) {
  for (var e = [], t = arguments.length, i = 0, r = gn(n); i < r; i++) {
    var a = n[i];
    if (!Fn(e, a)) {
      var s;
      for (s = 1; s < t && Fn(arguments[s], a); s++)
        ;
      s === t && e.push(a);
    }
  }
  return e;
}
function Ks(n) {
  for (var e = n && Cg(n, gn).length || 0, t = Array(e), i = 0; i < e; i++)
    t[i] = $c(n, i);
  return t;
}
const EE = ln(Ks);
function DE(n, e) {
  for (var t = {}, i = 0, r = gn(n); i < r; i++)
    e ? t[n[i]] = e[i] : t[n[i][0]] = n[i][1];
  return t;
}
function SE(n, e, t) {
  e == null && (e = n || 0, n = 0), t || (t = e < n ? -1 : 1);
  for (var i = Math.max(Math.ceil((e - n) / t), 0), r = Array(i), a = 0; a < i; a++, n += t)
    r[a] = n;
  return r;
}
function CE(n, e) {
  if (e == null || e < 1) return [];
  for (var t = [], i = 0, r = n.length; i < r; )
    t.push(oo.call(n, i, i += e));
  return t;
}
function Og(n, e) {
  return n._chain ? ht(e).chain() : e;
}
function Lg(n) {
  return ri($s(n), function(e) {
    var t = ht[e] = n[e];
    ht.prototype[e] = function() {
      var i = [this._wrapped];
      return b6.apply(i, arguments), Og(this, t.apply(ht, i));
    };
  }), ht;
}
ri(["pop", "push", "reverse", "shift", "sort", "splice", "unshift"], function(n) {
  var e = Mc[n];
  ht.prototype[n] = function() {
    var t = this._wrapped;
    return t != null && (e.apply(t, arguments), (n === "shift" || n === "splice") && t.length === 0 && delete t[0]), Og(this, t);
  };
});
ri(["concat", "join", "slice"], function(n) {
  var e = Mc[n];
  ht.prototype[n] = function() {
    var t = this._wrapped;
    return t != null && (t = e.apply(t, arguments)), Og(this, t);
  };
});
const W6 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  VERSION: Qm,
  after: Jw,
  all: ac,
  allKeys: Ia,
  any: sc,
  assign: ba,
  before: Tg,
  bind: xg,
  bindAll: $w,
  chain: Hw,
  chunk: CE,
  clone: kw,
  collect: Li,
  compact: vE,
  compose: Zw,
  constant: sg,
  contains: Fn,
  countBy: pE,
  create: Aw,
  debounce: Yw,
  default: ht,
  defaults: mg,
  defer: Xw,
  delay: _g,
  detect: Gs,
  difference: Rg,
  drop: Ir,
  each: ri,
  escape: Mw,
  every: ac,
  extend: pg,
  extendOwn: ba,
  filter: Ji,
  find: Gs,
  findIndex: zc,
  findKey: wg,
  findLastIndex: Eg,
  findWhere: rE,
  first: oa,
  flatten: xE,
  foldl: sa,
  foldr: rc,
  forEach: ri,
  functions: $s,
  get: yg,
  groupBy: fE,
  has: Uw,
  head: oa,
  identity: qc,
  include: Fn,
  includes: Fn,
  indexBy: hE,
  indexOf: Sg,
  initial: Ug,
  inject: sa,
  intersection: wE,
  invert: fg,
  invoke: oE,
  isArguments: jc,
  isArray: sr,
  isArrayBuffer: ig,
  isBoolean: eg,
  isDataView: zs,
  isDate: sw,
  isElement: aw,
  isEmpty: gw,
  isEqual: yw,
  isError: uw,
  isFinite: fw,
  isFunction: Yt,
  isMap: Tw,
  isMatch: ug,
  isNaN: ag,
  isNull: rw,
  isNumber: tg,
  isObject: ar,
  isRegExp: ow,
  isSet: Ew,
  isString: Bc,
  isSymbol: ng,
  isTypedArray: og,
  isUndefined: Jm,
  isWeakMap: ww,
  isWeakSet: Dw,
  iteratee: Vc,
  keys: Bt,
  last: yE,
  lastIndexOf: iE,
  map: Li,
  mapObject: Ow,
  matcher: Fr,
  matches: Fr,
  max: Cg,
  memoize: Gw,
  methods: $s,
  min: cE,
  mixin: Lg,
  negate: Hc,
  noop: vg,
  now: ya,
  object: DE,
  omit: bE,
  once: eE,
  pairs: Sw,
  partial: qr,
  partition: mE,
  pick: Ig,
  pluck: $c,
  property: Wc,
  propertyOf: Lw,
  random: ic,
  range: SE,
  reduce: sa,
  reduceRight: rc,
  reject: sE,
  rest: Ir,
  restArguments: ln,
  result: Ww,
  sample: kg,
  select: Ji,
  shuffle: lE,
  size: gE,
  some: sc,
  sortBy: dE,
  sortedIndex: Dg,
  tail: Ir,
  take: oa,
  tap: Iw,
  template: qw,
  templateSettings: jw,
  throttle: Kw,
  times: Pw,
  toArray: Ag,
  toPath: gg,
  transpose: Ks,
  unescape: Bw,
  union: TE,
  uniq: Xs,
  unique: Xs,
  uniqueId: Vw,
  unzip: Ks,
  values: jr,
  where: uE,
  without: _E,
  wrap: Qw,
  zip: EE
}, Symbol.toStringTag, { value: "Module" }));
var om = Lg(W6);
om._ = om;
const V6 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  VERSION: Qm,
  after: Jw,
  all: ac,
  allKeys: Ia,
  any: sc,
  assign: ba,
  before: Tg,
  bind: xg,
  bindAll: $w,
  chain: Hw,
  chunk: CE,
  clone: kw,
  collect: Li,
  compact: vE,
  compose: Zw,
  constant: sg,
  contains: Fn,
  countBy: pE,
  create: Aw,
  debounce: Yw,
  default: om,
  defaults: mg,
  defer: Xw,
  delay: _g,
  detect: Gs,
  difference: Rg,
  drop: Ir,
  each: ri,
  escape: Mw,
  every: ac,
  extend: pg,
  extendOwn: ba,
  filter: Ji,
  find: Gs,
  findIndex: zc,
  findKey: wg,
  findLastIndex: Eg,
  findWhere: rE,
  first: oa,
  flatten: xE,
  foldl: sa,
  foldr: rc,
  forEach: ri,
  functions: $s,
  get: yg,
  groupBy: fE,
  has: Uw,
  head: oa,
  identity: qc,
  include: Fn,
  includes: Fn,
  indexBy: hE,
  indexOf: Sg,
  initial: Ug,
  inject: sa,
  intersection: wE,
  invert: fg,
  invoke: oE,
  isArguments: jc,
  isArray: sr,
  isArrayBuffer: ig,
  isBoolean: eg,
  isDataView: zs,
  isDate: sw,
  isElement: aw,
  isEmpty: gw,
  isEqual: yw,
  isError: uw,
  isFinite: fw,
  isFunction: Yt,
  isMap: Tw,
  isMatch: ug,
  isNaN: ag,
  isNull: rw,
  isNumber: tg,
  isObject: ar,
  isRegExp: ow,
  isSet: Ew,
  isString: Bc,
  isSymbol: ng,
  isTypedArray: og,
  isUndefined: Jm,
  isWeakMap: ww,
  isWeakSet: Dw,
  iteratee: Vc,
  keys: Bt,
  last: yE,
  lastIndexOf: iE,
  map: Li,
  mapObject: Ow,
  matcher: Fr,
  matches: Fr,
  max: Cg,
  memoize: Gw,
  methods: $s,
  min: cE,
  mixin: Lg,
  negate: Hc,
  noop: vg,
  now: ya,
  object: DE,
  omit: bE,
  once: eE,
  pairs: Sw,
  partial: qr,
  partition: mE,
  pick: Ig,
  pluck: $c,
  property: Wc,
  propertyOf: Lw,
  random: ic,
  range: SE,
  reduce: sa,
  reduceRight: rc,
  reject: sE,
  rest: Ir,
  restArguments: ln,
  result: Ww,
  sample: kg,
  select: Ji,
  shuffle: lE,
  size: gE,
  some: sc,
  sortBy: dE,
  sortedIndex: Dg,
  tail: Ir,
  take: oa,
  tap: Iw,
  template: qw,
  templateSettings: jw,
  throttle: Kw,
  times: Pw,
  toArray: Ag,
  toPath: gg,
  transpose: Ks,
  unescape: Bw,
  union: TE,
  uniq: Xs,
  unique: Xs,
  uniqueId: Vw,
  unzip: Ks,
  values: jr,
  where: uE,
  without: _E,
  wrap: Qw,
  zip: EE
}, Symbol.toStringTag, { value: "Module" })), Pt = /* @__PURE__ */ kc(V6);
var Jo = {}, On = {}, Cf = { exports: {} }, eu = { exports: {} }, Vv;
function Ua() {
  if (Vv) return eu.exports;
  Vv = 1;
  var n = /* @__PURE__ */ (function() {
    return this === void 0;
  })();
  if (n)
    eu.exports = {
      freeze: Object.freeze,
      defineProperty: Object.defineProperty,
      getDescriptor: Object.getOwnPropertyDescriptor,
      keys: Object.keys,
      names: Object.getOwnPropertyNames,
      getPrototypeOf: Object.getPrototypeOf,
      isArray: Array.isArray,
      isES5: n,
      propertyIsWritable: function(l, h) {
        var f = Object.getOwnPropertyDescriptor(l, h);
        return !!(!f || f.writable || f.set);
      }
    };
  else {
    var e = {}.hasOwnProperty, t = {}.toString, i = {}.constructor.prototype, r = function(l) {
      var h = [];
      for (var f in l)
        e.call(l, f) && h.push(f);
      return h;
    }, a = function(l, h) {
      return { value: l[h] };
    }, s = function(l, h, f) {
      return l[h] = f.value, l;
    }, o = function(l) {
      return l;
    }, u = function(l) {
      try {
        return Object(l).constructor.prototype;
      } catch {
        return i;
      }
    }, c = function(l) {
      try {
        return t.call(l) === "[object Array]";
      } catch {
        return !1;
      }
    };
    eu.exports = {
      isArray: c,
      keys: r,
      names: r,
      defineProperty: s,
      getDescriptor: a,
      freeze: o,
      getPrototypeOf: u,
      isES5: n,
      propertyIsWritable: function() {
        return !0;
      }
    };
  }
  return eu.exports;
}
var os, Hv;
function Tt() {
  if (Hv) return os;
  Hv = 1;
  var n = Ua(), e = typeof navigator > "u", t = { e: {} }, i, r = typeof self < "u" ? self : typeof window < "u" ? window : typeof At < "u" ? At : os !== void 0 ? os : null;
  function a() {
    try {
      var K = i;
      return i = null, K.apply(this, arguments);
    } catch (ie) {
      return t.e = ie, t;
    }
  }
  function s(K) {
    return i = K, a;
  }
  var o = function(K, ie) {
    var ge = {}.hasOwnProperty;
    function pe() {
      this.constructor = K, this.constructor$ = ie;
      for (var ce in ie.prototype)
        ge.call(ie.prototype, ce) && ce.charAt(ce.length - 1) !== "$" && (this[ce + "$"] = ie.prototype[ce]);
    }
    return pe.prototype = ie.prototype, K.prototype = new pe(), K.prototype;
  };
  function u(K) {
    return K == null || K === !0 || K === !1 || typeof K == "string" || typeof K == "number";
  }
  function c(K) {
    return typeof K == "function" || typeof K == "object" && K !== null;
  }
  function l(K) {
    return u(K) ? new Error(T(K)) : K;
  }
  function h(K, ie) {
    var ge = K.length, pe = new Array(ge + 1), ce;
    for (ce = 0; ce < ge; ++ce)
      pe[ce] = K[ce];
    return pe[ce] = ie, pe;
  }
  function f(K, ie, ge) {
    if (n.isES5) {
      var pe = Object.getOwnPropertyDescriptor(K, ie);
      if (pe != null)
        return pe.get == null && pe.set == null ? pe.value : ge;
    } else
      return {}.hasOwnProperty.call(K, ie) ? K[ie] : void 0;
  }
  function d(K, ie, ge) {
    if (u(K)) return K;
    var pe = {
      value: ge,
      configurable: !0,
      enumerable: !1,
      writable: !0
    };
    return n.defineProperty(K, ie, pe), K;
  }
  function y(K) {
    throw K;
  }
  var m = (function() {
    var K = [
      Array.prototype,
      Object.prototype,
      Function.prototype
    ], ie = function(ce) {
      for (var oe = 0; oe < K.length; ++oe)
        if (K[oe] === ce)
          return !0;
      return !1;
    };
    if (n.isES5) {
      var ge = Object.getOwnPropertyNames;
      return function(ce) {
        for (var oe = [], De = /* @__PURE__ */ Object.create(null); ce != null && !ie(ce); ) {
          var Re;
          try {
            Re = ge(ce);
          } catch {
            return oe;
          }
          for (var Me = 0; Me < Re.length; ++Me) {
            var F = Re[Me];
            if (!De[F]) {
              De[F] = !0;
              var P = Object.getOwnPropertyDescriptor(ce, F);
              P != null && P.get == null && P.set == null && oe.push(F);
            }
          }
          ce = n.getPrototypeOf(ce);
        }
        return oe;
      };
    } else {
      var pe = {}.hasOwnProperty;
      return function(ce) {
        if (ie(ce)) return [];
        var oe = [];
        e: for (var De in ce)
          if (pe.call(ce, De))
            oe.push(De);
          else {
            for (var Re = 0; Re < K.length; ++Re)
              if (pe.call(K[Re], De))
                continue e;
            oe.push(De);
          }
        return oe;
      };
    }
  })(), b = /this\s*\.\s*\S+\s*=/;
  function p(K) {
    try {
      if (typeof K == "function") {
        var ie = n.names(K.prototype), ge = n.isES5 && ie.length > 1, pe = ie.length > 0 && !(ie.length === 1 && ie[0] === "constructor"), ce = b.test(K + "") && n.names(K).length > 0;
        if (ge || pe || ce)
          return !0;
      }
      return !1;
    } catch {
      return !1;
    }
  }
  function g(K) {
    return K;
  }
  var v = /^[a-z$_][a-z$_0-9]*$/i;
  function _(K) {
    return v.test(K);
  }
  function x(K, ie, ge) {
    for (var pe = new Array(K), ce = 0; ce < K; ++ce)
      pe[ce] = ie + ce + ge;
    return pe;
  }
  function T(K) {
    try {
      return K + "";
    } catch {
      return "[no string representation]";
    }
  }
  function E(K) {
    return K !== null && typeof K == "object" && typeof K.message == "string" && typeof K.name == "string";
  }
  function U(K) {
    try {
      d(K, "isOperational", !0);
    } catch {
    }
  }
  function D(K) {
    return K == null ? !1 : K instanceof Error.__BluebirdErrorTypes__.OperationalError || K.isOperational === !0;
  }
  function L(K) {
    return E(K) && n.propertyIsWritable(K, "stack");
  }
  var j = (function() {
    return "stack" in new Error() ? function(K) {
      return L(K) ? K : new Error(T(K));
    } : function(K) {
      if (L(K)) return K;
      try {
        throw new Error(T(K));
      } catch (ie) {
        return ie;
      }
    };
  })();
  function C(K) {
    return {}.toString.call(K);
  }
  function k(K, ie, ge) {
    for (var pe = n.names(K), ce = 0; ce < pe.length; ++ce) {
      var oe = pe[ce];
      if (ge(oe))
        try {
          n.defineProperty(ie, oe, n.getDescriptor(K, oe));
        } catch {
        }
    }
  }
  var I = function(K) {
    return n.isArray(K) ? K : null;
  };
  if (typeof Symbol < "u" && Symbol.iterator) {
    var $ = typeof Array.from == "function" ? function(K) {
      return Array.from(K);
    } : function(K) {
      for (var ie = [], ge = K[Symbol.iterator](), pe; !(pe = ge.next()).done; )
        ie.push(pe.value);
      return ie;
    };
    I = function(K) {
      return n.isArray(K) ? K : K != null && typeof K[Symbol.iterator] == "function" ? $(K) : null;
    };
  }
  var W = typeof process < "u" && C(process).toLowerCase() === "[object process]", B = typeof process < "u" && typeof process.env < "u";
  function z(K) {
    return B ? process.env[K] : void 0;
  }
  function q() {
    if (typeof Promise == "function")
      try {
        var K = new Promise(function() {
        });
        if ({}.toString.call(K) === "[object Promise]")
          return Promise;
      } catch {
      }
  }
  function Y(K, ie) {
    return K.bind(ie);
  }
  var H = {
    isClass: p,
    isIdentifier: _,
    inheritedDataKeys: m,
    getDataPropertyOrDefault: f,
    thrower: y,
    isArray: n.isArray,
    asArray: I,
    notEnumerableProp: d,
    isPrimitive: u,
    isObject: c,
    isError: E,
    canEvaluate: e,
    errorObj: t,
    tryCatch: s,
    inherits: o,
    withAppended: h,
    maybeWrapAsError: l,
    toFastProperties: g,
    filledRange: x,
    toString: T,
    canAttachTrace: L,
    ensureErrorObject: j,
    originatesFromRejection: D,
    markAsOriginatingFromRejection: U,
    classString: C,
    copyDescriptors: k,
    hasDevTools: typeof chrome < "u" && chrome && typeof chrome.loadTimes == "function",
    isNode: W,
    hasEnvVariables: B,
    env: z,
    global: r,
    getNativePromise: q,
    domainBind: Y
  };
  H.isRecentNode = H.isNode && (function() {
    var K = process.versions.node.split(".").map(Number);
    return K[0] === 0 && K[1] > 10 || K[0] > 0;
  })(), H.isNode && H.toFastProperties(process);
  try {
    throw new Error();
  } catch (K) {
    H.lastLineError = K;
  }
  return os = H, os;
}
var tu = { exports: {} }, Af, zv;
function H6() {
  if (zv) return Af;
  zv = 1;
  var n = Tt(), e, t = function() {
    throw new Error(`No async scheduler available

    See http://goo.gl/MqrFmX
`);
  }, i = n.getNativePromise();
  if (n.isNode && typeof MutationObserver > "u") {
    var r = At.setImmediate, a = process.nextTick;
    e = n.isRecentNode ? function(o) {
      r.call(At, o);
    } : function(o) {
      a.call(process, o);
    };
  } else if (typeof i == "function" && typeof i.resolve == "function") {
    var s = i.resolve();
    e = function(o) {
      s.then(o);
    };
  } else typeof MutationObserver < "u" && !(typeof window < "u" && window.navigator && (window.navigator.standalone || window.cordova)) ? e = (function() {
    var o = document.createElement("div"), u = { attributes: !0 }, c = !1, l = document.createElement("div"), h = new MutationObserver(function() {
      o.classList.toggle("foo"), c = !1;
    });
    h.observe(l, u);
    var f = function() {
      c || (c = !0, l.classList.toggle("foo"));
    };
    return function(y) {
      var m = new MutationObserver(function() {
        m.disconnect(), y();
      });
      m.observe(o, u), f();
    };
  })() : typeof setImmediate < "u" ? e = function(o) {
    setImmediate(o);
  } : typeof setTimeout < "u" ? e = function(o) {
    setTimeout(o, 0);
  } : e = t;
  return Af = e, Af;
}
var kf, $v;
function z6() {
  if ($v) return kf;
  $v = 1;
  function n(t, i, r, a, s) {
    for (var o = 0; o < s; ++o)
      r[o + a] = t[o + i], t[o + i] = void 0;
  }
  function e(t) {
    this._capacity = t, this._length = 0, this._front = 0;
  }
  return e.prototype._willBeOverCapacity = function(t) {
    return this._capacity < t;
  }, e.prototype._pushOne = function(t) {
    var i = this.length();
    this._checkCapacity(i + 1);
    var r = this._front + i & this._capacity - 1;
    this[r] = t, this._length = i + 1;
  }, e.prototype.push = function(t, i, r) {
    var a = this.length() + 3;
    if (this._willBeOverCapacity(a)) {
      this._pushOne(t), this._pushOne(i), this._pushOne(r);
      return;
    }
    var s = this._front + a - 3;
    this._checkCapacity(a);
    var o = this._capacity - 1;
    this[s + 0 & o] = t, this[s + 1 & o] = i, this[s + 2 & o] = r, this._length = a;
  }, e.prototype.shift = function() {
    var t = this._front, i = this[t];
    return this[t] = void 0, this._front = t + 1 & this._capacity - 1, this._length--, i;
  }, e.prototype.length = function() {
    return this._length;
  }, e.prototype._checkCapacity = function(t) {
    this._capacity < t && this._resizeTo(this._capacity << 1);
  }, e.prototype._resizeTo = function(t) {
    var i = this._capacity;
    this._capacity = t;
    var r = this._front, a = this._length, s = r + a & i - 1;
    n(this, 0, this, i, s);
  }, kf = e, kf;
}
var Gv;
function $6() {
  if (Gv) return tu.exports;
  Gv = 1;
  var n;
  try {
    throw new Error();
  } catch (u) {
    n = u;
  }
  var e = H6(), t = z6(), i = Tt();
  function r() {
    this._customScheduler = !1, this._isTickUsed = !1, this._lateQueue = new t(16), this._normalQueue = new t(16), this._haveDrainedQueues = !1, this._trampolineEnabled = !0;
    var u = this;
    this.drainQueues = function() {
      u._drainQueues();
    }, this._schedule = e;
  }
  r.prototype.setScheduler = function(u) {
    var c = this._schedule;
    return this._schedule = u, this._customScheduler = !0, c;
  }, r.prototype.hasCustomScheduler = function() {
    return this._customScheduler;
  }, r.prototype.enableTrampoline = function() {
    this._trampolineEnabled = !0;
  }, r.prototype.disableTrampolineIfNecessary = function() {
    i.hasDevTools && (this._trampolineEnabled = !1);
  }, r.prototype.haveItemsQueued = function() {
    return this._isTickUsed || this._haveDrainedQueues;
  }, r.prototype.fatalError = function(u, c) {
    c ? (process.stderr.write("Fatal " + (u instanceof Error ? u.stack : u) + `
`), process.exit(2)) : this.throwLater(u);
  }, r.prototype.throwLater = function(u, c) {
    if (arguments.length === 1 && (c = u, u = function() {
      throw c;
    }), typeof setTimeout < "u")
      setTimeout(function() {
        u(c);
      }, 0);
    else try {
      this._schedule(function() {
        u(c);
      });
    } catch {
      throw new Error(`No async scheduler available

    See http://goo.gl/MqrFmX
`);
    }
  };
  function a(u, c, l) {
    this._lateQueue.push(u, c, l), this._queueTick();
  }
  function s(u, c, l) {
    this._normalQueue.push(u, c, l), this._queueTick();
  }
  function o(u) {
    this._normalQueue._pushOne(u), this._queueTick();
  }
  return i.hasDevTools ? (r.prototype.invokeLater = function(u, c, l) {
    this._trampolineEnabled ? a.call(this, u, c, l) : this._schedule(function() {
      setTimeout(function() {
        u.call(c, l);
      }, 100);
    });
  }, r.prototype.invoke = function(u, c, l) {
    this._trampolineEnabled ? s.call(this, u, c, l) : this._schedule(function() {
      u.call(c, l);
    });
  }, r.prototype.settlePromises = function(u) {
    this._trampolineEnabled ? o.call(this, u) : this._schedule(function() {
      u._settlePromises();
    });
  }) : (r.prototype.invokeLater = a, r.prototype.invoke = s, r.prototype.settlePromises = o), r.prototype._drainQueue = function(u) {
    for (; u.length() > 0; ) {
      var c = u.shift();
      if (typeof c != "function") {
        c._settlePromises();
        continue;
      }
      var l = u.shift(), h = u.shift();
      c.call(l, h);
    }
  }, r.prototype._drainQueues = function() {
    this._drainQueue(this._normalQueue), this._reset(), this._haveDrainedQueues = !0, this._drainQueue(this._lateQueue);
  }, r.prototype._queueTick = function() {
    this._isTickUsed || (this._isTickUsed = !0, this._schedule(this.drainQueues));
  }, r.prototype._reset = function() {
    this._isTickUsed = !1;
  }, tu.exports = r, tu.exports.firstLineError = n, tu.exports;
}
var If, Xv;
function er() {
  if (Xv) return If;
  Xv = 1;
  var n = Ua(), e = n.freeze, t = Tt(), i = t.inherits, r = t.notEnumerableProp;
  function a(p, g) {
    function v(_) {
      if (!(this instanceof v)) return new v(_);
      r(
        this,
        "message",
        typeof _ == "string" ? _ : g
      ), r(this, "name", p), Error.captureStackTrace ? Error.captureStackTrace(this, this.constructor) : Error.call(this);
    }
    return i(v, Error), v;
  }
  var s, o, u = a("Warning", "warning"), c = a("CancellationError", "cancellation error"), l = a("TimeoutError", "timeout error"), h = a("AggregateError", "aggregate error");
  try {
    s = TypeError, o = RangeError;
  } catch {
    s = a("TypeError", "type error"), o = a("RangeError", "range error");
  }
  for (var f = "join pop push shift unshift slice filter forEach some every map indexOf lastIndexOf reduce reduceRight sort reverse".split(" "), d = 0; d < f.length; ++d)
    typeof Array.prototype[f[d]] == "function" && (h.prototype[f[d]] = Array.prototype[f[d]]);
  n.defineProperty(h.prototype, "length", {
    value: 0,
    configurable: !1,
    writable: !0,
    enumerable: !0
  }), h.prototype.isOperational = !0;
  var y = 0;
  h.prototype.toString = function() {
    var p = Array(y * 4 + 1).join(" "), g = `
` + p + `AggregateError of:
`;
    y++, p = Array(y * 4 + 1).join(" ");
    for (var v = 0; v < this.length; ++v) {
      for (var _ = this[v] === this ? "[Circular AggregateError]" : this[v] + "", x = _.split(`
`), T = 0; T < x.length; ++T)
        x[T] = p + x[T];
      _ = x.join(`
`), g += _ + `
`;
    }
    return y--, g;
  };
  function m(p) {
    if (!(this instanceof m))
      return new m(p);
    r(this, "name", "OperationalError"), r(this, "message", p), this.cause = p, this.isOperational = !0, p instanceof Error ? (r(this, "message", p.message), r(this, "stack", p.stack)) : Error.captureStackTrace && Error.captureStackTrace(this, this.constructor);
  }
  i(m, Error);
  var b = Error.__BluebirdErrorTypes__;
  return b || (b = e({
    CancellationError: c,
    TimeoutError: l,
    OperationalError: m,
    RejectionError: m,
    AggregateError: h
  }), n.defineProperty(Error, "__BluebirdErrorTypes__", {
    value: b,
    writable: !1,
    enumerable: !1,
    configurable: !1
  })), If = {
    Error,
    TypeError: s,
    RangeError: o,
    CancellationError: b.CancellationError,
    OperationalError: b.OperationalError,
    TimeoutError: b.TimeoutError,
    AggregateError: b.AggregateError,
    Warning: u
  }, If;
}
var Uf, Kv;
function G6() {
  return Kv || (Kv = 1, Uf = function(n, e) {
    var t = Tt(), i = t.errorObj, r = t.isObject;
    function a(h, f) {
      if (r(h)) {
        if (h instanceof n) return h;
        var d = o(h);
        if (d === i) {
          f && f._pushContext();
          var y = n.reject(d.e);
          return f && f._popContext(), y;
        } else if (typeof d == "function") {
          if (c(h)) {
            var y = new n(e);
            return h._then(
              y._fulfill,
              y._reject,
              void 0,
              y,
              null
            ), y;
          }
          return l(h, d, f);
        }
      }
      return h;
    }
    function s(h) {
      return h.then;
    }
    function o(h) {
      try {
        return s(h);
      } catch (f) {
        return i.e = f, i;
      }
    }
    var u = {}.hasOwnProperty;
    function c(h) {
      try {
        return u.call(h, "_promise0");
      } catch {
        return !1;
      }
    }
    function l(h, f, d) {
      var y = new n(e), m = y;
      d && d._pushContext(), y._captureStackTrace(), d && d._popContext();
      var b = !0, p = t.tryCatch(f).call(h, g, v);
      b = !1, y && p === i && (y._rejectCallback(p.e, !0, !0), y = null);
      function g(_) {
        y && (y._resolveCallback(_), y = null);
      }
      function v(_) {
        y && (y._rejectCallback(_, b, !0), y = null);
      }
      return m;
    }
    return a;
  }), Uf;
}
var Rf, Yv;
function X6() {
  return Yv || (Yv = 1, Rf = function(n, e, t, i, r) {
    var a = Tt();
    a.isArray;
    function s(u) {
      switch (u) {
        case -2:
          return [];
        case -3:
          return {};
      }
    }
    function o(u) {
      var c = this._promise = new n(e);
      u instanceof n && c._propagateFrom(u, 3), c._setOnCancel(this), this._values = u, this._length = 0, this._totalResolved = 0, this._init(void 0, -2);
    }
    return a.inherits(o, r), o.prototype.length = function() {
      return this._length;
    }, o.prototype.promise = function() {
      return this._promise;
    }, o.prototype._init = function u(c, l) {
      var h = t(this._values, this._promise);
      if (h instanceof n) {
        h = h._target();
        var f = h._bitField;
        if (this._values = h, (f & 50397184) === 0)
          return this._promise._setAsyncGuaranteed(), h._then(
            u,
            this._reject,
            void 0,
            this,
            l
          );
        if ((f & 33554432) !== 0)
          h = h._value();
        else return (f & 16777216) !== 0 ? this._reject(h._reason()) : this._cancel();
      }
      if (h = a.asArray(h), h === null) {
        var d = i(
          "expecting an array or an iterable object but got " + a.classString(h)
        ).reason();
        this._promise._rejectCallback(d, !1);
        return;
      }
      if (h.length === 0) {
        l === -5 ? this._resolveEmptyArray() : this._resolve(s(l));
        return;
      }
      this._iterate(h);
    }, o.prototype._iterate = function(u) {
      var c = this.getActualLength(u.length);
      this._length = c, this._values = this.shouldCopyValues() ? new Array(c) : this._values;
      for (var l = this._promise, h = !1, f = null, d = 0; d < c; ++d) {
        var y = t(u[d], l);
        y instanceof n ? (y = y._target(), f = y._bitField) : f = null, h ? f !== null && y.suppressUnhandledRejections() : f !== null ? (f & 50397184) === 0 ? (y._proxy(this, d), this._values[d] = y) : (f & 33554432) !== 0 ? h = this._promiseFulfilled(y._value(), d) : (f & 16777216) !== 0 ? h = this._promiseRejected(y._reason(), d) : h = this._promiseCancelled(d) : h = this._promiseFulfilled(y, d);
      }
      h || l._setAsyncGuaranteed();
    }, o.prototype._isResolved = function() {
      return this._values === null;
    }, o.prototype._resolve = function(u) {
      this._values = null, this._promise._fulfill(u);
    }, o.prototype._cancel = function() {
      this._isResolved() || !this._promise._isCancellable() || (this._values = null, this._promise._cancel());
    }, o.prototype._reject = function(u) {
      this._values = null, this._promise._rejectCallback(u, !1);
    }, o.prototype._promiseFulfilled = function(u, c) {
      this._values[c] = u;
      var l = ++this._totalResolved;
      return l >= this._length ? (this._resolve(this._values), !0) : !1;
    }, o.prototype._promiseCancelled = function() {
      return this._cancel(), !0;
    }, o.prototype._promiseRejected = function(u) {
      return this._totalResolved++, this._reject(u), !0;
    }, o.prototype._resultCancelled = function() {
      if (!this._isResolved()) {
        var u = this._values;
        if (this._cancel(), u instanceof n)
          u.cancel();
        else
          for (var c = 0; c < u.length; ++c)
            u[c] instanceof n && u[c].cancel();
      }
    }, o.prototype.shouldCopyValues = function() {
      return !0;
    }, o.prototype.getActualLength = function(u) {
      return u;
    }, o;
  }), Rf;
}
var Of, Qv;
function K6() {
  return Qv || (Qv = 1, Of = function(n) {
    var e = !1, t = [];
    n.prototype._promiseCreated = function() {
    }, n.prototype._pushContext = function() {
    }, n.prototype._popContext = function() {
      return null;
    }, n._peekContext = n.prototype._peekContext = function() {
    };
    function i() {
      this._trace = new i.CapturedTrace(a());
    }
    i.prototype._pushContext = function() {
      this._trace !== void 0 && (this._trace._promiseCreated = null, t.push(this._trace));
    }, i.prototype._popContext = function() {
      if (this._trace !== void 0) {
        var s = t.pop(), o = s._promiseCreated;
        return s._promiseCreated = null, o;
      }
      return null;
    };
    function r() {
      if (e) return new i();
    }
    function a() {
      var s = t.length - 1;
      if (s >= 0)
        return t[s];
    }
    return i.CapturedTrace = null, i.create = r, i.deactivateLongStackTraces = function() {
    }, i.activateLongStackTraces = function() {
      var s = n.prototype._pushContext, o = n.prototype._popContext, u = n._peekContext, c = n.prototype._peekContext, l = n.prototype._promiseCreated;
      i.deactivateLongStackTraces = function() {
        n.prototype._pushContext = s, n.prototype._popContext = o, n._peekContext = u, n.prototype._peekContext = c, n.prototype._promiseCreated = l, e = !1;
      }, e = !0, n.prototype._pushContext = i.prototype._pushContext, n.prototype._popContext = i.prototype._popContext, n._peekContext = n.prototype._peekContext = a, n.prototype._promiseCreated = function() {
        var h = this._peekContext();
        h && h._promiseCreated == null && (h._promiseCreated = this);
      };
    }, i;
  }), Of;
}
var Lf, Zv;
function Y6() {
  return Zv || (Zv = 1, Lf = function(n, e) {
    var t = n._getDomain, i = n._async, r = er().Warning, a = Tt(), s = a.canAttachTrace, o, u, c = /[\\\/]bluebird[\\\/]js[\\\/](release|debug|instrumented)/, l = /\((?:timers\.js):\d+:\d+\)/, h = /[\/<\(](.+?):(\d+):(\d+)\)?\s*$/, f = null, d = null, y = !1, m, b = !!(a.env("BLUEBIRD_DEBUG") != 0 && (a.env("BLUEBIRD_DEBUG") || a.env("NODE_ENV") === "development")), p = !!(a.env("BLUEBIRD_WARNINGS") != 0 && (b || a.env("BLUEBIRD_WARNINGS"))), g = !!(a.env("BLUEBIRD_LONG_STACK_TRACES") != 0 && (b || a.env("BLUEBIRD_LONG_STACK_TRACES"))), v = a.env("BLUEBIRD_W_FORGOTTEN_RETURN") != 0 && (p || !!a.env("BLUEBIRD_W_FORGOTTEN_RETURN"));
    n.prototype.suppressUnhandledRejections = function() {
      var le = this._target();
      le._bitField = le._bitField & -1048577 | 524288;
    }, n.prototype._ensurePossibleRejectionHandled = function() {
      (this._bitField & 524288) === 0 && (this._setRejectionIsUnhandled(), i.invokeLater(this._notifyUnhandledRejection, this, void 0));
    }, n.prototype._notifyUnhandledRejectionIsHandled = function() {
      P(
        "rejectionHandled",
        o,
        void 0,
        this
      );
    }, n.prototype._setReturnedNonUndefined = function() {
      this._bitField = this._bitField | 268435456;
    }, n.prototype._returnedNonUndefined = function() {
      return (this._bitField & 268435456) !== 0;
    }, n.prototype._notifyUnhandledRejection = function() {
      if (this._isRejectionUnhandled()) {
        var le = this._settledValue();
        this._setUnhandledRejectionIsNotified(), P(
          "unhandledRejection",
          u,
          le,
          this
        );
      }
    }, n.prototype._setUnhandledRejectionIsNotified = function() {
      this._bitField = this._bitField | 262144;
    }, n.prototype._unsetUnhandledRejectionIsNotified = function() {
      this._bitField = this._bitField & -262145;
    }, n.prototype._isUnhandledRejectionNotified = function() {
      return (this._bitField & 262144) > 0;
    }, n.prototype._setRejectionIsUnhandled = function() {
      this._bitField = this._bitField | 1048576;
    }, n.prototype._unsetRejectionIsUnhandled = function() {
      this._bitField = this._bitField & -1048577, this._isUnhandledRejectionNotified() && (this._unsetUnhandledRejectionIsNotified(), this._notifyUnhandledRejectionIsHandled());
    }, n.prototype._isRejectionUnhandled = function() {
      return (this._bitField & 1048576) > 0;
    }, n.prototype._warn = function(le, ye, we) {
      return ge(le, ye, we || this);
    }, n.onPossiblyUnhandledRejection = function(le) {
      var ye = t();
      u = typeof le == "function" ? ye === null ? le : a.domainBind(ye, le) : void 0;
    }, n.onUnhandledRejectionHandled = function(le) {
      var ye = t();
      o = typeof le == "function" ? ye === null ? le : a.domainBind(ye, le) : void 0;
    };
    var _ = function() {
    };
    n.longStackTraces = function() {
      if (i.haveItemsQueued() && !xe.longStackTraces)
        throw new Error(`cannot enable long stack traces after promises have been created

    See http://goo.gl/MqrFmX
`);
      if (!xe.longStackTraces && he()) {
        var le = n.prototype._captureStackTrace, ye = n.prototype._attachExtraTrace;
        xe.longStackTraces = !0, _ = function() {
          if (i.haveItemsQueued() && !xe.longStackTraces)
            throw new Error(`cannot enable long stack traces after promises have been created

    See http://goo.gl/MqrFmX
`);
          n.prototype._captureStackTrace = le, n.prototype._attachExtraTrace = ye, e.deactivateLongStackTraces(), i.enableTrampoline(), xe.longStackTraces = !1;
        }, n.prototype._captureStackTrace = Y, n.prototype._attachExtraTrace = H, e.activateLongStackTraces(), i.disableTrampolineIfNecessary();
      }
    }, n.hasLongStackTraces = function() {
      return xe.longStackTraces && he();
    };
    var x = (function() {
      try {
        if (typeof CustomEvent == "function") {
          var le = new CustomEvent("CustomEvent");
          return a.global.dispatchEvent(le), function(ye, we) {
            var Ue = new CustomEvent(ye.toLowerCase(), {
              detail: we,
              cancelable: !0
            });
            return !a.global.dispatchEvent(Ue);
          };
        } else if (typeof Event == "function") {
          var le = new Event("CustomEvent");
          return a.global.dispatchEvent(le), function(we, Ue) {
            var Q = new Event(we.toLowerCase(), {
              cancelable: !0
            });
            return Q.detail = Ue, !a.global.dispatchEvent(Q);
          };
        } else {
          var le = document.createEvent("CustomEvent");
          return le.initCustomEvent("testingtheevent", !1, !0, {}), a.global.dispatchEvent(le), function(we, Ue) {
            var Q = document.createEvent("CustomEvent");
            return Q.initCustomEvent(
              we.toLowerCase(),
              !1,
              !0,
              Ue
            ), !a.global.dispatchEvent(Q);
          };
        }
      } catch {
      }
      return function() {
        return !1;
      };
    })(), T = (function() {
      return a.isNode ? function() {
        return process.emit.apply(process, arguments);
      } : a.global ? function(le) {
        var ye = "on" + le.toLowerCase(), we = a.global[ye];
        return we ? (we.apply(a.global, [].slice.call(arguments, 1)), !0) : !1;
      } : function() {
        return !1;
      };
    })();
    function E(le, ye) {
      return { promise: ye };
    }
    var U = {
      promiseCreated: E,
      promiseFulfilled: E,
      promiseRejected: E,
      promiseResolved: E,
      promiseCancelled: E,
      promiseChained: function(le, ye, we) {
        return { promise: ye, child: we };
      },
      warning: function(le, ye) {
        return { warning: ye };
      },
      unhandledRejection: function(le, ye, we) {
        return { reason: ye, promise: we };
      },
      rejectionHandled: E
    }, D = function(le) {
      var ye = !1;
      try {
        ye = T.apply(null, arguments);
      } catch (Ue) {
        i.throwLater(Ue), ye = !0;
      }
      var we = !1;
      try {
        we = x(
          le,
          U[le].apply(null, arguments)
        );
      } catch (Ue) {
        i.throwLater(Ue), we = !0;
      }
      return we || ye;
    };
    n.config = function(le) {
      if (le = Object(le), "longStackTraces" in le && (le.longStackTraces ? n.longStackTraces() : !le.longStackTraces && n.hasLongStackTraces() && _()), "warnings" in le) {
        var ye = le.warnings;
        xe.warnings = !!ye, v = xe.warnings, a.isObject(ye) && "wForgottenReturn" in ye && (v = !!ye.wForgottenReturn);
      }
      if ("cancellation" in le && le.cancellation && !xe.cancellation) {
        if (i.haveItemsQueued())
          throw new Error(
            "cannot enable cancellation after promises are in use"
          );
        n.prototype._clearCancellationData = $, n.prototype._propagateFrom = W, n.prototype._onCancel = k, n.prototype._setOnCancel = I, n.prototype._attachCancellationCallback = C, n.prototype._execute = j, z = W, xe.cancellation = !0;
      }
      return "monitoring" in le && (le.monitoring && !xe.monitoring ? (xe.monitoring = !0, n.prototype._fireEvent = D) : !le.monitoring && xe.monitoring && (xe.monitoring = !1, n.prototype._fireEvent = L)), n;
    };
    function L() {
      return !1;
    }
    n.prototype._fireEvent = L, n.prototype._execute = function(le, ye, we) {
      try {
        le(ye, we);
      } catch (Ue) {
        return Ue;
      }
    }, n.prototype._onCancel = function() {
    }, n.prototype._setOnCancel = function(le) {
    }, n.prototype._attachCancellationCallback = function(le) {
    }, n.prototype._captureStackTrace = function() {
    }, n.prototype._attachExtraTrace = function() {
    }, n.prototype._clearCancellationData = function() {
    }, n.prototype._propagateFrom = function(le, ye) {
    };
    function j(le, ye, we) {
      var Ue = this;
      try {
        le(ye, we, function(Q) {
          if (typeof Q != "function")
            throw new TypeError("onCancel must be a function, got: " + a.toString(Q));
          Ue._attachCancellationCallback(Q);
        });
      } catch (Q) {
        return Q;
      }
    }
    function C(le) {
      if (!this._isCancellable()) return this;
      var ye = this._onCancel();
      ye !== void 0 ? a.isArray(ye) ? ye.push(le) : this._setOnCancel([ye, le]) : this._setOnCancel(le);
    }
    function k() {
      return this._onCancelField;
    }
    function I(le) {
      this._onCancelField = le;
    }
    function $() {
      this._cancellationParent = void 0, this._onCancelField = void 0;
    }
    function W(le, ye) {
      if ((ye & 1) !== 0) {
        this._cancellationParent = le;
        var we = le._branchesRemainingToCancel;
        we === void 0 && (we = 0), le._branchesRemainingToCancel = we + 1;
      }
      (ye & 2) !== 0 && le._isBound() && this._setBoundTo(le._boundTo);
    }
    function B(le, ye) {
      (ye & 2) !== 0 && le._isBound() && this._setBoundTo(le._boundTo);
    }
    var z = B;
    function q() {
      var le = this._boundTo;
      return le !== void 0 && le instanceof n ? le.isFulfilled() ? le.value() : void 0 : le;
    }
    function Y() {
      this._trace = new Ee(this._peekContext());
    }
    function H(le, ye) {
      if (s(le)) {
        var we = this._trace;
        if (we !== void 0 && ye && (we = we._parent), we !== void 0)
          we.attachExtraTrace(le);
        else if (!le.__stackCleaned__) {
          var Ue = Me(le);
          a.notEnumerableProp(
            le,
            "stack",
            Ue.message + `
` + Ue.stack.join(`
`)
          ), a.notEnumerableProp(le, "__stackCleaned__", !0);
        }
      }
    }
    function K(le, ye, we, Ue, Q) {
      if (le === void 0 && ye !== null && v) {
        if (Q !== void 0 && Q._returnedNonUndefined() || (Ue._bitField & 65535) === 0) return;
        we && (we = we + " ");
        var M = "", N = "";
        if (ye._trace) {
          for (var Z = ye._trace.stack.split(`
`), de = De(Z), Te = de.length - 1; Te >= 0; --Te) {
            var Ie = de[Te];
            if (!l.test(Ie)) {
              var je = Ie.match(h);
              je && (M = "at " + je[1] + ":" + je[2] + ":" + je[3] + " ");
              break;
            }
          }
          if (de.length > 0) {
            for (var Ze = de[0], Te = 0; Te < Z.length; ++Te)
              if (Z[Te] === Ze) {
                Te > 0 && (N = `
` + Z[Te - 1]);
                break;
              }
          }
        }
        var Qe = "a promise was created in a " + we + "handler " + M + "but was not returned from it, see http://goo.gl/rRqMUw" + N;
        Ue._warn(Qe, !0, ye);
      }
    }
    function ie(le, ye) {
      var we = le + " is deprecated and will be removed in a future version.";
      return ye && (we += " Use " + ye + " instead."), ge(we);
    }
    function ge(le, ye, we) {
      if (xe.warnings) {
        var Ue = new r(le), Q;
        if (ye)
          we._attachExtraTrace(Ue);
        else if (xe.longStackTraces && (Q = n._peekContext()))
          Q.attachExtraTrace(Ue);
        else {
          var M = Me(Ue);
          Ue.stack = M.message + `
` + M.stack.join(`
`);
        }
        D("warning", Ue) || F(Ue, "", !0);
      }
    }
    function pe(le, ye) {
      for (var we = 0; we < ye.length - 1; ++we)
        ye[we].push("From previous event:"), ye[we] = ye[we].join(`
`);
      return we < ye.length && (ye[we] = ye[we].join(`
`)), le + `
` + ye.join(`
`);
    }
    function ce(le) {
      for (var ye = 0; ye < le.length; ++ye)
        (le[ye].length === 0 || ye + 1 < le.length && le[ye][0] === le[ye + 1][0]) && (le.splice(ye, 1), ye--);
    }
    function oe(le) {
      for (var ye = le[0], we = 1; we < le.length; ++we) {
        for (var Ue = le[we], Q = ye.length - 1, M = ye[Q], N = -1, Z = Ue.length - 1; Z >= 0; --Z)
          if (Ue[Z] === M) {
            N = Z;
            break;
          }
        for (var Z = N; Z >= 0; --Z) {
          var de = Ue[Z];
          if (ye[Q] === de)
            ye.pop(), Q--;
          else
            break;
        }
        ye = Ue;
      }
    }
    function De(le) {
      for (var ye = [], we = 0; we < le.length; ++we) {
        var Ue = le[we], Q = Ue === "    (No stack trace)" || f.test(Ue), M = Q && ae(Ue);
        Q && !M && (y && Ue.charAt(0) !== " " && (Ue = "    " + Ue), ye.push(Ue));
      }
      return ye;
    }
    function Re(le) {
      for (var ye = le.stack.replace(/\s+$/g, "").split(`
`), we = 0; we < ye.length; ++we) {
        var Ue = ye[we];
        if (Ue === "    (No stack trace)" || f.test(Ue))
          break;
      }
      return we > 0 && le.name != "SyntaxError" && (ye = ye.slice(we)), ye;
    }
    function Me(le) {
      var ye = le.stack, we = le.toString();
      return ye = typeof ye == "string" && ye.length > 0 ? Re(le) : ["    (No stack trace)"], {
        message: we,
        stack: le.name == "SyntaxError" ? ye : De(ye)
      };
    }
    function F(le, ye, we) {
      if (typeof console < "u") {
        var Ue;
        if (a.isObject(le)) {
          var Q = le.stack;
          Ue = ye + d(Q, le);
        } else
          Ue = ye + String(le);
        typeof m == "function" ? m(Ue, we) : (typeof console.log == "function" || typeof console.log == "object") && console.log(Ue);
      }
    }
    function P(le, ye, we, Ue) {
      var Q = !1;
      try {
        typeof ye == "function" && (Q = !0, le === "rejectionHandled" ? ye(Ue) : ye(we, Ue));
      } catch (M) {
        i.throwLater(M);
      }
      le === "unhandledRejection" ? !D(le, we, Ue) && !Q && F(we, "Unhandled rejection ") : D(le, Ue);
    }
    function ne(le) {
      var ye;
      if (typeof le == "function")
        ye = "[function " + (le.name || "anonymous") + "]";
      else {
        ye = le && typeof le.toString == "function" ? le.toString() : a.toString(le);
        var we = /\[object [a-zA-Z0-9$_]+\]/;
        if (we.test(ye))
          try {
            var Ue = JSON.stringify(le);
            ye = Ue;
          } catch {
          }
        ye.length === 0 && (ye = "(empty array)");
      }
      return "(<" + S(ye) + ">, no stack trace)";
    }
    function S(le) {
      var ye = 41;
      return le.length < ye ? le : le.substr(0, ye - 3) + "...";
    }
    function he() {
      return typeof Se == "function";
    }
    var ae = function() {
      return !1;
    }, te = /[\/<\(]([^:\/]+):(\d+):(?:\d+)\)?\s*$/;
    function ee(le) {
      var ye = le.match(te);
      if (ye)
        return {
          fileName: ye[1],
          line: parseInt(ye[2], 10)
        };
    }
    function ve(le, ye) {
      if (he()) {
        for (var we = le.stack.split(`
`), Ue = ye.stack.split(`
`), Q = -1, M = -1, N, Z, de = 0; de < we.length; ++de) {
          var Te = ee(we[de]);
          if (Te) {
            N = Te.fileName, Q = Te.line;
            break;
          }
        }
        for (var de = 0; de < Ue.length; ++de) {
          var Te = ee(Ue[de]);
          if (Te) {
            Z = Te.fileName, M = Te.line;
            break;
          }
        }
        Q < 0 || M < 0 || !N || !Z || N !== Z || Q >= M || (ae = function(Ie) {
          if (c.test(Ie)) return !0;
          var je = ee(Ie);
          return !!(je && je.fileName === N && Q <= je.line && je.line <= M);
        });
      }
    }
    function Ee(le) {
      this._parent = le, this._promisesCreated = 0;
      var ye = this._length = 1 + (le === void 0 ? 0 : le._length);
      Se(this, Ee), ye > 32 && this.uncycle();
    }
    a.inherits(Ee, Error), e.CapturedTrace = Ee, Ee.prototype.uncycle = function() {
      var le = this._length;
      if (!(le < 2)) {
        for (var ye = [], we = {}, Ue = 0, Q = this; Q !== void 0; ++Ue)
          ye.push(Q), Q = Q._parent;
        le = this._length = Ue;
        for (var Ue = le - 1; Ue >= 0; --Ue) {
          var M = ye[Ue].stack;
          we[M] === void 0 && (we[M] = Ue);
        }
        for (var Ue = 0; Ue < le; ++Ue) {
          var N = ye[Ue].stack, Z = we[N];
          if (Z !== void 0 && Z !== Ue) {
            Z > 0 && (ye[Z - 1]._parent = void 0, ye[Z - 1]._length = 1), ye[Ue]._parent = void 0, ye[Ue]._length = 1;
            var de = Ue > 0 ? ye[Ue - 1] : this;
            Z < le - 1 ? (de._parent = ye[Z + 1], de._parent.uncycle(), de._length = de._parent._length + 1) : (de._parent = void 0, de._length = 1);
            for (var Te = de._length + 1, Ie = Ue - 2; Ie >= 0; --Ie)
              ye[Ie]._length = Te, Te++;
            return;
          }
        }
      }
    }, Ee.prototype.attachExtraTrace = function(le) {
      if (!le.__stackCleaned__) {
        this.uncycle();
        for (var ye = Me(le), we = ye.message, Ue = [ye.stack], Q = this; Q !== void 0; )
          Ue.push(De(Q.stack.split(`
`))), Q = Q._parent;
        oe(Ue), ce(Ue), a.notEnumerableProp(le, "stack", pe(we, Ue)), a.notEnumerableProp(le, "__stackCleaned__", !0);
      }
    };
    var Se = (function() {
      var ye = /^\s*at\s*/, we = function(N, Z) {
        return typeof N == "string" ? N : Z.name !== void 0 && Z.message !== void 0 ? Z.toString() : ne(Z);
      };
      if (typeof Error.stackTraceLimit == "number" && typeof Error.captureStackTrace == "function") {
        Error.stackTraceLimit += 6, f = ye, d = we;
        var Ue = Error.captureStackTrace;
        return ae = function(N) {
          return c.test(N);
        }, function(N, Z) {
          Error.stackTraceLimit += 6, Ue(N, Z), Error.stackTraceLimit -= 6;
        };
      }
      var Q = new Error();
      if (typeof Q.stack == "string" && Q.stack.split(`
`)[0].indexOf("stackDetection@") >= 0)
        return f = /@/, d = we, y = !0, function(Z) {
          Z.stack = new Error().stack;
        };
      var M;
      try {
        throw new Error();
      } catch (N) {
        M = "stack" in N;
      }
      return !("stack" in Q) && M && typeof Error.stackTraceLimit == "number" ? (f = ye, d = we, function(Z) {
        Error.stackTraceLimit += 6;
        try {
          throw new Error();
        } catch (de) {
          Z.stack = de.stack;
        }
        Error.stackTraceLimit -= 6;
      }) : (d = function(N, Z) {
        return typeof N == "string" ? N : (typeof Z == "object" || typeof Z == "function") && Z.name !== void 0 && Z.message !== void 0 ? Z.toString() : ne(Z);
      }, null);
    })();
    typeof console < "u" && typeof console.warn < "u" && (m = function(le) {
      console.warn(le);
    }, a.isNode && process.stderr.isTTY ? m = function(le, ye) {
      var we = ye ? "\x1B[33m" : "\x1B[31m";
      console.warn(we + le + `\x1B[0m
`);
    } : !a.isNode && typeof new Error().stack == "string" && (m = function(le, ye) {
      console.warn(
        "%c" + le,
        ye ? "color: darkorange" : "color: red"
      );
    }));
    var xe = {
      warnings: p,
      longStackTraces: !1,
      cancellation: !1,
      monitoring: !1
    };
    return g && n.longStackTraces(), {
      longStackTraces: function() {
        return xe.longStackTraces;
      },
      warnings: function() {
        return xe.warnings;
      },
      cancellation: function() {
        return xe.cancellation;
      },
      monitoring: function() {
        return xe.monitoring;
      },
      propagateFromFunction: function() {
        return z;
      },
      boundValueFunction: function() {
        return q;
      },
      checkForgottenReturns: K,
      setBounds: ve,
      warn: ge,
      deprecated: ie,
      CapturedTrace: Ee,
      fireDomEvent: x,
      fireGlobalEvent: T
    };
  }), Lf;
}
var Pf, Jv;
function Q6() {
  return Jv || (Jv = 1, Pf = function(n, e) {
    var t = Tt(), i = n.CancellationError, r = t.errorObj;
    function a(h, f, d) {
      this.promise = h, this.type = f, this.handler = d, this.called = !1, this.cancelPromise = null;
    }
    a.prototype.isFinallyHandler = function() {
      return this.type === 0;
    };
    function s(h) {
      this.finallyHandler = h;
    }
    s.prototype._resultCancelled = function() {
      o(this.finallyHandler);
    };
    function o(h, f) {
      return h.cancelPromise != null ? (arguments.length > 1 ? h.cancelPromise._reject(f) : h.cancelPromise._cancel(), h.cancelPromise = null, !0) : !1;
    }
    function u() {
      return l.call(this, this.promise._target()._settledValue());
    }
    function c(h) {
      if (!o(this, h))
        return r.e = h, r;
    }
    function l(h) {
      var f = this.promise, d = this.handler;
      if (!this.called) {
        this.called = !0;
        var y = this.isFinallyHandler() ? d.call(f._boundValue()) : d.call(f._boundValue(), h);
        if (y !== void 0) {
          f._setReturnedNonUndefined();
          var m = e(y, f);
          if (m instanceof n) {
            if (this.cancelPromise != null)
              if (m._isCancelled()) {
                var b = new i("late cancellation observer");
                return f._attachExtraTrace(b), r.e = b, r;
              } else m.isPending() && m._attachCancellationCallback(
                new s(this)
              );
            return m._then(
              u,
              c,
              void 0,
              this,
              void 0
            );
          }
        }
      }
      return f.isRejected() ? (o(this), r.e = h, r) : (o(this), h);
    }
    return n.prototype._passThrough = function(h, f, d, y) {
      return typeof h != "function" ? this.then() : this._then(
        d,
        y,
        void 0,
        new a(this, f, h),
        void 0
      );
    }, n.prototype.lastly = n.prototype.finally = function(h) {
      return this._passThrough(
        h,
        0,
        l,
        l
      );
    }, n.prototype.tap = function(h) {
      return this._passThrough(h, 1, l);
    }, a;
  }), Pf;
}
var Ff, e1;
function Z6() {
  return e1 || (e1 = 1, Ff = function(n) {
    var e = Tt(), t = Ua().keys, i = e.tryCatch, r = e.errorObj;
    function a(s, o, u) {
      return function(c) {
        var l = u._boundValue();
        e: for (var h = 0; h < s.length; ++h) {
          var f = s[h];
          if (f === Error || f != null && f.prototype instanceof Error) {
            if (c instanceof f)
              return i(o).call(l, c);
          } else if (typeof f == "function") {
            var d = i(f).call(l, c);
            if (d === r)
              return d;
            if (d)
              return i(o).call(l, c);
          } else if (e.isObject(c)) {
            for (var y = t(f), m = 0; m < y.length; ++m) {
              var b = y[m];
              if (f[b] != c[b])
                continue e;
            }
            return i(o).call(l, c);
          }
        }
        return n;
      };
    }
    return a;
  }), Ff;
}
var Nf, t1;
function AE() {
  if (t1) return Nf;
  t1 = 1;
  var n = Tt(), e = n.maybeWrapAsError, t = er(), i = t.OperationalError, r = Ua();
  function a(c) {
    return c instanceof Error && r.getPrototypeOf(c) === Error.prototype;
  }
  var s = /^(?:name|message|stack|cause)$/;
  function o(c) {
    var l;
    if (a(c)) {
      l = new i(c), l.name = c.name, l.message = c.message, l.stack = c.stack;
      for (var h = r.keys(c), f = 0; f < h.length; ++f) {
        var d = h[f];
        s.test(d) || (l[d] = c[d]);
      }
      return l;
    }
    return n.markAsOriginatingFromRejection(c), c;
  }
  function u(c, l) {
    return function(h, f) {
      if (c !== null) {
        if (h) {
          var d = o(e(h));
          c._attachExtraTrace(d), c._reject(d);
        } else if (!l)
          c._fulfill(f);
        else {
          for (var y = arguments.length, m = new Array(Math.max(y - 1, 0)), b = 1; b < y; ++b)
            m[b - 1] = arguments[b];
          c._fulfill(m);
        }
        c = null;
      }
    };
  }
  return Nf = u, Nf;
}
var Mf, n1;
function J6() {
  return n1 || (n1 = 1, Mf = function(n, e, t, i, r) {
    var a = Tt(), s = a.tryCatch;
    n.method = function(o) {
      if (typeof o != "function")
        throw new n.TypeError("expecting a function but got " + a.classString(o));
      return function() {
        var u = new n(e);
        u._captureStackTrace(), u._pushContext();
        var c = s(o).apply(this, arguments), l = u._popContext();
        return r.checkForgottenReturns(
          c,
          l,
          "Promise.method",
          u
        ), u._resolveFromSyncValue(c), u;
      };
    }, n.attempt = n.try = function(o) {
      if (typeof o != "function")
        return i("expecting a function but got " + a.classString(o));
      var u = new n(e);
      u._captureStackTrace(), u._pushContext();
      var c;
      if (arguments.length > 1) {
        r.deprecated("calling Promise.try with more than 1 argument");
        var l = arguments[1], h = arguments[2];
        c = a.isArray(l) ? s(o).apply(h, l) : s(o).call(h, l);
      } else
        c = s(o)();
      var f = u._popContext();
      return r.checkForgottenReturns(
        c,
        f,
        "Promise.try",
        u
      ), u._resolveFromSyncValue(c), u;
    }, n.prototype._resolveFromSyncValue = function(o) {
      o === a.errorObj ? this._rejectCallback(o.e, !1) : this._resolveCallback(o, !0);
    };
  }), Mf;
}
var Bf, i1;
function ek() {
  return i1 || (i1 = 1, Bf = function(n, e, t, i) {
    var r = !1, a = function(c, l) {
      this._reject(l);
    }, s = function(c, l) {
      l.promiseRejectionQueued = !0, l.bindingPromise._then(a, a, null, this, c);
    }, o = function(c, l) {
      (this._bitField & 50397184) === 0 && this._resolveCallback(l.target);
    }, u = function(c, l) {
      l.promiseRejectionQueued || this._reject(c);
    };
    n.prototype.bind = function(c) {
      r || (r = !0, n.prototype._propagateFrom = i.propagateFromFunction(), n.prototype._boundValue = i.boundValueFunction());
      var l = t(c), h = new n(e);
      h._propagateFrom(this, 1);
      var f = this._target();
      if (h._setBoundTo(l), l instanceof n) {
        var d = {
          promiseRejectionQueued: !1,
          promise: h,
          target: f,
          bindingPromise: l
        };
        f._then(e, s, void 0, h, d), l._then(
          o,
          u,
          void 0,
          h,
          d
        ), h._setOnCancel(l);
      } else
        h._resolveCallback(f);
      return h;
    }, n.prototype._setBoundTo = function(c) {
      c !== void 0 ? (this._bitField = this._bitField | 2097152, this._boundTo = c) : this._bitField = this._bitField & -2097153;
    }, n.prototype._isBound = function() {
      return (this._bitField & 2097152) === 2097152;
    }, n.bind = function(c, l) {
      return n.resolve(l).bind(c);
    };
  }), Bf;
}
var jf, r1;
function tk() {
  return r1 || (r1 = 1, jf = function(n, e, t, i) {
    var r = Tt(), a = r.tryCatch, s = r.errorObj, o = n._async;
    n.prototype.break = n.prototype.cancel = function() {
      if (!i.cancellation()) return this._warn("cancellation is disabled");
      for (var u = this, c = u; u._isCancellable(); ) {
        if (!u._cancelBy(c)) {
          c._isFollowing() ? c._followee().cancel() : c._cancelBranched();
          break;
        }
        var l = u._cancellationParent;
        if (l == null || !l._isCancellable()) {
          u._isFollowing() ? u._followee().cancel() : u._cancelBranched();
          break;
        } else
          u._isFollowing() && u._followee().cancel(), u._setWillBeCancelled(), c = u, u = l;
      }
    }, n.prototype._branchHasCancelled = function() {
      this._branchesRemainingToCancel--;
    }, n.prototype._enoughBranchesHaveCancelled = function() {
      return this._branchesRemainingToCancel === void 0 || this._branchesRemainingToCancel <= 0;
    }, n.prototype._cancelBy = function(u) {
      return u === this ? (this._branchesRemainingToCancel = 0, this._invokeOnCancel(), !0) : (this._branchHasCancelled(), this._enoughBranchesHaveCancelled() ? (this._invokeOnCancel(), !0) : !1);
    }, n.prototype._cancelBranched = function() {
      this._enoughBranchesHaveCancelled() && this._cancel();
    }, n.prototype._cancel = function() {
      this._isCancellable() && (this._setCancelled(), o.invoke(this._cancelPromises, this, void 0));
    }, n.prototype._cancelPromises = function() {
      this._length() > 0 && this._settlePromises();
    }, n.prototype._unsetOnCancel = function() {
      this._onCancelField = void 0;
    }, n.prototype._isCancellable = function() {
      return this.isPending() && !this._isCancelled();
    }, n.prototype.isCancellable = function() {
      return this.isPending() && !this.isCancelled();
    }, n.prototype._doInvokeOnCancel = function(u, c) {
      if (r.isArray(u))
        for (var l = 0; l < u.length; ++l)
          this._doInvokeOnCancel(u[l], c);
      else if (u !== void 0)
        if (typeof u == "function") {
          if (!c) {
            var h = a(u).call(this._boundValue());
            h === s && (this._attachExtraTrace(h.e), o.throwLater(h.e));
          }
        } else
          u._resultCancelled(this);
    }, n.prototype._invokeOnCancel = function() {
      var u = this._onCancel();
      this._unsetOnCancel(), o.invoke(this._doInvokeOnCancel, this, u);
    }, n.prototype._invokeInternalOnCancel = function() {
      this._isCancellable() && (this._doInvokeOnCancel(this._onCancel(), !0), this._unsetOnCancel());
    }, n.prototype._resultCancelled = function() {
      this.cancel();
    };
  }), jf;
}
var qf, a1;
function nk() {
  return a1 || (a1 = 1, qf = function(n) {
    function e() {
      return this.value;
    }
    function t() {
      throw this.reason;
    }
    n.prototype.return = n.prototype.thenReturn = function(i) {
      return i instanceof n && i.suppressUnhandledRejections(), this._then(
        e,
        void 0,
        void 0,
        { value: i },
        void 0
      );
    }, n.prototype.throw = n.prototype.thenThrow = function(i) {
      return this._then(
        t,
        void 0,
        void 0,
        { reason: i },
        void 0
      );
    }, n.prototype.catchThrow = function(i) {
      if (arguments.length <= 1)
        return this._then(
          void 0,
          t,
          void 0,
          { reason: i },
          void 0
        );
      var r = arguments[1], a = function() {
        throw r;
      };
      return this.caught(i, a);
    }, n.prototype.catchReturn = function(i) {
      if (arguments.length <= 1)
        return i instanceof n && i.suppressUnhandledRejections(), this._then(
          void 0,
          e,
          void 0,
          { value: i },
          void 0
        );
      var r = arguments[1];
      r instanceof n && r.suppressUnhandledRejections();
      var a = function() {
        return r;
      };
      return this.caught(i, a);
    };
  }), qf;
}
var Wf, s1;
function ik() {
  return s1 || (s1 = 1, Wf = function(n) {
    function e(u) {
      u !== void 0 ? (u = u._target(), this._bitField = u._bitField, this._settledValueField = u._isFateSealed() ? u._settledValue() : void 0) : (this._bitField = 0, this._settledValueField = void 0);
    }
    e.prototype._settledValue = function() {
      return this._settledValueField;
    };
    var t = e.prototype.value = function() {
      if (!this.isFulfilled())
        throw new TypeError(`cannot get fulfillment value of a non-fulfilled promise

    See http://goo.gl/MqrFmX
`);
      return this._settledValue();
    }, i = e.prototype.error = e.prototype.reason = function() {
      if (!this.isRejected())
        throw new TypeError(`cannot get rejection reason of a non-rejected promise

    See http://goo.gl/MqrFmX
`);
      return this._settledValue();
    }, r = e.prototype.isFulfilled = function() {
      return (this._bitField & 33554432) !== 0;
    }, a = e.prototype.isRejected = function() {
      return (this._bitField & 16777216) !== 0;
    }, s = e.prototype.isPending = function() {
      return (this._bitField & 50397184) === 0;
    }, o = e.prototype.isResolved = function() {
      return (this._bitField & 50331648) !== 0;
    };
    e.prototype.isCancelled = function() {
      return (this._bitField & 8454144) !== 0;
    }, n.prototype.__isCancelled = function() {
      return (this._bitField & 65536) === 65536;
    }, n.prototype._isCancelled = function() {
      return this._target().__isCancelled();
    }, n.prototype.isCancelled = function() {
      return (this._target()._bitField & 8454144) !== 0;
    }, n.prototype.isPending = function() {
      return s.call(this._target());
    }, n.prototype.isRejected = function() {
      return a.call(this._target());
    }, n.prototype.isFulfilled = function() {
      return r.call(this._target());
    }, n.prototype.isResolved = function() {
      return o.call(this._target());
    }, n.prototype.value = function() {
      return t.call(this._target());
    }, n.prototype.reason = function() {
      var u = this._target();
      return u._unsetRejectionIsUnhandled(), i.call(u);
    }, n.prototype._value = function() {
      return this._settledValue();
    }, n.prototype._reason = function() {
      return this._unsetRejectionIsUnhandled(), this._settledValue();
    }, n.PromiseInspection = e;
  }), Wf;
}
var Vf, o1;
function rk() {
  return o1 || (o1 = 1, Vf = function(n, e, t, i, r, a) {
    var s = Tt(), o = s.canEvaluate, u = s.tryCatch, c = s.errorObj, l;
    if (o) {
      for (var h = function(g) {
        return new Function("value", "holder", `                             
	            'use strict';                                                    
	            holder.pIndex = value;                                           
	            holder.checkFulfillment(this);                                   
	            `.replace(/Index/g, g));
      }, f = function(g) {
        return new Function("promise", "holder", `                           
	            'use strict';                                                    
	            holder.pIndex = promise;                                         
	            `.replace(/Index/g, g));
      }, d = function(g) {
        for (var v = new Array(g), _ = 0; _ < v.length; ++_)
          v[_] = "this.p" + (_ + 1);
        var x = v.join(" = ") + " = null;", T = `var promise;
` + v.map(function(L) {
          return `                                                         
	                promise = ` + L + `;                                      
	                if (promise instanceof Promise) {                            
	                    promise.cancel();                                        
	                }                                                            
	            `;
        }).join(`
`), E = v.join(", "), U = "Holder$" + g, D = `return function(tryCatch, errorObj, Promise, async) {    
	            'use strict';                                                    
	            function [TheName](fn) {                                         
	                [TheProperties]                                              
	                this.fn = fn;                                                
	                this.asyncNeeded = true;                                     
	                this.now = 0;                                                
	            }                                                                
	                                                                             
	            [TheName].prototype._callFunction = function(promise) {          
	                promise._pushContext();                                      
	                var ret = tryCatch(this.fn)([ThePassedArguments]);           
	                promise._popContext();                                       
	                if (ret === errorObj) {                                      
	                    promise._rejectCallback(ret.e, false);                   
	                } else {                                                     
	                    promise._resolveCallback(ret);                           
	                }                                                            
	            };                                                               
	                                                                             
	            [TheName].prototype.checkFulfillment = function(promise) {       
	                var now = ++this.now;                                        
	                if (now === [TheTotal]) {                                    
	                    if (this.asyncNeeded) {                                  
	                        async.invoke(this._callFunction, this, promise);     
	                    } else {                                                 
	                        this._callFunction(promise);                         
	                    }                                                        
	                                                                             
	                }                                                            
	            };                                                               
	                                                                             
	            [TheName].prototype._resultCancelled = function() {              
	                [CancellationCode]                                           
	            };                                                               
	                                                                             
	            return [TheName];                                                
	        }(tryCatch, errorObj, Promise, async);                               
	        `;
        return D = D.replace(/\[TheName\]/g, U).replace(/\[TheTotal\]/g, g).replace(/\[ThePassedArguments\]/g, E).replace(/\[TheProperties\]/g, x).replace(/\[CancellationCode\]/g, T), new Function("tryCatch", "errorObj", "Promise", "async", D)(u, c, n, r);
      }, y = [], m = [], b = [], p = 0; p < 8; ++p)
        y.push(d(p + 1)), m.push(h(p + 1)), b.push(f(p + 1));
      l = function(g) {
        this._reject(g);
      };
    }
    n.join = function() {
      var g = arguments.length - 1, v;
      if (g > 0 && typeof arguments[g] == "function" && (v = arguments[g], g <= 8 && o)) {
        var I = new n(i);
        I._captureStackTrace();
        for (var _ = y[g - 1], x = new _(v), T = m, E = 0; E < g; ++E) {
          var U = t(arguments[E], I);
          if (U instanceof n) {
            U = U._target();
            var D = U._bitField;
            (D & 50397184) === 0 ? (U._then(
              T[E],
              l,
              void 0,
              I,
              x
            ), b[E](U, x), x.asyncNeeded = !1) : (D & 33554432) !== 0 ? T[E].call(
              I,
              U._value(),
              x
            ) : (D & 16777216) !== 0 ? I._reject(U._reason()) : I._cancel();
          } else
            T[E].call(I, U, x);
        }
        if (!I._isFateSealed()) {
          if (x.asyncNeeded) {
            var L = a();
            L !== null && (x.fn = s.domainBind(L, x.fn));
          }
          I._setAsyncGuaranteed(), I._setOnCancel(x);
        }
        return I;
      }
      for (var j = arguments.length, C = new Array(j), k = 0; k < j; ++k)
        C[k] = arguments[k];
      v && C.pop();
      var I = new e(C).promise();
      return v !== void 0 ? I.spread(v) : I;
    };
  }), Vf;
}
var Hf, u1;
function ak() {
  return u1 || (u1 = 1, Hf = function(n, e, t, i, r, a) {
    var s = n._getDomain, o = Tt(), u = o.tryCatch, c = o.errorObj, l = n._async;
    function h(d, y, m, b) {
      this.constructor$(d), this._promise._captureStackTrace();
      var p = s();
      this._callback = p === null ? y : o.domainBind(p, y), this._preservedValues = b === r ? new Array(this.length()) : null, this._limit = m, this._inFlight = 0, this._queue = [], l.invoke(this._asyncInit, this, void 0);
    }
    o.inherits(h, e), h.prototype._asyncInit = function() {
      this._init$(void 0, -2);
    }, h.prototype._init = function() {
    }, h.prototype._promiseFulfilled = function(d, y) {
      var m = this._values, b = this.length(), p = this._preservedValues, g = this._limit;
      if (y < 0) {
        if (y = y * -1 - 1, m[y] = d, g >= 1 && (this._inFlight--, this._drainQueue(), this._isResolved()))
          return !0;
      } else {
        if (g >= 1 && this._inFlight >= g)
          return m[y] = d, this._queue.push(y), !1;
        p !== null && (p[y] = d);
        var v = this._promise, _ = this._callback, x = v._boundValue();
        v._pushContext();
        var T = u(_).call(x, d, y, b), E = v._popContext();
        if (a.checkForgottenReturns(
          T,
          E,
          p !== null ? "Promise.filter" : "Promise.map",
          v
        ), T === c)
          return this._reject(T.e), !0;
        var U = i(T, this._promise);
        if (U instanceof n) {
          U = U._target();
          var D = U._bitField;
          if ((D & 50397184) === 0)
            return g >= 1 && this._inFlight++, m[y] = U, U._proxy(this, (y + 1) * -1), !1;
          if ((D & 33554432) !== 0)
            T = U._value();
          else return (D & 16777216) !== 0 ? (this._reject(U._reason()), !0) : (this._cancel(), !0);
        }
        m[y] = T;
      }
      var L = ++this._totalResolved;
      return L >= b ? (p !== null ? this._filter(m, p) : this._resolve(m), !0) : !1;
    }, h.prototype._drainQueue = function() {
      for (var d = this._queue, y = this._limit, m = this._values; d.length > 0 && this._inFlight < y; ) {
        if (this._isResolved()) return;
        var b = d.pop();
        this._promiseFulfilled(m[b], b);
      }
    }, h.prototype._filter = function(d, y) {
      for (var m = y.length, b = new Array(m), p = 0, g = 0; g < m; ++g)
        d[g] && (b[p++] = y[g]);
      b.length = p, this._resolve(b);
    }, h.prototype.preservedValues = function() {
      return this._preservedValues;
    };
    function f(d, y, m, b) {
      if (typeof y != "function")
        return t("expecting a function but got " + o.classString(y));
      var p = 0;
      if (m !== void 0)
        if (typeof m == "object" && m !== null) {
          if (typeof m.concurrency != "number")
            return n.reject(
              new TypeError("'concurrency' must be a number but it is " + o.classString(m.concurrency))
            );
          p = m.concurrency;
        } else
          return n.reject(new TypeError(
            "options argument must be an object but it is " + o.classString(m)
          ));
      return p = typeof p == "number" && isFinite(p) && p >= 1 ? p : 0, new h(d, y, p, b).promise();
    }
    n.prototype.map = function(d, y) {
      return f(this, d, y, null);
    }, n.map = function(d, y, m, b) {
      return f(d, y, m, b);
    };
  }), Hf;
}
var zf, c1;
function sk() {
  if (c1) return zf;
  c1 = 1;
  var n = Object.create;
  if (n) {
    var e = n(null), t = n(null);
    e[" size"] = t[" size"] = 0;
  }
  return zf = function(i) {
    var r = Tt(), a = r.canEvaluate, s = r.isIdentifier, o, u;
    {
      var c = function(b) {
        return new Function("ensureMethod", `                                    
	        return function(obj) {                                               
	            'use strict'                                                     
	            var len = this.length;                                           
	            ensureMethod(obj, 'methodName');                                 
	            switch(len) {                                                    
	                case 1: return obj.methodName(this[0]);                      
	                case 2: return obj.methodName(this[0], this[1]);             
	                case 3: return obj.methodName(this[0], this[1], this[2]);    
	                case 0: return obj.methodName();                             
	                default:                                                     
	                    return obj.methodName.apply(obj, this);                  
	            }                                                                
	        };                                                                   
	        `.replace(/methodName/g, b))(f);
      }, l = function(b) {
        return new Function("obj", `                                             
	        'use strict';                                                        
	        return obj.propertyName;                                             
	        `.replace("propertyName", b));
      }, h = function(b, p, g) {
        var v = g[b];
        if (typeof v != "function") {
          if (!s(b))
            return null;
          if (v = p(b), g[b] = v, g[" size"]++, g[" size"] > 512) {
            for (var _ = Object.keys(g), x = 0; x < 256; ++x) delete g[_[x]];
            g[" size"] = _.length - 256;
          }
        }
        return v;
      };
      o = function(b) {
        return h(b, c, e);
      }, u = function(b) {
        return h(b, l, t);
      };
    }
    function f(b, p) {
      var g;
      if (b != null && (g = b[p]), typeof g != "function") {
        var v = "Object " + r.classString(b) + " has no method '" + r.toString(p) + "'";
        throw new i.TypeError(v);
      }
      return g;
    }
    function d(b) {
      var p = this.pop(), g = f(b, p);
      return g.apply(b, this);
    }
    i.prototype.call = function(b) {
      for (var p = arguments.length, g = new Array(Math.max(p - 1, 0)), v = 1; v < p; ++v)
        g[v - 1] = arguments[v];
      if (a) {
        var _ = o(b);
        if (_ !== null)
          return this._then(
            _,
            void 0,
            void 0,
            g,
            void 0
          );
      }
      return g.push(b), this._then(d, void 0, void 0, g, void 0);
    };
    function y(b) {
      return b[this];
    }
    function m(b) {
      var p = +this;
      return p < 0 && (p = Math.max(0, p + b.length)), b[p];
    }
    i.prototype.get = function(b) {
      var p = typeof b == "number", g;
      if (p)
        g = m;
      else if (a) {
        var v = u(b);
        g = v !== null ? v : y;
      } else
        g = y;
      return this._then(g, void 0, void 0, b, void 0);
    };
  }, zf;
}
var $f, l1;
function ok() {
  return l1 || (l1 = 1, $f = function(n, e, t, i, r, a) {
    var s = Tt(), o = er().TypeError, u = Tt().inherits, c = s.errorObj, l = s.tryCatch, h = {};
    function f(v) {
      setTimeout(function() {
        throw v;
      }, 0);
    }
    function d(v) {
      var _ = t(v);
      return _ !== v && typeof v._isDisposable == "function" && typeof v._getDisposer == "function" && v._isDisposable() && _._setDisposable(v._getDisposer()), _;
    }
    function y(v, _) {
      var x = 0, T = v.length, E = new n(r);
      function U() {
        if (x >= T) return E._fulfill();
        var D = d(v[x++]);
        if (D instanceof n && D._isDisposable()) {
          try {
            D = t(
              D._getDisposer().tryDispose(_),
              v.promise
            );
          } catch (L) {
            return f(L);
          }
          if (D instanceof n)
            return D._then(
              U,
              f,
              null,
              null,
              null
            );
        }
        U();
      }
      return U(), E;
    }
    function m(v, _, x) {
      this._data = v, this._promise = _, this._context = x;
    }
    m.prototype.data = function() {
      return this._data;
    }, m.prototype.promise = function() {
      return this._promise;
    }, m.prototype.resource = function() {
      return this.promise().isFulfilled() ? this.promise().value() : h;
    }, m.prototype.tryDispose = function(v) {
      var _ = this.resource(), x = this._context;
      x !== void 0 && x._pushContext();
      var T = _ !== h ? this.doDispose(_, v) : null;
      return x !== void 0 && x._popContext(), this._promise._unsetDisposable(), this._data = null, T;
    }, m.isDisposer = function(v) {
      return v != null && typeof v.resource == "function" && typeof v.tryDispose == "function";
    };
    function b(v, _, x) {
      this.constructor$(v, _, x);
    }
    u(b, m), b.prototype.doDispose = function(v, _) {
      var x = this.data();
      return x.call(v, v, _);
    };
    function p(v) {
      return m.isDisposer(v) ? (this.resources[this.index]._setDisposable(v), v.promise()) : v;
    }
    function g(v) {
      this.length = v, this.promise = null, this[v - 1] = null;
    }
    g.prototype._resultCancelled = function() {
      for (var v = this.length, _ = 0; _ < v; ++_) {
        var x = this[_];
        x instanceof n && x.cancel();
      }
    }, n.using = function() {
      var v = arguments.length;
      if (v < 2) return e(
        "you must pass at least 2 arguments to Promise.using"
      );
      var _ = arguments[v - 1];
      if (typeof _ != "function")
        return e("expecting a function but got " + s.classString(_));
      var x, T = !0;
      v === 2 && Array.isArray(arguments[0]) ? (x = arguments[0], v = x.length, T = !1) : (x = arguments, v--);
      for (var E = new g(v), U = 0; U < v; ++U) {
        var D = x[U];
        if (m.isDisposer(D)) {
          var L = D;
          D = D.promise(), D._setDisposable(L);
        } else {
          var j = t(D);
          j instanceof n && (D = j._then(p, null, null, {
            resources: E,
            index: U
          }, void 0));
        }
        E[U] = D;
      }
      for (var C = new Array(E.length), U = 0; U < C.length; ++U)
        C[U] = n.resolve(E[U]).reflect();
      var k = n.all(C).then(function($) {
        for (var W = 0; W < $.length; ++W) {
          var B = $[W];
          if (B.isRejected())
            return c.e = B.error(), c;
          if (!B.isFulfilled()) {
            k.cancel();
            return;
          }
          $[W] = B.value();
        }
        I._pushContext(), _ = l(_);
        var z = T ? _.apply(void 0, $) : _($), q = I._popContext();
        return a.checkForgottenReturns(
          z,
          q,
          "Promise.using",
          I
        ), z;
      }), I = k.lastly(function() {
        var $ = new n.PromiseInspection(k);
        return y(E, $);
      });
      return E.promise = I, I._setOnCancel(E), I;
    }, n.prototype._setDisposable = function(v) {
      this._bitField = this._bitField | 131072, this._disposer = v;
    }, n.prototype._isDisposable = function() {
      return (this._bitField & 131072) > 0;
    }, n.prototype._getDisposer = function() {
      return this._disposer;
    }, n.prototype._unsetDisposable = function() {
      this._bitField = this._bitField & -131073, this._disposer = void 0;
    }, n.prototype.disposer = function(v) {
      if (typeof v == "function")
        return new b(v, this, i());
      throw new o();
    };
  }), $f;
}
var Gf, d1;
function uk() {
  return d1 || (d1 = 1, Gf = function(n, e, t) {
    var i = Tt(), r = n.TimeoutError;
    function a(h) {
      this.handle = h;
    }
    a.prototype._resultCancelled = function() {
      clearTimeout(this.handle);
    };
    var s = function(h) {
      return o(+this).thenReturn(h);
    }, o = n.delay = function(h, f) {
      var d, y;
      return f !== void 0 ? (d = n.resolve(f)._then(s, null, null, h, void 0), t.cancellation() && f instanceof n && d._setOnCancel(f)) : (d = new n(e), y = setTimeout(function() {
        d._fulfill();
      }, +h), t.cancellation() && d._setOnCancel(new a(y)), d._captureStackTrace()), d._setAsyncGuaranteed(), d;
    };
    n.prototype.delay = function(h) {
      return o(h, this);
    };
    var u = function(h, f, d) {
      var y;
      typeof f != "string" ? f instanceof Error ? y = f : y = new r("operation timed out") : y = new r(f), i.markAsOriginatingFromRejection(y), h._attachExtraTrace(y), h._reject(y), d?.cancel();
    };
    function c(h) {
      return clearTimeout(this.handle), h;
    }
    function l(h) {
      throw clearTimeout(this.handle), h;
    }
    n.prototype.timeout = function(h, f) {
      h = +h;
      var d, y, m = new a(setTimeout(function() {
        d.isPending() && u(d, f, y);
      }, h));
      return t.cancellation() ? (y = this.then(), d = y._then(
        c,
        l,
        void 0,
        m,
        void 0
      ), d._setOnCancel(m)) : d = this._then(
        c,
        l,
        void 0,
        m,
        void 0
      ), d;
    };
  }), Gf;
}
var Xf, f1;
function ck() {
  return f1 || (f1 = 1, Xf = function(n, e, t, i, r, a) {
    var s = er(), o = s.TypeError, u = Tt(), c = u.errorObj, l = u.tryCatch, h = [];
    function f(y, m, b) {
      for (var p = 0; p < m.length; ++p) {
        b._pushContext();
        var g = l(m[p])(y);
        if (b._popContext(), g === c) {
          b._pushContext();
          var v = n.reject(c.e);
          return b._popContext(), v;
        }
        var _ = i(g, b);
        if (_ instanceof n) return _;
      }
      return null;
    }
    function d(y, m, b, p) {
      if (a.cancellation()) {
        var g = new n(t), v = this._finallyPromise = new n(t);
        this._promise = g.lastly(function() {
          return v;
        }), g._captureStackTrace(), g._setOnCancel(this);
      } else {
        var _ = this._promise = new n(t);
        _._captureStackTrace();
      }
      this._stack = p, this._generatorFunction = y, this._receiver = m, this._generator = void 0, this._yieldHandlers = typeof b == "function" ? [b].concat(h) : h, this._yieldedPromise = null, this._cancellationPhase = !1;
    }
    u.inherits(d, r), d.prototype._isResolved = function() {
      return this._promise === null;
    }, d.prototype._cleanup = function() {
      this._promise = this._generator = null, a.cancellation() && this._finallyPromise !== null && (this._finallyPromise._fulfill(), this._finallyPromise = null);
    }, d.prototype._promiseCancelled = function() {
      if (!this._isResolved()) {
        var y = typeof this._generator.return < "u", m;
        if (y)
          this._promise._pushContext(), m = l(this._generator.return).call(
            this._generator,
            void 0
          ), this._promise._popContext();
        else {
          var b = new n.CancellationError(
            "generator .return() sentinel"
          );
          n.coroutine.returnSentinel = b, this._promise._attachExtraTrace(b), this._promise._pushContext(), m = l(this._generator.throw).call(
            this._generator,
            b
          ), this._promise._popContext();
        }
        this._cancellationPhase = !0, this._yieldedPromise = null, this._continue(m);
      }
    }, d.prototype._promiseFulfilled = function(y) {
      this._yieldedPromise = null, this._promise._pushContext();
      var m = l(this._generator.next).call(this._generator, y);
      this._promise._popContext(), this._continue(m);
    }, d.prototype._promiseRejected = function(y) {
      this._yieldedPromise = null, this._promise._attachExtraTrace(y), this._promise._pushContext();
      var m = l(this._generator.throw).call(this._generator, y);
      this._promise._popContext(), this._continue(m);
    }, d.prototype._resultCancelled = function() {
      if (this._yieldedPromise instanceof n) {
        var y = this._yieldedPromise;
        this._yieldedPromise = null, y.cancel();
      }
    }, d.prototype.promise = function() {
      return this._promise;
    }, d.prototype._run = function() {
      this._generator = this._generatorFunction.call(this._receiver), this._receiver = this._generatorFunction = void 0, this._promiseFulfilled(void 0);
    }, d.prototype._continue = function(y) {
      var m = this._promise;
      if (y === c)
        return this._cleanup(), this._cancellationPhase ? m.cancel() : m._rejectCallback(y.e, !1);
      var b = y.value;
      if (y.done === !0)
        return this._cleanup(), this._cancellationPhase ? m.cancel() : m._resolveCallback(b);
      var p = i(b, this._promise);
      if (!(p instanceof n) && (p = f(
        p,
        this._yieldHandlers,
        this._promise
      ), p === null)) {
        this._promiseRejected(
          new o(
            `A value %s was yielded that could not be treated as a promise

    See http://goo.gl/MqrFmX

`.replace("%s", b) + `From coroutine:
` + this._stack.split(`
`).slice(1, -7).join(`
`)
          )
        );
        return;
      }
      p = p._target();
      var g = p._bitField;
      (g & 50397184) === 0 ? (this._yieldedPromise = p, p._proxy(this, null)) : (g & 33554432) !== 0 ? n._async.invoke(
        this._promiseFulfilled,
        this,
        p._value()
      ) : (g & 16777216) !== 0 ? n._async.invoke(
        this._promiseRejected,
        this,
        p._reason()
      ) : this._promiseCancelled();
    }, n.coroutine = function(y, m) {
      if (typeof y != "function")
        throw new o(`generatorFunction must be a function

    See http://goo.gl/MqrFmX
`);
      var b = Object(m).yieldHandler, p = d, g = new Error().stack;
      return function() {
        var v = y.apply(this, arguments), _ = new p(
          void 0,
          void 0,
          b,
          g
        ), x = _.promise();
        return _._generator = v, _._promiseFulfilled(void 0), x;
      };
    }, n.coroutine.addYieldHandler = function(y) {
      if (typeof y != "function")
        throw new o("expecting a function but got " + u.classString(y));
      h.push(y);
    }, n.spawn = function(y) {
      if (a.deprecated("Promise.spawn()", "Promise.coroutine()"), typeof y != "function")
        return e(`generatorFunction must be a function

    See http://goo.gl/MqrFmX
`);
      var m = new d(y, this), b = m.promise();
      return m._run(n.spawn), b;
    };
  }), Xf;
}
var Kf, h1;
function lk() {
  return h1 || (h1 = 1, Kf = function(n) {
    var e = Tt(), t = n._async, i = e.tryCatch, r = e.errorObj;
    function a(u, c) {
      var l = this;
      if (!e.isArray(u)) return s.call(l, u, c);
      var h = i(c).apply(l._boundValue(), [null].concat(u));
      h === r && t.throwLater(h.e);
    }
    function s(u, c) {
      var l = this, h = l._boundValue(), f = u === void 0 ? i(c).call(h, null) : i(c).call(h, null, u);
      f === r && t.throwLater(f.e);
    }
    function o(u, c) {
      var l = this;
      if (!u) {
        var h = new Error(u + "");
        h.cause = u, u = h;
      }
      var f = i(c).call(l._boundValue(), u);
      f === r && t.throwLater(f.e);
    }
    n.prototype.asCallback = n.prototype.nodeify = function(u, c) {
      if (typeof u == "function") {
        var l = s;
        c !== void 0 && Object(c).spread && (l = a), this._then(
          l,
          o,
          void 0,
          this,
          u
        );
      }
      return this;
    };
  }), Kf;
}
var Yf, p1;
function dk() {
  return p1 || (p1 = 1, Yf = function(n, e) {
    var t = {}, i = Tt(), r = AE(), a = i.withAppended, s = i.maybeWrapAsError, o = i.canEvaluate, u = er().TypeError, c = "Async", l = { __isPromisified__: !0 }, h = [
      "arity",
      "length",
      "name",
      "arguments",
      "caller",
      "callee",
      "prototype",
      "__isPromisified__"
    ], f = new RegExp("^(?:" + h.join("|") + ")$"), d = function(k) {
      return i.isIdentifier(k) && k.charAt(0) !== "_" && k !== "constructor";
    };
    function y(k) {
      return !f.test(k);
    }
    function m(k) {
      try {
        return k.__isPromisified__ === !0;
      } catch {
        return !1;
      }
    }
    function b(k, I, $) {
      var W = i.getDataPropertyOrDefault(
        k,
        I + $,
        l
      );
      return W ? m(W) : !1;
    }
    function p(k, I, $) {
      for (var W = 0; W < k.length; W += 2) {
        var B = k[W];
        if ($.test(B)) {
          for (var z = B.replace($, ""), q = 0; q < k.length; q += 2)
            if (k[q] === z)
              throw new u(`Cannot promisify an API that has normal methods with '%s'-suffix

    See http://goo.gl/MqrFmX
`.replace("%s", I));
        }
      }
    }
    function g(k, I, $, W) {
      for (var B = i.inheritedDataKeys(k), z = [], q = 0; q < B.length; ++q) {
        var Y = B[q], H = k[Y], K = W === d ? !0 : d(Y);
        typeof H == "function" && !m(H) && !b(k, Y, I) && W(Y, H, k, K) && z.push(Y, H);
      }
      return p(z, I, $), z;
    }
    var v = function(k) {
      return k.replace(/([$])/, "\\$");
    }, _;
    {
      var x = function(k) {
        for (var I = [k], $ = Math.max(0, k - 1 - 3), W = k - 1; W >= $; --W)
          I.push(W);
        for (var W = k + 1; W <= 3; ++W)
          I.push(W);
        return I;
      }, T = function(k) {
        return i.filledRange(k, "_arg", "");
      }, E = function(k) {
        return i.filledRange(
          Math.max(k, 3),
          "_arg",
          ""
        );
      }, U = function(k) {
        return typeof k.length == "number" ? Math.max(Math.min(k.length, 1024), 0) : 0;
      };
      _ = function(k, I, $, W, B, z) {
        var q = Math.max(0, U(W) - 1), Y = x(q), H = typeof k == "string" || I === t;
        function K(ce) {
          var oe = T(ce).join(", "), De = ce > 0 ? ", " : "", Re;
          return H ? Re = `ret = callback.call(this, {{args}}, nodeback); break;
` : Re = I === void 0 ? `ret = callback({{args}}, nodeback); break;
` : `ret = callback.call(receiver, {{args}}, nodeback); break;
`, Re.replace("{{args}}", oe).replace(", ", De);
        }
        function ie() {
          for (var ce = "", oe = 0; oe < Y.length; ++oe)
            ce += "case " + Y[oe] + ":" + K(Y[oe]);
          return ce += `                                                             
	        default:                                                             
	            var args = new Array(len + 1);                                   
	            var i = 0;                                                       
	            for (var i = 0; i < len; ++i) {                                  
	               args[i] = arguments[i];                                       
	            }                                                                
	            args[i] = nodeback;                                              
	            [CodeForCall]                                                    
	            break;                                                           
	        `.replace("[CodeForCall]", H ? `ret = callback.apply(this, args);
` : `ret = callback.apply(receiver, args);
`), ce;
        }
        var ge = typeof k == "string" ? "this != null ? this['" + k + "'] : fn" : "fn", pe = `'use strict';                                                
	        var ret = function (Parameters) {                                    
	            'use strict';                                                    
	            var len = arguments.length;                                      
	            var promise = new Promise(INTERNAL);                             
	            promise._captureStackTrace();                                    
	            var nodeback = nodebackForPromise(promise, ` + z + `);   
	            var ret;                                                         
	            var callback = tryCatch([GetFunctionCode]);                      
	            switch(len) {                                                    
	                [CodeForSwitchCase]                                          
	            }                                                                
	            if (ret === errorObj) {                                          
	                promise._rejectCallback(maybeWrapAsError(ret.e), true, true);
	            }                                                                
	            if (!promise._isFateSealed()) promise._setAsyncGuaranteed();     
	            return promise;                                                  
	        };                                                                   
	        notEnumerableProp(ret, '__isPromisified__', true);                   
	        return ret;                                                          
	    `.replace("[CodeForSwitchCase]", ie()).replace("[GetFunctionCode]", ge);
        return pe = pe.replace("Parameters", E(q)), new Function(
          "Promise",
          "fn",
          "receiver",
          "withAppended",
          "maybeWrapAsError",
          "nodebackForPromise",
          "tryCatch",
          "errorObj",
          "notEnumerableProp",
          "INTERNAL",
          pe
        )(
          n,
          W,
          I,
          a,
          s,
          r,
          i.tryCatch,
          i.errorObj,
          i.notEnumerableProp,
          e
        );
      };
    }
    function D(k, I, $, W, B, z) {
      var q = /* @__PURE__ */ (function() {
        return this;
      })(), Y = k;
      typeof Y == "string" && (k = W);
      function H() {
        var K = I;
        I === t && (K = this);
        var ie = new n(e);
        ie._captureStackTrace();
        var ge = typeof Y == "string" && this !== q ? this[Y] : k, pe = r(ie, z);
        try {
          ge.apply(K, a(arguments, pe));
        } catch (ce) {
          ie._rejectCallback(s(ce), !0, !0);
        }
        return ie._isFateSealed() || ie._setAsyncGuaranteed(), ie;
      }
      return i.notEnumerableProp(H, "__isPromisified__", !0), H;
    }
    var L = o ? _ : D;
    function j(k, I, $, W, B) {
      for (var z = new RegExp(v(I) + "$"), q = g(k, I, z, $), Y = 0, H = q.length; Y < H; Y += 2) {
        var K = q[Y], ie = q[Y + 1], ge = K + I;
        if (W === L)
          k[ge] = L(K, t, K, ie, I, B);
        else {
          var pe = W(ie, function() {
            return L(
              K,
              t,
              K,
              ie,
              I,
              B
            );
          });
          i.notEnumerableProp(pe, "__isPromisified__", !0), k[ge] = pe;
        }
      }
      return i.toFastProperties(k), k;
    }
    function C(k, I, $) {
      return L(
        k,
        I,
        void 0,
        k,
        null,
        $
      );
    }
    n.promisify = function(k, I) {
      if (typeof k != "function")
        throw new u("expecting a function but got " + i.classString(k));
      if (m(k))
        return k;
      I = Object(I);
      var $ = I.context === void 0 ? t : I.context, W = !!I.multiArgs, B = C(k, $, W);
      return i.copyDescriptors(k, B, y), B;
    }, n.promisifyAll = function(k, I) {
      if (typeof k != "function" && typeof k != "object")
        throw new u(`the target of promisifyAll must be an object or a function

    See http://goo.gl/MqrFmX
`);
      I = Object(I);
      var $ = !!I.multiArgs, W = I.suffix;
      typeof W != "string" && (W = c);
      var B = I.filter;
      typeof B != "function" && (B = d);
      var z = I.promisifier;
      if (typeof z != "function" && (z = L), !i.isIdentifier(W))
        throw new RangeError(`suffix must be a valid identifier

    See http://goo.gl/MqrFmX
`);
      for (var q = i.inheritedDataKeys(k), Y = 0; Y < q.length; ++Y) {
        var H = k[q[Y]];
        q[Y] !== "constructor" && i.isClass(H) && (j(
          H.prototype,
          W,
          B,
          z,
          $
        ), j(H, W, B, z, $));
      }
      return j(k, W, B, z, $);
    };
  }), Yf;
}
var Qf, m1;
function fk() {
  return m1 || (m1 = 1, Qf = function(n, e, t, i) {
    var r = Tt(), a = r.isObject, s = Ua(), o;
    typeof Map == "function" && (o = Map);
    var u = /* @__PURE__ */ (function() {
      var f = 0, d = 0;
      function y(m, b) {
        this[f] = m, this[f + d] = b, f++;
      }
      return function(b) {
        d = b.size, f = 0;
        var p = new Array(b.size * 2);
        return b.forEach(y, p), p;
      };
    })(), c = function(f) {
      for (var d = new o(), y = f.length / 2 | 0, m = 0; m < y; ++m) {
        var b = f[y + m], p = f[m];
        d.set(b, p);
      }
      return d;
    };
    function l(f) {
      var d = !1, y;
      if (o !== void 0 && f instanceof o)
        y = u(f), d = !0;
      else {
        var m = s.keys(f), b = m.length;
        y = new Array(b * 2);
        for (var p = 0; p < b; ++p) {
          var g = m[p];
          y[p] = f[g], y[p + b] = g;
        }
      }
      this.constructor$(y), this._isMap = d, this._init$(void 0, -3);
    }
    r.inherits(l, e), l.prototype._init = function() {
    }, l.prototype._promiseFulfilled = function(f, d) {
      this._values[d] = f;
      var y = ++this._totalResolved;
      if (y >= this._length) {
        var m;
        if (this._isMap)
          m = c(this._values);
        else {
          m = {};
          for (var b = this.length(), p = 0, g = this.length(); p < g; ++p)
            m[this._values[p + b]] = this._values[p];
        }
        return this._resolve(m), !0;
      }
      return !1;
    }, l.prototype.shouldCopyValues = function() {
      return !1;
    }, l.prototype.getActualLength = function(f) {
      return f >> 1;
    };
    function h(f) {
      var d, y = t(f);
      if (a(y))
        y instanceof n ? d = y._then(
          n.props,
          void 0,
          void 0,
          void 0,
          void 0
        ) : d = new l(y).promise();
      else return i(`cannot await properties of a non-object

    See http://goo.gl/MqrFmX
`);
      return y instanceof n && d._propagateFrom(y, 2), d;
    }
    n.prototype.props = function() {
      return h(this);
    }, n.props = function(f) {
      return h(f);
    };
  }), Qf;
}
var Zf, g1;
function hk() {
  return g1 || (g1 = 1, Zf = function(n, e, t, i) {
    var r = Tt(), a = function(o) {
      return o.then(function(u) {
        return s(u, o);
      });
    };
    function s(o, u) {
      var c = t(o);
      if (c instanceof n)
        return a(c);
      if (o = r.asArray(o), o === null)
        return i("expecting an array or an iterable object but got " + r.classString(o));
      var l = new n(e);
      u !== void 0 && l._propagateFrom(u, 3);
      for (var h = l._fulfill, f = l._reject, d = 0, y = o.length; d < y; ++d) {
        var m = o[d];
        m === void 0 && !(d in o) || n.cast(m)._then(h, f, void 0, l, null);
      }
      return l;
    }
    n.race = function(o) {
      return s(o, void 0);
    }, n.prototype.race = function() {
      return s(this, void 0);
    };
  }), Zf;
}
var Jf, b1;
function pk() {
  return b1 || (b1 = 1, Jf = function(n, e, t, i, r, a) {
    var s = n._getDomain, o = Tt(), u = o.tryCatch;
    function c(y, m, b, p) {
      this.constructor$(y);
      var g = s();
      this._fn = g === null ? m : o.domainBind(g, m), b !== void 0 && (b = n.resolve(b), b._attachCancellationCallback(this)), this._initialValue = b, this._currentCancellable = null, p === r ? this._eachValues = Array(this._length) : p === 0 ? this._eachValues = null : this._eachValues = void 0, this._promise._captureStackTrace(), this._init$(void 0, -5);
    }
    o.inherits(c, e), c.prototype._gotAccum = function(y) {
      this._eachValues !== void 0 && this._eachValues !== null && y !== r && this._eachValues.push(y);
    }, c.prototype._eachComplete = function(y) {
      return this._eachValues !== null && this._eachValues.push(y), this._eachValues;
    }, c.prototype._init = function() {
    }, c.prototype._resolveEmptyArray = function() {
      this._resolve(this._eachValues !== void 0 ? this._eachValues : this._initialValue);
    }, c.prototype.shouldCopyValues = function() {
      return !1;
    }, c.prototype._resolve = function(y) {
      this._promise._resolveCallback(y), this._values = null;
    }, c.prototype._resultCancelled = function(y) {
      if (y === this._initialValue) return this._cancel();
      this._isResolved() || (this._resultCancelled$(), this._currentCancellable instanceof n && this._currentCancellable.cancel(), this._initialValue instanceof n && this._initialValue.cancel());
    }, c.prototype._iterate = function(y) {
      this._values = y;
      var m, b, p = y.length;
      if (this._initialValue !== void 0 ? (m = this._initialValue, b = 0) : (m = n.resolve(y[0]), b = 1), this._currentCancellable = m, !m.isRejected())
        for (; b < p; ++b) {
          var g = {
            accum: null,
            value: y[b],
            index: b,
            length: p,
            array: this
          };
          m = m._then(f, void 0, void 0, g, void 0);
        }
      this._eachValues !== void 0 && (m = m._then(this._eachComplete, void 0, void 0, this, void 0)), m._then(l, l, void 0, m, this);
    }, n.prototype.reduce = function(y, m) {
      return h(this, y, m, null);
    }, n.reduce = function(y, m, b, p) {
      return h(y, m, b, p);
    };
    function l(y, m) {
      this.isFulfilled() ? m._resolve(y) : m._reject(y);
    }
    function h(y, m, b, p) {
      if (typeof m != "function")
        return t("expecting a function but got " + o.classString(m));
      var g = new c(y, m, b, p);
      return g.promise();
    }
    function f(y) {
      this.accum = y, this.array._gotAccum(y);
      var m = i(this.value, this.array._promise);
      return m instanceof n ? (this.array._currentCancellable = m, m._then(d, void 0, void 0, this, void 0)) : d.call(this, m);
    }
    function d(y) {
      var m = this.array, b = m._promise, p = u(m._fn);
      b._pushContext();
      var g;
      m._eachValues !== void 0 ? g = p.call(b._boundValue(), y, this.index, this.length) : g = p.call(
        b._boundValue(),
        this.accum,
        y,
        this.index,
        this.length
      ), g instanceof n && (m._currentCancellable = g);
      var v = b._popContext();
      return a.checkForgottenReturns(
        g,
        v,
        m._eachValues !== void 0 ? "Promise.each" : "Promise.reduce",
        b
      ), g;
    }
  }), Jf;
}
var eh, y1;
function mk() {
  return y1 || (y1 = 1, eh = function(n, e, t) {
    var i = n.PromiseInspection, r = Tt();
    function a(s) {
      this.constructor$(s);
    }
    r.inherits(a, e), a.prototype._promiseResolved = function(s, o) {
      this._values[s] = o;
      var u = ++this._totalResolved;
      return u >= this._length ? (this._resolve(this._values), !0) : !1;
    }, a.prototype._promiseFulfilled = function(s, o) {
      var u = new i();
      return u._bitField = 33554432, u._settledValueField = s, this._promiseResolved(o, u);
    }, a.prototype._promiseRejected = function(s, o) {
      var u = new i();
      return u._bitField = 16777216, u._settledValueField = s, this._promiseResolved(o, u);
    }, n.settle = function(s) {
      return t.deprecated(".settle()", ".reflect()"), new a(s).promise();
    }, n.prototype.settle = function() {
      return n.settle(this);
    };
  }), eh;
}
var th, v1;
function gk() {
  return v1 || (v1 = 1, th = function(n, e, t) {
    var i = Tt(), r = er().RangeError, a = er().AggregateError, s = i.isArray, o = {};
    function u(l) {
      this.constructor$(l), this._howMany = 0, this._unwrap = !1, this._initialized = !1;
    }
    i.inherits(u, e), u.prototype._init = function() {
      if (this._initialized) {
        if (this._howMany === 0) {
          this._resolve([]);
          return;
        }
        this._init$(void 0, -5);
        var l = s(this._values);
        !this._isResolved() && l && this._howMany > this._canPossiblyFulfill() && this._reject(this._getRangeError(this.length()));
      }
    }, u.prototype.init = function() {
      this._initialized = !0, this._init();
    }, u.prototype.setUnwrap = function() {
      this._unwrap = !0;
    }, u.prototype.howMany = function() {
      return this._howMany;
    }, u.prototype.setHowMany = function(l) {
      this._howMany = l;
    }, u.prototype._promiseFulfilled = function(l) {
      return this._addFulfilled(l), this._fulfilled() === this.howMany() ? (this._values.length = this.howMany(), this.howMany() === 1 && this._unwrap ? this._resolve(this._values[0]) : this._resolve(this._values), !0) : !1;
    }, u.prototype._promiseRejected = function(l) {
      return this._addRejected(l), this._checkOutcome();
    }, u.prototype._promiseCancelled = function() {
      return this._values instanceof n || this._values == null ? this._cancel() : (this._addRejected(o), this._checkOutcome());
    }, u.prototype._checkOutcome = function() {
      if (this.howMany() > this._canPossiblyFulfill()) {
        for (var l = new a(), h = this.length(); h < this._values.length; ++h)
          this._values[h] !== o && l.push(this._values[h]);
        return l.length > 0 ? this._reject(l) : this._cancel(), !0;
      }
      return !1;
    }, u.prototype._fulfilled = function() {
      return this._totalResolved;
    }, u.prototype._rejected = function() {
      return this._values.length - this.length();
    }, u.prototype._addRejected = function(l) {
      this._values.push(l);
    }, u.prototype._addFulfilled = function(l) {
      this._values[this._totalResolved++] = l;
    }, u.prototype._canPossiblyFulfill = function() {
      return this.length() - this._rejected();
    }, u.prototype._getRangeError = function(l) {
      var h = "Input array must contain at least " + this._howMany + " items but contains only " + l + " items";
      return new r(h);
    }, u.prototype._resolveEmptyArray = function() {
      this._reject(this._getRangeError(0));
    };
    function c(l, h) {
      if ((h | 0) !== h || h < 0)
        return t(`expecting a positive integer

    See http://goo.gl/MqrFmX
`);
      var f = new u(l), d = f.promise();
      return f.setHowMany(h), f.init(), d;
    }
    n.some = function(l, h) {
      return c(l, h);
    }, n.prototype.some = function(l) {
      return c(this, l);
    }, n._SomePromiseArray = u;
  }), th;
}
var nh, x1;
function bk() {
  return x1 || (x1 = 1, nh = function(n, e) {
    var t = n.map;
    n.prototype.filter = function(i, r) {
      return t(this, i, r, e);
    }, n.filter = function(i, r, a) {
      return t(i, r, a, e);
    };
  }), nh;
}
var ih, _1;
function yk() {
  return _1 || (_1 = 1, ih = function(n, e) {
    var t = n.reduce, i = n.all;
    function r() {
      return i(this);
    }
    function a(s, o) {
      return t(s, o, e, e);
    }
    n.prototype.each = function(s) {
      return t(this, s, e, 0)._then(r, void 0, void 0, this, void 0);
    }, n.prototype.mapSeries = function(s) {
      return t(this, s, e, e);
    }, n.each = function(s, o) {
      return t(s, o, e, 0)._then(r, void 0, void 0, s, void 0);
    }, n.mapSeries = a;
  }), ih;
}
var rh, T1;
function vk() {
  return T1 || (T1 = 1, rh = function(n) {
    var e = n._SomePromiseArray;
    function t(i) {
      var r = new e(i), a = r.promise();
      return r.setHowMany(1), r.setUnwrap(), r.init(), a;
    }
    n.any = function(i) {
      return t(i);
    }, n.prototype.any = function() {
      return t(this);
    };
  }), rh;
}
var w1;
function xk() {
  return w1 || (w1 = 1, (function(n) {
    n.exports = function() {
      var e = function() {
        return new f(`circular promise resolution chain

    See http://goo.gl/MqrFmX
`);
      }, t = function() {
        return new C.PromiseInspection(this._target());
      }, i = function(W) {
        return C.reject(new f(W));
      };
      function r() {
      }
      var a = {}, s = Tt(), o;
      s.isNode ? o = function() {
        var W = process.domain;
        return W === void 0 && (W = null), W;
      } : o = function() {
        return null;
      }, s.notEnumerableProp(C, "_getDomain", o);
      var u = Ua(), c = $6(), l = new c();
      u.defineProperty(C, "_async", { value: l });
      var h = er(), f = C.TypeError = h.TypeError;
      C.RangeError = h.RangeError;
      var d = C.CancellationError = h.CancellationError;
      C.TimeoutError = h.TimeoutError, C.OperationalError = h.OperationalError, C.RejectionError = h.OperationalError, C.AggregateError = h.AggregateError;
      var y = function() {
      }, m = {}, b = {}, p = G6()(C, y), g = X6()(
        C,
        y,
        p,
        i,
        r
      ), v = K6()(C), _ = v.create, x = Y6()(C, v);
      x.CapturedTrace;
      var T = Q6()(C, p), E = Z6()(b), U = AE(), D = s.errorObj, L = s.tryCatch;
      function j(W, B) {
        if (typeof B != "function")
          throw new f("expecting a function but got " + s.classString(B));
        if (W.constructor !== C)
          throw new f(`the promise constructor cannot be invoked directly

    See http://goo.gl/MqrFmX
`);
      }
      function C(W) {
        this._bitField = 0, this._fulfillmentHandler0 = void 0, this._rejectionHandler0 = void 0, this._promise0 = void 0, this._receiver0 = void 0, W !== y && (j(this, W), this._resolveFromExecutor(W)), this._promiseCreated(), this._fireEvent("promiseCreated", this);
      }
      C.prototype.toString = function() {
        return "[object Promise]";
      }, C.prototype.caught = C.prototype.catch = function(W) {
        var B = arguments.length;
        if (B > 1) {
          var z = new Array(B - 1), q = 0, Y;
          for (Y = 0; Y < B - 1; ++Y) {
            var H = arguments[Y];
            if (s.isObject(H))
              z[q++] = H;
            else
              return i("expecting an object but got A catch statement predicate " + s.classString(H));
          }
          return z.length = q, W = arguments[Y], this.then(void 0, E(z, W, this));
        }
        return this.then(void 0, W);
      }, C.prototype.reflect = function() {
        return this._then(
          t,
          t,
          void 0,
          this,
          void 0
        );
      }, C.prototype.then = function(W, B) {
        if (x.warnings() && arguments.length > 0 && typeof W != "function" && typeof B != "function") {
          var z = ".then() only accepts functions but was passed: " + s.classString(W);
          arguments.length > 1 && (z += ", " + s.classString(B)), this._warn(z);
        }
        return this._then(W, B, void 0, void 0, void 0);
      }, C.prototype.done = function(W, B) {
        var z = this._then(W, B, void 0, void 0, void 0);
        z._setIsFinal();
      }, C.prototype.spread = function(W) {
        return typeof W != "function" ? i("expecting a function but got " + s.classString(W)) : this.all()._then(W, void 0, void 0, m, void 0);
      }, C.prototype.toJSON = function() {
        var W = {
          isFulfilled: !1,
          isRejected: !1,
          fulfillmentValue: void 0,
          rejectionReason: void 0
        };
        return this.isFulfilled() ? (W.fulfillmentValue = this.value(), W.isFulfilled = !0) : this.isRejected() && (W.rejectionReason = this.reason(), W.isRejected = !0), W;
      }, C.prototype.all = function() {
        return arguments.length > 0 && this._warn(".all() was passed arguments but it does not take any"), new g(this).promise();
      }, C.prototype.error = function(W) {
        return this.caught(s.originatesFromRejection, W);
      }, C.getNewLibraryCopy = n.exports, C.is = function(W) {
        return W instanceof C;
      }, C.fromNode = C.fromCallback = function(W) {
        var B = new C(y);
        B._captureStackTrace();
        var z = arguments.length > 1 ? !!Object(arguments[1]).multiArgs : !1, q = L(W)(U(B, z));
        return q === D && B._rejectCallback(q.e, !0), B._isFateSealed() || B._setAsyncGuaranteed(), B;
      }, C.all = function(W) {
        return new g(W).promise();
      }, C.cast = function(W) {
        var B = p(W);
        return B instanceof C || (B = new C(y), B._captureStackTrace(), B._setFulfilled(), B._rejectionHandler0 = W), B;
      }, C.resolve = C.fulfilled = C.cast, C.reject = C.rejected = function(W) {
        var B = new C(y);
        return B._captureStackTrace(), B._rejectCallback(W, !0), B;
      }, C.setScheduler = function(W) {
        if (typeof W != "function")
          throw new f("expecting a function but got " + s.classString(W));
        return l.setScheduler(W);
      }, C.prototype._then = function(W, B, z, q, Y) {
        var H = Y !== void 0, K = H ? Y : new C(y), ie = this._target(), ge = ie._bitField;
        H || (K._propagateFrom(this, 3), K._captureStackTrace(), q === void 0 && (this._bitField & 2097152) !== 0 && ((ge & 50397184) !== 0 ? q = this._boundValue() : q = ie === this ? void 0 : this._boundTo), this._fireEvent("promiseChained", this, K));
        var pe = o();
        if ((ge & 50397184) !== 0) {
          var ce, oe, De = ie._settlePromiseCtx;
          (ge & 33554432) !== 0 ? (oe = ie._rejectionHandler0, ce = W) : (ge & 16777216) !== 0 ? (oe = ie._fulfillmentHandler0, ce = B, ie._unsetRejectionIsUnhandled()) : (De = ie._settlePromiseLateCancellationObserver, oe = new d("late cancellation observer"), ie._attachExtraTrace(oe), ce = B), l.invoke(De, ie, {
            handler: pe === null ? ce : typeof ce == "function" && s.domainBind(pe, ce),
            promise: K,
            receiver: q,
            value: oe
          });
        } else
          ie._addCallbacks(W, B, K, q, pe);
        return K;
      }, C.prototype._length = function() {
        return this._bitField & 65535;
      }, C.prototype._isFateSealed = function() {
        return (this._bitField & 117506048) !== 0;
      }, C.prototype._isFollowing = function() {
        return (this._bitField & 67108864) === 67108864;
      }, C.prototype._setLength = function(W) {
        this._bitField = this._bitField & -65536 | W & 65535;
      }, C.prototype._setFulfilled = function() {
        this._bitField = this._bitField | 33554432, this._fireEvent("promiseFulfilled", this);
      }, C.prototype._setRejected = function() {
        this._bitField = this._bitField | 16777216, this._fireEvent("promiseRejected", this);
      }, C.prototype._setFollowing = function() {
        this._bitField = this._bitField | 67108864, this._fireEvent("promiseResolved", this);
      }, C.prototype._setIsFinal = function() {
        this._bitField = this._bitField | 4194304;
      }, C.prototype._isFinal = function() {
        return (this._bitField & 4194304) > 0;
      }, C.prototype._unsetCancelled = function() {
        this._bitField = this._bitField & -65537;
      }, C.prototype._setCancelled = function() {
        this._bitField = this._bitField | 65536, this._fireEvent("promiseCancelled", this);
      }, C.prototype._setWillBeCancelled = function() {
        this._bitField = this._bitField | 8388608;
      }, C.prototype._setAsyncGuaranteed = function() {
        l.hasCustomScheduler() || (this._bitField = this._bitField | 134217728);
      }, C.prototype._receiverAt = function(W) {
        var B = W === 0 ? this._receiver0 : this[W * 4 - 4 + 3];
        if (B !== a)
          return B === void 0 && this._isBound() ? this._boundValue() : B;
      }, C.prototype._promiseAt = function(W) {
        return this[W * 4 - 4 + 2];
      }, C.prototype._fulfillmentHandlerAt = function(W) {
        return this[W * 4 - 4 + 0];
      }, C.prototype._rejectionHandlerAt = function(W) {
        return this[W * 4 - 4 + 1];
      }, C.prototype._boundValue = function() {
      }, C.prototype._migrateCallback0 = function(W) {
        W._bitField;
        var B = W._fulfillmentHandler0, z = W._rejectionHandler0, q = W._promise0, Y = W._receiverAt(0);
        Y === void 0 && (Y = a), this._addCallbacks(B, z, q, Y, null);
      }, C.prototype._migrateCallbackAt = function(W, B) {
        var z = W._fulfillmentHandlerAt(B), q = W._rejectionHandlerAt(B), Y = W._promiseAt(B), H = W._receiverAt(B);
        H === void 0 && (H = a), this._addCallbacks(z, q, Y, H, null);
      }, C.prototype._addCallbacks = function(W, B, z, q, Y) {
        var H = this._length();
        if (H >= 65531 && (H = 0, this._setLength(0)), H === 0)
          this._promise0 = z, this._receiver0 = q, typeof W == "function" && (this._fulfillmentHandler0 = Y === null ? W : s.domainBind(Y, W)), typeof B == "function" && (this._rejectionHandler0 = Y === null ? B : s.domainBind(Y, B));
        else {
          var K = H * 4 - 4;
          this[K + 2] = z, this[K + 3] = q, typeof W == "function" && (this[K + 0] = Y === null ? W : s.domainBind(Y, W)), typeof B == "function" && (this[K + 1] = Y === null ? B : s.domainBind(Y, B));
        }
        return this._setLength(H + 1), H;
      }, C.prototype._proxy = function(W, B) {
        this._addCallbacks(void 0, void 0, B, W, null);
      }, C.prototype._resolveCallback = function(W, B) {
        if ((this._bitField & 117506048) === 0) {
          if (W === this)
            return this._rejectCallback(e(), !1);
          var z = p(W, this);
          if (!(z instanceof C)) return this._fulfill(W);
          B && this._propagateFrom(z, 2);
          var q = z._target();
          if (q === this) {
            this._reject(e());
            return;
          }
          var Y = q._bitField;
          if ((Y & 50397184) === 0) {
            var H = this._length();
            H > 0 && q._migrateCallback0(this);
            for (var K = 1; K < H; ++K)
              q._migrateCallbackAt(this, K);
            this._setFollowing(), this._setLength(0), this._setFollowee(q);
          } else if ((Y & 33554432) !== 0)
            this._fulfill(q._value());
          else if ((Y & 16777216) !== 0)
            this._reject(q._reason());
          else {
            var ie = new d("late cancellation observer");
            q._attachExtraTrace(ie), this._reject(ie);
          }
        }
      }, C.prototype._rejectCallback = function(W, B, z) {
        var q = s.ensureErrorObject(W), Y = q === W;
        if (!Y && !z && x.warnings()) {
          var H = "a promise was rejected with a non-error: " + s.classString(W);
          this._warn(H, !0);
        }
        this._attachExtraTrace(q, B ? Y : !1), this._reject(W);
      }, C.prototype._resolveFromExecutor = function(W) {
        var B = this;
        this._captureStackTrace(), this._pushContext();
        var z = !0, q = this._execute(W, function(Y) {
          B._resolveCallback(Y);
        }, function(Y) {
          B._rejectCallback(Y, z);
        });
        z = !1, this._popContext(), q !== void 0 && B._rejectCallback(q, !0);
      }, C.prototype._settlePromiseFromHandler = function(W, B, z, q) {
        var Y = q._bitField;
        if ((Y & 65536) === 0) {
          q._pushContext();
          var H;
          B === m ? !z || typeof z.length != "number" ? (H = D, H.e = new f("cannot .spread() a non-array: " + s.classString(z))) : H = L(W).apply(this._boundValue(), z) : H = L(W).call(B, z);
          var K = q._popContext();
          Y = q._bitField, (Y & 65536) === 0 && (H === b ? q._reject(z) : H === D ? q._rejectCallback(H.e, !1) : (x.checkForgottenReturns(H, K, "", q, this), q._resolveCallback(H)));
        }
      }, C.prototype._target = function() {
        for (var W = this; W._isFollowing(); ) W = W._followee();
        return W;
      }, C.prototype._followee = function() {
        return this._rejectionHandler0;
      }, C.prototype._setFollowee = function(W) {
        this._rejectionHandler0 = W;
      }, C.prototype._settlePromise = function(W, B, z, q) {
        var Y = W instanceof C, H = this._bitField, K = (H & 134217728) !== 0;
        (H & 65536) !== 0 ? (Y && W._invokeInternalOnCancel(), z instanceof T && z.isFinallyHandler() ? (z.cancelPromise = W, L(B).call(z, q) === D && W._reject(D.e)) : B === t ? W._fulfill(t.call(z)) : z instanceof r ? z._promiseCancelled(W) : Y || W instanceof g ? W._cancel() : z.cancel()) : typeof B == "function" ? Y ? (K && W._setAsyncGuaranteed(), this._settlePromiseFromHandler(B, z, q, W)) : B.call(z, q, W) : z instanceof r ? z._isResolved() || ((H & 33554432) !== 0 ? z._promiseFulfilled(q, W) : z._promiseRejected(q, W)) : Y && (K && W._setAsyncGuaranteed(), (H & 33554432) !== 0 ? W._fulfill(q) : W._reject(q));
      }, C.prototype._settlePromiseLateCancellationObserver = function(W) {
        var B = W.handler, z = W.promise, q = W.receiver, Y = W.value;
        typeof B == "function" ? z instanceof C ? this._settlePromiseFromHandler(B, q, Y, z) : B.call(q, Y, z) : z instanceof C && z._reject(Y);
      }, C.prototype._settlePromiseCtx = function(W) {
        this._settlePromise(W.promise, W.handler, W.receiver, W.value);
      }, C.prototype._settlePromise0 = function(W, B, z) {
        var q = this._promise0, Y = this._receiverAt(0);
        this._promise0 = void 0, this._receiver0 = void 0, this._settlePromise(q, W, Y, B);
      }, C.prototype._clearCallbackDataAtIndex = function(W) {
        var B = W * 4 - 4;
        this[B + 2] = this[B + 3] = this[B + 0] = this[B + 1] = void 0;
      }, C.prototype._fulfill = function(W) {
        var B = this._bitField;
        if (!((B & 117506048) >>> 16)) {
          if (W === this) {
            var z = e();
            return this._attachExtraTrace(z), this._reject(z);
          }
          this._setFulfilled(), this._rejectionHandler0 = W, (B & 65535) > 0 && ((B & 134217728) !== 0 ? this._settlePromises() : l.settlePromises(this));
        }
      }, C.prototype._reject = function(W) {
        var B = this._bitField;
        if (!((B & 117506048) >>> 16)) {
          if (this._setRejected(), this._fulfillmentHandler0 = W, this._isFinal())
            return l.fatalError(W, s.isNode);
          (B & 65535) > 0 ? l.settlePromises(this) : this._ensurePossibleRejectionHandled();
        }
      }, C.prototype._fulfillPromises = function(W, B) {
        for (var z = 1; z < W; z++) {
          var q = this._fulfillmentHandlerAt(z), Y = this._promiseAt(z), H = this._receiverAt(z);
          this._clearCallbackDataAtIndex(z), this._settlePromise(Y, q, H, B);
        }
      }, C.prototype._rejectPromises = function(W, B) {
        for (var z = 1; z < W; z++) {
          var q = this._rejectionHandlerAt(z), Y = this._promiseAt(z), H = this._receiverAt(z);
          this._clearCallbackDataAtIndex(z), this._settlePromise(Y, q, H, B);
        }
      }, C.prototype._settlePromises = function() {
        var W = this._bitField, B = W & 65535;
        if (B > 0) {
          if ((W & 16842752) !== 0) {
            var z = this._fulfillmentHandler0;
            this._settlePromise0(this._rejectionHandler0, z, W), this._rejectPromises(B, z);
          } else {
            var q = this._rejectionHandler0;
            this._settlePromise0(this._fulfillmentHandler0, q, W), this._fulfillPromises(B, q);
          }
          this._setLength(0);
        }
        this._clearCancellationData();
      }, C.prototype._settledValue = function() {
        var W = this._bitField;
        if ((W & 33554432) !== 0)
          return this._rejectionHandler0;
        if ((W & 16777216) !== 0)
          return this._fulfillmentHandler0;
      };
      function k(W) {
        this.promise._resolveCallback(W);
      }
      function I(W) {
        this.promise._rejectCallback(W, !1);
      }
      C.defer = C.pending = function() {
        x.deprecated("Promise.defer", "new Promise");
        var W = new C(y);
        return {
          promise: W,
          resolve: k,
          reject: I
        };
      }, s.notEnumerableProp(
        C,
        "_makeSelfResolutionError",
        e
      ), J6()(
        C,
        y,
        p,
        i,
        x
      ), ek()(C, y, p, x), tk()(C, g, i, x), nk()(C), ik()(C), rk()(
        C,
        g,
        p,
        y,
        l,
        o
      ), C.Promise = C, C.version = "3.4.7", ak()(C, g, i, p, y, x), sk()(C), ok()(C, i, p, _, y, x), uk()(C, y, x), ck()(C, i, y, p, r, x), lk()(C), dk()(C, y), fk()(C, g, p, i), hk()(C, y, p, i), pk()(C, g, i, p, y, x), mk()(C, g, x), gk()(C, g, i), bk()(C, y), yk()(C, y), vk()(C), s.toFastProperties(C), s.toFastProperties(C.prototype);
      function $(W) {
        var B = new C(y);
        B._fulfillmentHandler0 = W, B._rejectionHandler0 = W, B._promise0 = W, B._receiver0 = W;
      }
      return $({ a: 1 }), $({ b: 2 }), $({ c: 3 }), $(1), $(function() {
      }), $(void 0), $(!1), $(new C(y)), x.setBounds(c.firstLineError, s.lastLineError), C;
    };
  })(Cf)), Cf.exports;
}
var E1;
function ur() {
  if (E1) return On;
  E1 = 1;
  var n = Pt, e = xk()();
  On.defer = t, On.when = e.resolve, On.resolve = e.resolve, On.all = e.all, On.props = e.props, On.reject = e.reject, On.promisify = e.promisify, On.mapSeries = e.mapSeries, On.attempt = e.attempt, On.nfcall = function(i) {
    var r = Array.prototype.slice.call(arguments, 1), a = e.promisify(i);
    return a.apply(null, r);
  }, e.prototype.fail = e.prototype.caught, e.prototype.also = function(i) {
    return this.then(function(r) {
      var a = n.extend({}, r, i(r));
      return e.props(a);
    });
  };
  function t() {
    var i, r, a = new e.Promise(function(s, o) {
      i = s, r = o;
    });
    return {
      resolve: i,
      reject: r,
      promise: a
    };
  }
  return On;
}
var bt = {}, D1;
function Vr() {
  if (D1) return bt;
  D1 = 1;
  var n = Pt, e = bt.types = {
    document: "document",
    paragraph: "paragraph",
    run: "run",
    text: "text",
    tab: "tab",
    hyperlink: "hyperlink",
    noteReference: "noteReference",
    image: "image",
    note: "note",
    commentReference: "commentReference",
    comment: "comment",
    table: "table",
    tableRow: "tableRow",
    tableCell: "tableCell",
    break: "break",
    bookmarkStart: "bookmarkStart"
  };
  function t(x, T) {
    return T = T || {}, {
      type: e.document,
      children: x,
      notes: T.notes || new l({}),
      comments: T.comments || []
    };
  }
  function i(x, T) {
    T = T || {};
    var E = T.indent || {};
    return {
      type: e.paragraph,
      children: x,
      styleId: T.styleId || null,
      styleName: T.styleName || null,
      numbering: T.numbering || null,
      alignment: T.alignment || null,
      indent: {
        start: E.start || null,
        end: E.end || null,
        firstLine: E.firstLine || null,
        hanging: E.hanging || null
      }
    };
  }
  function r(x, T) {
    return T = T || {}, {
      type: e.run,
      children: x,
      styleId: T.styleId || null,
      styleName: T.styleName || null,
      isBold: T.isBold,
      isUnderline: T.isUnderline,
      isItalic: T.isItalic,
      isStrikethrough: T.isStrikethrough,
      isAllCaps: T.isAllCaps,
      isSmallCaps: T.isSmallCaps,
      verticalAlignment: T.verticalAlignment || a.baseline,
      font: T.font || null,
      fontSize: T.fontSize || null
    };
  }
  var a = {
    baseline: "baseline",
    superscript: "superscript",
    subscript: "subscript"
  };
  function s(x) {
    return {
      type: e.text,
      value: x
    };
  }
  function o() {
    return {
      type: e.tab
    };
  }
  function u(x, T) {
    return {
      type: e.hyperlink,
      children: x,
      href: T.href,
      anchor: T.anchor,
      targetFrame: T.targetFrame
    };
  }
  function c(x) {
    return {
      type: e.noteReference,
      noteType: x.noteType,
      noteId: x.noteId
    };
  }
  function l(x) {
    this._notes = n.indexBy(x, function(T) {
      return y(T.noteType, T.noteId);
    });
  }
  l.prototype.resolve = function(x) {
    return this.findNoteByKey(y(x.noteType, x.noteId));
  }, l.prototype.findNoteByKey = function(x) {
    return this._notes[x] || null;
  };
  function h(x) {
    return {
      type: e.note,
      noteType: x.noteType,
      noteId: x.noteId,
      body: x.body
    };
  }
  function f(x) {
    return {
      type: e.commentReference,
      commentId: x.commentId
    };
  }
  function d(x) {
    return {
      type: e.comment,
      commentId: x.commentId,
      body: x.body,
      authorName: x.authorName,
      authorInitials: x.authorInitials
    };
  }
  function y(x, T) {
    return x + "-" + T;
  }
  function m(x) {
    return {
      type: e.image,
      read: x.readImage,
      altText: x.altText,
      contentType: x.contentType
    };
  }
  function b(x, T) {
    return T = T || {}, {
      type: e.table,
      children: x,
      styleId: T.styleId || null,
      styleName: T.styleName || null
    };
  }
  function p(x, T) {
    return T = T || {}, {
      type: e.tableRow,
      children: x,
      isHeader: T.isHeader || !1
    };
  }
  function g(x, T) {
    return T = T || {}, {
      type: e.tableCell,
      children: x,
      colSpan: T.colSpan == null ? 1 : T.colSpan,
      rowSpan: T.rowSpan == null ? 1 : T.rowSpan
    };
  }
  function v(x) {
    return {
      type: e.break,
      breakType: x
    };
  }
  function _(x) {
    return {
      type: e.bookmarkStart,
      name: x.name
    };
  }
  return bt.document = bt.Document = t, bt.paragraph = bt.Paragraph = i, bt.run = bt.Run = r, bt.Text = s, bt.tab = bt.Tab = o, bt.Hyperlink = u, bt.noteReference = bt.NoteReference = c, bt.Notes = l, bt.Note = h, bt.commentReference = f, bt.comment = d, bt.Image = m, bt.Table = b, bt.TableRow = p, bt.TableCell = g, bt.lineBreak = v("line"), bt.pageBreak = v("page"), bt.columnBreak = v("column"), bt.BookmarkStart = _, bt.verticalAlignment = a, bt;
}
var Qr = {}, S1;
function Pi() {
  if (S1) return Qr;
  S1 = 1;
  var n = Pt;
  Qr.Result = e, Qr.success = t, Qr.warning = i, Qr.error = r;
  function e(u, c) {
    this.value = u, this.messages = c || [];
  }
  e.prototype.map = function(u) {
    return new e(u(this.value), this.messages);
  }, e.prototype.flatMap = function(u) {
    var c = u(this.value);
    return new e(c.value, a([this, c]));
  }, e.prototype.flatMapThen = function(u) {
    var c = this;
    return u(this.value).then(function(l) {
      return new e(l.value, a([c, l]));
    });
  }, e.combine = function(u) {
    var c = n.flatten(n.pluck(u, "value")), l = a(u);
    return new e(c, l);
  };
  function t(u) {
    return new e(u, []);
  }
  function i(u) {
    return {
      type: "warning",
      message: u
    };
  }
  function r(u) {
    return {
      type: "error",
      message: u.message,
      error: u
    };
  }
  function a(u) {
    var c = [];
    return n.flatten(n.pluck(u, "messages"), !0).forEach(function(l) {
      s(c, l) || c.push(l);
    }), c;
  }
  function s(u, c) {
    return n.find(u, o.bind(null, c)) !== void 0;
  }
  function o(u, c) {
    return u.type === c.type && u.message === c.message;
  }
  return Qr;
}
var us = {};
function nu(n) {
  throw new Error('Could not dynamically require "' + n + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}
var ah = { exports: {} };
/*!

JSZip v3.10.1 - A JavaScript class for generating and reading zip files
<http://stuartk.com/jszip>

(c) 2009-2016 Stuart Knightley <stuart [at] stuartk.com>
Dual licenced under the MIT license or GPLv3. See https://raw.github.com/Stuk/jszip/main/LICENSE.markdown.

JSZip uses the library pako released under the MIT license :
https://github.com/nodeca/pako/blob/main/LICENSE
*/
var C1;
function _k() {
  return C1 || (C1 = 1, (function(n, e) {
    (function(t) {
      n.exports = t();
    })(function() {
      return (function t(i, r, a) {
        function s(c, l) {
          if (!r[c]) {
            if (!i[c]) {
              var h = typeof nu == "function" && nu;
              if (!l && h) return h(c, !0);
              if (o) return o(c, !0);
              var f = new Error("Cannot find module '" + c + "'");
              throw f.code = "MODULE_NOT_FOUND", f;
            }
            var d = r[c] = { exports: {} };
            i[c][0].call(d.exports, function(y) {
              var m = i[c][1][y];
              return s(m || y);
            }, d, d.exports, t, i, r, a);
          }
          return r[c].exports;
        }
        for (var o = typeof nu == "function" && nu, u = 0; u < a.length; u++) s(a[u]);
        return s;
      })({ 1: [function(t, i, r) {
        var a = t("./utils"), s = t("./support"), o = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
        r.encode = function(u) {
          for (var c, l, h, f, d, y, m, b = [], p = 0, g = u.length, v = g, _ = a.getTypeOf(u) !== "string"; p < u.length; ) v = g - p, h = _ ? (c = u[p++], l = p < g ? u[p++] : 0, p < g ? u[p++] : 0) : (c = u.charCodeAt(p++), l = p < g ? u.charCodeAt(p++) : 0, p < g ? u.charCodeAt(p++) : 0), f = c >> 2, d = (3 & c) << 4 | l >> 4, y = 1 < v ? (15 & l) << 2 | h >> 6 : 64, m = 2 < v ? 63 & h : 64, b.push(o.charAt(f) + o.charAt(d) + o.charAt(y) + o.charAt(m));
          return b.join("");
        }, r.decode = function(u) {
          var c, l, h, f, d, y, m = 0, b = 0, p = "data:";
          if (u.substr(0, p.length) === p) throw new Error("Invalid base64 input, it looks like a data url.");
          var g, v = 3 * (u = u.replace(/[^A-Za-z0-9+/=]/g, "")).length / 4;
          if (u.charAt(u.length - 1) === o.charAt(64) && v--, u.charAt(u.length - 2) === o.charAt(64) && v--, v % 1 != 0) throw new Error("Invalid base64 input, bad content length.");
          for (g = s.uint8array ? new Uint8Array(0 | v) : new Array(0 | v); m < u.length; ) c = o.indexOf(u.charAt(m++)) << 2 | (f = o.indexOf(u.charAt(m++))) >> 4, l = (15 & f) << 4 | (d = o.indexOf(u.charAt(m++))) >> 2, h = (3 & d) << 6 | (y = o.indexOf(u.charAt(m++))), g[b++] = c, d !== 64 && (g[b++] = l), y !== 64 && (g[b++] = h);
          return g;
        };
      }, { "./support": 30, "./utils": 32 }], 2: [function(t, i, r) {
        var a = t("./external"), s = t("./stream/DataWorker"), o = t("./stream/Crc32Probe"), u = t("./stream/DataLengthProbe");
        function c(l, h, f, d, y) {
          this.compressedSize = l, this.uncompressedSize = h, this.crc32 = f, this.compression = d, this.compressedContent = y;
        }
        c.prototype = { getContentWorker: function() {
          var l = new s(a.Promise.resolve(this.compressedContent)).pipe(this.compression.uncompressWorker()).pipe(new u("data_length")), h = this;
          return l.on("end", function() {
            if (this.streamInfo.data_length !== h.uncompressedSize) throw new Error("Bug : uncompressed data size mismatch");
          }), l;
        }, getCompressedWorker: function() {
          return new s(a.Promise.resolve(this.compressedContent)).withStreamInfo("compressedSize", this.compressedSize).withStreamInfo("uncompressedSize", this.uncompressedSize).withStreamInfo("crc32", this.crc32).withStreamInfo("compression", this.compression);
        } }, c.createWorkerFrom = function(l, h, f) {
          return l.pipe(new o()).pipe(new u("uncompressedSize")).pipe(h.compressWorker(f)).pipe(new u("compressedSize")).withStreamInfo("compression", h);
        }, i.exports = c;
      }, { "./external": 6, "./stream/Crc32Probe": 25, "./stream/DataLengthProbe": 26, "./stream/DataWorker": 27 }], 3: [function(t, i, r) {
        var a = t("./stream/GenericWorker");
        r.STORE = { magic: "\0\0", compressWorker: function() {
          return new a("STORE compression");
        }, uncompressWorker: function() {
          return new a("STORE decompression");
        } }, r.DEFLATE = t("./flate");
      }, { "./flate": 7, "./stream/GenericWorker": 28 }], 4: [function(t, i, r) {
        var a = t("./utils"), s = (function() {
          for (var o, u = [], c = 0; c < 256; c++) {
            o = c;
            for (var l = 0; l < 8; l++) o = 1 & o ? 3988292384 ^ o >>> 1 : o >>> 1;
            u[c] = o;
          }
          return u;
        })();
        i.exports = function(o, u) {
          return o !== void 0 && o.length ? a.getTypeOf(o) !== "string" ? (function(c, l, h, f) {
            var d = s, y = f + h;
            c ^= -1;
            for (var m = f; m < y; m++) c = c >>> 8 ^ d[255 & (c ^ l[m])];
            return -1 ^ c;
          })(0 | u, o, o.length, 0) : (function(c, l, h, f) {
            var d = s, y = f + h;
            c ^= -1;
            for (var m = f; m < y; m++) c = c >>> 8 ^ d[255 & (c ^ l.charCodeAt(m))];
            return -1 ^ c;
          })(0 | u, o, o.length, 0) : 0;
        };
      }, { "./utils": 32 }], 5: [function(t, i, r) {
        r.base64 = !1, r.binary = !1, r.dir = !1, r.createFolders = !0, r.date = null, r.compression = null, r.compressionOptions = null, r.comment = null, r.unixPermissions = null, r.dosPermissions = null;
      }, {}], 6: [function(t, i, r) {
        var a = null;
        a = typeof Promise < "u" ? Promise : t("lie"), i.exports = { Promise: a };
      }, { lie: 37 }], 7: [function(t, i, r) {
        var a = typeof Uint8Array < "u" && typeof Uint16Array < "u" && typeof Uint32Array < "u", s = t("pako"), o = t("./utils"), u = t("./stream/GenericWorker"), c = a ? "uint8array" : "array";
        function l(h, f) {
          u.call(this, "FlateWorker/" + h), this._pako = null, this._pakoAction = h, this._pakoOptions = f, this.meta = {};
        }
        r.magic = "\b\0", o.inherits(l, u), l.prototype.processChunk = function(h) {
          this.meta = h.meta, this._pako === null && this._createPako(), this._pako.push(o.transformTo(c, h.data), !1);
        }, l.prototype.flush = function() {
          u.prototype.flush.call(this), this._pako === null && this._createPako(), this._pako.push([], !0);
        }, l.prototype.cleanUp = function() {
          u.prototype.cleanUp.call(this), this._pako = null;
        }, l.prototype._createPako = function() {
          this._pako = new s[this._pakoAction]({ raw: !0, level: this._pakoOptions.level || -1 });
          var h = this;
          this._pako.onData = function(f) {
            h.push({ data: f, meta: h.meta });
          };
        }, r.compressWorker = function(h) {
          return new l("Deflate", h);
        }, r.uncompressWorker = function() {
          return new l("Inflate", {});
        };
      }, { "./stream/GenericWorker": 28, "./utils": 32, pako: 38 }], 8: [function(t, i, r) {
        function a(d, y) {
          var m, b = "";
          for (m = 0; m < y; m++) b += String.fromCharCode(255 & d), d >>>= 8;
          return b;
        }
        function s(d, y, m, b, p, g) {
          var v, _, x = d.file, T = d.compression, E = g !== c.utf8encode, U = o.transformTo("string", g(x.name)), D = o.transformTo("string", c.utf8encode(x.name)), L = x.comment, j = o.transformTo("string", g(L)), C = o.transformTo("string", c.utf8encode(L)), k = D.length !== x.name.length, I = C.length !== L.length, $ = "", W = "", B = "", z = x.dir, q = x.date, Y = { crc32: 0, compressedSize: 0, uncompressedSize: 0 };
          y && !m || (Y.crc32 = d.crc32, Y.compressedSize = d.compressedSize, Y.uncompressedSize = d.uncompressedSize);
          var H = 0;
          y && (H |= 8), E || !k && !I || (H |= 2048);
          var K = 0, ie = 0;
          z && (K |= 16), p === "UNIX" ? (ie = 798, K |= (function(pe, ce) {
            var oe = pe;
            return pe || (oe = ce ? 16893 : 33204), (65535 & oe) << 16;
          })(x.unixPermissions, z)) : (ie = 20, K |= (function(pe) {
            return 63 & (pe || 0);
          })(x.dosPermissions)), v = q.getUTCHours(), v <<= 6, v |= q.getUTCMinutes(), v <<= 5, v |= q.getUTCSeconds() / 2, _ = q.getUTCFullYear() - 1980, _ <<= 4, _ |= q.getUTCMonth() + 1, _ <<= 5, _ |= q.getUTCDate(), k && (W = a(1, 1) + a(l(U), 4) + D, $ += "up" + a(W.length, 2) + W), I && (B = a(1, 1) + a(l(j), 4) + C, $ += "uc" + a(B.length, 2) + B);
          var ge = "";
          return ge += `
\0`, ge += a(H, 2), ge += T.magic, ge += a(v, 2), ge += a(_, 2), ge += a(Y.crc32, 4), ge += a(Y.compressedSize, 4), ge += a(Y.uncompressedSize, 4), ge += a(U.length, 2), ge += a($.length, 2), { fileRecord: h.LOCAL_FILE_HEADER + ge + U + $, dirRecord: h.CENTRAL_FILE_HEADER + a(ie, 2) + ge + a(j.length, 2) + "\0\0\0\0" + a(K, 4) + a(b, 4) + U + $ + j };
        }
        var o = t("../utils"), u = t("../stream/GenericWorker"), c = t("../utf8"), l = t("../crc32"), h = t("../signature");
        function f(d, y, m, b) {
          u.call(this, "ZipFileWorker"), this.bytesWritten = 0, this.zipComment = y, this.zipPlatform = m, this.encodeFileName = b, this.streamFiles = d, this.accumulate = !1, this.contentBuffer = [], this.dirRecords = [], this.currentSourceOffset = 0, this.entriesCount = 0, this.currentFile = null, this._sources = [];
        }
        o.inherits(f, u), f.prototype.push = function(d) {
          var y = d.meta.percent || 0, m = this.entriesCount, b = this._sources.length;
          this.accumulate ? this.contentBuffer.push(d) : (this.bytesWritten += d.data.length, u.prototype.push.call(this, { data: d.data, meta: { currentFile: this.currentFile, percent: m ? (y + 100 * (m - b - 1)) / m : 100 } }));
        }, f.prototype.openedSource = function(d) {
          this.currentSourceOffset = this.bytesWritten, this.currentFile = d.file.name;
          var y = this.streamFiles && !d.file.dir;
          if (y) {
            var m = s(d, y, !1, this.currentSourceOffset, this.zipPlatform, this.encodeFileName);
            this.push({ data: m.fileRecord, meta: { percent: 0 } });
          } else this.accumulate = !0;
        }, f.prototype.closedSource = function(d) {
          this.accumulate = !1;
          var y = this.streamFiles && !d.file.dir, m = s(d, y, !0, this.currentSourceOffset, this.zipPlatform, this.encodeFileName);
          if (this.dirRecords.push(m.dirRecord), y) this.push({ data: (function(b) {
            return h.DATA_DESCRIPTOR + a(b.crc32, 4) + a(b.compressedSize, 4) + a(b.uncompressedSize, 4);
          })(d), meta: { percent: 100 } });
          else for (this.push({ data: m.fileRecord, meta: { percent: 0 } }); this.contentBuffer.length; ) this.push(this.contentBuffer.shift());
          this.currentFile = null;
        }, f.prototype.flush = function() {
          for (var d = this.bytesWritten, y = 0; y < this.dirRecords.length; y++) this.push({ data: this.dirRecords[y], meta: { percent: 100 } });
          var m = this.bytesWritten - d, b = (function(p, g, v, _, x) {
            var T = o.transformTo("string", x(_));
            return h.CENTRAL_DIRECTORY_END + "\0\0\0\0" + a(p, 2) + a(p, 2) + a(g, 4) + a(v, 4) + a(T.length, 2) + T;
          })(this.dirRecords.length, m, d, this.zipComment, this.encodeFileName);
          this.push({ data: b, meta: { percent: 100 } });
        }, f.prototype.prepareNextSource = function() {
          this.previous = this._sources.shift(), this.openedSource(this.previous.streamInfo), this.isPaused ? this.previous.pause() : this.previous.resume();
        }, f.prototype.registerPrevious = function(d) {
          this._sources.push(d);
          var y = this;
          return d.on("data", function(m) {
            y.processChunk(m);
          }), d.on("end", function() {
            y.closedSource(y.previous.streamInfo), y._sources.length ? y.prepareNextSource() : y.end();
          }), d.on("error", function(m) {
            y.error(m);
          }), this;
        }, f.prototype.resume = function() {
          return !!u.prototype.resume.call(this) && (!this.previous && this._sources.length ? (this.prepareNextSource(), !0) : this.previous || this._sources.length || this.generatedError ? void 0 : (this.end(), !0));
        }, f.prototype.error = function(d) {
          var y = this._sources;
          if (!u.prototype.error.call(this, d)) return !1;
          for (var m = 0; m < y.length; m++) try {
            y[m].error(d);
          } catch {
          }
          return !0;
        }, f.prototype.lock = function() {
          u.prototype.lock.call(this);
          for (var d = this._sources, y = 0; y < d.length; y++) d[y].lock();
        }, i.exports = f;
      }, { "../crc32": 4, "../signature": 23, "../stream/GenericWorker": 28, "../utf8": 31, "../utils": 32 }], 9: [function(t, i, r) {
        var a = t("../compressions"), s = t("./ZipFileWorker");
        r.generateWorker = function(o, u, c) {
          var l = new s(u.streamFiles, c, u.platform, u.encodeFileName), h = 0;
          try {
            o.forEach(function(f, d) {
              h++;
              var y = (function(g, v) {
                var _ = g || v, x = a[_];
                if (!x) throw new Error(_ + " is not a valid compression method !");
                return x;
              })(d.options.compression, u.compression), m = d.options.compressionOptions || u.compressionOptions || {}, b = d.dir, p = d.date;
              d._compressWorker(y, m).withStreamInfo("file", { name: f, dir: b, date: p, comment: d.comment || "", unixPermissions: d.unixPermissions, dosPermissions: d.dosPermissions }).pipe(l);
            }), l.entriesCount = h;
          } catch (f) {
            l.error(f);
          }
          return l;
        };
      }, { "../compressions": 3, "./ZipFileWorker": 8 }], 10: [function(t, i, r) {
        function a() {
          if (!(this instanceof a)) return new a();
          if (arguments.length) throw new Error("The constructor with parameters has been removed in JSZip 3.0, please check the upgrade guide.");
          this.files = /* @__PURE__ */ Object.create(null), this.comment = null, this.root = "", this.clone = function() {
            var s = new a();
            for (var o in this) typeof this[o] != "function" && (s[o] = this[o]);
            return s;
          };
        }
        (a.prototype = t("./object")).loadAsync = t("./load"), a.support = t("./support"), a.defaults = t("./defaults"), a.version = "3.10.1", a.loadAsync = function(s, o) {
          return new a().loadAsync(s, o);
        }, a.external = t("./external"), i.exports = a;
      }, { "./defaults": 5, "./external": 6, "./load": 11, "./object": 15, "./support": 30 }], 11: [function(t, i, r) {
        var a = t("./utils"), s = t("./external"), o = t("./utf8"), u = t("./zipEntries"), c = t("./stream/Crc32Probe"), l = t("./nodejsUtils");
        function h(f) {
          return new s.Promise(function(d, y) {
            var m = f.decompressed.getContentWorker().pipe(new c());
            m.on("error", function(b) {
              y(b);
            }).on("end", function() {
              m.streamInfo.crc32 !== f.decompressed.crc32 ? y(new Error("Corrupted zip : CRC32 mismatch")) : d();
            }).resume();
          });
        }
        i.exports = function(f, d) {
          var y = this;
          return d = a.extend(d || {}, { base64: !1, checkCRC32: !1, optimizedBinaryString: !1, createFolders: !1, decodeFileName: o.utf8decode }), l.isNode && l.isStream(f) ? s.Promise.reject(new Error("JSZip can't accept a stream when loading a zip file.")) : a.prepareContent("the loaded zip file", f, !0, d.optimizedBinaryString, d.base64).then(function(m) {
            var b = new u(d);
            return b.load(m), b;
          }).then(function(m) {
            var b = [s.Promise.resolve(m)], p = m.files;
            if (d.checkCRC32) for (var g = 0; g < p.length; g++) b.push(h(p[g]));
            return s.Promise.all(b);
          }).then(function(m) {
            for (var b = m.shift(), p = b.files, g = 0; g < p.length; g++) {
              var v = p[g], _ = v.fileNameStr, x = a.resolve(v.fileNameStr);
              y.file(x, v.decompressed, { binary: !0, optimizedBinaryString: !0, date: v.date, dir: v.dir, comment: v.fileCommentStr.length ? v.fileCommentStr : null, unixPermissions: v.unixPermissions, dosPermissions: v.dosPermissions, createFolders: d.createFolders }), v.dir || (y.file(x).unsafeOriginalName = _);
            }
            return b.zipComment.length && (y.comment = b.zipComment), y;
          });
        };
      }, { "./external": 6, "./nodejsUtils": 14, "./stream/Crc32Probe": 25, "./utf8": 31, "./utils": 32, "./zipEntries": 33 }], 12: [function(t, i, r) {
        var a = t("../utils"), s = t("../stream/GenericWorker");
        function o(u, c) {
          s.call(this, "Nodejs stream input adapter for " + u), this._upstreamEnded = !1, this._bindStream(c);
        }
        a.inherits(o, s), o.prototype._bindStream = function(u) {
          var c = this;
          (this._stream = u).pause(), u.on("data", function(l) {
            c.push({ data: l, meta: { percent: 0 } });
          }).on("error", function(l) {
            c.isPaused ? this.generatedError = l : c.error(l);
          }).on("end", function() {
            c.isPaused ? c._upstreamEnded = !0 : c.end();
          });
        }, o.prototype.pause = function() {
          return !!s.prototype.pause.call(this) && (this._stream.pause(), !0);
        }, o.prototype.resume = function() {
          return !!s.prototype.resume.call(this) && (this._upstreamEnded ? this.end() : this._stream.resume(), !0);
        }, i.exports = o;
      }, { "../stream/GenericWorker": 28, "../utils": 32 }], 13: [function(t, i, r) {
        var a = t("readable-stream").Readable;
        function s(o, u, c) {
          a.call(this, u), this._helper = o;
          var l = this;
          o.on("data", function(h, f) {
            l.push(h) || l._helper.pause(), c && c(f);
          }).on("error", function(h) {
            l.emit("error", h);
          }).on("end", function() {
            l.push(null);
          });
        }
        t("../utils").inherits(s, a), s.prototype._read = function() {
          this._helper.resume();
        }, i.exports = s;
      }, { "../utils": 32, "readable-stream": 16 }], 14: [function(t, i, r) {
        i.exports = { isNode: typeof Buffer < "u", newBufferFrom: function(a, s) {
          if (Buffer.from && Buffer.from !== Uint8Array.from) return Buffer.from(a, s);
          if (typeof a == "number") throw new Error('The "data" argument must not be a number');
          return new Buffer(a, s);
        }, allocBuffer: function(a) {
          if (Buffer.alloc) return Buffer.alloc(a);
          var s = new Buffer(a);
          return s.fill(0), s;
        }, isBuffer: function(a) {
          return Buffer.isBuffer(a);
        }, isStream: function(a) {
          return a && typeof a.on == "function" && typeof a.pause == "function" && typeof a.resume == "function";
        } };
      }, {}], 15: [function(t, i, r) {
        function a(x, T, E) {
          var U, D = o.getTypeOf(T), L = o.extend(E || {}, l);
          L.date = L.date || /* @__PURE__ */ new Date(), L.compression !== null && (L.compression = L.compression.toUpperCase()), typeof L.unixPermissions == "string" && (L.unixPermissions = parseInt(L.unixPermissions, 8)), L.unixPermissions && 16384 & L.unixPermissions && (L.dir = !0), L.dosPermissions && 16 & L.dosPermissions && (L.dir = !0), L.dir && (x = p(x)), L.createFolders && (U = b(x)) && g.call(this, U, !0);
          var j = D === "string" && L.binary === !1 && L.base64 === !1;
          E && E.binary !== void 0 || (L.binary = !j), (T instanceof h && T.uncompressedSize === 0 || L.dir || !T || T.length === 0) && (L.base64 = !1, L.binary = !0, T = "", L.compression = "STORE", D = "string");
          var C = null;
          C = T instanceof h || T instanceof u ? T : y.isNode && y.isStream(T) ? new m(x, T) : o.prepareContent(x, T, L.binary, L.optimizedBinaryString, L.base64);
          var k = new f(x, C, L);
          this.files[x] = k;
        }
        var s = t("./utf8"), o = t("./utils"), u = t("./stream/GenericWorker"), c = t("./stream/StreamHelper"), l = t("./defaults"), h = t("./compressedObject"), f = t("./zipObject"), d = t("./generate"), y = t("./nodejsUtils"), m = t("./nodejs/NodejsStreamInputAdapter"), b = function(x) {
          x.slice(-1) === "/" && (x = x.substring(0, x.length - 1));
          var T = x.lastIndexOf("/");
          return 0 < T ? x.substring(0, T) : "";
        }, p = function(x) {
          return x.slice(-1) !== "/" && (x += "/"), x;
        }, g = function(x, T) {
          return T = T !== void 0 ? T : l.createFolders, x = p(x), this.files[x] || a.call(this, x, null, { dir: !0, createFolders: T }), this.files[x];
        };
        function v(x) {
          return Object.prototype.toString.call(x) === "[object RegExp]";
        }
        var _ = { load: function() {
          throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
        }, forEach: function(x) {
          var T, E, U;
          for (T in this.files) U = this.files[T], (E = T.slice(this.root.length, T.length)) && T.slice(0, this.root.length) === this.root && x(E, U);
        }, filter: function(x) {
          var T = [];
          return this.forEach(function(E, U) {
            x(E, U) && T.push(U);
          }), T;
        }, file: function(x, T, E) {
          if (arguments.length !== 1) return x = this.root + x, a.call(this, x, T, E), this;
          if (v(x)) {
            var U = x;
            return this.filter(function(L, j) {
              return !j.dir && U.test(L);
            });
          }
          var D = this.files[this.root + x];
          return D && !D.dir ? D : null;
        }, folder: function(x) {
          if (!x) return this;
          if (v(x)) return this.filter(function(D, L) {
            return L.dir && x.test(D);
          });
          var T = this.root + x, E = g.call(this, T), U = this.clone();
          return U.root = E.name, U;
        }, remove: function(x) {
          x = this.root + x;
          var T = this.files[x];
          if (T || (x.slice(-1) !== "/" && (x += "/"), T = this.files[x]), T && !T.dir) delete this.files[x];
          else for (var E = this.filter(function(D, L) {
            return L.name.slice(0, x.length) === x;
          }), U = 0; U < E.length; U++) delete this.files[E[U].name];
          return this;
        }, generate: function() {
          throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
        }, generateInternalStream: function(x) {
          var T, E = {};
          try {
            if ((E = o.extend(x || {}, { streamFiles: !1, compression: "STORE", compressionOptions: null, type: "", platform: "DOS", comment: null, mimeType: "application/zip", encodeFileName: s.utf8encode })).type = E.type.toLowerCase(), E.compression = E.compression.toUpperCase(), E.type === "binarystring" && (E.type = "string"), !E.type) throw new Error("No output type specified.");
            o.checkSupport(E.type), E.platform !== "darwin" && E.platform !== "freebsd" && E.platform !== "linux" && E.platform !== "sunos" || (E.platform = "UNIX"), E.platform === "win32" && (E.platform = "DOS");
            var U = E.comment || this.comment || "";
            T = d.generateWorker(this, E, U);
          } catch (D) {
            (T = new u("error")).error(D);
          }
          return new c(T, E.type || "string", E.mimeType);
        }, generateAsync: function(x, T) {
          return this.generateInternalStream(x).accumulate(T);
        }, generateNodeStream: function(x, T) {
          return (x = x || {}).type || (x.type = "nodebuffer"), this.generateInternalStream(x).toNodejsStream(T);
        } };
        i.exports = _;
      }, { "./compressedObject": 2, "./defaults": 5, "./generate": 9, "./nodejs/NodejsStreamInputAdapter": 12, "./nodejsUtils": 14, "./stream/GenericWorker": 28, "./stream/StreamHelper": 29, "./utf8": 31, "./utils": 32, "./zipObject": 35 }], 16: [function(t, i, r) {
        i.exports = t("stream");
      }, { stream: void 0 }], 17: [function(t, i, r) {
        var a = t("./DataReader");
        function s(o) {
          a.call(this, o);
          for (var u = 0; u < this.data.length; u++) o[u] = 255 & o[u];
        }
        t("../utils").inherits(s, a), s.prototype.byteAt = function(o) {
          return this.data[this.zero + o];
        }, s.prototype.lastIndexOfSignature = function(o) {
          for (var u = o.charCodeAt(0), c = o.charCodeAt(1), l = o.charCodeAt(2), h = o.charCodeAt(3), f = this.length - 4; 0 <= f; --f) if (this.data[f] === u && this.data[f + 1] === c && this.data[f + 2] === l && this.data[f + 3] === h) return f - this.zero;
          return -1;
        }, s.prototype.readAndCheckSignature = function(o) {
          var u = o.charCodeAt(0), c = o.charCodeAt(1), l = o.charCodeAt(2), h = o.charCodeAt(3), f = this.readData(4);
          return u === f[0] && c === f[1] && l === f[2] && h === f[3];
        }, s.prototype.readData = function(o) {
          if (this.checkOffset(o), o === 0) return [];
          var u = this.data.slice(this.zero + this.index, this.zero + this.index + o);
          return this.index += o, u;
        }, i.exports = s;
      }, { "../utils": 32, "./DataReader": 18 }], 18: [function(t, i, r) {
        var a = t("../utils");
        function s(o) {
          this.data = o, this.length = o.length, this.index = 0, this.zero = 0;
        }
        s.prototype = { checkOffset: function(o) {
          this.checkIndex(this.index + o);
        }, checkIndex: function(o) {
          if (this.length < this.zero + o || o < 0) throw new Error("End of data reached (data length = " + this.length + ", asked index = " + o + "). Corrupted zip ?");
        }, setIndex: function(o) {
          this.checkIndex(o), this.index = o;
        }, skip: function(o) {
          this.setIndex(this.index + o);
        }, byteAt: function() {
        }, readInt: function(o) {
          var u, c = 0;
          for (this.checkOffset(o), u = this.index + o - 1; u >= this.index; u--) c = (c << 8) + this.byteAt(u);
          return this.index += o, c;
        }, readString: function(o) {
          return a.transformTo("string", this.readData(o));
        }, readData: function() {
        }, lastIndexOfSignature: function() {
        }, readAndCheckSignature: function() {
        }, readDate: function() {
          var o = this.readInt(4);
          return new Date(Date.UTC(1980 + (o >> 25 & 127), (o >> 21 & 15) - 1, o >> 16 & 31, o >> 11 & 31, o >> 5 & 63, (31 & o) << 1));
        } }, i.exports = s;
      }, { "../utils": 32 }], 19: [function(t, i, r) {
        var a = t("./Uint8ArrayReader");
        function s(o) {
          a.call(this, o);
        }
        t("../utils").inherits(s, a), s.prototype.readData = function(o) {
          this.checkOffset(o);
          var u = this.data.slice(this.zero + this.index, this.zero + this.index + o);
          return this.index += o, u;
        }, i.exports = s;
      }, { "../utils": 32, "./Uint8ArrayReader": 21 }], 20: [function(t, i, r) {
        var a = t("./DataReader");
        function s(o) {
          a.call(this, o);
        }
        t("../utils").inherits(s, a), s.prototype.byteAt = function(o) {
          return this.data.charCodeAt(this.zero + o);
        }, s.prototype.lastIndexOfSignature = function(o) {
          return this.data.lastIndexOf(o) - this.zero;
        }, s.prototype.readAndCheckSignature = function(o) {
          return o === this.readData(4);
        }, s.prototype.readData = function(o) {
          this.checkOffset(o);
          var u = this.data.slice(this.zero + this.index, this.zero + this.index + o);
          return this.index += o, u;
        }, i.exports = s;
      }, { "../utils": 32, "./DataReader": 18 }], 21: [function(t, i, r) {
        var a = t("./ArrayReader");
        function s(o) {
          a.call(this, o);
        }
        t("../utils").inherits(s, a), s.prototype.readData = function(o) {
          if (this.checkOffset(o), o === 0) return new Uint8Array(0);
          var u = this.data.subarray(this.zero + this.index, this.zero + this.index + o);
          return this.index += o, u;
        }, i.exports = s;
      }, { "../utils": 32, "./ArrayReader": 17 }], 22: [function(t, i, r) {
        var a = t("../utils"), s = t("../support"), o = t("./ArrayReader"), u = t("./StringReader"), c = t("./NodeBufferReader"), l = t("./Uint8ArrayReader");
        i.exports = function(h) {
          var f = a.getTypeOf(h);
          return a.checkSupport(f), f !== "string" || s.uint8array ? f === "nodebuffer" ? new c(h) : s.uint8array ? new l(a.transformTo("uint8array", h)) : new o(a.transformTo("array", h)) : new u(h);
        };
      }, { "../support": 30, "../utils": 32, "./ArrayReader": 17, "./NodeBufferReader": 19, "./StringReader": 20, "./Uint8ArrayReader": 21 }], 23: [function(t, i, r) {
        r.LOCAL_FILE_HEADER = "PK", r.CENTRAL_FILE_HEADER = "PK", r.CENTRAL_DIRECTORY_END = "PK", r.ZIP64_CENTRAL_DIRECTORY_LOCATOR = "PK\x07", r.ZIP64_CENTRAL_DIRECTORY_END = "PK", r.DATA_DESCRIPTOR = "PK\x07\b";
      }, {}], 24: [function(t, i, r) {
        var a = t("./GenericWorker"), s = t("../utils");
        function o(u) {
          a.call(this, "ConvertWorker to " + u), this.destType = u;
        }
        s.inherits(o, a), o.prototype.processChunk = function(u) {
          this.push({ data: s.transformTo(this.destType, u.data), meta: u.meta });
        }, i.exports = o;
      }, { "../utils": 32, "./GenericWorker": 28 }], 25: [function(t, i, r) {
        var a = t("./GenericWorker"), s = t("../crc32");
        function o() {
          a.call(this, "Crc32Probe"), this.withStreamInfo("crc32", 0);
        }
        t("../utils").inherits(o, a), o.prototype.processChunk = function(u) {
          this.streamInfo.crc32 = s(u.data, this.streamInfo.crc32 || 0), this.push(u);
        }, i.exports = o;
      }, { "../crc32": 4, "../utils": 32, "./GenericWorker": 28 }], 26: [function(t, i, r) {
        var a = t("../utils"), s = t("./GenericWorker");
        function o(u) {
          s.call(this, "DataLengthProbe for " + u), this.propName = u, this.withStreamInfo(u, 0);
        }
        a.inherits(o, s), o.prototype.processChunk = function(u) {
          if (u) {
            var c = this.streamInfo[this.propName] || 0;
            this.streamInfo[this.propName] = c + u.data.length;
          }
          s.prototype.processChunk.call(this, u);
        }, i.exports = o;
      }, { "../utils": 32, "./GenericWorker": 28 }], 27: [function(t, i, r) {
        var a = t("../utils"), s = t("./GenericWorker");
        function o(u) {
          s.call(this, "DataWorker");
          var c = this;
          this.dataIsReady = !1, this.index = 0, this.max = 0, this.data = null, this.type = "", this._tickScheduled = !1, u.then(function(l) {
            c.dataIsReady = !0, c.data = l, c.max = l && l.length || 0, c.type = a.getTypeOf(l), c.isPaused || c._tickAndRepeat();
          }, function(l) {
            c.error(l);
          });
        }
        a.inherits(o, s), o.prototype.cleanUp = function() {
          s.prototype.cleanUp.call(this), this.data = null;
        }, o.prototype.resume = function() {
          return !!s.prototype.resume.call(this) && (!this._tickScheduled && this.dataIsReady && (this._tickScheduled = !0, a.delay(this._tickAndRepeat, [], this)), !0);
        }, o.prototype._tickAndRepeat = function() {
          this._tickScheduled = !1, this.isPaused || this.isFinished || (this._tick(), this.isFinished || (a.delay(this._tickAndRepeat, [], this), this._tickScheduled = !0));
        }, o.prototype._tick = function() {
          if (this.isPaused || this.isFinished) return !1;
          var u = null, c = Math.min(this.max, this.index + 16384);
          if (this.index >= this.max) return this.end();
          switch (this.type) {
            case "string":
              u = this.data.substring(this.index, c);
              break;
            case "uint8array":
              u = this.data.subarray(this.index, c);
              break;
            case "array":
            case "nodebuffer":
              u = this.data.slice(this.index, c);
          }
          return this.index = c, this.push({ data: u, meta: { percent: this.max ? this.index / this.max * 100 : 0 } });
        }, i.exports = o;
      }, { "../utils": 32, "./GenericWorker": 28 }], 28: [function(t, i, r) {
        function a(s) {
          this.name = s || "default", this.streamInfo = {}, this.generatedError = null, this.extraStreamInfo = {}, this.isPaused = !0, this.isFinished = !1, this.isLocked = !1, this._listeners = { data: [], end: [], error: [] }, this.previous = null;
        }
        a.prototype = { push: function(s) {
          this.emit("data", s);
        }, end: function() {
          if (this.isFinished) return !1;
          this.flush();
          try {
            this.emit("end"), this.cleanUp(), this.isFinished = !0;
          } catch (s) {
            this.emit("error", s);
          }
          return !0;
        }, error: function(s) {
          return !this.isFinished && (this.isPaused ? this.generatedError = s : (this.isFinished = !0, this.emit("error", s), this.previous && this.previous.error(s), this.cleanUp()), !0);
        }, on: function(s, o) {
          return this._listeners[s].push(o), this;
        }, cleanUp: function() {
          this.streamInfo = this.generatedError = this.extraStreamInfo = null, this._listeners = [];
        }, emit: function(s, o) {
          if (this._listeners[s]) for (var u = 0; u < this._listeners[s].length; u++) this._listeners[s][u].call(this, o);
        }, pipe: function(s) {
          return s.registerPrevious(this);
        }, registerPrevious: function(s) {
          if (this.isLocked) throw new Error("The stream '" + this + "' has already been used.");
          this.streamInfo = s.streamInfo, this.mergeStreamInfo(), this.previous = s;
          var o = this;
          return s.on("data", function(u) {
            o.processChunk(u);
          }), s.on("end", function() {
            o.end();
          }), s.on("error", function(u) {
            o.error(u);
          }), this;
        }, pause: function() {
          return !this.isPaused && !this.isFinished && (this.isPaused = !0, this.previous && this.previous.pause(), !0);
        }, resume: function() {
          if (!this.isPaused || this.isFinished) return !1;
          var s = this.isPaused = !1;
          return this.generatedError && (this.error(this.generatedError), s = !0), this.previous && this.previous.resume(), !s;
        }, flush: function() {
        }, processChunk: function(s) {
          this.push(s);
        }, withStreamInfo: function(s, o) {
          return this.extraStreamInfo[s] = o, this.mergeStreamInfo(), this;
        }, mergeStreamInfo: function() {
          for (var s in this.extraStreamInfo) Object.prototype.hasOwnProperty.call(this.extraStreamInfo, s) && (this.streamInfo[s] = this.extraStreamInfo[s]);
        }, lock: function() {
          if (this.isLocked) throw new Error("The stream '" + this + "' has already been used.");
          this.isLocked = !0, this.previous && this.previous.lock();
        }, toString: function() {
          var s = "Worker " + this.name;
          return this.previous ? this.previous + " -> " + s : s;
        } }, i.exports = a;
      }, {}], 29: [function(t, i, r) {
        var a = t("../utils"), s = t("./ConvertWorker"), o = t("./GenericWorker"), u = t("../base64"), c = t("../support"), l = t("../external"), h = null;
        if (c.nodestream) try {
          h = t("../nodejs/NodejsStreamOutputAdapter");
        } catch {
        }
        function f(y, m) {
          return new l.Promise(function(b, p) {
            var g = [], v = y._internalType, _ = y._outputType, x = y._mimeType;
            y.on("data", function(T, E) {
              g.push(T), m && m(E);
            }).on("error", function(T) {
              g = [], p(T);
            }).on("end", function() {
              try {
                var T = (function(E, U, D) {
                  switch (E) {
                    case "blob":
                      return a.newBlob(a.transformTo("arraybuffer", U), D);
                    case "base64":
                      return u.encode(U);
                    default:
                      return a.transformTo(E, U);
                  }
                })(_, (function(E, U) {
                  var D, L = 0, j = null, C = 0;
                  for (D = 0; D < U.length; D++) C += U[D].length;
                  switch (E) {
                    case "string":
                      return U.join("");
                    case "array":
                      return Array.prototype.concat.apply([], U);
                    case "uint8array":
                      for (j = new Uint8Array(C), D = 0; D < U.length; D++) j.set(U[D], L), L += U[D].length;
                      return j;
                    case "nodebuffer":
                      return Buffer.concat(U);
                    default:
                      throw new Error("concat : unsupported type '" + E + "'");
                  }
                })(v, g), x);
                b(T);
              } catch (E) {
                p(E);
              }
              g = [];
            }).resume();
          });
        }
        function d(y, m, b) {
          var p = m;
          switch (m) {
            case "blob":
            case "arraybuffer":
              p = "uint8array";
              break;
            case "base64":
              p = "string";
          }
          try {
            this._internalType = p, this._outputType = m, this._mimeType = b, a.checkSupport(p), this._worker = y.pipe(new s(p)), y.lock();
          } catch (g) {
            this._worker = new o("error"), this._worker.error(g);
          }
        }
        d.prototype = { accumulate: function(y) {
          return f(this, y);
        }, on: function(y, m) {
          var b = this;
          return y === "data" ? this._worker.on(y, function(p) {
            m.call(b, p.data, p.meta);
          }) : this._worker.on(y, function() {
            a.delay(m, arguments, b);
          }), this;
        }, resume: function() {
          return a.delay(this._worker.resume, [], this._worker), this;
        }, pause: function() {
          return this._worker.pause(), this;
        }, toNodejsStream: function(y) {
          if (a.checkSupport("nodestream"), this._outputType !== "nodebuffer") throw new Error(this._outputType + " is not supported by this method");
          return new h(this, { objectMode: this._outputType !== "nodebuffer" }, y);
        } }, i.exports = d;
      }, { "../base64": 1, "../external": 6, "../nodejs/NodejsStreamOutputAdapter": 13, "../support": 30, "../utils": 32, "./ConvertWorker": 24, "./GenericWorker": 28 }], 30: [function(t, i, r) {
        if (r.base64 = !0, r.array = !0, r.string = !0, r.arraybuffer = typeof ArrayBuffer < "u" && typeof Uint8Array < "u", r.nodebuffer = typeof Buffer < "u", r.uint8array = typeof Uint8Array < "u", typeof ArrayBuffer > "u") r.blob = !1;
        else {
          var a = new ArrayBuffer(0);
          try {
            r.blob = new Blob([a], { type: "application/zip" }).size === 0;
          } catch {
            try {
              var s = new (self.BlobBuilder || self.WebKitBlobBuilder || self.MozBlobBuilder || self.MSBlobBuilder)();
              s.append(a), r.blob = s.getBlob("application/zip").size === 0;
            } catch {
              r.blob = !1;
            }
          }
        }
        try {
          r.nodestream = !!t("readable-stream").Readable;
        } catch {
          r.nodestream = !1;
        }
      }, { "readable-stream": 16 }], 31: [function(t, i, r) {
        for (var a = t("./utils"), s = t("./support"), o = t("./nodejsUtils"), u = t("./stream/GenericWorker"), c = new Array(256), l = 0; l < 256; l++) c[l] = 252 <= l ? 6 : 248 <= l ? 5 : 240 <= l ? 4 : 224 <= l ? 3 : 192 <= l ? 2 : 1;
        c[254] = c[254] = 1;
        function h() {
          u.call(this, "utf-8 decode"), this.leftOver = null;
        }
        function f() {
          u.call(this, "utf-8 encode");
        }
        r.utf8encode = function(d) {
          return s.nodebuffer ? o.newBufferFrom(d, "utf-8") : (function(y) {
            var m, b, p, g, v, _ = y.length, x = 0;
            for (g = 0; g < _; g++) (64512 & (b = y.charCodeAt(g))) == 55296 && g + 1 < _ && (64512 & (p = y.charCodeAt(g + 1))) == 56320 && (b = 65536 + (b - 55296 << 10) + (p - 56320), g++), x += b < 128 ? 1 : b < 2048 ? 2 : b < 65536 ? 3 : 4;
            for (m = s.uint8array ? new Uint8Array(x) : new Array(x), g = v = 0; v < x; g++) (64512 & (b = y.charCodeAt(g))) == 55296 && g + 1 < _ && (64512 & (p = y.charCodeAt(g + 1))) == 56320 && (b = 65536 + (b - 55296 << 10) + (p - 56320), g++), b < 128 ? m[v++] = b : (b < 2048 ? m[v++] = 192 | b >>> 6 : (b < 65536 ? m[v++] = 224 | b >>> 12 : (m[v++] = 240 | b >>> 18, m[v++] = 128 | b >>> 12 & 63), m[v++] = 128 | b >>> 6 & 63), m[v++] = 128 | 63 & b);
            return m;
          })(d);
        }, r.utf8decode = function(d) {
          return s.nodebuffer ? a.transformTo("nodebuffer", d).toString("utf-8") : (function(y) {
            var m, b, p, g, v = y.length, _ = new Array(2 * v);
            for (m = b = 0; m < v; ) if ((p = y[m++]) < 128) _[b++] = p;
            else if (4 < (g = c[p])) _[b++] = 65533, m += g - 1;
            else {
              for (p &= g === 2 ? 31 : g === 3 ? 15 : 7; 1 < g && m < v; ) p = p << 6 | 63 & y[m++], g--;
              1 < g ? _[b++] = 65533 : p < 65536 ? _[b++] = p : (p -= 65536, _[b++] = 55296 | p >> 10 & 1023, _[b++] = 56320 | 1023 & p);
            }
            return _.length !== b && (_.subarray ? _ = _.subarray(0, b) : _.length = b), a.applyFromCharCode(_);
          })(d = a.transformTo(s.uint8array ? "uint8array" : "array", d));
        }, a.inherits(h, u), h.prototype.processChunk = function(d) {
          var y = a.transformTo(s.uint8array ? "uint8array" : "array", d.data);
          if (this.leftOver && this.leftOver.length) {
            if (s.uint8array) {
              var m = y;
              (y = new Uint8Array(m.length + this.leftOver.length)).set(this.leftOver, 0), y.set(m, this.leftOver.length);
            } else y = this.leftOver.concat(y);
            this.leftOver = null;
          }
          var b = (function(g, v) {
            var _;
            for ((v = v || g.length) > g.length && (v = g.length), _ = v - 1; 0 <= _ && (192 & g[_]) == 128; ) _--;
            return _ < 0 || _ === 0 ? v : _ + c[g[_]] > v ? _ : v;
          })(y), p = y;
          b !== y.length && (s.uint8array ? (p = y.subarray(0, b), this.leftOver = y.subarray(b, y.length)) : (p = y.slice(0, b), this.leftOver = y.slice(b, y.length))), this.push({ data: r.utf8decode(p), meta: d.meta });
        }, h.prototype.flush = function() {
          this.leftOver && this.leftOver.length && (this.push({ data: r.utf8decode(this.leftOver), meta: {} }), this.leftOver = null);
        }, r.Utf8DecodeWorker = h, a.inherits(f, u), f.prototype.processChunk = function(d) {
          this.push({ data: r.utf8encode(d.data), meta: d.meta });
        }, r.Utf8EncodeWorker = f;
      }, { "./nodejsUtils": 14, "./stream/GenericWorker": 28, "./support": 30, "./utils": 32 }], 32: [function(t, i, r) {
        var a = t("./support"), s = t("./base64"), o = t("./nodejsUtils"), u = t("./external");
        function c(m) {
          return m;
        }
        function l(m, b) {
          for (var p = 0; p < m.length; ++p) b[p] = 255 & m.charCodeAt(p);
          return b;
        }
        t("setimmediate"), r.newBlob = function(m, b) {
          r.checkSupport("blob");
          try {
            return new Blob([m], { type: b });
          } catch {
            try {
              var p = new (self.BlobBuilder || self.WebKitBlobBuilder || self.MozBlobBuilder || self.MSBlobBuilder)();
              return p.append(m), p.getBlob(b);
            } catch {
              throw new Error("Bug : can't construct the Blob.");
            }
          }
        };
        var h = { stringifyByChunk: function(m, b, p) {
          var g = [], v = 0, _ = m.length;
          if (_ <= p) return String.fromCharCode.apply(null, m);
          for (; v < _; ) b === "array" || b === "nodebuffer" ? g.push(String.fromCharCode.apply(null, m.slice(v, Math.min(v + p, _)))) : g.push(String.fromCharCode.apply(null, m.subarray(v, Math.min(v + p, _)))), v += p;
          return g.join("");
        }, stringifyByChar: function(m) {
          for (var b = "", p = 0; p < m.length; p++) b += String.fromCharCode(m[p]);
          return b;
        }, applyCanBeUsed: { uint8array: (function() {
          try {
            return a.uint8array && String.fromCharCode.apply(null, new Uint8Array(1)).length === 1;
          } catch {
            return !1;
          }
        })(), nodebuffer: (function() {
          try {
            return a.nodebuffer && String.fromCharCode.apply(null, o.allocBuffer(1)).length === 1;
          } catch {
            return !1;
          }
        })() } };
        function f(m) {
          var b = 65536, p = r.getTypeOf(m), g = !0;
          if (p === "uint8array" ? g = h.applyCanBeUsed.uint8array : p === "nodebuffer" && (g = h.applyCanBeUsed.nodebuffer), g) for (; 1 < b; ) try {
            return h.stringifyByChunk(m, p, b);
          } catch {
            b = Math.floor(b / 2);
          }
          return h.stringifyByChar(m);
        }
        function d(m, b) {
          for (var p = 0; p < m.length; p++) b[p] = m[p];
          return b;
        }
        r.applyFromCharCode = f;
        var y = {};
        y.string = { string: c, array: function(m) {
          return l(m, new Array(m.length));
        }, arraybuffer: function(m) {
          return y.string.uint8array(m).buffer;
        }, uint8array: function(m) {
          return l(m, new Uint8Array(m.length));
        }, nodebuffer: function(m) {
          return l(m, o.allocBuffer(m.length));
        } }, y.array = { string: f, array: c, arraybuffer: function(m) {
          return new Uint8Array(m).buffer;
        }, uint8array: function(m) {
          return new Uint8Array(m);
        }, nodebuffer: function(m) {
          return o.newBufferFrom(m);
        } }, y.arraybuffer = { string: function(m) {
          return f(new Uint8Array(m));
        }, array: function(m) {
          return d(new Uint8Array(m), new Array(m.byteLength));
        }, arraybuffer: c, uint8array: function(m) {
          return new Uint8Array(m);
        }, nodebuffer: function(m) {
          return o.newBufferFrom(new Uint8Array(m));
        } }, y.uint8array = { string: f, array: function(m) {
          return d(m, new Array(m.length));
        }, arraybuffer: function(m) {
          return m.buffer;
        }, uint8array: c, nodebuffer: function(m) {
          return o.newBufferFrom(m);
        } }, y.nodebuffer = { string: f, array: function(m) {
          return d(m, new Array(m.length));
        }, arraybuffer: function(m) {
          return y.nodebuffer.uint8array(m).buffer;
        }, uint8array: function(m) {
          return d(m, new Uint8Array(m.length));
        }, nodebuffer: c }, r.transformTo = function(m, b) {
          if (b = b || "", !m) return b;
          r.checkSupport(m);
          var p = r.getTypeOf(b);
          return y[p][m](b);
        }, r.resolve = function(m) {
          for (var b = m.split("/"), p = [], g = 0; g < b.length; g++) {
            var v = b[g];
            v === "." || v === "" && g !== 0 && g !== b.length - 1 || (v === ".." ? p.pop() : p.push(v));
          }
          return p.join("/");
        }, r.getTypeOf = function(m) {
          return typeof m == "string" ? "string" : Object.prototype.toString.call(m) === "[object Array]" ? "array" : a.nodebuffer && o.isBuffer(m) ? "nodebuffer" : a.uint8array && m instanceof Uint8Array ? "uint8array" : a.arraybuffer && m instanceof ArrayBuffer ? "arraybuffer" : void 0;
        }, r.checkSupport = function(m) {
          if (!a[m.toLowerCase()]) throw new Error(m + " is not supported by this platform");
        }, r.MAX_VALUE_16BITS = 65535, r.MAX_VALUE_32BITS = -1, r.pretty = function(m) {
          var b, p, g = "";
          for (p = 0; p < (m || "").length; p++) g += "\\x" + ((b = m.charCodeAt(p)) < 16 ? "0" : "") + b.toString(16).toUpperCase();
          return g;
        }, r.delay = function(m, b, p) {
          setImmediate(function() {
            m.apply(p || null, b || []);
          });
        }, r.inherits = function(m, b) {
          function p() {
          }
          p.prototype = b.prototype, m.prototype = new p();
        }, r.extend = function() {
          var m, b, p = {};
          for (m = 0; m < arguments.length; m++) for (b in arguments[m]) Object.prototype.hasOwnProperty.call(arguments[m], b) && p[b] === void 0 && (p[b] = arguments[m][b]);
          return p;
        }, r.prepareContent = function(m, b, p, g, v) {
          return u.Promise.resolve(b).then(function(_) {
            return a.blob && (_ instanceof Blob || ["[object File]", "[object Blob]"].indexOf(Object.prototype.toString.call(_)) !== -1) && typeof FileReader < "u" ? new u.Promise(function(x, T) {
              var E = new FileReader();
              E.onload = function(U) {
                x(U.target.result);
              }, E.onerror = function(U) {
                T(U.target.error);
              }, E.readAsArrayBuffer(_);
            }) : _;
          }).then(function(_) {
            var x = r.getTypeOf(_);
            return x ? (x === "arraybuffer" ? _ = r.transformTo("uint8array", _) : x === "string" && (v ? _ = s.decode(_) : p && g !== !0 && (_ = (function(T) {
              return l(T, a.uint8array ? new Uint8Array(T.length) : new Array(T.length));
            })(_))), _) : u.Promise.reject(new Error("Can't read the data of '" + m + "'. Is it in a supported JavaScript type (String, Blob, ArrayBuffer, etc) ?"));
          });
        };
      }, { "./base64": 1, "./external": 6, "./nodejsUtils": 14, "./support": 30, setimmediate: 54 }], 33: [function(t, i, r) {
        var a = t("./reader/readerFor"), s = t("./utils"), o = t("./signature"), u = t("./zipEntry"), c = t("./support");
        function l(h) {
          this.files = [], this.loadOptions = h;
        }
        l.prototype = { checkSignature: function(h) {
          if (!this.reader.readAndCheckSignature(h)) {
            this.reader.index -= 4;
            var f = this.reader.readString(4);
            throw new Error("Corrupted zip or bug: unexpected signature (" + s.pretty(f) + ", expected " + s.pretty(h) + ")");
          }
        }, isSignature: function(h, f) {
          var d = this.reader.index;
          this.reader.setIndex(h);
          var y = this.reader.readString(4) === f;
          return this.reader.setIndex(d), y;
        }, readBlockEndOfCentral: function() {
          this.diskNumber = this.reader.readInt(2), this.diskWithCentralDirStart = this.reader.readInt(2), this.centralDirRecordsOnThisDisk = this.reader.readInt(2), this.centralDirRecords = this.reader.readInt(2), this.centralDirSize = this.reader.readInt(4), this.centralDirOffset = this.reader.readInt(4), this.zipCommentLength = this.reader.readInt(2);
          var h = this.reader.readData(this.zipCommentLength), f = c.uint8array ? "uint8array" : "array", d = s.transformTo(f, h);
          this.zipComment = this.loadOptions.decodeFileName(d);
        }, readBlockZip64EndOfCentral: function() {
          this.zip64EndOfCentralSize = this.reader.readInt(8), this.reader.skip(4), this.diskNumber = this.reader.readInt(4), this.diskWithCentralDirStart = this.reader.readInt(4), this.centralDirRecordsOnThisDisk = this.reader.readInt(8), this.centralDirRecords = this.reader.readInt(8), this.centralDirSize = this.reader.readInt(8), this.centralDirOffset = this.reader.readInt(8), this.zip64ExtensibleData = {};
          for (var h, f, d, y = this.zip64EndOfCentralSize - 44; 0 < y; ) h = this.reader.readInt(2), f = this.reader.readInt(4), d = this.reader.readData(f), this.zip64ExtensibleData[h] = { id: h, length: f, value: d };
        }, readBlockZip64EndOfCentralLocator: function() {
          if (this.diskWithZip64CentralDirStart = this.reader.readInt(4), this.relativeOffsetEndOfZip64CentralDir = this.reader.readInt(8), this.disksCount = this.reader.readInt(4), 1 < this.disksCount) throw new Error("Multi-volumes zip are not supported");
        }, readLocalFiles: function() {
          var h, f;
          for (h = 0; h < this.files.length; h++) f = this.files[h], this.reader.setIndex(f.localHeaderOffset), this.checkSignature(o.LOCAL_FILE_HEADER), f.readLocalPart(this.reader), f.handleUTF8(), f.processAttributes();
        }, readCentralDir: function() {
          var h;
          for (this.reader.setIndex(this.centralDirOffset); this.reader.readAndCheckSignature(o.CENTRAL_FILE_HEADER); ) (h = new u({ zip64: this.zip64 }, this.loadOptions)).readCentralPart(this.reader), this.files.push(h);
          if (this.centralDirRecords !== this.files.length && this.centralDirRecords !== 0 && this.files.length === 0) throw new Error("Corrupted zip or bug: expected " + this.centralDirRecords + " records in central dir, got " + this.files.length);
        }, readEndOfCentral: function() {
          var h = this.reader.lastIndexOfSignature(o.CENTRAL_DIRECTORY_END);
          if (h < 0) throw this.isSignature(0, o.LOCAL_FILE_HEADER) ? new Error("Corrupted zip: can't find end of central directory") : new Error("Can't find end of central directory : is this a zip file ? If it is, see https://stuk.github.io/jszip/documentation/howto/read_zip.html");
          this.reader.setIndex(h);
          var f = h;
          if (this.checkSignature(o.CENTRAL_DIRECTORY_END), this.readBlockEndOfCentral(), this.diskNumber === s.MAX_VALUE_16BITS || this.diskWithCentralDirStart === s.MAX_VALUE_16BITS || this.centralDirRecordsOnThisDisk === s.MAX_VALUE_16BITS || this.centralDirRecords === s.MAX_VALUE_16BITS || this.centralDirSize === s.MAX_VALUE_32BITS || this.centralDirOffset === s.MAX_VALUE_32BITS) {
            if (this.zip64 = !0, (h = this.reader.lastIndexOfSignature(o.ZIP64_CENTRAL_DIRECTORY_LOCATOR)) < 0) throw new Error("Corrupted zip: can't find the ZIP64 end of central directory locator");
            if (this.reader.setIndex(h), this.checkSignature(o.ZIP64_CENTRAL_DIRECTORY_LOCATOR), this.readBlockZip64EndOfCentralLocator(), !this.isSignature(this.relativeOffsetEndOfZip64CentralDir, o.ZIP64_CENTRAL_DIRECTORY_END) && (this.relativeOffsetEndOfZip64CentralDir = this.reader.lastIndexOfSignature(o.ZIP64_CENTRAL_DIRECTORY_END), this.relativeOffsetEndOfZip64CentralDir < 0)) throw new Error("Corrupted zip: can't find the ZIP64 end of central directory");
            this.reader.setIndex(this.relativeOffsetEndOfZip64CentralDir), this.checkSignature(o.ZIP64_CENTRAL_DIRECTORY_END), this.readBlockZip64EndOfCentral();
          }
          var d = this.centralDirOffset + this.centralDirSize;
          this.zip64 && (d += 20, d += 12 + this.zip64EndOfCentralSize);
          var y = f - d;
          if (0 < y) this.isSignature(f, o.CENTRAL_FILE_HEADER) || (this.reader.zero = y);
          else if (y < 0) throw new Error("Corrupted zip: missing " + Math.abs(y) + " bytes.");
        }, prepareReader: function(h) {
          this.reader = a(h);
        }, load: function(h) {
          this.prepareReader(h), this.readEndOfCentral(), this.readCentralDir(), this.readLocalFiles();
        } }, i.exports = l;
      }, { "./reader/readerFor": 22, "./signature": 23, "./support": 30, "./utils": 32, "./zipEntry": 34 }], 34: [function(t, i, r) {
        var a = t("./reader/readerFor"), s = t("./utils"), o = t("./compressedObject"), u = t("./crc32"), c = t("./utf8"), l = t("./compressions"), h = t("./support");
        function f(d, y) {
          this.options = d, this.loadOptions = y;
        }
        f.prototype = { isEncrypted: function() {
          return (1 & this.bitFlag) == 1;
        }, useUTF8: function() {
          return (2048 & this.bitFlag) == 2048;
        }, readLocalPart: function(d) {
          var y, m;
          if (d.skip(22), this.fileNameLength = d.readInt(2), m = d.readInt(2), this.fileName = d.readData(this.fileNameLength), d.skip(m), this.compressedSize === -1 || this.uncompressedSize === -1) throw new Error("Bug or corrupted zip : didn't get enough information from the central directory (compressedSize === -1 || uncompressedSize === -1)");
          if ((y = (function(b) {
            for (var p in l) if (Object.prototype.hasOwnProperty.call(l, p) && l[p].magic === b) return l[p];
            return null;
          })(this.compressionMethod)) === null) throw new Error("Corrupted zip : compression " + s.pretty(this.compressionMethod) + " unknown (inner file : " + s.transformTo("string", this.fileName) + ")");
          this.decompressed = new o(this.compressedSize, this.uncompressedSize, this.crc32, y, d.readData(this.compressedSize));
        }, readCentralPart: function(d) {
          this.versionMadeBy = d.readInt(2), d.skip(2), this.bitFlag = d.readInt(2), this.compressionMethod = d.readString(2), this.date = d.readDate(), this.crc32 = d.readInt(4), this.compressedSize = d.readInt(4), this.uncompressedSize = d.readInt(4);
          var y = d.readInt(2);
          if (this.extraFieldsLength = d.readInt(2), this.fileCommentLength = d.readInt(2), this.diskNumberStart = d.readInt(2), this.internalFileAttributes = d.readInt(2), this.externalFileAttributes = d.readInt(4), this.localHeaderOffset = d.readInt(4), this.isEncrypted()) throw new Error("Encrypted zip are not supported");
          d.skip(y), this.readExtraFields(d), this.parseZIP64ExtraField(d), this.fileComment = d.readData(this.fileCommentLength);
        }, processAttributes: function() {
          this.unixPermissions = null, this.dosPermissions = null;
          var d = this.versionMadeBy >> 8;
          this.dir = !!(16 & this.externalFileAttributes), d == 0 && (this.dosPermissions = 63 & this.externalFileAttributes), d == 3 && (this.unixPermissions = this.externalFileAttributes >> 16 & 65535), this.dir || this.fileNameStr.slice(-1) !== "/" || (this.dir = !0);
        }, parseZIP64ExtraField: function() {
          if (this.extraFields[1]) {
            var d = a(this.extraFields[1].value);
            this.uncompressedSize === s.MAX_VALUE_32BITS && (this.uncompressedSize = d.readInt(8)), this.compressedSize === s.MAX_VALUE_32BITS && (this.compressedSize = d.readInt(8)), this.localHeaderOffset === s.MAX_VALUE_32BITS && (this.localHeaderOffset = d.readInt(8)), this.diskNumberStart === s.MAX_VALUE_32BITS && (this.diskNumberStart = d.readInt(4));
          }
        }, readExtraFields: function(d) {
          var y, m, b, p = d.index + this.extraFieldsLength;
          for (this.extraFields || (this.extraFields = {}); d.index + 4 < p; ) y = d.readInt(2), m = d.readInt(2), b = d.readData(m), this.extraFields[y] = { id: y, length: m, value: b };
          d.setIndex(p);
        }, handleUTF8: function() {
          var d = h.uint8array ? "uint8array" : "array";
          if (this.useUTF8()) this.fileNameStr = c.utf8decode(this.fileName), this.fileCommentStr = c.utf8decode(this.fileComment);
          else {
            var y = this.findExtraFieldUnicodePath();
            if (y !== null) this.fileNameStr = y;
            else {
              var m = s.transformTo(d, this.fileName);
              this.fileNameStr = this.loadOptions.decodeFileName(m);
            }
            var b = this.findExtraFieldUnicodeComment();
            if (b !== null) this.fileCommentStr = b;
            else {
              var p = s.transformTo(d, this.fileComment);
              this.fileCommentStr = this.loadOptions.decodeFileName(p);
            }
          }
        }, findExtraFieldUnicodePath: function() {
          var d = this.extraFields[28789];
          if (d) {
            var y = a(d.value);
            return y.readInt(1) !== 1 || u(this.fileName) !== y.readInt(4) ? null : c.utf8decode(y.readData(d.length - 5));
          }
          return null;
        }, findExtraFieldUnicodeComment: function() {
          var d = this.extraFields[25461];
          if (d) {
            var y = a(d.value);
            return y.readInt(1) !== 1 || u(this.fileComment) !== y.readInt(4) ? null : c.utf8decode(y.readData(d.length - 5));
          }
          return null;
        } }, i.exports = f;
      }, { "./compressedObject": 2, "./compressions": 3, "./crc32": 4, "./reader/readerFor": 22, "./support": 30, "./utf8": 31, "./utils": 32 }], 35: [function(t, i, r) {
        function a(y, m, b) {
          this.name = y, this.dir = b.dir, this.date = b.date, this.comment = b.comment, this.unixPermissions = b.unixPermissions, this.dosPermissions = b.dosPermissions, this._data = m, this._dataBinary = b.binary, this.options = { compression: b.compression, compressionOptions: b.compressionOptions };
        }
        var s = t("./stream/StreamHelper"), o = t("./stream/DataWorker"), u = t("./utf8"), c = t("./compressedObject"), l = t("./stream/GenericWorker");
        a.prototype = { internalStream: function(y) {
          var m = null, b = "string";
          try {
            if (!y) throw new Error("No output type specified.");
            var p = (b = y.toLowerCase()) === "string" || b === "text";
            b !== "binarystring" && b !== "text" || (b = "string"), m = this._decompressWorker();
            var g = !this._dataBinary;
            g && !p && (m = m.pipe(new u.Utf8EncodeWorker())), !g && p && (m = m.pipe(new u.Utf8DecodeWorker()));
          } catch (v) {
            (m = new l("error")).error(v);
          }
          return new s(m, b, "");
        }, async: function(y, m) {
          return this.internalStream(y).accumulate(m);
        }, nodeStream: function(y, m) {
          return this.internalStream(y || "nodebuffer").toNodejsStream(m);
        }, _compressWorker: function(y, m) {
          if (this._data instanceof c && this._data.compression.magic === y.magic) return this._data.getCompressedWorker();
          var b = this._decompressWorker();
          return this._dataBinary || (b = b.pipe(new u.Utf8EncodeWorker())), c.createWorkerFrom(b, y, m);
        }, _decompressWorker: function() {
          return this._data instanceof c ? this._data.getContentWorker() : this._data instanceof l ? this._data : new o(this._data);
        } };
        for (var h = ["asText", "asBinary", "asNodeBuffer", "asUint8Array", "asArrayBuffer"], f = function() {
          throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
        }, d = 0; d < h.length; d++) a.prototype[h[d]] = f;
        i.exports = a;
      }, { "./compressedObject": 2, "./stream/DataWorker": 27, "./stream/GenericWorker": 28, "./stream/StreamHelper": 29, "./utf8": 31 }], 36: [function(t, i, r) {
        (function(a) {
          var s, o, u = a.MutationObserver || a.WebKitMutationObserver;
          if (u) {
            var c = 0, l = new u(y), h = a.document.createTextNode("");
            l.observe(h, { characterData: !0 }), s = function() {
              h.data = c = ++c % 2;
            };
          } else if (a.setImmediate || a.MessageChannel === void 0) s = "document" in a && "onreadystatechange" in a.document.createElement("script") ? function() {
            var m = a.document.createElement("script");
            m.onreadystatechange = function() {
              y(), m.onreadystatechange = null, m.parentNode.removeChild(m), m = null;
            }, a.document.documentElement.appendChild(m);
          } : function() {
            setTimeout(y, 0);
          };
          else {
            var f = new a.MessageChannel();
            f.port1.onmessage = y, s = function() {
              f.port2.postMessage(0);
            };
          }
          var d = [];
          function y() {
            var m, b;
            o = !0;
            for (var p = d.length; p; ) {
              for (b = d, d = [], m = -1; ++m < p; ) b[m]();
              p = d.length;
            }
            o = !1;
          }
          i.exports = function(m) {
            d.push(m) !== 1 || o || s();
          };
        }).call(this, typeof At < "u" ? At : typeof self < "u" ? self : typeof window < "u" ? window : {});
      }, {}], 37: [function(t, i, r) {
        var a = t("immediate");
        function s() {
        }
        var o = {}, u = ["REJECTED"], c = ["FULFILLED"], l = ["PENDING"];
        function h(p) {
          if (typeof p != "function") throw new TypeError("resolver must be a function");
          this.state = l, this.queue = [], this.outcome = void 0, p !== s && m(this, p);
        }
        function f(p, g, v) {
          this.promise = p, typeof g == "function" && (this.onFulfilled = g, this.callFulfilled = this.otherCallFulfilled), typeof v == "function" && (this.onRejected = v, this.callRejected = this.otherCallRejected);
        }
        function d(p, g, v) {
          a(function() {
            var _;
            try {
              _ = g(v);
            } catch (x) {
              return o.reject(p, x);
            }
            _ === p ? o.reject(p, new TypeError("Cannot resolve promise with itself")) : o.resolve(p, _);
          });
        }
        function y(p) {
          var g = p && p.then;
          if (p && (typeof p == "object" || typeof p == "function") && typeof g == "function") return function() {
            g.apply(p, arguments);
          };
        }
        function m(p, g) {
          var v = !1;
          function _(E) {
            v || (v = !0, o.reject(p, E));
          }
          function x(E) {
            v || (v = !0, o.resolve(p, E));
          }
          var T = b(function() {
            g(x, _);
          });
          T.status === "error" && _(T.value);
        }
        function b(p, g) {
          var v = {};
          try {
            v.value = p(g), v.status = "success";
          } catch (_) {
            v.status = "error", v.value = _;
          }
          return v;
        }
        (i.exports = h).prototype.finally = function(p) {
          if (typeof p != "function") return this;
          var g = this.constructor;
          return this.then(function(v) {
            return g.resolve(p()).then(function() {
              return v;
            });
          }, function(v) {
            return g.resolve(p()).then(function() {
              throw v;
            });
          });
        }, h.prototype.catch = function(p) {
          return this.then(null, p);
        }, h.prototype.then = function(p, g) {
          if (typeof p != "function" && this.state === c || typeof g != "function" && this.state === u) return this;
          var v = new this.constructor(s);
          return this.state !== l ? d(v, this.state === c ? p : g, this.outcome) : this.queue.push(new f(v, p, g)), v;
        }, f.prototype.callFulfilled = function(p) {
          o.resolve(this.promise, p);
        }, f.prototype.otherCallFulfilled = function(p) {
          d(this.promise, this.onFulfilled, p);
        }, f.prototype.callRejected = function(p) {
          o.reject(this.promise, p);
        }, f.prototype.otherCallRejected = function(p) {
          d(this.promise, this.onRejected, p);
        }, o.resolve = function(p, g) {
          var v = b(y, g);
          if (v.status === "error") return o.reject(p, v.value);
          var _ = v.value;
          if (_) m(p, _);
          else {
            p.state = c, p.outcome = g;
            for (var x = -1, T = p.queue.length; ++x < T; ) p.queue[x].callFulfilled(g);
          }
          return p;
        }, o.reject = function(p, g) {
          p.state = u, p.outcome = g;
          for (var v = -1, _ = p.queue.length; ++v < _; ) p.queue[v].callRejected(g);
          return p;
        }, h.resolve = function(p) {
          return p instanceof this ? p : o.resolve(new this(s), p);
        }, h.reject = function(p) {
          var g = new this(s);
          return o.reject(g, p);
        }, h.all = function(p) {
          var g = this;
          if (Object.prototype.toString.call(p) !== "[object Array]") return this.reject(new TypeError("must be an array"));
          var v = p.length, _ = !1;
          if (!v) return this.resolve([]);
          for (var x = new Array(v), T = 0, E = -1, U = new this(s); ++E < v; ) D(p[E], E);
          return U;
          function D(L, j) {
            g.resolve(L).then(function(C) {
              x[j] = C, ++T !== v || _ || (_ = !0, o.resolve(U, x));
            }, function(C) {
              _ || (_ = !0, o.reject(U, C));
            });
          }
        }, h.race = function(p) {
          var g = this;
          if (Object.prototype.toString.call(p) !== "[object Array]") return this.reject(new TypeError("must be an array"));
          var v = p.length, _ = !1;
          if (!v) return this.resolve([]);
          for (var x = -1, T = new this(s); ++x < v; ) E = p[x], g.resolve(E).then(function(U) {
            _ || (_ = !0, o.resolve(T, U));
          }, function(U) {
            _ || (_ = !0, o.reject(T, U));
          });
          var E;
          return T;
        };
      }, { immediate: 36 }], 38: [function(t, i, r) {
        var a = {};
        (0, t("./lib/utils/common").assign)(a, t("./lib/deflate"), t("./lib/inflate"), t("./lib/zlib/constants")), i.exports = a;
      }, { "./lib/deflate": 39, "./lib/inflate": 40, "./lib/utils/common": 41, "./lib/zlib/constants": 44 }], 39: [function(t, i, r) {
        var a = t("./zlib/deflate"), s = t("./utils/common"), o = t("./utils/strings"), u = t("./zlib/messages"), c = t("./zlib/zstream"), l = Object.prototype.toString, h = 0, f = -1, d = 0, y = 8;
        function m(p) {
          if (!(this instanceof m)) return new m(p);
          this.options = s.assign({ level: f, method: y, chunkSize: 16384, windowBits: 15, memLevel: 8, strategy: d, to: "" }, p || {});
          var g = this.options;
          g.raw && 0 < g.windowBits ? g.windowBits = -g.windowBits : g.gzip && 0 < g.windowBits && g.windowBits < 16 && (g.windowBits += 16), this.err = 0, this.msg = "", this.ended = !1, this.chunks = [], this.strm = new c(), this.strm.avail_out = 0;
          var v = a.deflateInit2(this.strm, g.level, g.method, g.windowBits, g.memLevel, g.strategy);
          if (v !== h) throw new Error(u[v]);
          if (g.header && a.deflateSetHeader(this.strm, g.header), g.dictionary) {
            var _;
            if (_ = typeof g.dictionary == "string" ? o.string2buf(g.dictionary) : l.call(g.dictionary) === "[object ArrayBuffer]" ? new Uint8Array(g.dictionary) : g.dictionary, (v = a.deflateSetDictionary(this.strm, _)) !== h) throw new Error(u[v]);
            this._dict_set = !0;
          }
        }
        function b(p, g) {
          var v = new m(g);
          if (v.push(p, !0), v.err) throw v.msg || u[v.err];
          return v.result;
        }
        m.prototype.push = function(p, g) {
          var v, _, x = this.strm, T = this.options.chunkSize;
          if (this.ended) return !1;
          _ = g === ~~g ? g : g === !0 ? 4 : 0, typeof p == "string" ? x.input = o.string2buf(p) : l.call(p) === "[object ArrayBuffer]" ? x.input = new Uint8Array(p) : x.input = p, x.next_in = 0, x.avail_in = x.input.length;
          do {
            if (x.avail_out === 0 && (x.output = new s.Buf8(T), x.next_out = 0, x.avail_out = T), (v = a.deflate(x, _)) !== 1 && v !== h) return this.onEnd(v), !(this.ended = !0);
            x.avail_out !== 0 && (x.avail_in !== 0 || _ !== 4 && _ !== 2) || (this.options.to === "string" ? this.onData(o.buf2binstring(s.shrinkBuf(x.output, x.next_out))) : this.onData(s.shrinkBuf(x.output, x.next_out)));
          } while ((0 < x.avail_in || x.avail_out === 0) && v !== 1);
          return _ === 4 ? (v = a.deflateEnd(this.strm), this.onEnd(v), this.ended = !0, v === h) : _ !== 2 || (this.onEnd(h), !(x.avail_out = 0));
        }, m.prototype.onData = function(p) {
          this.chunks.push(p);
        }, m.prototype.onEnd = function(p) {
          p === h && (this.options.to === "string" ? this.result = this.chunks.join("") : this.result = s.flattenChunks(this.chunks)), this.chunks = [], this.err = p, this.msg = this.strm.msg;
        }, r.Deflate = m, r.deflate = b, r.deflateRaw = function(p, g) {
          return (g = g || {}).raw = !0, b(p, g);
        }, r.gzip = function(p, g) {
          return (g = g || {}).gzip = !0, b(p, g);
        };
      }, { "./utils/common": 41, "./utils/strings": 42, "./zlib/deflate": 46, "./zlib/messages": 51, "./zlib/zstream": 53 }], 40: [function(t, i, r) {
        var a = t("./zlib/inflate"), s = t("./utils/common"), o = t("./utils/strings"), u = t("./zlib/constants"), c = t("./zlib/messages"), l = t("./zlib/zstream"), h = t("./zlib/gzheader"), f = Object.prototype.toString;
        function d(m) {
          if (!(this instanceof d)) return new d(m);
          this.options = s.assign({ chunkSize: 16384, windowBits: 0, to: "" }, m || {});
          var b = this.options;
          b.raw && 0 <= b.windowBits && b.windowBits < 16 && (b.windowBits = -b.windowBits, b.windowBits === 0 && (b.windowBits = -15)), !(0 <= b.windowBits && b.windowBits < 16) || m && m.windowBits || (b.windowBits += 32), 15 < b.windowBits && b.windowBits < 48 && (15 & b.windowBits) == 0 && (b.windowBits |= 15), this.err = 0, this.msg = "", this.ended = !1, this.chunks = [], this.strm = new l(), this.strm.avail_out = 0;
          var p = a.inflateInit2(this.strm, b.windowBits);
          if (p !== u.Z_OK) throw new Error(c[p]);
          this.header = new h(), a.inflateGetHeader(this.strm, this.header);
        }
        function y(m, b) {
          var p = new d(b);
          if (p.push(m, !0), p.err) throw p.msg || c[p.err];
          return p.result;
        }
        d.prototype.push = function(m, b) {
          var p, g, v, _, x, T, E = this.strm, U = this.options.chunkSize, D = this.options.dictionary, L = !1;
          if (this.ended) return !1;
          g = b === ~~b ? b : b === !0 ? u.Z_FINISH : u.Z_NO_FLUSH, typeof m == "string" ? E.input = o.binstring2buf(m) : f.call(m) === "[object ArrayBuffer]" ? E.input = new Uint8Array(m) : E.input = m, E.next_in = 0, E.avail_in = E.input.length;
          do {
            if (E.avail_out === 0 && (E.output = new s.Buf8(U), E.next_out = 0, E.avail_out = U), (p = a.inflate(E, u.Z_NO_FLUSH)) === u.Z_NEED_DICT && D && (T = typeof D == "string" ? o.string2buf(D) : f.call(D) === "[object ArrayBuffer]" ? new Uint8Array(D) : D, p = a.inflateSetDictionary(this.strm, T)), p === u.Z_BUF_ERROR && L === !0 && (p = u.Z_OK, L = !1), p !== u.Z_STREAM_END && p !== u.Z_OK) return this.onEnd(p), !(this.ended = !0);
            E.next_out && (E.avail_out !== 0 && p !== u.Z_STREAM_END && (E.avail_in !== 0 || g !== u.Z_FINISH && g !== u.Z_SYNC_FLUSH) || (this.options.to === "string" ? (v = o.utf8border(E.output, E.next_out), _ = E.next_out - v, x = o.buf2string(E.output, v), E.next_out = _, E.avail_out = U - _, _ && s.arraySet(E.output, E.output, v, _, 0), this.onData(x)) : this.onData(s.shrinkBuf(E.output, E.next_out)))), E.avail_in === 0 && E.avail_out === 0 && (L = !0);
          } while ((0 < E.avail_in || E.avail_out === 0) && p !== u.Z_STREAM_END);
          return p === u.Z_STREAM_END && (g = u.Z_FINISH), g === u.Z_FINISH ? (p = a.inflateEnd(this.strm), this.onEnd(p), this.ended = !0, p === u.Z_OK) : g !== u.Z_SYNC_FLUSH || (this.onEnd(u.Z_OK), !(E.avail_out = 0));
        }, d.prototype.onData = function(m) {
          this.chunks.push(m);
        }, d.prototype.onEnd = function(m) {
          m === u.Z_OK && (this.options.to === "string" ? this.result = this.chunks.join("") : this.result = s.flattenChunks(this.chunks)), this.chunks = [], this.err = m, this.msg = this.strm.msg;
        }, r.Inflate = d, r.inflate = y, r.inflateRaw = function(m, b) {
          return (b = b || {}).raw = !0, y(m, b);
        }, r.ungzip = y;
      }, { "./utils/common": 41, "./utils/strings": 42, "./zlib/constants": 44, "./zlib/gzheader": 47, "./zlib/inflate": 49, "./zlib/messages": 51, "./zlib/zstream": 53 }], 41: [function(t, i, r) {
        var a = typeof Uint8Array < "u" && typeof Uint16Array < "u" && typeof Int32Array < "u";
        r.assign = function(u) {
          for (var c = Array.prototype.slice.call(arguments, 1); c.length; ) {
            var l = c.shift();
            if (l) {
              if (typeof l != "object") throw new TypeError(l + "must be non-object");
              for (var h in l) l.hasOwnProperty(h) && (u[h] = l[h]);
            }
          }
          return u;
        }, r.shrinkBuf = function(u, c) {
          return u.length === c ? u : u.subarray ? u.subarray(0, c) : (u.length = c, u);
        };
        var s = { arraySet: function(u, c, l, h, f) {
          if (c.subarray && u.subarray) u.set(c.subarray(l, l + h), f);
          else for (var d = 0; d < h; d++) u[f + d] = c[l + d];
        }, flattenChunks: function(u) {
          var c, l, h, f, d, y;
          for (c = h = 0, l = u.length; c < l; c++) h += u[c].length;
          for (y = new Uint8Array(h), c = f = 0, l = u.length; c < l; c++) d = u[c], y.set(d, f), f += d.length;
          return y;
        } }, o = { arraySet: function(u, c, l, h, f) {
          for (var d = 0; d < h; d++) u[f + d] = c[l + d];
        }, flattenChunks: function(u) {
          return [].concat.apply([], u);
        } };
        r.setTyped = function(u) {
          u ? (r.Buf8 = Uint8Array, r.Buf16 = Uint16Array, r.Buf32 = Int32Array, r.assign(r, s)) : (r.Buf8 = Array, r.Buf16 = Array, r.Buf32 = Array, r.assign(r, o));
        }, r.setTyped(a);
      }, {}], 42: [function(t, i, r) {
        var a = t("./common"), s = !0, o = !0;
        try {
          String.fromCharCode.apply(null, [0]);
        } catch {
          s = !1;
        }
        try {
          String.fromCharCode.apply(null, new Uint8Array(1));
        } catch {
          o = !1;
        }
        for (var u = new a.Buf8(256), c = 0; c < 256; c++) u[c] = 252 <= c ? 6 : 248 <= c ? 5 : 240 <= c ? 4 : 224 <= c ? 3 : 192 <= c ? 2 : 1;
        function l(h, f) {
          if (f < 65537 && (h.subarray && o || !h.subarray && s)) return String.fromCharCode.apply(null, a.shrinkBuf(h, f));
          for (var d = "", y = 0; y < f; y++) d += String.fromCharCode(h[y]);
          return d;
        }
        u[254] = u[254] = 1, r.string2buf = function(h) {
          var f, d, y, m, b, p = h.length, g = 0;
          for (m = 0; m < p; m++) (64512 & (d = h.charCodeAt(m))) == 55296 && m + 1 < p && (64512 & (y = h.charCodeAt(m + 1))) == 56320 && (d = 65536 + (d - 55296 << 10) + (y - 56320), m++), g += d < 128 ? 1 : d < 2048 ? 2 : d < 65536 ? 3 : 4;
          for (f = new a.Buf8(g), m = b = 0; b < g; m++) (64512 & (d = h.charCodeAt(m))) == 55296 && m + 1 < p && (64512 & (y = h.charCodeAt(m + 1))) == 56320 && (d = 65536 + (d - 55296 << 10) + (y - 56320), m++), d < 128 ? f[b++] = d : (d < 2048 ? f[b++] = 192 | d >>> 6 : (d < 65536 ? f[b++] = 224 | d >>> 12 : (f[b++] = 240 | d >>> 18, f[b++] = 128 | d >>> 12 & 63), f[b++] = 128 | d >>> 6 & 63), f[b++] = 128 | 63 & d);
          return f;
        }, r.buf2binstring = function(h) {
          return l(h, h.length);
        }, r.binstring2buf = function(h) {
          for (var f = new a.Buf8(h.length), d = 0, y = f.length; d < y; d++) f[d] = h.charCodeAt(d);
          return f;
        }, r.buf2string = function(h, f) {
          var d, y, m, b, p = f || h.length, g = new Array(2 * p);
          for (d = y = 0; d < p; ) if ((m = h[d++]) < 128) g[y++] = m;
          else if (4 < (b = u[m])) g[y++] = 65533, d += b - 1;
          else {
            for (m &= b === 2 ? 31 : b === 3 ? 15 : 7; 1 < b && d < p; ) m = m << 6 | 63 & h[d++], b--;
            1 < b ? g[y++] = 65533 : m < 65536 ? g[y++] = m : (m -= 65536, g[y++] = 55296 | m >> 10 & 1023, g[y++] = 56320 | 1023 & m);
          }
          return l(g, y);
        }, r.utf8border = function(h, f) {
          var d;
          for ((f = f || h.length) > h.length && (f = h.length), d = f - 1; 0 <= d && (192 & h[d]) == 128; ) d--;
          return d < 0 || d === 0 ? f : d + u[h[d]] > f ? d : f;
        };
      }, { "./common": 41 }], 43: [function(t, i, r) {
        i.exports = function(a, s, o, u) {
          for (var c = 65535 & a | 0, l = a >>> 16 & 65535 | 0, h = 0; o !== 0; ) {
            for (o -= h = 2e3 < o ? 2e3 : o; l = l + (c = c + s[u++] | 0) | 0, --h; ) ;
            c %= 65521, l %= 65521;
          }
          return c | l << 16 | 0;
        };
      }, {}], 44: [function(t, i, r) {
        i.exports = { Z_NO_FLUSH: 0, Z_PARTIAL_FLUSH: 1, Z_SYNC_FLUSH: 2, Z_FULL_FLUSH: 3, Z_FINISH: 4, Z_BLOCK: 5, Z_TREES: 6, Z_OK: 0, Z_STREAM_END: 1, Z_NEED_DICT: 2, Z_ERRNO: -1, Z_STREAM_ERROR: -2, Z_DATA_ERROR: -3, Z_BUF_ERROR: -5, Z_NO_COMPRESSION: 0, Z_BEST_SPEED: 1, Z_BEST_COMPRESSION: 9, Z_DEFAULT_COMPRESSION: -1, Z_FILTERED: 1, Z_HUFFMAN_ONLY: 2, Z_RLE: 3, Z_FIXED: 4, Z_DEFAULT_STRATEGY: 0, Z_BINARY: 0, Z_TEXT: 1, Z_UNKNOWN: 2, Z_DEFLATED: 8 };
      }, {}], 45: [function(t, i, r) {
        var a = (function() {
          for (var s, o = [], u = 0; u < 256; u++) {
            s = u;
            for (var c = 0; c < 8; c++) s = 1 & s ? 3988292384 ^ s >>> 1 : s >>> 1;
            o[u] = s;
          }
          return o;
        })();
        i.exports = function(s, o, u, c) {
          var l = a, h = c + u;
          s ^= -1;
          for (var f = c; f < h; f++) s = s >>> 8 ^ l[255 & (s ^ o[f])];
          return -1 ^ s;
        };
      }, {}], 46: [function(t, i, r) {
        var a, s = t("../utils/common"), o = t("./trees"), u = t("./adler32"), c = t("./crc32"), l = t("./messages"), h = 0, f = 4, d = 0, y = -2, m = -1, b = 4, p = 2, g = 8, v = 9, _ = 286, x = 30, T = 19, E = 2 * _ + 1, U = 15, D = 3, L = 258, j = L + D + 1, C = 42, k = 113, I = 1, $ = 2, W = 3, B = 4;
        function z(S, he) {
          return S.msg = l[he], he;
        }
        function q(S) {
          return (S << 1) - (4 < S ? 9 : 0);
        }
        function Y(S) {
          for (var he = S.length; 0 <= --he; ) S[he] = 0;
        }
        function H(S) {
          var he = S.state, ae = he.pending;
          ae > S.avail_out && (ae = S.avail_out), ae !== 0 && (s.arraySet(S.output, he.pending_buf, he.pending_out, ae, S.next_out), S.next_out += ae, he.pending_out += ae, S.total_out += ae, S.avail_out -= ae, he.pending -= ae, he.pending === 0 && (he.pending_out = 0));
        }
        function K(S, he) {
          o._tr_flush_block(S, 0 <= S.block_start ? S.block_start : -1, S.strstart - S.block_start, he), S.block_start = S.strstart, H(S.strm);
        }
        function ie(S, he) {
          S.pending_buf[S.pending++] = he;
        }
        function ge(S, he) {
          S.pending_buf[S.pending++] = he >>> 8 & 255, S.pending_buf[S.pending++] = 255 & he;
        }
        function pe(S, he) {
          var ae, te, ee = S.max_chain_length, ve = S.strstart, Ee = S.prev_length, Se = S.nice_match, xe = S.strstart > S.w_size - j ? S.strstart - (S.w_size - j) : 0, le = S.window, ye = S.w_mask, we = S.prev, Ue = S.strstart + L, Q = le[ve + Ee - 1], M = le[ve + Ee];
          S.prev_length >= S.good_match && (ee >>= 2), Se > S.lookahead && (Se = S.lookahead);
          do
            if (le[(ae = he) + Ee] === M && le[ae + Ee - 1] === Q && le[ae] === le[ve] && le[++ae] === le[ve + 1]) {
              ve += 2, ae++;
              do
                ;
              while (le[++ve] === le[++ae] && le[++ve] === le[++ae] && le[++ve] === le[++ae] && le[++ve] === le[++ae] && le[++ve] === le[++ae] && le[++ve] === le[++ae] && le[++ve] === le[++ae] && le[++ve] === le[++ae] && ve < Ue);
              if (te = L - (Ue - ve), ve = Ue - L, Ee < te) {
                if (S.match_start = he, Se <= (Ee = te)) break;
                Q = le[ve + Ee - 1], M = le[ve + Ee];
              }
            }
          while ((he = we[he & ye]) > xe && --ee != 0);
          return Ee <= S.lookahead ? Ee : S.lookahead;
        }
        function ce(S) {
          var he, ae, te, ee, ve, Ee, Se, xe, le, ye, we = S.w_size;
          do {
            if (ee = S.window_size - S.lookahead - S.strstart, S.strstart >= we + (we - j)) {
              for (s.arraySet(S.window, S.window, we, we, 0), S.match_start -= we, S.strstart -= we, S.block_start -= we, he = ae = S.hash_size; te = S.head[--he], S.head[he] = we <= te ? te - we : 0, --ae; ) ;
              for (he = ae = we; te = S.prev[--he], S.prev[he] = we <= te ? te - we : 0, --ae; ) ;
              ee += we;
            }
            if (S.strm.avail_in === 0) break;
            if (Ee = S.strm, Se = S.window, xe = S.strstart + S.lookahead, le = ee, ye = void 0, ye = Ee.avail_in, le < ye && (ye = le), ae = ye === 0 ? 0 : (Ee.avail_in -= ye, s.arraySet(Se, Ee.input, Ee.next_in, ye, xe), Ee.state.wrap === 1 ? Ee.adler = u(Ee.adler, Se, ye, xe) : Ee.state.wrap === 2 && (Ee.adler = c(Ee.adler, Se, ye, xe)), Ee.next_in += ye, Ee.total_in += ye, ye), S.lookahead += ae, S.lookahead + S.insert >= D) for (ve = S.strstart - S.insert, S.ins_h = S.window[ve], S.ins_h = (S.ins_h << S.hash_shift ^ S.window[ve + 1]) & S.hash_mask; S.insert && (S.ins_h = (S.ins_h << S.hash_shift ^ S.window[ve + D - 1]) & S.hash_mask, S.prev[ve & S.w_mask] = S.head[S.ins_h], S.head[S.ins_h] = ve, ve++, S.insert--, !(S.lookahead + S.insert < D)); ) ;
          } while (S.lookahead < j && S.strm.avail_in !== 0);
        }
        function oe(S, he) {
          for (var ae, te; ; ) {
            if (S.lookahead < j) {
              if (ce(S), S.lookahead < j && he === h) return I;
              if (S.lookahead === 0) break;
            }
            if (ae = 0, S.lookahead >= D && (S.ins_h = (S.ins_h << S.hash_shift ^ S.window[S.strstart + D - 1]) & S.hash_mask, ae = S.prev[S.strstart & S.w_mask] = S.head[S.ins_h], S.head[S.ins_h] = S.strstart), ae !== 0 && S.strstart - ae <= S.w_size - j && (S.match_length = pe(S, ae)), S.match_length >= D) if (te = o._tr_tally(S, S.strstart - S.match_start, S.match_length - D), S.lookahead -= S.match_length, S.match_length <= S.max_lazy_match && S.lookahead >= D) {
              for (S.match_length--; S.strstart++, S.ins_h = (S.ins_h << S.hash_shift ^ S.window[S.strstart + D - 1]) & S.hash_mask, ae = S.prev[S.strstart & S.w_mask] = S.head[S.ins_h], S.head[S.ins_h] = S.strstart, --S.match_length != 0; ) ;
              S.strstart++;
            } else S.strstart += S.match_length, S.match_length = 0, S.ins_h = S.window[S.strstart], S.ins_h = (S.ins_h << S.hash_shift ^ S.window[S.strstart + 1]) & S.hash_mask;
            else te = o._tr_tally(S, 0, S.window[S.strstart]), S.lookahead--, S.strstart++;
            if (te && (K(S, !1), S.strm.avail_out === 0)) return I;
          }
          return S.insert = S.strstart < D - 1 ? S.strstart : D - 1, he === f ? (K(S, !0), S.strm.avail_out === 0 ? W : B) : S.last_lit && (K(S, !1), S.strm.avail_out === 0) ? I : $;
        }
        function De(S, he) {
          for (var ae, te, ee; ; ) {
            if (S.lookahead < j) {
              if (ce(S), S.lookahead < j && he === h) return I;
              if (S.lookahead === 0) break;
            }
            if (ae = 0, S.lookahead >= D && (S.ins_h = (S.ins_h << S.hash_shift ^ S.window[S.strstart + D - 1]) & S.hash_mask, ae = S.prev[S.strstart & S.w_mask] = S.head[S.ins_h], S.head[S.ins_h] = S.strstart), S.prev_length = S.match_length, S.prev_match = S.match_start, S.match_length = D - 1, ae !== 0 && S.prev_length < S.max_lazy_match && S.strstart - ae <= S.w_size - j && (S.match_length = pe(S, ae), S.match_length <= 5 && (S.strategy === 1 || S.match_length === D && 4096 < S.strstart - S.match_start) && (S.match_length = D - 1)), S.prev_length >= D && S.match_length <= S.prev_length) {
              for (ee = S.strstart + S.lookahead - D, te = o._tr_tally(S, S.strstart - 1 - S.prev_match, S.prev_length - D), S.lookahead -= S.prev_length - 1, S.prev_length -= 2; ++S.strstart <= ee && (S.ins_h = (S.ins_h << S.hash_shift ^ S.window[S.strstart + D - 1]) & S.hash_mask, ae = S.prev[S.strstart & S.w_mask] = S.head[S.ins_h], S.head[S.ins_h] = S.strstart), --S.prev_length != 0; ) ;
              if (S.match_available = 0, S.match_length = D - 1, S.strstart++, te && (K(S, !1), S.strm.avail_out === 0)) return I;
            } else if (S.match_available) {
              if ((te = o._tr_tally(S, 0, S.window[S.strstart - 1])) && K(S, !1), S.strstart++, S.lookahead--, S.strm.avail_out === 0) return I;
            } else S.match_available = 1, S.strstart++, S.lookahead--;
          }
          return S.match_available && (te = o._tr_tally(S, 0, S.window[S.strstart - 1]), S.match_available = 0), S.insert = S.strstart < D - 1 ? S.strstart : D - 1, he === f ? (K(S, !0), S.strm.avail_out === 0 ? W : B) : S.last_lit && (K(S, !1), S.strm.avail_out === 0) ? I : $;
        }
        function Re(S, he, ae, te, ee) {
          this.good_length = S, this.max_lazy = he, this.nice_length = ae, this.max_chain = te, this.func = ee;
        }
        function Me() {
          this.strm = null, this.status = 0, this.pending_buf = null, this.pending_buf_size = 0, this.pending_out = 0, this.pending = 0, this.wrap = 0, this.gzhead = null, this.gzindex = 0, this.method = g, this.last_flush = -1, this.w_size = 0, this.w_bits = 0, this.w_mask = 0, this.window = null, this.window_size = 0, this.prev = null, this.head = null, this.ins_h = 0, this.hash_size = 0, this.hash_bits = 0, this.hash_mask = 0, this.hash_shift = 0, this.block_start = 0, this.match_length = 0, this.prev_match = 0, this.match_available = 0, this.strstart = 0, this.match_start = 0, this.lookahead = 0, this.prev_length = 0, this.max_chain_length = 0, this.max_lazy_match = 0, this.level = 0, this.strategy = 0, this.good_match = 0, this.nice_match = 0, this.dyn_ltree = new s.Buf16(2 * E), this.dyn_dtree = new s.Buf16(2 * (2 * x + 1)), this.bl_tree = new s.Buf16(2 * (2 * T + 1)), Y(this.dyn_ltree), Y(this.dyn_dtree), Y(this.bl_tree), this.l_desc = null, this.d_desc = null, this.bl_desc = null, this.bl_count = new s.Buf16(U + 1), this.heap = new s.Buf16(2 * _ + 1), Y(this.heap), this.heap_len = 0, this.heap_max = 0, this.depth = new s.Buf16(2 * _ + 1), Y(this.depth), this.l_buf = 0, this.lit_bufsize = 0, this.last_lit = 0, this.d_buf = 0, this.opt_len = 0, this.static_len = 0, this.matches = 0, this.insert = 0, this.bi_buf = 0, this.bi_valid = 0;
        }
        function F(S) {
          var he;
          return S && S.state ? (S.total_in = S.total_out = 0, S.data_type = p, (he = S.state).pending = 0, he.pending_out = 0, he.wrap < 0 && (he.wrap = -he.wrap), he.status = he.wrap ? C : k, S.adler = he.wrap === 2 ? 0 : 1, he.last_flush = h, o._tr_init(he), d) : z(S, y);
        }
        function P(S) {
          var he = F(S);
          return he === d && (function(ae) {
            ae.window_size = 2 * ae.w_size, Y(ae.head), ae.max_lazy_match = a[ae.level].max_lazy, ae.good_match = a[ae.level].good_length, ae.nice_match = a[ae.level].nice_length, ae.max_chain_length = a[ae.level].max_chain, ae.strstart = 0, ae.block_start = 0, ae.lookahead = 0, ae.insert = 0, ae.match_length = ae.prev_length = D - 1, ae.match_available = 0, ae.ins_h = 0;
          })(S.state), he;
        }
        function ne(S, he, ae, te, ee, ve) {
          if (!S) return y;
          var Ee = 1;
          if (he === m && (he = 6), te < 0 ? (Ee = 0, te = -te) : 15 < te && (Ee = 2, te -= 16), ee < 1 || v < ee || ae !== g || te < 8 || 15 < te || he < 0 || 9 < he || ve < 0 || b < ve) return z(S, y);
          te === 8 && (te = 9);
          var Se = new Me();
          return (S.state = Se).strm = S, Se.wrap = Ee, Se.gzhead = null, Se.w_bits = te, Se.w_size = 1 << Se.w_bits, Se.w_mask = Se.w_size - 1, Se.hash_bits = ee + 7, Se.hash_size = 1 << Se.hash_bits, Se.hash_mask = Se.hash_size - 1, Se.hash_shift = ~~((Se.hash_bits + D - 1) / D), Se.window = new s.Buf8(2 * Se.w_size), Se.head = new s.Buf16(Se.hash_size), Se.prev = new s.Buf16(Se.w_size), Se.lit_bufsize = 1 << ee + 6, Se.pending_buf_size = 4 * Se.lit_bufsize, Se.pending_buf = new s.Buf8(Se.pending_buf_size), Se.d_buf = 1 * Se.lit_bufsize, Se.l_buf = 3 * Se.lit_bufsize, Se.level = he, Se.strategy = ve, Se.method = ae, P(S);
        }
        a = [new Re(0, 0, 0, 0, function(S, he) {
          var ae = 65535;
          for (ae > S.pending_buf_size - 5 && (ae = S.pending_buf_size - 5); ; ) {
            if (S.lookahead <= 1) {
              if (ce(S), S.lookahead === 0 && he === h) return I;
              if (S.lookahead === 0) break;
            }
            S.strstart += S.lookahead, S.lookahead = 0;
            var te = S.block_start + ae;
            if ((S.strstart === 0 || S.strstart >= te) && (S.lookahead = S.strstart - te, S.strstart = te, K(S, !1), S.strm.avail_out === 0) || S.strstart - S.block_start >= S.w_size - j && (K(S, !1), S.strm.avail_out === 0)) return I;
          }
          return S.insert = 0, he === f ? (K(S, !0), S.strm.avail_out === 0 ? W : B) : (S.strstart > S.block_start && (K(S, !1), S.strm.avail_out), I);
        }), new Re(4, 4, 8, 4, oe), new Re(4, 5, 16, 8, oe), new Re(4, 6, 32, 32, oe), new Re(4, 4, 16, 16, De), new Re(8, 16, 32, 32, De), new Re(8, 16, 128, 128, De), new Re(8, 32, 128, 256, De), new Re(32, 128, 258, 1024, De), new Re(32, 258, 258, 4096, De)], r.deflateInit = function(S, he) {
          return ne(S, he, g, 15, 8, 0);
        }, r.deflateInit2 = ne, r.deflateReset = P, r.deflateResetKeep = F, r.deflateSetHeader = function(S, he) {
          return S && S.state ? S.state.wrap !== 2 ? y : (S.state.gzhead = he, d) : y;
        }, r.deflate = function(S, he) {
          var ae, te, ee, ve;
          if (!S || !S.state || 5 < he || he < 0) return S ? z(S, y) : y;
          if (te = S.state, !S.output || !S.input && S.avail_in !== 0 || te.status === 666 && he !== f) return z(S, S.avail_out === 0 ? -5 : y);
          if (te.strm = S, ae = te.last_flush, te.last_flush = he, te.status === C) if (te.wrap === 2) S.adler = 0, ie(te, 31), ie(te, 139), ie(te, 8), te.gzhead ? (ie(te, (te.gzhead.text ? 1 : 0) + (te.gzhead.hcrc ? 2 : 0) + (te.gzhead.extra ? 4 : 0) + (te.gzhead.name ? 8 : 0) + (te.gzhead.comment ? 16 : 0)), ie(te, 255 & te.gzhead.time), ie(te, te.gzhead.time >> 8 & 255), ie(te, te.gzhead.time >> 16 & 255), ie(te, te.gzhead.time >> 24 & 255), ie(te, te.level === 9 ? 2 : 2 <= te.strategy || te.level < 2 ? 4 : 0), ie(te, 255 & te.gzhead.os), te.gzhead.extra && te.gzhead.extra.length && (ie(te, 255 & te.gzhead.extra.length), ie(te, te.gzhead.extra.length >> 8 & 255)), te.gzhead.hcrc && (S.adler = c(S.adler, te.pending_buf, te.pending, 0)), te.gzindex = 0, te.status = 69) : (ie(te, 0), ie(te, 0), ie(te, 0), ie(te, 0), ie(te, 0), ie(te, te.level === 9 ? 2 : 2 <= te.strategy || te.level < 2 ? 4 : 0), ie(te, 3), te.status = k);
          else {
            var Ee = g + (te.w_bits - 8 << 4) << 8;
            Ee |= (2 <= te.strategy || te.level < 2 ? 0 : te.level < 6 ? 1 : te.level === 6 ? 2 : 3) << 6, te.strstart !== 0 && (Ee |= 32), Ee += 31 - Ee % 31, te.status = k, ge(te, Ee), te.strstart !== 0 && (ge(te, S.adler >>> 16), ge(te, 65535 & S.adler)), S.adler = 1;
          }
          if (te.status === 69) if (te.gzhead.extra) {
            for (ee = te.pending; te.gzindex < (65535 & te.gzhead.extra.length) && (te.pending !== te.pending_buf_size || (te.gzhead.hcrc && te.pending > ee && (S.adler = c(S.adler, te.pending_buf, te.pending - ee, ee)), H(S), ee = te.pending, te.pending !== te.pending_buf_size)); ) ie(te, 255 & te.gzhead.extra[te.gzindex]), te.gzindex++;
            te.gzhead.hcrc && te.pending > ee && (S.adler = c(S.adler, te.pending_buf, te.pending - ee, ee)), te.gzindex === te.gzhead.extra.length && (te.gzindex = 0, te.status = 73);
          } else te.status = 73;
          if (te.status === 73) if (te.gzhead.name) {
            ee = te.pending;
            do {
              if (te.pending === te.pending_buf_size && (te.gzhead.hcrc && te.pending > ee && (S.adler = c(S.adler, te.pending_buf, te.pending - ee, ee)), H(S), ee = te.pending, te.pending === te.pending_buf_size)) {
                ve = 1;
                break;
              }
              ve = te.gzindex < te.gzhead.name.length ? 255 & te.gzhead.name.charCodeAt(te.gzindex++) : 0, ie(te, ve);
            } while (ve !== 0);
            te.gzhead.hcrc && te.pending > ee && (S.adler = c(S.adler, te.pending_buf, te.pending - ee, ee)), ve === 0 && (te.gzindex = 0, te.status = 91);
          } else te.status = 91;
          if (te.status === 91) if (te.gzhead.comment) {
            ee = te.pending;
            do {
              if (te.pending === te.pending_buf_size && (te.gzhead.hcrc && te.pending > ee && (S.adler = c(S.adler, te.pending_buf, te.pending - ee, ee)), H(S), ee = te.pending, te.pending === te.pending_buf_size)) {
                ve = 1;
                break;
              }
              ve = te.gzindex < te.gzhead.comment.length ? 255 & te.gzhead.comment.charCodeAt(te.gzindex++) : 0, ie(te, ve);
            } while (ve !== 0);
            te.gzhead.hcrc && te.pending > ee && (S.adler = c(S.adler, te.pending_buf, te.pending - ee, ee)), ve === 0 && (te.status = 103);
          } else te.status = 103;
          if (te.status === 103 && (te.gzhead.hcrc ? (te.pending + 2 > te.pending_buf_size && H(S), te.pending + 2 <= te.pending_buf_size && (ie(te, 255 & S.adler), ie(te, S.adler >> 8 & 255), S.adler = 0, te.status = k)) : te.status = k), te.pending !== 0) {
            if (H(S), S.avail_out === 0) return te.last_flush = -1, d;
          } else if (S.avail_in === 0 && q(he) <= q(ae) && he !== f) return z(S, -5);
          if (te.status === 666 && S.avail_in !== 0) return z(S, -5);
          if (S.avail_in !== 0 || te.lookahead !== 0 || he !== h && te.status !== 666) {
            var Se = te.strategy === 2 ? (function(xe, le) {
              for (var ye; ; ) {
                if (xe.lookahead === 0 && (ce(xe), xe.lookahead === 0)) {
                  if (le === h) return I;
                  break;
                }
                if (xe.match_length = 0, ye = o._tr_tally(xe, 0, xe.window[xe.strstart]), xe.lookahead--, xe.strstart++, ye && (K(xe, !1), xe.strm.avail_out === 0)) return I;
              }
              return xe.insert = 0, le === f ? (K(xe, !0), xe.strm.avail_out === 0 ? W : B) : xe.last_lit && (K(xe, !1), xe.strm.avail_out === 0) ? I : $;
            })(te, he) : te.strategy === 3 ? (function(xe, le) {
              for (var ye, we, Ue, Q, M = xe.window; ; ) {
                if (xe.lookahead <= L) {
                  if (ce(xe), xe.lookahead <= L && le === h) return I;
                  if (xe.lookahead === 0) break;
                }
                if (xe.match_length = 0, xe.lookahead >= D && 0 < xe.strstart && (we = M[Ue = xe.strstart - 1]) === M[++Ue] && we === M[++Ue] && we === M[++Ue]) {
                  Q = xe.strstart + L;
                  do
                    ;
                  while (we === M[++Ue] && we === M[++Ue] && we === M[++Ue] && we === M[++Ue] && we === M[++Ue] && we === M[++Ue] && we === M[++Ue] && we === M[++Ue] && Ue < Q);
                  xe.match_length = L - (Q - Ue), xe.match_length > xe.lookahead && (xe.match_length = xe.lookahead);
                }
                if (xe.match_length >= D ? (ye = o._tr_tally(xe, 1, xe.match_length - D), xe.lookahead -= xe.match_length, xe.strstart += xe.match_length, xe.match_length = 0) : (ye = o._tr_tally(xe, 0, xe.window[xe.strstart]), xe.lookahead--, xe.strstart++), ye && (K(xe, !1), xe.strm.avail_out === 0)) return I;
              }
              return xe.insert = 0, le === f ? (K(xe, !0), xe.strm.avail_out === 0 ? W : B) : xe.last_lit && (K(xe, !1), xe.strm.avail_out === 0) ? I : $;
            })(te, he) : a[te.level].func(te, he);
            if (Se !== W && Se !== B || (te.status = 666), Se === I || Se === W) return S.avail_out === 0 && (te.last_flush = -1), d;
            if (Se === $ && (he === 1 ? o._tr_align(te) : he !== 5 && (o._tr_stored_block(te, 0, 0, !1), he === 3 && (Y(te.head), te.lookahead === 0 && (te.strstart = 0, te.block_start = 0, te.insert = 0))), H(S), S.avail_out === 0)) return te.last_flush = -1, d;
          }
          return he !== f ? d : te.wrap <= 0 ? 1 : (te.wrap === 2 ? (ie(te, 255 & S.adler), ie(te, S.adler >> 8 & 255), ie(te, S.adler >> 16 & 255), ie(te, S.adler >> 24 & 255), ie(te, 255 & S.total_in), ie(te, S.total_in >> 8 & 255), ie(te, S.total_in >> 16 & 255), ie(te, S.total_in >> 24 & 255)) : (ge(te, S.adler >>> 16), ge(te, 65535 & S.adler)), H(S), 0 < te.wrap && (te.wrap = -te.wrap), te.pending !== 0 ? d : 1);
        }, r.deflateEnd = function(S) {
          var he;
          return S && S.state ? (he = S.state.status) !== C && he !== 69 && he !== 73 && he !== 91 && he !== 103 && he !== k && he !== 666 ? z(S, y) : (S.state = null, he === k ? z(S, -3) : d) : y;
        }, r.deflateSetDictionary = function(S, he) {
          var ae, te, ee, ve, Ee, Se, xe, le, ye = he.length;
          if (!S || !S.state || (ve = (ae = S.state).wrap) === 2 || ve === 1 && ae.status !== C || ae.lookahead) return y;
          for (ve === 1 && (S.adler = u(S.adler, he, ye, 0)), ae.wrap = 0, ye >= ae.w_size && (ve === 0 && (Y(ae.head), ae.strstart = 0, ae.block_start = 0, ae.insert = 0), le = new s.Buf8(ae.w_size), s.arraySet(le, he, ye - ae.w_size, ae.w_size, 0), he = le, ye = ae.w_size), Ee = S.avail_in, Se = S.next_in, xe = S.input, S.avail_in = ye, S.next_in = 0, S.input = he, ce(ae); ae.lookahead >= D; ) {
            for (te = ae.strstart, ee = ae.lookahead - (D - 1); ae.ins_h = (ae.ins_h << ae.hash_shift ^ ae.window[te + D - 1]) & ae.hash_mask, ae.prev[te & ae.w_mask] = ae.head[ae.ins_h], ae.head[ae.ins_h] = te, te++, --ee; ) ;
            ae.strstart = te, ae.lookahead = D - 1, ce(ae);
          }
          return ae.strstart += ae.lookahead, ae.block_start = ae.strstart, ae.insert = ae.lookahead, ae.lookahead = 0, ae.match_length = ae.prev_length = D - 1, ae.match_available = 0, S.next_in = Se, S.input = xe, S.avail_in = Ee, ae.wrap = ve, d;
        }, r.deflateInfo = "pako deflate (from Nodeca project)";
      }, { "../utils/common": 41, "./adler32": 43, "./crc32": 45, "./messages": 51, "./trees": 52 }], 47: [function(t, i, r) {
        i.exports = function() {
          this.text = 0, this.time = 0, this.xflags = 0, this.os = 0, this.extra = null, this.extra_len = 0, this.name = "", this.comment = "", this.hcrc = 0, this.done = !1;
        };
      }, {}], 48: [function(t, i, r) {
        i.exports = function(a, s) {
          var o, u, c, l, h, f, d, y, m, b, p, g, v, _, x, T, E, U, D, L, j, C, k, I, $;
          o = a.state, u = a.next_in, I = a.input, c = u + (a.avail_in - 5), l = a.next_out, $ = a.output, h = l - (s - a.avail_out), f = l + (a.avail_out - 257), d = o.dmax, y = o.wsize, m = o.whave, b = o.wnext, p = o.window, g = o.hold, v = o.bits, _ = o.lencode, x = o.distcode, T = (1 << o.lenbits) - 1, E = (1 << o.distbits) - 1;
          e: do {
            v < 15 && (g += I[u++] << v, v += 8, g += I[u++] << v, v += 8), U = _[g & T];
            t: for (; ; ) {
              if (g >>>= D = U >>> 24, v -= D, (D = U >>> 16 & 255) === 0) $[l++] = 65535 & U;
              else {
                if (!(16 & D)) {
                  if ((64 & D) == 0) {
                    U = _[(65535 & U) + (g & (1 << D) - 1)];
                    continue t;
                  }
                  if (32 & D) {
                    o.mode = 12;
                    break e;
                  }
                  a.msg = "invalid literal/length code", o.mode = 30;
                  break e;
                }
                L = 65535 & U, (D &= 15) && (v < D && (g += I[u++] << v, v += 8), L += g & (1 << D) - 1, g >>>= D, v -= D), v < 15 && (g += I[u++] << v, v += 8, g += I[u++] << v, v += 8), U = x[g & E];
                n: for (; ; ) {
                  if (g >>>= D = U >>> 24, v -= D, !(16 & (D = U >>> 16 & 255))) {
                    if ((64 & D) == 0) {
                      U = x[(65535 & U) + (g & (1 << D) - 1)];
                      continue n;
                    }
                    a.msg = "invalid distance code", o.mode = 30;
                    break e;
                  }
                  if (j = 65535 & U, v < (D &= 15) && (g += I[u++] << v, (v += 8) < D && (g += I[u++] << v, v += 8)), d < (j += g & (1 << D) - 1)) {
                    a.msg = "invalid distance too far back", o.mode = 30;
                    break e;
                  }
                  if (g >>>= D, v -= D, (D = l - h) < j) {
                    if (m < (D = j - D) && o.sane) {
                      a.msg = "invalid distance too far back", o.mode = 30;
                      break e;
                    }
                    if (k = p, (C = 0) === b) {
                      if (C += y - D, D < L) {
                        for (L -= D; $[l++] = p[C++], --D; ) ;
                        C = l - j, k = $;
                      }
                    } else if (b < D) {
                      if (C += y + b - D, (D -= b) < L) {
                        for (L -= D; $[l++] = p[C++], --D; ) ;
                        if (C = 0, b < L) {
                          for (L -= D = b; $[l++] = p[C++], --D; ) ;
                          C = l - j, k = $;
                        }
                      }
                    } else if (C += b - D, D < L) {
                      for (L -= D; $[l++] = p[C++], --D; ) ;
                      C = l - j, k = $;
                    }
                    for (; 2 < L; ) $[l++] = k[C++], $[l++] = k[C++], $[l++] = k[C++], L -= 3;
                    L && ($[l++] = k[C++], 1 < L && ($[l++] = k[C++]));
                  } else {
                    for (C = l - j; $[l++] = $[C++], $[l++] = $[C++], $[l++] = $[C++], 2 < (L -= 3); ) ;
                    L && ($[l++] = $[C++], 1 < L && ($[l++] = $[C++]));
                  }
                  break;
                }
              }
              break;
            }
          } while (u < c && l < f);
          u -= L = v >> 3, g &= (1 << (v -= L << 3)) - 1, a.next_in = u, a.next_out = l, a.avail_in = u < c ? c - u + 5 : 5 - (u - c), a.avail_out = l < f ? f - l + 257 : 257 - (l - f), o.hold = g, o.bits = v;
        };
      }, {}], 49: [function(t, i, r) {
        var a = t("../utils/common"), s = t("./adler32"), o = t("./crc32"), u = t("./inffast"), c = t("./inftrees"), l = 1, h = 2, f = 0, d = -2, y = 1, m = 852, b = 592;
        function p(C) {
          return (C >>> 24 & 255) + (C >>> 8 & 65280) + ((65280 & C) << 8) + ((255 & C) << 24);
        }
        function g() {
          this.mode = 0, this.last = !1, this.wrap = 0, this.havedict = !1, this.flags = 0, this.dmax = 0, this.check = 0, this.total = 0, this.head = null, this.wbits = 0, this.wsize = 0, this.whave = 0, this.wnext = 0, this.window = null, this.hold = 0, this.bits = 0, this.length = 0, this.offset = 0, this.extra = 0, this.lencode = null, this.distcode = null, this.lenbits = 0, this.distbits = 0, this.ncode = 0, this.nlen = 0, this.ndist = 0, this.have = 0, this.next = null, this.lens = new a.Buf16(320), this.work = new a.Buf16(288), this.lendyn = null, this.distdyn = null, this.sane = 0, this.back = 0, this.was = 0;
        }
        function v(C) {
          var k;
          return C && C.state ? (k = C.state, C.total_in = C.total_out = k.total = 0, C.msg = "", k.wrap && (C.adler = 1 & k.wrap), k.mode = y, k.last = 0, k.havedict = 0, k.dmax = 32768, k.head = null, k.hold = 0, k.bits = 0, k.lencode = k.lendyn = new a.Buf32(m), k.distcode = k.distdyn = new a.Buf32(b), k.sane = 1, k.back = -1, f) : d;
        }
        function _(C) {
          var k;
          return C && C.state ? ((k = C.state).wsize = 0, k.whave = 0, k.wnext = 0, v(C)) : d;
        }
        function x(C, k) {
          var I, $;
          return C && C.state ? ($ = C.state, k < 0 ? (I = 0, k = -k) : (I = 1 + (k >> 4), k < 48 && (k &= 15)), k && (k < 8 || 15 < k) ? d : ($.window !== null && $.wbits !== k && ($.window = null), $.wrap = I, $.wbits = k, _(C))) : d;
        }
        function T(C, k) {
          var I, $;
          return C ? ($ = new g(), (C.state = $).window = null, (I = x(C, k)) !== f && (C.state = null), I) : d;
        }
        var E, U, D = !0;
        function L(C) {
          if (D) {
            var k;
            for (E = new a.Buf32(512), U = new a.Buf32(32), k = 0; k < 144; ) C.lens[k++] = 8;
            for (; k < 256; ) C.lens[k++] = 9;
            for (; k < 280; ) C.lens[k++] = 7;
            for (; k < 288; ) C.lens[k++] = 8;
            for (c(l, C.lens, 0, 288, E, 0, C.work, { bits: 9 }), k = 0; k < 32; ) C.lens[k++] = 5;
            c(h, C.lens, 0, 32, U, 0, C.work, { bits: 5 }), D = !1;
          }
          C.lencode = E, C.lenbits = 9, C.distcode = U, C.distbits = 5;
        }
        function j(C, k, I, $) {
          var W, B = C.state;
          return B.window === null && (B.wsize = 1 << B.wbits, B.wnext = 0, B.whave = 0, B.window = new a.Buf8(B.wsize)), $ >= B.wsize ? (a.arraySet(B.window, k, I - B.wsize, B.wsize, 0), B.wnext = 0, B.whave = B.wsize) : ($ < (W = B.wsize - B.wnext) && (W = $), a.arraySet(B.window, k, I - $, W, B.wnext), ($ -= W) ? (a.arraySet(B.window, k, I - $, $, 0), B.wnext = $, B.whave = B.wsize) : (B.wnext += W, B.wnext === B.wsize && (B.wnext = 0), B.whave < B.wsize && (B.whave += W))), 0;
        }
        r.inflateReset = _, r.inflateReset2 = x, r.inflateResetKeep = v, r.inflateInit = function(C) {
          return T(C, 15);
        }, r.inflateInit2 = T, r.inflate = function(C, k) {
          var I, $, W, B, z, q, Y, H, K, ie, ge, pe, ce, oe, De, Re, Me, F, P, ne, S, he, ae, te, ee = 0, ve = new a.Buf8(4), Ee = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
          if (!C || !C.state || !C.output || !C.input && C.avail_in !== 0) return d;
          (I = C.state).mode === 12 && (I.mode = 13), z = C.next_out, W = C.output, Y = C.avail_out, B = C.next_in, $ = C.input, q = C.avail_in, H = I.hold, K = I.bits, ie = q, ge = Y, he = f;
          e: for (; ; ) switch (I.mode) {
            case y:
              if (I.wrap === 0) {
                I.mode = 13;
                break;
              }
              for (; K < 16; ) {
                if (q === 0) break e;
                q--, H += $[B++] << K, K += 8;
              }
              if (2 & I.wrap && H === 35615) {
                ve[I.check = 0] = 255 & H, ve[1] = H >>> 8 & 255, I.check = o(I.check, ve, 2, 0), K = H = 0, I.mode = 2;
                break;
              }
              if (I.flags = 0, I.head && (I.head.done = !1), !(1 & I.wrap) || (((255 & H) << 8) + (H >> 8)) % 31) {
                C.msg = "incorrect header check", I.mode = 30;
                break;
              }
              if ((15 & H) != 8) {
                C.msg = "unknown compression method", I.mode = 30;
                break;
              }
              if (K -= 4, S = 8 + (15 & (H >>>= 4)), I.wbits === 0) I.wbits = S;
              else if (S > I.wbits) {
                C.msg = "invalid window size", I.mode = 30;
                break;
              }
              I.dmax = 1 << S, C.adler = I.check = 1, I.mode = 512 & H ? 10 : 12, K = H = 0;
              break;
            case 2:
              for (; K < 16; ) {
                if (q === 0) break e;
                q--, H += $[B++] << K, K += 8;
              }
              if (I.flags = H, (255 & I.flags) != 8) {
                C.msg = "unknown compression method", I.mode = 30;
                break;
              }
              if (57344 & I.flags) {
                C.msg = "unknown header flags set", I.mode = 30;
                break;
              }
              I.head && (I.head.text = H >> 8 & 1), 512 & I.flags && (ve[0] = 255 & H, ve[1] = H >>> 8 & 255, I.check = o(I.check, ve, 2, 0)), K = H = 0, I.mode = 3;
            case 3:
              for (; K < 32; ) {
                if (q === 0) break e;
                q--, H += $[B++] << K, K += 8;
              }
              I.head && (I.head.time = H), 512 & I.flags && (ve[0] = 255 & H, ve[1] = H >>> 8 & 255, ve[2] = H >>> 16 & 255, ve[3] = H >>> 24 & 255, I.check = o(I.check, ve, 4, 0)), K = H = 0, I.mode = 4;
            case 4:
              for (; K < 16; ) {
                if (q === 0) break e;
                q--, H += $[B++] << K, K += 8;
              }
              I.head && (I.head.xflags = 255 & H, I.head.os = H >> 8), 512 & I.flags && (ve[0] = 255 & H, ve[1] = H >>> 8 & 255, I.check = o(I.check, ve, 2, 0)), K = H = 0, I.mode = 5;
            case 5:
              if (1024 & I.flags) {
                for (; K < 16; ) {
                  if (q === 0) break e;
                  q--, H += $[B++] << K, K += 8;
                }
                I.length = H, I.head && (I.head.extra_len = H), 512 & I.flags && (ve[0] = 255 & H, ve[1] = H >>> 8 & 255, I.check = o(I.check, ve, 2, 0)), K = H = 0;
              } else I.head && (I.head.extra = null);
              I.mode = 6;
            case 6:
              if (1024 & I.flags && (q < (pe = I.length) && (pe = q), pe && (I.head && (S = I.head.extra_len - I.length, I.head.extra || (I.head.extra = new Array(I.head.extra_len)), a.arraySet(I.head.extra, $, B, pe, S)), 512 & I.flags && (I.check = o(I.check, $, pe, B)), q -= pe, B += pe, I.length -= pe), I.length)) break e;
              I.length = 0, I.mode = 7;
            case 7:
              if (2048 & I.flags) {
                if (q === 0) break e;
                for (pe = 0; S = $[B + pe++], I.head && S && I.length < 65536 && (I.head.name += String.fromCharCode(S)), S && pe < q; ) ;
                if (512 & I.flags && (I.check = o(I.check, $, pe, B)), q -= pe, B += pe, S) break e;
              } else I.head && (I.head.name = null);
              I.length = 0, I.mode = 8;
            case 8:
              if (4096 & I.flags) {
                if (q === 0) break e;
                for (pe = 0; S = $[B + pe++], I.head && S && I.length < 65536 && (I.head.comment += String.fromCharCode(S)), S && pe < q; ) ;
                if (512 & I.flags && (I.check = o(I.check, $, pe, B)), q -= pe, B += pe, S) break e;
              } else I.head && (I.head.comment = null);
              I.mode = 9;
            case 9:
              if (512 & I.flags) {
                for (; K < 16; ) {
                  if (q === 0) break e;
                  q--, H += $[B++] << K, K += 8;
                }
                if (H !== (65535 & I.check)) {
                  C.msg = "header crc mismatch", I.mode = 30;
                  break;
                }
                K = H = 0;
              }
              I.head && (I.head.hcrc = I.flags >> 9 & 1, I.head.done = !0), C.adler = I.check = 0, I.mode = 12;
              break;
            case 10:
              for (; K < 32; ) {
                if (q === 0) break e;
                q--, H += $[B++] << K, K += 8;
              }
              C.adler = I.check = p(H), K = H = 0, I.mode = 11;
            case 11:
              if (I.havedict === 0) return C.next_out = z, C.avail_out = Y, C.next_in = B, C.avail_in = q, I.hold = H, I.bits = K, 2;
              C.adler = I.check = 1, I.mode = 12;
            case 12:
              if (k === 5 || k === 6) break e;
            case 13:
              if (I.last) {
                H >>>= 7 & K, K -= 7 & K, I.mode = 27;
                break;
              }
              for (; K < 3; ) {
                if (q === 0) break e;
                q--, H += $[B++] << K, K += 8;
              }
              switch (I.last = 1 & H, K -= 1, 3 & (H >>>= 1)) {
                case 0:
                  I.mode = 14;
                  break;
                case 1:
                  if (L(I), I.mode = 20, k !== 6) break;
                  H >>>= 2, K -= 2;
                  break e;
                case 2:
                  I.mode = 17;
                  break;
                case 3:
                  C.msg = "invalid block type", I.mode = 30;
              }
              H >>>= 2, K -= 2;
              break;
            case 14:
              for (H >>>= 7 & K, K -= 7 & K; K < 32; ) {
                if (q === 0) break e;
                q--, H += $[B++] << K, K += 8;
              }
              if ((65535 & H) != (H >>> 16 ^ 65535)) {
                C.msg = "invalid stored block lengths", I.mode = 30;
                break;
              }
              if (I.length = 65535 & H, K = H = 0, I.mode = 15, k === 6) break e;
            case 15:
              I.mode = 16;
            case 16:
              if (pe = I.length) {
                if (q < pe && (pe = q), Y < pe && (pe = Y), pe === 0) break e;
                a.arraySet(W, $, B, pe, z), q -= pe, B += pe, Y -= pe, z += pe, I.length -= pe;
                break;
              }
              I.mode = 12;
              break;
            case 17:
              for (; K < 14; ) {
                if (q === 0) break e;
                q--, H += $[B++] << K, K += 8;
              }
              if (I.nlen = 257 + (31 & H), H >>>= 5, K -= 5, I.ndist = 1 + (31 & H), H >>>= 5, K -= 5, I.ncode = 4 + (15 & H), H >>>= 4, K -= 4, 286 < I.nlen || 30 < I.ndist) {
                C.msg = "too many length or distance symbols", I.mode = 30;
                break;
              }
              I.have = 0, I.mode = 18;
            case 18:
              for (; I.have < I.ncode; ) {
                for (; K < 3; ) {
                  if (q === 0) break e;
                  q--, H += $[B++] << K, K += 8;
                }
                I.lens[Ee[I.have++]] = 7 & H, H >>>= 3, K -= 3;
              }
              for (; I.have < 19; ) I.lens[Ee[I.have++]] = 0;
              if (I.lencode = I.lendyn, I.lenbits = 7, ae = { bits: I.lenbits }, he = c(0, I.lens, 0, 19, I.lencode, 0, I.work, ae), I.lenbits = ae.bits, he) {
                C.msg = "invalid code lengths set", I.mode = 30;
                break;
              }
              I.have = 0, I.mode = 19;
            case 19:
              for (; I.have < I.nlen + I.ndist; ) {
                for (; Re = (ee = I.lencode[H & (1 << I.lenbits) - 1]) >>> 16 & 255, Me = 65535 & ee, !((De = ee >>> 24) <= K); ) {
                  if (q === 0) break e;
                  q--, H += $[B++] << K, K += 8;
                }
                if (Me < 16) H >>>= De, K -= De, I.lens[I.have++] = Me;
                else {
                  if (Me === 16) {
                    for (te = De + 2; K < te; ) {
                      if (q === 0) break e;
                      q--, H += $[B++] << K, K += 8;
                    }
                    if (H >>>= De, K -= De, I.have === 0) {
                      C.msg = "invalid bit length repeat", I.mode = 30;
                      break;
                    }
                    S = I.lens[I.have - 1], pe = 3 + (3 & H), H >>>= 2, K -= 2;
                  } else if (Me === 17) {
                    for (te = De + 3; K < te; ) {
                      if (q === 0) break e;
                      q--, H += $[B++] << K, K += 8;
                    }
                    K -= De, S = 0, pe = 3 + (7 & (H >>>= De)), H >>>= 3, K -= 3;
                  } else {
                    for (te = De + 7; K < te; ) {
                      if (q === 0) break e;
                      q--, H += $[B++] << K, K += 8;
                    }
                    K -= De, S = 0, pe = 11 + (127 & (H >>>= De)), H >>>= 7, K -= 7;
                  }
                  if (I.have + pe > I.nlen + I.ndist) {
                    C.msg = "invalid bit length repeat", I.mode = 30;
                    break;
                  }
                  for (; pe--; ) I.lens[I.have++] = S;
                }
              }
              if (I.mode === 30) break;
              if (I.lens[256] === 0) {
                C.msg = "invalid code -- missing end-of-block", I.mode = 30;
                break;
              }
              if (I.lenbits = 9, ae = { bits: I.lenbits }, he = c(l, I.lens, 0, I.nlen, I.lencode, 0, I.work, ae), I.lenbits = ae.bits, he) {
                C.msg = "invalid literal/lengths set", I.mode = 30;
                break;
              }
              if (I.distbits = 6, I.distcode = I.distdyn, ae = { bits: I.distbits }, he = c(h, I.lens, I.nlen, I.ndist, I.distcode, 0, I.work, ae), I.distbits = ae.bits, he) {
                C.msg = "invalid distances set", I.mode = 30;
                break;
              }
              if (I.mode = 20, k === 6) break e;
            case 20:
              I.mode = 21;
            case 21:
              if (6 <= q && 258 <= Y) {
                C.next_out = z, C.avail_out = Y, C.next_in = B, C.avail_in = q, I.hold = H, I.bits = K, u(C, ge), z = C.next_out, W = C.output, Y = C.avail_out, B = C.next_in, $ = C.input, q = C.avail_in, H = I.hold, K = I.bits, I.mode === 12 && (I.back = -1);
                break;
              }
              for (I.back = 0; Re = (ee = I.lencode[H & (1 << I.lenbits) - 1]) >>> 16 & 255, Me = 65535 & ee, !((De = ee >>> 24) <= K); ) {
                if (q === 0) break e;
                q--, H += $[B++] << K, K += 8;
              }
              if (Re && (240 & Re) == 0) {
                for (F = De, P = Re, ne = Me; Re = (ee = I.lencode[ne + ((H & (1 << F + P) - 1) >> F)]) >>> 16 & 255, Me = 65535 & ee, !(F + (De = ee >>> 24) <= K); ) {
                  if (q === 0) break e;
                  q--, H += $[B++] << K, K += 8;
                }
                H >>>= F, K -= F, I.back += F;
              }
              if (H >>>= De, K -= De, I.back += De, I.length = Me, Re === 0) {
                I.mode = 26;
                break;
              }
              if (32 & Re) {
                I.back = -1, I.mode = 12;
                break;
              }
              if (64 & Re) {
                C.msg = "invalid literal/length code", I.mode = 30;
                break;
              }
              I.extra = 15 & Re, I.mode = 22;
            case 22:
              if (I.extra) {
                for (te = I.extra; K < te; ) {
                  if (q === 0) break e;
                  q--, H += $[B++] << K, K += 8;
                }
                I.length += H & (1 << I.extra) - 1, H >>>= I.extra, K -= I.extra, I.back += I.extra;
              }
              I.was = I.length, I.mode = 23;
            case 23:
              for (; Re = (ee = I.distcode[H & (1 << I.distbits) - 1]) >>> 16 & 255, Me = 65535 & ee, !((De = ee >>> 24) <= K); ) {
                if (q === 0) break e;
                q--, H += $[B++] << K, K += 8;
              }
              if ((240 & Re) == 0) {
                for (F = De, P = Re, ne = Me; Re = (ee = I.distcode[ne + ((H & (1 << F + P) - 1) >> F)]) >>> 16 & 255, Me = 65535 & ee, !(F + (De = ee >>> 24) <= K); ) {
                  if (q === 0) break e;
                  q--, H += $[B++] << K, K += 8;
                }
                H >>>= F, K -= F, I.back += F;
              }
              if (H >>>= De, K -= De, I.back += De, 64 & Re) {
                C.msg = "invalid distance code", I.mode = 30;
                break;
              }
              I.offset = Me, I.extra = 15 & Re, I.mode = 24;
            case 24:
              if (I.extra) {
                for (te = I.extra; K < te; ) {
                  if (q === 0) break e;
                  q--, H += $[B++] << K, K += 8;
                }
                I.offset += H & (1 << I.extra) - 1, H >>>= I.extra, K -= I.extra, I.back += I.extra;
              }
              if (I.offset > I.dmax) {
                C.msg = "invalid distance too far back", I.mode = 30;
                break;
              }
              I.mode = 25;
            case 25:
              if (Y === 0) break e;
              if (pe = ge - Y, I.offset > pe) {
                if ((pe = I.offset - pe) > I.whave && I.sane) {
                  C.msg = "invalid distance too far back", I.mode = 30;
                  break;
                }
                ce = pe > I.wnext ? (pe -= I.wnext, I.wsize - pe) : I.wnext - pe, pe > I.length && (pe = I.length), oe = I.window;
              } else oe = W, ce = z - I.offset, pe = I.length;
              for (Y < pe && (pe = Y), Y -= pe, I.length -= pe; W[z++] = oe[ce++], --pe; ) ;
              I.length === 0 && (I.mode = 21);
              break;
            case 26:
              if (Y === 0) break e;
              W[z++] = I.length, Y--, I.mode = 21;
              break;
            case 27:
              if (I.wrap) {
                for (; K < 32; ) {
                  if (q === 0) break e;
                  q--, H |= $[B++] << K, K += 8;
                }
                if (ge -= Y, C.total_out += ge, I.total += ge, ge && (C.adler = I.check = I.flags ? o(I.check, W, ge, z - ge) : s(I.check, W, ge, z - ge)), ge = Y, (I.flags ? H : p(H)) !== I.check) {
                  C.msg = "incorrect data check", I.mode = 30;
                  break;
                }
                K = H = 0;
              }
              I.mode = 28;
            case 28:
              if (I.wrap && I.flags) {
                for (; K < 32; ) {
                  if (q === 0) break e;
                  q--, H += $[B++] << K, K += 8;
                }
                if (H !== (4294967295 & I.total)) {
                  C.msg = "incorrect length check", I.mode = 30;
                  break;
                }
                K = H = 0;
              }
              I.mode = 29;
            case 29:
              he = 1;
              break e;
            case 30:
              he = -3;
              break e;
            case 31:
              return -4;
            case 32:
            default:
              return d;
          }
          return C.next_out = z, C.avail_out = Y, C.next_in = B, C.avail_in = q, I.hold = H, I.bits = K, (I.wsize || ge !== C.avail_out && I.mode < 30 && (I.mode < 27 || k !== 4)) && j(C, C.output, C.next_out, ge - C.avail_out) ? (I.mode = 31, -4) : (ie -= C.avail_in, ge -= C.avail_out, C.total_in += ie, C.total_out += ge, I.total += ge, I.wrap && ge && (C.adler = I.check = I.flags ? o(I.check, W, ge, C.next_out - ge) : s(I.check, W, ge, C.next_out - ge)), C.data_type = I.bits + (I.last ? 64 : 0) + (I.mode === 12 ? 128 : 0) + (I.mode === 20 || I.mode === 15 ? 256 : 0), (ie == 0 && ge === 0 || k === 4) && he === f && (he = -5), he);
        }, r.inflateEnd = function(C) {
          if (!C || !C.state) return d;
          var k = C.state;
          return k.window && (k.window = null), C.state = null, f;
        }, r.inflateGetHeader = function(C, k) {
          var I;
          return C && C.state ? (2 & (I = C.state).wrap) == 0 ? d : ((I.head = k).done = !1, f) : d;
        }, r.inflateSetDictionary = function(C, k) {
          var I, $ = k.length;
          return C && C.state ? (I = C.state).wrap !== 0 && I.mode !== 11 ? d : I.mode === 11 && s(1, k, $, 0) !== I.check ? -3 : j(C, k, $, $) ? (I.mode = 31, -4) : (I.havedict = 1, f) : d;
        }, r.inflateInfo = "pako inflate (from Nodeca project)";
      }, { "../utils/common": 41, "./adler32": 43, "./crc32": 45, "./inffast": 48, "./inftrees": 50 }], 50: [function(t, i, r) {
        var a = t("../utils/common"), s = [3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0], o = [16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18, 19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78], u = [1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577, 0, 0], c = [16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22, 23, 23, 24, 24, 25, 25, 26, 26, 27, 27, 28, 28, 29, 29, 64, 64];
        i.exports = function(l, h, f, d, y, m, b, p) {
          var g, v, _, x, T, E, U, D, L, j = p.bits, C = 0, k = 0, I = 0, $ = 0, W = 0, B = 0, z = 0, q = 0, Y = 0, H = 0, K = null, ie = 0, ge = new a.Buf16(16), pe = new a.Buf16(16), ce = null, oe = 0;
          for (C = 0; C <= 15; C++) ge[C] = 0;
          for (k = 0; k < d; k++) ge[h[f + k]]++;
          for (W = j, $ = 15; 1 <= $ && ge[$] === 0; $--) ;
          if ($ < W && (W = $), $ === 0) return y[m++] = 20971520, y[m++] = 20971520, p.bits = 1, 0;
          for (I = 1; I < $ && ge[I] === 0; I++) ;
          for (W < I && (W = I), C = q = 1; C <= 15; C++) if (q <<= 1, (q -= ge[C]) < 0) return -1;
          if (0 < q && (l === 0 || $ !== 1)) return -1;
          for (pe[1] = 0, C = 1; C < 15; C++) pe[C + 1] = pe[C] + ge[C];
          for (k = 0; k < d; k++) h[f + k] !== 0 && (b[pe[h[f + k]]++] = k);
          if (E = l === 0 ? (K = ce = b, 19) : l === 1 ? (K = s, ie -= 257, ce = o, oe -= 257, 256) : (K = u, ce = c, -1), C = I, T = m, z = k = H = 0, _ = -1, x = (Y = 1 << (B = W)) - 1, l === 1 && 852 < Y || l === 2 && 592 < Y) return 1;
          for (; ; ) {
            for (U = C - z, L = b[k] < E ? (D = 0, b[k]) : b[k] > E ? (D = ce[oe + b[k]], K[ie + b[k]]) : (D = 96, 0), g = 1 << C - z, I = v = 1 << B; y[T + (H >> z) + (v -= g)] = U << 24 | D << 16 | L | 0, v !== 0; ) ;
            for (g = 1 << C - 1; H & g; ) g >>= 1;
            if (g !== 0 ? (H &= g - 1, H += g) : H = 0, k++, --ge[C] == 0) {
              if (C === $) break;
              C = h[f + b[k]];
            }
            if (W < C && (H & x) !== _) {
              for (z === 0 && (z = W), T += I, q = 1 << (B = C - z); B + z < $ && !((q -= ge[B + z]) <= 0); ) B++, q <<= 1;
              if (Y += 1 << B, l === 1 && 852 < Y || l === 2 && 592 < Y) return 1;
              y[_ = H & x] = W << 24 | B << 16 | T - m | 0;
            }
          }
          return H !== 0 && (y[T + H] = C - z << 24 | 64 << 16 | 0), p.bits = W, 0;
        };
      }, { "../utils/common": 41 }], 51: [function(t, i, r) {
        i.exports = { 2: "need dictionary", 1: "stream end", 0: "", "-1": "file error", "-2": "stream error", "-3": "data error", "-4": "insufficient memory", "-5": "buffer error", "-6": "incompatible version" };
      }, {}], 52: [function(t, i, r) {
        var a = t("../utils/common"), s = 0, o = 1;
        function u(ee) {
          for (var ve = ee.length; 0 <= --ve; ) ee[ve] = 0;
        }
        var c = 0, l = 29, h = 256, f = h + 1 + l, d = 30, y = 19, m = 2 * f + 1, b = 15, p = 16, g = 7, v = 256, _ = 16, x = 17, T = 18, E = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0], U = [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13], D = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7], L = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15], j = new Array(2 * (f + 2));
        u(j);
        var C = new Array(2 * d);
        u(C);
        var k = new Array(512);
        u(k);
        var I = new Array(256);
        u(I);
        var $ = new Array(l);
        u($);
        var W, B, z, q = new Array(d);
        function Y(ee, ve, Ee, Se, xe) {
          this.static_tree = ee, this.extra_bits = ve, this.extra_base = Ee, this.elems = Se, this.max_length = xe, this.has_stree = ee && ee.length;
        }
        function H(ee, ve) {
          this.dyn_tree = ee, this.max_code = 0, this.stat_desc = ve;
        }
        function K(ee) {
          return ee < 256 ? k[ee] : k[256 + (ee >>> 7)];
        }
        function ie(ee, ve) {
          ee.pending_buf[ee.pending++] = 255 & ve, ee.pending_buf[ee.pending++] = ve >>> 8 & 255;
        }
        function ge(ee, ve, Ee) {
          ee.bi_valid > p - Ee ? (ee.bi_buf |= ve << ee.bi_valid & 65535, ie(ee, ee.bi_buf), ee.bi_buf = ve >> p - ee.bi_valid, ee.bi_valid += Ee - p) : (ee.bi_buf |= ve << ee.bi_valid & 65535, ee.bi_valid += Ee);
        }
        function pe(ee, ve, Ee) {
          ge(ee, Ee[2 * ve], Ee[2 * ve + 1]);
        }
        function ce(ee, ve) {
          for (var Ee = 0; Ee |= 1 & ee, ee >>>= 1, Ee <<= 1, 0 < --ve; ) ;
          return Ee >>> 1;
        }
        function oe(ee, ve, Ee) {
          var Se, xe, le = new Array(b + 1), ye = 0;
          for (Se = 1; Se <= b; Se++) le[Se] = ye = ye + Ee[Se - 1] << 1;
          for (xe = 0; xe <= ve; xe++) {
            var we = ee[2 * xe + 1];
            we !== 0 && (ee[2 * xe] = ce(le[we]++, we));
          }
        }
        function De(ee) {
          var ve;
          for (ve = 0; ve < f; ve++) ee.dyn_ltree[2 * ve] = 0;
          for (ve = 0; ve < d; ve++) ee.dyn_dtree[2 * ve] = 0;
          for (ve = 0; ve < y; ve++) ee.bl_tree[2 * ve] = 0;
          ee.dyn_ltree[2 * v] = 1, ee.opt_len = ee.static_len = 0, ee.last_lit = ee.matches = 0;
        }
        function Re(ee) {
          8 < ee.bi_valid ? ie(ee, ee.bi_buf) : 0 < ee.bi_valid && (ee.pending_buf[ee.pending++] = ee.bi_buf), ee.bi_buf = 0, ee.bi_valid = 0;
        }
        function Me(ee, ve, Ee, Se) {
          var xe = 2 * ve, le = 2 * Ee;
          return ee[xe] < ee[le] || ee[xe] === ee[le] && Se[ve] <= Se[Ee];
        }
        function F(ee, ve, Ee) {
          for (var Se = ee.heap[Ee], xe = Ee << 1; xe <= ee.heap_len && (xe < ee.heap_len && Me(ve, ee.heap[xe + 1], ee.heap[xe], ee.depth) && xe++, !Me(ve, Se, ee.heap[xe], ee.depth)); ) ee.heap[Ee] = ee.heap[xe], Ee = xe, xe <<= 1;
          ee.heap[Ee] = Se;
        }
        function P(ee, ve, Ee) {
          var Se, xe, le, ye, we = 0;
          if (ee.last_lit !== 0) for (; Se = ee.pending_buf[ee.d_buf + 2 * we] << 8 | ee.pending_buf[ee.d_buf + 2 * we + 1], xe = ee.pending_buf[ee.l_buf + we], we++, Se === 0 ? pe(ee, xe, ve) : (pe(ee, (le = I[xe]) + h + 1, ve), (ye = E[le]) !== 0 && ge(ee, xe -= $[le], ye), pe(ee, le = K(--Se), Ee), (ye = U[le]) !== 0 && ge(ee, Se -= q[le], ye)), we < ee.last_lit; ) ;
          pe(ee, v, ve);
        }
        function ne(ee, ve) {
          var Ee, Se, xe, le = ve.dyn_tree, ye = ve.stat_desc.static_tree, we = ve.stat_desc.has_stree, Ue = ve.stat_desc.elems, Q = -1;
          for (ee.heap_len = 0, ee.heap_max = m, Ee = 0; Ee < Ue; Ee++) le[2 * Ee] !== 0 ? (ee.heap[++ee.heap_len] = Q = Ee, ee.depth[Ee] = 0) : le[2 * Ee + 1] = 0;
          for (; ee.heap_len < 2; ) le[2 * (xe = ee.heap[++ee.heap_len] = Q < 2 ? ++Q : 0)] = 1, ee.depth[xe] = 0, ee.opt_len--, we && (ee.static_len -= ye[2 * xe + 1]);
          for (ve.max_code = Q, Ee = ee.heap_len >> 1; 1 <= Ee; Ee--) F(ee, le, Ee);
          for (xe = Ue; Ee = ee.heap[1], ee.heap[1] = ee.heap[ee.heap_len--], F(ee, le, 1), Se = ee.heap[1], ee.heap[--ee.heap_max] = Ee, ee.heap[--ee.heap_max] = Se, le[2 * xe] = le[2 * Ee] + le[2 * Se], ee.depth[xe] = (ee.depth[Ee] >= ee.depth[Se] ? ee.depth[Ee] : ee.depth[Se]) + 1, le[2 * Ee + 1] = le[2 * Se + 1] = xe, ee.heap[1] = xe++, F(ee, le, 1), 2 <= ee.heap_len; ) ;
          ee.heap[--ee.heap_max] = ee.heap[1], (function(M, N) {
            var Z, de, Te, Ie, je, Ze, Qe = N.dyn_tree, ot = N.max_code, rt = N.stat_desc.static_tree, Bi = N.stat_desc.has_stree, oi = N.stat_desc.extra_bits, ui = N.stat_desc.extra_base, G = N.stat_desc.max_length, J = 0;
            for (Ie = 0; Ie <= b; Ie++) M.bl_count[Ie] = 0;
            for (Qe[2 * M.heap[M.heap_max] + 1] = 0, Z = M.heap_max + 1; Z < m; Z++) G < (Ie = Qe[2 * Qe[2 * (de = M.heap[Z]) + 1] + 1] + 1) && (Ie = G, J++), Qe[2 * de + 1] = Ie, ot < de || (M.bl_count[Ie]++, je = 0, ui <= de && (je = oi[de - ui]), Ze = Qe[2 * de], M.opt_len += Ze * (Ie + je), Bi && (M.static_len += Ze * (rt[2 * de + 1] + je)));
            if (J !== 0) {
              do {
                for (Ie = G - 1; M.bl_count[Ie] === 0; ) Ie--;
                M.bl_count[Ie]--, M.bl_count[Ie + 1] += 2, M.bl_count[G]--, J -= 2;
              } while (0 < J);
              for (Ie = G; Ie !== 0; Ie--) for (de = M.bl_count[Ie]; de !== 0; ) ot < (Te = M.heap[--Z]) || (Qe[2 * Te + 1] !== Ie && (M.opt_len += (Ie - Qe[2 * Te + 1]) * Qe[2 * Te], Qe[2 * Te + 1] = Ie), de--);
            }
          })(ee, ve), oe(le, Q, ee.bl_count);
        }
        function S(ee, ve, Ee) {
          var Se, xe, le = -1, ye = ve[1], we = 0, Ue = 7, Q = 4;
          for (ye === 0 && (Ue = 138, Q = 3), ve[2 * (Ee + 1) + 1] = 65535, Se = 0; Se <= Ee; Se++) xe = ye, ye = ve[2 * (Se + 1) + 1], ++we < Ue && xe === ye || (we < Q ? ee.bl_tree[2 * xe] += we : xe !== 0 ? (xe !== le && ee.bl_tree[2 * xe]++, ee.bl_tree[2 * _]++) : we <= 10 ? ee.bl_tree[2 * x]++ : ee.bl_tree[2 * T]++, le = xe, Q = (we = 0) === ye ? (Ue = 138, 3) : xe === ye ? (Ue = 6, 3) : (Ue = 7, 4));
        }
        function he(ee, ve, Ee) {
          var Se, xe, le = -1, ye = ve[1], we = 0, Ue = 7, Q = 4;
          for (ye === 0 && (Ue = 138, Q = 3), Se = 0; Se <= Ee; Se++) if (xe = ye, ye = ve[2 * (Se + 1) + 1], !(++we < Ue && xe === ye)) {
            if (we < Q) for (; pe(ee, xe, ee.bl_tree), --we != 0; ) ;
            else xe !== 0 ? (xe !== le && (pe(ee, xe, ee.bl_tree), we--), pe(ee, _, ee.bl_tree), ge(ee, we - 3, 2)) : we <= 10 ? (pe(ee, x, ee.bl_tree), ge(ee, we - 3, 3)) : (pe(ee, T, ee.bl_tree), ge(ee, we - 11, 7));
            le = xe, Q = (we = 0) === ye ? (Ue = 138, 3) : xe === ye ? (Ue = 6, 3) : (Ue = 7, 4);
          }
        }
        u(q);
        var ae = !1;
        function te(ee, ve, Ee, Se) {
          ge(ee, (c << 1) + (Se ? 1 : 0), 3), (function(xe, le, ye, we) {
            Re(xe), ie(xe, ye), ie(xe, ~ye), a.arraySet(xe.pending_buf, xe.window, le, ye, xe.pending), xe.pending += ye;
          })(ee, ve, Ee);
        }
        r._tr_init = function(ee) {
          ae || ((function() {
            var ve, Ee, Se, xe, le, ye = new Array(b + 1);
            for (xe = Se = 0; xe < l - 1; xe++) for ($[xe] = Se, ve = 0; ve < 1 << E[xe]; ve++) I[Se++] = xe;
            for (I[Se - 1] = xe, xe = le = 0; xe < 16; xe++) for (q[xe] = le, ve = 0; ve < 1 << U[xe]; ve++) k[le++] = xe;
            for (le >>= 7; xe < d; xe++) for (q[xe] = le << 7, ve = 0; ve < 1 << U[xe] - 7; ve++) k[256 + le++] = xe;
            for (Ee = 0; Ee <= b; Ee++) ye[Ee] = 0;
            for (ve = 0; ve <= 143; ) j[2 * ve + 1] = 8, ve++, ye[8]++;
            for (; ve <= 255; ) j[2 * ve + 1] = 9, ve++, ye[9]++;
            for (; ve <= 279; ) j[2 * ve + 1] = 7, ve++, ye[7]++;
            for (; ve <= 287; ) j[2 * ve + 1] = 8, ve++, ye[8]++;
            for (oe(j, f + 1, ye), ve = 0; ve < d; ve++) C[2 * ve + 1] = 5, C[2 * ve] = ce(ve, 5);
            W = new Y(j, E, h + 1, f, b), B = new Y(C, U, 0, d, b), z = new Y(new Array(0), D, 0, y, g);
          })(), ae = !0), ee.l_desc = new H(ee.dyn_ltree, W), ee.d_desc = new H(ee.dyn_dtree, B), ee.bl_desc = new H(ee.bl_tree, z), ee.bi_buf = 0, ee.bi_valid = 0, De(ee);
        }, r._tr_stored_block = te, r._tr_flush_block = function(ee, ve, Ee, Se) {
          var xe, le, ye = 0;
          0 < ee.level ? (ee.strm.data_type === 2 && (ee.strm.data_type = (function(we) {
            var Ue, Q = 4093624447;
            for (Ue = 0; Ue <= 31; Ue++, Q >>>= 1) if (1 & Q && we.dyn_ltree[2 * Ue] !== 0) return s;
            if (we.dyn_ltree[18] !== 0 || we.dyn_ltree[20] !== 0 || we.dyn_ltree[26] !== 0) return o;
            for (Ue = 32; Ue < h; Ue++) if (we.dyn_ltree[2 * Ue] !== 0) return o;
            return s;
          })(ee)), ne(ee, ee.l_desc), ne(ee, ee.d_desc), ye = (function(we) {
            var Ue;
            for (S(we, we.dyn_ltree, we.l_desc.max_code), S(we, we.dyn_dtree, we.d_desc.max_code), ne(we, we.bl_desc), Ue = y - 1; 3 <= Ue && we.bl_tree[2 * L[Ue] + 1] === 0; Ue--) ;
            return we.opt_len += 3 * (Ue + 1) + 5 + 5 + 4, Ue;
          })(ee), xe = ee.opt_len + 3 + 7 >>> 3, (le = ee.static_len + 3 + 7 >>> 3) <= xe && (xe = le)) : xe = le = Ee + 5, Ee + 4 <= xe && ve !== -1 ? te(ee, ve, Ee, Se) : ee.strategy === 4 || le === xe ? (ge(ee, 2 + (Se ? 1 : 0), 3), P(ee, j, C)) : (ge(ee, 4 + (Se ? 1 : 0), 3), (function(we, Ue, Q, M) {
            var N;
            for (ge(we, Ue - 257, 5), ge(we, Q - 1, 5), ge(we, M - 4, 4), N = 0; N < M; N++) ge(we, we.bl_tree[2 * L[N] + 1], 3);
            he(we, we.dyn_ltree, Ue - 1), he(we, we.dyn_dtree, Q - 1);
          })(ee, ee.l_desc.max_code + 1, ee.d_desc.max_code + 1, ye + 1), P(ee, ee.dyn_ltree, ee.dyn_dtree)), De(ee), Se && Re(ee);
        }, r._tr_tally = function(ee, ve, Ee) {
          return ee.pending_buf[ee.d_buf + 2 * ee.last_lit] = ve >>> 8 & 255, ee.pending_buf[ee.d_buf + 2 * ee.last_lit + 1] = 255 & ve, ee.pending_buf[ee.l_buf + ee.last_lit] = 255 & Ee, ee.last_lit++, ve === 0 ? ee.dyn_ltree[2 * Ee]++ : (ee.matches++, ve--, ee.dyn_ltree[2 * (I[Ee] + h + 1)]++, ee.dyn_dtree[2 * K(ve)]++), ee.last_lit === ee.lit_bufsize - 1;
        }, r._tr_align = function(ee) {
          ge(ee, 2, 3), pe(ee, v, j), (function(ve) {
            ve.bi_valid === 16 ? (ie(ve, ve.bi_buf), ve.bi_buf = 0, ve.bi_valid = 0) : 8 <= ve.bi_valid && (ve.pending_buf[ve.pending++] = 255 & ve.bi_buf, ve.bi_buf >>= 8, ve.bi_valid -= 8);
          })(ee);
        };
      }, { "../utils/common": 41 }], 53: [function(t, i, r) {
        i.exports = function() {
          this.input = null, this.next_in = 0, this.avail_in = 0, this.total_in = 0, this.output = null, this.next_out = 0, this.avail_out = 0, this.total_out = 0, this.msg = "", this.state = null, this.data_type = 2, this.adler = 0;
        };
      }, {}], 54: [function(t, i, r) {
        (function(a) {
          (function(s, o) {
            if (!s.setImmediate) {
              var u, c, l, h, f = 1, d = {}, y = !1, m = s.document, b = Object.getPrototypeOf && Object.getPrototypeOf(s);
              b = b && b.setTimeout ? b : s, u = {}.toString.call(s.process) === "[object process]" ? function(_) {
                process.nextTick(function() {
                  g(_);
                });
              } : (function() {
                if (s.postMessage && !s.importScripts) {
                  var _ = !0, x = s.onmessage;
                  return s.onmessage = function() {
                    _ = !1;
                  }, s.postMessage("", "*"), s.onmessage = x, _;
                }
              })() ? (h = "setImmediate$" + Math.random() + "$", s.addEventListener ? s.addEventListener("message", v, !1) : s.attachEvent("onmessage", v), function(_) {
                s.postMessage(h + _, "*");
              }) : s.MessageChannel ? ((l = new MessageChannel()).port1.onmessage = function(_) {
                g(_.data);
              }, function(_) {
                l.port2.postMessage(_);
              }) : m && "onreadystatechange" in m.createElement("script") ? (c = m.documentElement, function(_) {
                var x = m.createElement("script");
                x.onreadystatechange = function() {
                  g(_), x.onreadystatechange = null, c.removeChild(x), x = null;
                }, c.appendChild(x);
              }) : function(_) {
                setTimeout(g, 0, _);
              }, b.setImmediate = function(_) {
                typeof _ != "function" && (_ = new Function("" + _));
                for (var x = new Array(arguments.length - 1), T = 0; T < x.length; T++) x[T] = arguments[T + 1];
                var E = { callback: _, args: x };
                return d[f] = E, u(f), f++;
              }, b.clearImmediate = p;
            }
            function p(_) {
              delete d[_];
            }
            function g(_) {
              if (y) setTimeout(g, 0, _);
              else {
                var x = d[_];
                if (x) {
                  y = !0;
                  try {
                    (function(T) {
                      var E = T.callback, U = T.args;
                      switch (U.length) {
                        case 0:
                          E();
                          break;
                        case 1:
                          E(U[0]);
                          break;
                        case 2:
                          E(U[0], U[1]);
                          break;
                        case 3:
                          E(U[0], U[1], U[2]);
                          break;
                        default:
                          E.apply(o, U);
                      }
                    })(x);
                  } finally {
                    p(_), y = !1;
                  }
                }
              }
            }
            function v(_) {
              _.source === s && typeof _.data == "string" && _.data.indexOf(h) === 0 && g(+_.data.slice(h.length));
            }
          })(typeof self > "u" ? a === void 0 ? this : a : self);
        }).call(this, typeof At < "u" ? At : typeof self < "u" ? self : typeof window < "u" ? window : {});
      }, {}] }, {}, [10])(10);
    });
  })(ah)), ah.exports;
}
var A1;
function kE() {
  if (A1) return us;
  A1 = 1;
  var n = _k();
  us.openArrayBuffer = e, us.splitPath = i, us.joinPath = r;
  function e(a) {
    return n.loadAsync(a).then(function(s) {
      function o(h) {
        return s.file(h) !== null;
      }
      function u(h, f) {
        return s.file(h).async("uint8array").then(function(d) {
          var y = t(d);
          return f ? y.toString(f) : y;
        });
      }
      function c(h, f) {
        s.file(h, f);
      }
      function l() {
        return s.generateAsync({ type: "nodebuffer" });
      }
      return {
        exists: o,
        read: u,
        write: c,
        toBuffer: l
      };
    });
  }
  function t(a) {
    return Buffer.from && Buffer.from !== Uint8Array.from ? Buffer.from(a) : new Buffer(a);
  }
  function i(a) {
    var s = a.lastIndexOf("/");
    return s === -1 ? { dirname: "", basename: a } : {
      dirname: a.substring(0, s),
      basename: a.substring(s + 1)
    };
  }
  function r() {
    var a = Array.prototype.filter.call(arguments, function(o) {
      return o;
    }), s = [];
    return a.forEach(function(o) {
      /^\//.test(o) ? s = [o] : s.push(o);
    }), s.join("/");
  }
  return us;
}
var iu = {}, vr = {}, cs = {}, k1;
function IE() {
  if (k1) return cs;
  k1 = 1;
  var n = Pt;
  cs.Element = t, cs.element = function(a, s, o) {
    return new t(a, s, o);
  }, cs.text = function(a) {
    return {
      type: "text",
      value: a
    };
  };
  var e = {
    first: function() {
      return null;
    },
    firstOrEmpty: function() {
      return e;
    },
    attributes: {}
  };
  function t(a, s, o) {
    this.type = "element", this.name = a, this.attributes = s || {}, this.children = o || [];
  }
  t.prototype.first = function(a) {
    return n.find(this.children, function(s) {
      return s.name === a;
    });
  }, t.prototype.firstOrEmpty = function(a) {
    return this.first(a) || e;
  }, t.prototype.getElementsByTagName = function(a) {
    var s = n.filter(this.children, function(o) {
      return o.name === a;
    });
    return r(s);
  }, t.prototype.text = function() {
    if (this.children.length === 0)
      return "";
    if (this.children.length !== 1 || this.children[0].type !== "text")
      throw new Error("Not implemented");
    return this.children[0].value;
  };
  var i = {
    getElementsByTagName: function(a) {
      return r(n.flatten(this.map(function(s) {
        return s.getElementsByTagName(a);
      }, !0)));
    }
  };
  function r(a) {
    return n.extend(a, i);
  }
  return cs;
}
var sh = {}, oh = {}, ru = { exports: {} }, I1;
function Pg() {
  if (I1) return ru.exports;
  I1 = 1;
  var n = typeof Reflect == "object" ? Reflect : null, e = n && typeof n.apply == "function" ? n.apply : function(x, T, E) {
    return Function.prototype.apply.call(x, T, E);
  }, t;
  n && typeof n.ownKeys == "function" ? t = n.ownKeys : Object.getOwnPropertySymbols ? t = function(x) {
    return Object.getOwnPropertyNames(x).concat(Object.getOwnPropertySymbols(x));
  } : t = function(x) {
    return Object.getOwnPropertyNames(x);
  };
  function i(_) {
    console && console.warn && console.warn(_);
  }
  var r = Number.isNaN || function(x) {
    return x !== x;
  };
  function a() {
    a.init.call(this);
  }
  ru.exports = a, ru.exports.once = p, a.EventEmitter = a, a.prototype._events = void 0, a.prototype._eventsCount = 0, a.prototype._maxListeners = void 0;
  var s = 10;
  function o(_) {
    if (typeof _ != "function")
      throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof _);
  }
  Object.defineProperty(a, "defaultMaxListeners", {
    enumerable: !0,
    get: function() {
      return s;
    },
    set: function(_) {
      if (typeof _ != "number" || _ < 0 || r(_))
        throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + _ + ".");
      s = _;
    }
  }), a.init = function() {
    (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) && (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0), this._maxListeners = this._maxListeners || void 0;
  }, a.prototype.setMaxListeners = function(x) {
    if (typeof x != "number" || x < 0 || r(x))
      throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + x + ".");
    return this._maxListeners = x, this;
  };
  function u(_) {
    return _._maxListeners === void 0 ? a.defaultMaxListeners : _._maxListeners;
  }
  a.prototype.getMaxListeners = function() {
    return u(this);
  }, a.prototype.emit = function(x) {
    for (var T = [], E = 1; E < arguments.length; E++) T.push(arguments[E]);
    var U = x === "error", D = this._events;
    if (D !== void 0)
      U = U && D.error === void 0;
    else if (!U)
      return !1;
    if (U) {
      var L;
      if (T.length > 0 && (L = T[0]), L instanceof Error)
        throw L;
      var j = new Error("Unhandled error." + (L ? " (" + L.message + ")" : ""));
      throw j.context = L, j;
    }
    var C = D[x];
    if (C === void 0)
      return !1;
    if (typeof C == "function")
      e(C, this, T);
    else
      for (var k = C.length, I = y(C, k), E = 0; E < k; ++E)
        e(I[E], this, T);
    return !0;
  };
  function c(_, x, T, E) {
    var U, D, L;
    if (o(T), D = _._events, D === void 0 ? (D = _._events = /* @__PURE__ */ Object.create(null), _._eventsCount = 0) : (D.newListener !== void 0 && (_.emit(
      "newListener",
      x,
      T.listener ? T.listener : T
    ), D = _._events), L = D[x]), L === void 0)
      L = D[x] = T, ++_._eventsCount;
    else if (typeof L == "function" ? L = D[x] = E ? [T, L] : [L, T] : E ? L.unshift(T) : L.push(T), U = u(_), U > 0 && L.length > U && !L.warned) {
      L.warned = !0;
      var j = new Error("Possible EventEmitter memory leak detected. " + L.length + " " + String(x) + " listeners added. Use emitter.setMaxListeners() to increase limit");
      j.name = "MaxListenersExceededWarning", j.emitter = _, j.type = x, j.count = L.length, i(j);
    }
    return _;
  }
  a.prototype.addListener = function(x, T) {
    return c(this, x, T, !1);
  }, a.prototype.on = a.prototype.addListener, a.prototype.prependListener = function(x, T) {
    return c(this, x, T, !0);
  };
  function l() {
    if (!this.fired)
      return this.target.removeListener(this.type, this.wrapFn), this.fired = !0, arguments.length === 0 ? this.listener.call(this.target) : this.listener.apply(this.target, arguments);
  }
  function h(_, x, T) {
    var E = { fired: !1, wrapFn: void 0, target: _, type: x, listener: T }, U = l.bind(E);
    return U.listener = T, E.wrapFn = U, U;
  }
  a.prototype.once = function(x, T) {
    return o(T), this.on(x, h(this, x, T)), this;
  }, a.prototype.prependOnceListener = function(x, T) {
    return o(T), this.prependListener(x, h(this, x, T)), this;
  }, a.prototype.removeListener = function(x, T) {
    var E, U, D, L, j;
    if (o(T), U = this._events, U === void 0)
      return this;
    if (E = U[x], E === void 0)
      return this;
    if (E === T || E.listener === T)
      --this._eventsCount === 0 ? this._events = /* @__PURE__ */ Object.create(null) : (delete U[x], U.removeListener && this.emit("removeListener", x, E.listener || T));
    else if (typeof E != "function") {
      for (D = -1, L = E.length - 1; L >= 0; L--)
        if (E[L] === T || E[L].listener === T) {
          j = E[L].listener, D = L;
          break;
        }
      if (D < 0)
        return this;
      D === 0 ? E.shift() : m(E, D), E.length === 1 && (U[x] = E[0]), U.removeListener !== void 0 && this.emit("removeListener", x, j || T);
    }
    return this;
  }, a.prototype.off = a.prototype.removeListener, a.prototype.removeAllListeners = function(x) {
    var T, E, U;
    if (E = this._events, E === void 0)
      return this;
    if (E.removeListener === void 0)
      return arguments.length === 0 ? (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0) : E[x] !== void 0 && (--this._eventsCount === 0 ? this._events = /* @__PURE__ */ Object.create(null) : delete E[x]), this;
    if (arguments.length === 0) {
      var D = Object.keys(E), L;
      for (U = 0; U < D.length; ++U)
        L = D[U], L !== "removeListener" && this.removeAllListeners(L);
      return this.removeAllListeners("removeListener"), this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0, this;
    }
    if (T = E[x], typeof T == "function")
      this.removeListener(x, T);
    else if (T !== void 0)
      for (U = T.length - 1; U >= 0; U--)
        this.removeListener(x, T[U]);
    return this;
  };
  function f(_, x, T) {
    var E = _._events;
    if (E === void 0)
      return [];
    var U = E[x];
    return U === void 0 ? [] : typeof U == "function" ? T ? [U.listener || U] : [U] : T ? b(U) : y(U, U.length);
  }
  a.prototype.listeners = function(x) {
    return f(this, x, !0);
  }, a.prototype.rawListeners = function(x) {
    return f(this, x, !1);
  }, a.listenerCount = function(_, x) {
    return typeof _.listenerCount == "function" ? _.listenerCount(x) : d.call(_, x);
  }, a.prototype.listenerCount = d;
  function d(_) {
    var x = this._events;
    if (x !== void 0) {
      var T = x[_];
      if (typeof T == "function")
        return 1;
      if (T !== void 0)
        return T.length;
    }
    return 0;
  }
  a.prototype.eventNames = function() {
    return this._eventsCount > 0 ? t(this._events) : [];
  };
  function y(_, x) {
    for (var T = new Array(x), E = 0; E < x; ++E)
      T[E] = _[E];
    return T;
  }
  function m(_, x) {
    for (; x + 1 < _.length; x++)
      _[x] = _[x + 1];
    _.pop();
  }
  function b(_) {
    for (var x = new Array(_.length), T = 0; T < x.length; ++T)
      x[T] = _[T].listener || _[T];
    return x;
  }
  function p(_, x) {
    return new Promise(function(T, E) {
      function U(L) {
        _.removeListener(x, D), E(L);
      }
      function D() {
        typeof _.removeListener == "function" && _.removeListener("error", U), T([].slice.call(arguments));
      }
      v(_, x, D, { once: !0 }), x !== "error" && g(_, U, { once: !0 });
    });
  }
  function g(_, x, T) {
    typeof _.on == "function" && v(_, "error", x, T);
  }
  function v(_, x, T, E) {
    if (typeof _.on == "function")
      E.once ? _.once(x, T) : _.on(x, T);
    else if (typeof _.addEventListener == "function")
      _.addEventListener(x, function U(D) {
        E.once && _.removeEventListener(x, U), T(D);
      });
    else
      throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof _);
  }
  return ru.exports;
}
var au = { exports: {} }, U1;
function Ra() {
  return U1 || (U1 = 1, typeof Object.create == "function" ? au.exports = function(e, t) {
    t && (e.super_ = t, e.prototype = Object.create(t.prototype, {
      constructor: {
        value: e,
        enumerable: !1,
        writable: !0,
        configurable: !0
      }
    }));
  } : au.exports = function(e, t) {
    if (t) {
      e.super_ = t;
      var i = function() {
      };
      i.prototype = t.prototype, e.prototype = new i(), e.prototype.constructor = e;
    }
  }), au.exports;
}
var uh, R1;
function UE() {
  return R1 || (R1 = 1, uh = Pg().EventEmitter), uh;
}
var ch = {}, ls = {}, O1;
function Tk() {
  if (O1) return ls;
  O1 = 1, ls.byteLength = o, ls.toByteArray = c, ls.fromByteArray = f;
  for (var n = [], e = [], t = typeof Uint8Array < "u" ? Uint8Array : Array, i = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", r = 0, a = i.length; r < a; ++r)
    n[r] = i[r], e[i.charCodeAt(r)] = r;
  e[45] = 62, e[95] = 63;
  function s(d) {
    var y = d.length;
    if (y % 4 > 0)
      throw new Error("Invalid string. Length must be a multiple of 4");
    var m = d.indexOf("=");
    m === -1 && (m = y);
    var b = m === y ? 0 : 4 - m % 4;
    return [m, b];
  }
  function o(d) {
    var y = s(d), m = y[0], b = y[1];
    return (m + b) * 3 / 4 - b;
  }
  function u(d, y, m) {
    return (y + m) * 3 / 4 - m;
  }
  function c(d) {
    var y, m = s(d), b = m[0], p = m[1], g = new t(u(d, b, p)), v = 0, _ = p > 0 ? b - 4 : b, x;
    for (x = 0; x < _; x += 4)
      y = e[d.charCodeAt(x)] << 18 | e[d.charCodeAt(x + 1)] << 12 | e[d.charCodeAt(x + 2)] << 6 | e[d.charCodeAt(x + 3)], g[v++] = y >> 16 & 255, g[v++] = y >> 8 & 255, g[v++] = y & 255;
    return p === 2 && (y = e[d.charCodeAt(x)] << 2 | e[d.charCodeAt(x + 1)] >> 4, g[v++] = y & 255), p === 1 && (y = e[d.charCodeAt(x)] << 10 | e[d.charCodeAt(x + 1)] << 4 | e[d.charCodeAt(x + 2)] >> 2, g[v++] = y >> 8 & 255, g[v++] = y & 255), g;
  }
  function l(d) {
    return n[d >> 18 & 63] + n[d >> 12 & 63] + n[d >> 6 & 63] + n[d & 63];
  }
  function h(d, y, m) {
    for (var b, p = [], g = y; g < m; g += 3)
      b = (d[g] << 16 & 16711680) + (d[g + 1] << 8 & 65280) + (d[g + 2] & 255), p.push(l(b));
    return p.join("");
  }
  function f(d) {
    for (var y, m = d.length, b = m % 3, p = [], g = 16383, v = 0, _ = m - b; v < _; v += g)
      p.push(h(d, v, v + g > _ ? _ : v + g));
    return b === 1 ? (y = d[m - 1], p.push(
      n[y >> 2] + n[y << 4 & 63] + "=="
    )) : b === 2 && (y = (d[m - 2] << 8) + d[m - 1], p.push(
      n[y >> 10] + n[y >> 4 & 63] + n[y << 2 & 63] + "="
    )), p.join("");
  }
  return ls;
}
var su = {};
/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
var L1;
function wk() {
  return L1 || (L1 = 1, su.read = function(n, e, t, i, r) {
    var a, s, o = r * 8 - i - 1, u = (1 << o) - 1, c = u >> 1, l = -7, h = t ? r - 1 : 0, f = t ? -1 : 1, d = n[e + h];
    for (h += f, a = d & (1 << -l) - 1, d >>= -l, l += o; l > 0; a = a * 256 + n[e + h], h += f, l -= 8)
      ;
    for (s = a & (1 << -l) - 1, a >>= -l, l += i; l > 0; s = s * 256 + n[e + h], h += f, l -= 8)
      ;
    if (a === 0)
      a = 1 - c;
    else {
      if (a === u)
        return s ? NaN : (d ? -1 : 1) * (1 / 0);
      s = s + Math.pow(2, i), a = a - c;
    }
    return (d ? -1 : 1) * s * Math.pow(2, a - i);
  }, su.write = function(n, e, t, i, r, a) {
    var s, o, u, c = a * 8 - r - 1, l = (1 << c) - 1, h = l >> 1, f = r === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, d = i ? 0 : a - 1, y = i ? 1 : -1, m = e < 0 || e === 0 && 1 / e < 0 ? 1 : 0;
    for (e = Math.abs(e), isNaN(e) || e === 1 / 0 ? (o = isNaN(e) ? 1 : 0, s = l) : (s = Math.floor(Math.log(e) / Math.LN2), e * (u = Math.pow(2, -s)) < 1 && (s--, u *= 2), s + h >= 1 ? e += f / u : e += f * Math.pow(2, 1 - h), e * u >= 2 && (s++, u /= 2), s + h >= l ? (o = 0, s = l) : s + h >= 1 ? (o = (e * u - 1) * Math.pow(2, r), s = s + h) : (o = e * Math.pow(2, h - 1) * Math.pow(2, r), s = 0)); r >= 8; n[t + d] = o & 255, d += y, o /= 256, r -= 8)
      ;
    for (s = s << r | o, c += r; c > 0; n[t + d] = s & 255, d += y, s /= 256, c -= 8)
      ;
    n[t + d - y] |= m * 128;
  }), su;
}
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
var P1;
function lo() {
  return P1 || (P1 = 1, (function(n) {
    const e = Tk(), t = wk(), i = typeof Symbol == "function" && typeof Symbol.for == "function" ? Symbol.for("nodejs.util.inspect.custom") : null;
    n.Buffer = o, n.SlowBuffer = g, n.INSPECT_MAX_BYTES = 50;
    const r = 2147483647;
    n.kMaxLength = r, o.TYPED_ARRAY_SUPPORT = a(), !o.TYPED_ARRAY_SUPPORT && typeof console < "u" && typeof console.error == "function" && console.error(
      "This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."
    );
    function a() {
      try {
        const Q = new Uint8Array(1), M = { foo: function() {
          return 42;
        } };
        return Object.setPrototypeOf(M, Uint8Array.prototype), Object.setPrototypeOf(Q, M), Q.foo() === 42;
      } catch {
        return !1;
      }
    }
    Object.defineProperty(o.prototype, "parent", {
      enumerable: !0,
      get: function() {
        if (o.isBuffer(this))
          return this.buffer;
      }
    }), Object.defineProperty(o.prototype, "offset", {
      enumerable: !0,
      get: function() {
        if (o.isBuffer(this))
          return this.byteOffset;
      }
    });
    function s(Q) {
      if (Q > r)
        throw new RangeError('The value "' + Q + '" is invalid for option "size"');
      const M = new Uint8Array(Q);
      return Object.setPrototypeOf(M, o.prototype), M;
    }
    function o(Q, M, N) {
      if (typeof Q == "number") {
        if (typeof M == "string")
          throw new TypeError(
            'The "string" argument must be of type string. Received type number'
          );
        return h(Q);
      }
      return u(Q, M, N);
    }
    o.poolSize = 8192;
    function u(Q, M, N) {
      if (typeof Q == "string")
        return f(Q, M);
      if (ArrayBuffer.isView(Q))
        return y(Q);
      if (Q == null)
        throw new TypeError(
          "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof Q
        );
      if (xe(Q, ArrayBuffer) || Q && xe(Q.buffer, ArrayBuffer) || typeof SharedArrayBuffer < "u" && (xe(Q, SharedArrayBuffer) || Q && xe(Q.buffer, SharedArrayBuffer)))
        return m(Q, M, N);
      if (typeof Q == "number")
        throw new TypeError(
          'The "value" argument must not be of type number. Received type number'
        );
      const Z = Q.valueOf && Q.valueOf();
      if (Z != null && Z !== Q)
        return o.from(Z, M, N);
      const de = b(Q);
      if (de) return de;
      if (typeof Symbol < "u" && Symbol.toPrimitive != null && typeof Q[Symbol.toPrimitive] == "function")
        return o.from(Q[Symbol.toPrimitive]("string"), M, N);
      throw new TypeError(
        "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof Q
      );
    }
    o.from = function(Q, M, N) {
      return u(Q, M, N);
    }, Object.setPrototypeOf(o.prototype, Uint8Array.prototype), Object.setPrototypeOf(o, Uint8Array);
    function c(Q) {
      if (typeof Q != "number")
        throw new TypeError('"size" argument must be of type number');
      if (Q < 0)
        throw new RangeError('The value "' + Q + '" is invalid for option "size"');
    }
    function l(Q, M, N) {
      return c(Q), Q <= 0 ? s(Q) : M !== void 0 ? typeof N == "string" ? s(Q).fill(M, N) : s(Q).fill(M) : s(Q);
    }
    o.alloc = function(Q, M, N) {
      return l(Q, M, N);
    };
    function h(Q) {
      return c(Q), s(Q < 0 ? 0 : p(Q) | 0);
    }
    o.allocUnsafe = function(Q) {
      return h(Q);
    }, o.allocUnsafeSlow = function(Q) {
      return h(Q);
    };
    function f(Q, M) {
      if ((typeof M != "string" || M === "") && (M = "utf8"), !o.isEncoding(M))
        throw new TypeError("Unknown encoding: " + M);
      const N = v(Q, M) | 0;
      let Z = s(N);
      const de = Z.write(Q, M);
      return de !== N && (Z = Z.slice(0, de)), Z;
    }
    function d(Q) {
      const M = Q.length < 0 ? 0 : p(Q.length) | 0, N = s(M);
      for (let Z = 0; Z < M; Z += 1)
        N[Z] = Q[Z] & 255;
      return N;
    }
    function y(Q) {
      if (xe(Q, Uint8Array)) {
        const M = new Uint8Array(Q);
        return m(M.buffer, M.byteOffset, M.byteLength);
      }
      return d(Q);
    }
    function m(Q, M, N) {
      if (M < 0 || Q.byteLength < M)
        throw new RangeError('"offset" is outside of buffer bounds');
      if (Q.byteLength < M + (N || 0))
        throw new RangeError('"length" is outside of buffer bounds');
      let Z;
      return M === void 0 && N === void 0 ? Z = new Uint8Array(Q) : N === void 0 ? Z = new Uint8Array(Q, M) : Z = new Uint8Array(Q, M, N), Object.setPrototypeOf(Z, o.prototype), Z;
    }
    function b(Q) {
      if (o.isBuffer(Q)) {
        const M = p(Q.length) | 0, N = s(M);
        return N.length === 0 || Q.copy(N, 0, 0, M), N;
      }
      if (Q.length !== void 0)
        return typeof Q.length != "number" || le(Q.length) ? s(0) : d(Q);
      if (Q.type === "Buffer" && Array.isArray(Q.data))
        return d(Q.data);
    }
    function p(Q) {
      if (Q >= r)
        throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + r.toString(16) + " bytes");
      return Q | 0;
    }
    function g(Q) {
      return +Q != Q && (Q = 0), o.alloc(+Q);
    }
    o.isBuffer = function(M) {
      return M != null && M._isBuffer === !0 && M !== o.prototype;
    }, o.compare = function(M, N) {
      if (xe(M, Uint8Array) && (M = o.from(M, M.offset, M.byteLength)), xe(N, Uint8Array) && (N = o.from(N, N.offset, N.byteLength)), !o.isBuffer(M) || !o.isBuffer(N))
        throw new TypeError(
          'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
        );
      if (M === N) return 0;
      let Z = M.length, de = N.length;
      for (let Te = 0, Ie = Math.min(Z, de); Te < Ie; ++Te)
        if (M[Te] !== N[Te]) {
          Z = M[Te], de = N[Te];
          break;
        }
      return Z < de ? -1 : de < Z ? 1 : 0;
    }, o.isEncoding = function(M) {
      switch (String(M).toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "latin1":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return !0;
        default:
          return !1;
      }
    }, o.concat = function(M, N) {
      if (!Array.isArray(M))
        throw new TypeError('"list" argument must be an Array of Buffers');
      if (M.length === 0)
        return o.alloc(0);
      let Z;
      if (N === void 0)
        for (N = 0, Z = 0; Z < M.length; ++Z)
          N += M[Z].length;
      const de = o.allocUnsafe(N);
      let Te = 0;
      for (Z = 0; Z < M.length; ++Z) {
        let Ie = M[Z];
        if (xe(Ie, Uint8Array))
          Te + Ie.length > de.length ? (o.isBuffer(Ie) || (Ie = o.from(Ie)), Ie.copy(de, Te)) : Uint8Array.prototype.set.call(
            de,
            Ie,
            Te
          );
        else if (o.isBuffer(Ie))
          Ie.copy(de, Te);
        else
          throw new TypeError('"list" argument must be an Array of Buffers');
        Te += Ie.length;
      }
      return de;
    };
    function v(Q, M) {
      if (o.isBuffer(Q))
        return Q.length;
      if (ArrayBuffer.isView(Q) || xe(Q, ArrayBuffer))
        return Q.byteLength;
      if (typeof Q != "string")
        throw new TypeError(
          'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof Q
        );
      const N = Q.length, Z = arguments.length > 2 && arguments[2] === !0;
      if (!Z && N === 0) return 0;
      let de = !1;
      for (; ; )
        switch (M) {
          case "ascii":
          case "latin1":
          case "binary":
            return N;
          case "utf8":
          case "utf-8":
            return te(Q).length;
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return N * 2;
          case "hex":
            return N >>> 1;
          case "base64":
            return Ee(Q).length;
          default:
            if (de)
              return Z ? -1 : te(Q).length;
            M = ("" + M).toLowerCase(), de = !0;
        }
    }
    o.byteLength = v;
    function _(Q, M, N) {
      let Z = !1;
      if ((M === void 0 || M < 0) && (M = 0), M > this.length || ((N === void 0 || N > this.length) && (N = this.length), N <= 0) || (N >>>= 0, M >>>= 0, N <= M))
        return "";
      for (Q || (Q = "utf8"); ; )
        switch (Q) {
          case "hex":
            return q(this, M, N);
          case "utf8":
          case "utf-8":
            return I(this, M, N);
          case "ascii":
            return B(this, M, N);
          case "latin1":
          case "binary":
            return z(this, M, N);
          case "base64":
            return k(this, M, N);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return Y(this, M, N);
          default:
            if (Z) throw new TypeError("Unknown encoding: " + Q);
            Q = (Q + "").toLowerCase(), Z = !0;
        }
    }
    o.prototype._isBuffer = !0;
    function x(Q, M, N) {
      const Z = Q[M];
      Q[M] = Q[N], Q[N] = Z;
    }
    o.prototype.swap16 = function() {
      const M = this.length;
      if (M % 2 !== 0)
        throw new RangeError("Buffer size must be a multiple of 16-bits");
      for (let N = 0; N < M; N += 2)
        x(this, N, N + 1);
      return this;
    }, o.prototype.swap32 = function() {
      const M = this.length;
      if (M % 4 !== 0)
        throw new RangeError("Buffer size must be a multiple of 32-bits");
      for (let N = 0; N < M; N += 4)
        x(this, N, N + 3), x(this, N + 1, N + 2);
      return this;
    }, o.prototype.swap64 = function() {
      const M = this.length;
      if (M % 8 !== 0)
        throw new RangeError("Buffer size must be a multiple of 64-bits");
      for (let N = 0; N < M; N += 8)
        x(this, N, N + 7), x(this, N + 1, N + 6), x(this, N + 2, N + 5), x(this, N + 3, N + 4);
      return this;
    }, o.prototype.toString = function() {
      const M = this.length;
      return M === 0 ? "" : arguments.length === 0 ? I(this, 0, M) : _.apply(this, arguments);
    }, o.prototype.toLocaleString = o.prototype.toString, o.prototype.equals = function(M) {
      if (!o.isBuffer(M)) throw new TypeError("Argument must be a Buffer");
      return this === M ? !0 : o.compare(this, M) === 0;
    }, o.prototype.inspect = function() {
      let M = "";
      const N = n.INSPECT_MAX_BYTES;
      return M = this.toString("hex", 0, N).replace(/(.{2})/g, "$1 ").trim(), this.length > N && (M += " ... "), "<Buffer " + M + ">";
    }, i && (o.prototype[i] = o.prototype.inspect), o.prototype.compare = function(M, N, Z, de, Te) {
      if (xe(M, Uint8Array) && (M = o.from(M, M.offset, M.byteLength)), !o.isBuffer(M))
        throw new TypeError(
          'The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof M
        );
      if (N === void 0 && (N = 0), Z === void 0 && (Z = M ? M.length : 0), de === void 0 && (de = 0), Te === void 0 && (Te = this.length), N < 0 || Z > M.length || de < 0 || Te > this.length)
        throw new RangeError("out of range index");
      if (de >= Te && N >= Z)
        return 0;
      if (de >= Te)
        return -1;
      if (N >= Z)
        return 1;
      if (N >>>= 0, Z >>>= 0, de >>>= 0, Te >>>= 0, this === M) return 0;
      let Ie = Te - de, je = Z - N;
      const Ze = Math.min(Ie, je), Qe = this.slice(de, Te), ot = M.slice(N, Z);
      for (let rt = 0; rt < Ze; ++rt)
        if (Qe[rt] !== ot[rt]) {
          Ie = Qe[rt], je = ot[rt];
          break;
        }
      return Ie < je ? -1 : je < Ie ? 1 : 0;
    };
    function T(Q, M, N, Z, de) {
      if (Q.length === 0) return -1;
      if (typeof N == "string" ? (Z = N, N = 0) : N > 2147483647 ? N = 2147483647 : N < -2147483648 && (N = -2147483648), N = +N, le(N) && (N = de ? 0 : Q.length - 1), N < 0 && (N = Q.length + N), N >= Q.length) {
        if (de) return -1;
        N = Q.length - 1;
      } else if (N < 0)
        if (de) N = 0;
        else return -1;
      if (typeof M == "string" && (M = o.from(M, Z)), o.isBuffer(M))
        return M.length === 0 ? -1 : E(Q, M, N, Z, de);
      if (typeof M == "number")
        return M = M & 255, typeof Uint8Array.prototype.indexOf == "function" ? de ? Uint8Array.prototype.indexOf.call(Q, M, N) : Uint8Array.prototype.lastIndexOf.call(Q, M, N) : E(Q, [M], N, Z, de);
      throw new TypeError("val must be string, number or Buffer");
    }
    function E(Q, M, N, Z, de) {
      let Te = 1, Ie = Q.length, je = M.length;
      if (Z !== void 0 && (Z = String(Z).toLowerCase(), Z === "ucs2" || Z === "ucs-2" || Z === "utf16le" || Z === "utf-16le")) {
        if (Q.length < 2 || M.length < 2)
          return -1;
        Te = 2, Ie /= 2, je /= 2, N /= 2;
      }
      function Ze(ot, rt) {
        return Te === 1 ? ot[rt] : ot.readUInt16BE(rt * Te);
      }
      let Qe;
      if (de) {
        let ot = -1;
        for (Qe = N; Qe < Ie; Qe++)
          if (Ze(Q, Qe) === Ze(M, ot === -1 ? 0 : Qe - ot)) {
            if (ot === -1 && (ot = Qe), Qe - ot + 1 === je) return ot * Te;
          } else
            ot !== -1 && (Qe -= Qe - ot), ot = -1;
      } else
        for (N + je > Ie && (N = Ie - je), Qe = N; Qe >= 0; Qe--) {
          let ot = !0;
          for (let rt = 0; rt < je; rt++)
            if (Ze(Q, Qe + rt) !== Ze(M, rt)) {
              ot = !1;
              break;
            }
          if (ot) return Qe;
        }
      return -1;
    }
    o.prototype.includes = function(M, N, Z) {
      return this.indexOf(M, N, Z) !== -1;
    }, o.prototype.indexOf = function(M, N, Z) {
      return T(this, M, N, Z, !0);
    }, o.prototype.lastIndexOf = function(M, N, Z) {
      return T(this, M, N, Z, !1);
    };
    function U(Q, M, N, Z) {
      N = Number(N) || 0;
      const de = Q.length - N;
      Z ? (Z = Number(Z), Z > de && (Z = de)) : Z = de;
      const Te = M.length;
      Z > Te / 2 && (Z = Te / 2);
      let Ie;
      for (Ie = 0; Ie < Z; ++Ie) {
        const je = parseInt(M.substr(Ie * 2, 2), 16);
        if (le(je)) return Ie;
        Q[N + Ie] = je;
      }
      return Ie;
    }
    function D(Q, M, N, Z) {
      return Se(te(M, Q.length - N), Q, N, Z);
    }
    function L(Q, M, N, Z) {
      return Se(ee(M), Q, N, Z);
    }
    function j(Q, M, N, Z) {
      return Se(Ee(M), Q, N, Z);
    }
    function C(Q, M, N, Z) {
      return Se(ve(M, Q.length - N), Q, N, Z);
    }
    o.prototype.write = function(M, N, Z, de) {
      if (N === void 0)
        de = "utf8", Z = this.length, N = 0;
      else if (Z === void 0 && typeof N == "string")
        de = N, Z = this.length, N = 0;
      else if (isFinite(N))
        N = N >>> 0, isFinite(Z) ? (Z = Z >>> 0, de === void 0 && (de = "utf8")) : (de = Z, Z = void 0);
      else
        throw new Error(
          "Buffer.write(string, encoding, offset[, length]) is no longer supported"
        );
      const Te = this.length - N;
      if ((Z === void 0 || Z > Te) && (Z = Te), M.length > 0 && (Z < 0 || N < 0) || N > this.length)
        throw new RangeError("Attempt to write outside buffer bounds");
      de || (de = "utf8");
      let Ie = !1;
      for (; ; )
        switch (de) {
          case "hex":
            return U(this, M, N, Z);
          case "utf8":
          case "utf-8":
            return D(this, M, N, Z);
          case "ascii":
          case "latin1":
          case "binary":
            return L(this, M, N, Z);
          case "base64":
            return j(this, M, N, Z);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return C(this, M, N, Z);
          default:
            if (Ie) throw new TypeError("Unknown encoding: " + de);
            de = ("" + de).toLowerCase(), Ie = !0;
        }
    }, o.prototype.toJSON = function() {
      return {
        type: "Buffer",
        data: Array.prototype.slice.call(this._arr || this, 0)
      };
    };
    function k(Q, M, N) {
      return M === 0 && N === Q.length ? e.fromByteArray(Q) : e.fromByteArray(Q.slice(M, N));
    }
    function I(Q, M, N) {
      N = Math.min(Q.length, N);
      const Z = [];
      let de = M;
      for (; de < N; ) {
        const Te = Q[de];
        let Ie = null, je = Te > 239 ? 4 : Te > 223 ? 3 : Te > 191 ? 2 : 1;
        if (de + je <= N) {
          let Ze, Qe, ot, rt;
          switch (je) {
            case 1:
              Te < 128 && (Ie = Te);
              break;
            case 2:
              Ze = Q[de + 1], (Ze & 192) === 128 && (rt = (Te & 31) << 6 | Ze & 63, rt > 127 && (Ie = rt));
              break;
            case 3:
              Ze = Q[de + 1], Qe = Q[de + 2], (Ze & 192) === 128 && (Qe & 192) === 128 && (rt = (Te & 15) << 12 | (Ze & 63) << 6 | Qe & 63, rt > 2047 && (rt < 55296 || rt > 57343) && (Ie = rt));
              break;
            case 4:
              Ze = Q[de + 1], Qe = Q[de + 2], ot = Q[de + 3], (Ze & 192) === 128 && (Qe & 192) === 128 && (ot & 192) === 128 && (rt = (Te & 15) << 18 | (Ze & 63) << 12 | (Qe & 63) << 6 | ot & 63, rt > 65535 && rt < 1114112 && (Ie = rt));
          }
        }
        Ie === null ? (Ie = 65533, je = 1) : Ie > 65535 && (Ie -= 65536, Z.push(Ie >>> 10 & 1023 | 55296), Ie = 56320 | Ie & 1023), Z.push(Ie), de += je;
      }
      return W(Z);
    }
    const $ = 4096;
    function W(Q) {
      const M = Q.length;
      if (M <= $)
        return String.fromCharCode.apply(String, Q);
      let N = "", Z = 0;
      for (; Z < M; )
        N += String.fromCharCode.apply(
          String,
          Q.slice(Z, Z += $)
        );
      return N;
    }
    function B(Q, M, N) {
      let Z = "";
      N = Math.min(Q.length, N);
      for (let de = M; de < N; ++de)
        Z += String.fromCharCode(Q[de] & 127);
      return Z;
    }
    function z(Q, M, N) {
      let Z = "";
      N = Math.min(Q.length, N);
      for (let de = M; de < N; ++de)
        Z += String.fromCharCode(Q[de]);
      return Z;
    }
    function q(Q, M, N) {
      const Z = Q.length;
      (!M || M < 0) && (M = 0), (!N || N < 0 || N > Z) && (N = Z);
      let de = "";
      for (let Te = M; Te < N; ++Te)
        de += ye[Q[Te]];
      return de;
    }
    function Y(Q, M, N) {
      const Z = Q.slice(M, N);
      let de = "";
      for (let Te = 0; Te < Z.length - 1; Te += 2)
        de += String.fromCharCode(Z[Te] + Z[Te + 1] * 256);
      return de;
    }
    o.prototype.slice = function(M, N) {
      const Z = this.length;
      M = ~~M, N = N === void 0 ? Z : ~~N, M < 0 ? (M += Z, M < 0 && (M = 0)) : M > Z && (M = Z), N < 0 ? (N += Z, N < 0 && (N = 0)) : N > Z && (N = Z), N < M && (N = M);
      const de = this.subarray(M, N);
      return Object.setPrototypeOf(de, o.prototype), de;
    };
    function H(Q, M, N) {
      if (Q % 1 !== 0 || Q < 0) throw new RangeError("offset is not uint");
      if (Q + M > N) throw new RangeError("Trying to access beyond buffer length");
    }
    o.prototype.readUintLE = o.prototype.readUIntLE = function(M, N, Z) {
      M = M >>> 0, N = N >>> 0, Z || H(M, N, this.length);
      let de = this[M], Te = 1, Ie = 0;
      for (; ++Ie < N && (Te *= 256); )
        de += this[M + Ie] * Te;
      return de;
    }, o.prototype.readUintBE = o.prototype.readUIntBE = function(M, N, Z) {
      M = M >>> 0, N = N >>> 0, Z || H(M, N, this.length);
      let de = this[M + --N], Te = 1;
      for (; N > 0 && (Te *= 256); )
        de += this[M + --N] * Te;
      return de;
    }, o.prototype.readUint8 = o.prototype.readUInt8 = function(M, N) {
      return M = M >>> 0, N || H(M, 1, this.length), this[M];
    }, o.prototype.readUint16LE = o.prototype.readUInt16LE = function(M, N) {
      return M = M >>> 0, N || H(M, 2, this.length), this[M] | this[M + 1] << 8;
    }, o.prototype.readUint16BE = o.prototype.readUInt16BE = function(M, N) {
      return M = M >>> 0, N || H(M, 2, this.length), this[M] << 8 | this[M + 1];
    }, o.prototype.readUint32LE = o.prototype.readUInt32LE = function(M, N) {
      return M = M >>> 0, N || H(M, 4, this.length), (this[M] | this[M + 1] << 8 | this[M + 2] << 16) + this[M + 3] * 16777216;
    }, o.prototype.readUint32BE = o.prototype.readUInt32BE = function(M, N) {
      return M = M >>> 0, N || H(M, 4, this.length), this[M] * 16777216 + (this[M + 1] << 16 | this[M + 2] << 8 | this[M + 3]);
    }, o.prototype.readBigUInt64LE = we(function(M) {
      M = M >>> 0, ne(M, "offset");
      const N = this[M], Z = this[M + 7];
      (N === void 0 || Z === void 0) && S(M, this.length - 8);
      const de = N + this[++M] * 2 ** 8 + this[++M] * 2 ** 16 + this[++M] * 2 ** 24, Te = this[++M] + this[++M] * 2 ** 8 + this[++M] * 2 ** 16 + Z * 2 ** 24;
      return BigInt(de) + (BigInt(Te) << BigInt(32));
    }), o.prototype.readBigUInt64BE = we(function(M) {
      M = M >>> 0, ne(M, "offset");
      const N = this[M], Z = this[M + 7];
      (N === void 0 || Z === void 0) && S(M, this.length - 8);
      const de = N * 2 ** 24 + this[++M] * 2 ** 16 + this[++M] * 2 ** 8 + this[++M], Te = this[++M] * 2 ** 24 + this[++M] * 2 ** 16 + this[++M] * 2 ** 8 + Z;
      return (BigInt(de) << BigInt(32)) + BigInt(Te);
    }), o.prototype.readIntLE = function(M, N, Z) {
      M = M >>> 0, N = N >>> 0, Z || H(M, N, this.length);
      let de = this[M], Te = 1, Ie = 0;
      for (; ++Ie < N && (Te *= 256); )
        de += this[M + Ie] * Te;
      return Te *= 128, de >= Te && (de -= Math.pow(2, 8 * N)), de;
    }, o.prototype.readIntBE = function(M, N, Z) {
      M = M >>> 0, N = N >>> 0, Z || H(M, N, this.length);
      let de = N, Te = 1, Ie = this[M + --de];
      for (; de > 0 && (Te *= 256); )
        Ie += this[M + --de] * Te;
      return Te *= 128, Ie >= Te && (Ie -= Math.pow(2, 8 * N)), Ie;
    }, o.prototype.readInt8 = function(M, N) {
      return M = M >>> 0, N || H(M, 1, this.length), this[M] & 128 ? (255 - this[M] + 1) * -1 : this[M];
    }, o.prototype.readInt16LE = function(M, N) {
      M = M >>> 0, N || H(M, 2, this.length);
      const Z = this[M] | this[M + 1] << 8;
      return Z & 32768 ? Z | 4294901760 : Z;
    }, o.prototype.readInt16BE = function(M, N) {
      M = M >>> 0, N || H(M, 2, this.length);
      const Z = this[M + 1] | this[M] << 8;
      return Z & 32768 ? Z | 4294901760 : Z;
    }, o.prototype.readInt32LE = function(M, N) {
      return M = M >>> 0, N || H(M, 4, this.length), this[M] | this[M + 1] << 8 | this[M + 2] << 16 | this[M + 3] << 24;
    }, o.prototype.readInt32BE = function(M, N) {
      return M = M >>> 0, N || H(M, 4, this.length), this[M] << 24 | this[M + 1] << 16 | this[M + 2] << 8 | this[M + 3];
    }, o.prototype.readBigInt64LE = we(function(M) {
      M = M >>> 0, ne(M, "offset");
      const N = this[M], Z = this[M + 7];
      (N === void 0 || Z === void 0) && S(M, this.length - 8);
      const de = this[M + 4] + this[M + 5] * 2 ** 8 + this[M + 6] * 2 ** 16 + (Z << 24);
      return (BigInt(de) << BigInt(32)) + BigInt(N + this[++M] * 2 ** 8 + this[++M] * 2 ** 16 + this[++M] * 2 ** 24);
    }), o.prototype.readBigInt64BE = we(function(M) {
      M = M >>> 0, ne(M, "offset");
      const N = this[M], Z = this[M + 7];
      (N === void 0 || Z === void 0) && S(M, this.length - 8);
      const de = (N << 24) + // Overflow
      this[++M] * 2 ** 16 + this[++M] * 2 ** 8 + this[++M];
      return (BigInt(de) << BigInt(32)) + BigInt(this[++M] * 2 ** 24 + this[++M] * 2 ** 16 + this[++M] * 2 ** 8 + Z);
    }), o.prototype.readFloatLE = function(M, N) {
      return M = M >>> 0, N || H(M, 4, this.length), t.read(this, M, !0, 23, 4);
    }, o.prototype.readFloatBE = function(M, N) {
      return M = M >>> 0, N || H(M, 4, this.length), t.read(this, M, !1, 23, 4);
    }, o.prototype.readDoubleLE = function(M, N) {
      return M = M >>> 0, N || H(M, 8, this.length), t.read(this, M, !0, 52, 8);
    }, o.prototype.readDoubleBE = function(M, N) {
      return M = M >>> 0, N || H(M, 8, this.length), t.read(this, M, !1, 52, 8);
    };
    function K(Q, M, N, Z, de, Te) {
      if (!o.isBuffer(Q)) throw new TypeError('"buffer" argument must be a Buffer instance');
      if (M > de || M < Te) throw new RangeError('"value" argument is out of bounds');
      if (N + Z > Q.length) throw new RangeError("Index out of range");
    }
    o.prototype.writeUintLE = o.prototype.writeUIntLE = function(M, N, Z, de) {
      if (M = +M, N = N >>> 0, Z = Z >>> 0, !de) {
        const je = Math.pow(2, 8 * Z) - 1;
        K(this, M, N, Z, je, 0);
      }
      let Te = 1, Ie = 0;
      for (this[N] = M & 255; ++Ie < Z && (Te *= 256); )
        this[N + Ie] = M / Te & 255;
      return N + Z;
    }, o.prototype.writeUintBE = o.prototype.writeUIntBE = function(M, N, Z, de) {
      if (M = +M, N = N >>> 0, Z = Z >>> 0, !de) {
        const je = Math.pow(2, 8 * Z) - 1;
        K(this, M, N, Z, je, 0);
      }
      let Te = Z - 1, Ie = 1;
      for (this[N + Te] = M & 255; --Te >= 0 && (Ie *= 256); )
        this[N + Te] = M / Ie & 255;
      return N + Z;
    }, o.prototype.writeUint8 = o.prototype.writeUInt8 = function(M, N, Z) {
      return M = +M, N = N >>> 0, Z || K(this, M, N, 1, 255, 0), this[N] = M & 255, N + 1;
    }, o.prototype.writeUint16LE = o.prototype.writeUInt16LE = function(M, N, Z) {
      return M = +M, N = N >>> 0, Z || K(this, M, N, 2, 65535, 0), this[N] = M & 255, this[N + 1] = M >>> 8, N + 2;
    }, o.prototype.writeUint16BE = o.prototype.writeUInt16BE = function(M, N, Z) {
      return M = +M, N = N >>> 0, Z || K(this, M, N, 2, 65535, 0), this[N] = M >>> 8, this[N + 1] = M & 255, N + 2;
    }, o.prototype.writeUint32LE = o.prototype.writeUInt32LE = function(M, N, Z) {
      return M = +M, N = N >>> 0, Z || K(this, M, N, 4, 4294967295, 0), this[N + 3] = M >>> 24, this[N + 2] = M >>> 16, this[N + 1] = M >>> 8, this[N] = M & 255, N + 4;
    }, o.prototype.writeUint32BE = o.prototype.writeUInt32BE = function(M, N, Z) {
      return M = +M, N = N >>> 0, Z || K(this, M, N, 4, 4294967295, 0), this[N] = M >>> 24, this[N + 1] = M >>> 16, this[N + 2] = M >>> 8, this[N + 3] = M & 255, N + 4;
    };
    function ie(Q, M, N, Z, de) {
      P(M, Z, de, Q, N, 7);
      let Te = Number(M & BigInt(4294967295));
      Q[N++] = Te, Te = Te >> 8, Q[N++] = Te, Te = Te >> 8, Q[N++] = Te, Te = Te >> 8, Q[N++] = Te;
      let Ie = Number(M >> BigInt(32) & BigInt(4294967295));
      return Q[N++] = Ie, Ie = Ie >> 8, Q[N++] = Ie, Ie = Ie >> 8, Q[N++] = Ie, Ie = Ie >> 8, Q[N++] = Ie, N;
    }
    function ge(Q, M, N, Z, de) {
      P(M, Z, de, Q, N, 7);
      let Te = Number(M & BigInt(4294967295));
      Q[N + 7] = Te, Te = Te >> 8, Q[N + 6] = Te, Te = Te >> 8, Q[N + 5] = Te, Te = Te >> 8, Q[N + 4] = Te;
      let Ie = Number(M >> BigInt(32) & BigInt(4294967295));
      return Q[N + 3] = Ie, Ie = Ie >> 8, Q[N + 2] = Ie, Ie = Ie >> 8, Q[N + 1] = Ie, Ie = Ie >> 8, Q[N] = Ie, N + 8;
    }
    o.prototype.writeBigUInt64LE = we(function(M, N = 0) {
      return ie(this, M, N, BigInt(0), BigInt("0xffffffffffffffff"));
    }), o.prototype.writeBigUInt64BE = we(function(M, N = 0) {
      return ge(this, M, N, BigInt(0), BigInt("0xffffffffffffffff"));
    }), o.prototype.writeIntLE = function(M, N, Z, de) {
      if (M = +M, N = N >>> 0, !de) {
        const Ze = Math.pow(2, 8 * Z - 1);
        K(this, M, N, Z, Ze - 1, -Ze);
      }
      let Te = 0, Ie = 1, je = 0;
      for (this[N] = M & 255; ++Te < Z && (Ie *= 256); )
        M < 0 && je === 0 && this[N + Te - 1] !== 0 && (je = 1), this[N + Te] = (M / Ie >> 0) - je & 255;
      return N + Z;
    }, o.prototype.writeIntBE = function(M, N, Z, de) {
      if (M = +M, N = N >>> 0, !de) {
        const Ze = Math.pow(2, 8 * Z - 1);
        K(this, M, N, Z, Ze - 1, -Ze);
      }
      let Te = Z - 1, Ie = 1, je = 0;
      for (this[N + Te] = M & 255; --Te >= 0 && (Ie *= 256); )
        M < 0 && je === 0 && this[N + Te + 1] !== 0 && (je = 1), this[N + Te] = (M / Ie >> 0) - je & 255;
      return N + Z;
    }, o.prototype.writeInt8 = function(M, N, Z) {
      return M = +M, N = N >>> 0, Z || K(this, M, N, 1, 127, -128), M < 0 && (M = 255 + M + 1), this[N] = M & 255, N + 1;
    }, o.prototype.writeInt16LE = function(M, N, Z) {
      return M = +M, N = N >>> 0, Z || K(this, M, N, 2, 32767, -32768), this[N] = M & 255, this[N + 1] = M >>> 8, N + 2;
    }, o.prototype.writeInt16BE = function(M, N, Z) {
      return M = +M, N = N >>> 0, Z || K(this, M, N, 2, 32767, -32768), this[N] = M >>> 8, this[N + 1] = M & 255, N + 2;
    }, o.prototype.writeInt32LE = function(M, N, Z) {
      return M = +M, N = N >>> 0, Z || K(this, M, N, 4, 2147483647, -2147483648), this[N] = M & 255, this[N + 1] = M >>> 8, this[N + 2] = M >>> 16, this[N + 3] = M >>> 24, N + 4;
    }, o.prototype.writeInt32BE = function(M, N, Z) {
      return M = +M, N = N >>> 0, Z || K(this, M, N, 4, 2147483647, -2147483648), M < 0 && (M = 4294967295 + M + 1), this[N] = M >>> 24, this[N + 1] = M >>> 16, this[N + 2] = M >>> 8, this[N + 3] = M & 255, N + 4;
    }, o.prototype.writeBigInt64LE = we(function(M, N = 0) {
      return ie(this, M, N, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
    }), o.prototype.writeBigInt64BE = we(function(M, N = 0) {
      return ge(this, M, N, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
    });
    function pe(Q, M, N, Z, de, Te) {
      if (N + Z > Q.length) throw new RangeError("Index out of range");
      if (N < 0) throw new RangeError("Index out of range");
    }
    function ce(Q, M, N, Z, de) {
      return M = +M, N = N >>> 0, de || pe(Q, M, N, 4), t.write(Q, M, N, Z, 23, 4), N + 4;
    }
    o.prototype.writeFloatLE = function(M, N, Z) {
      return ce(this, M, N, !0, Z);
    }, o.prototype.writeFloatBE = function(M, N, Z) {
      return ce(this, M, N, !1, Z);
    };
    function oe(Q, M, N, Z, de) {
      return M = +M, N = N >>> 0, de || pe(Q, M, N, 8), t.write(Q, M, N, Z, 52, 8), N + 8;
    }
    o.prototype.writeDoubleLE = function(M, N, Z) {
      return oe(this, M, N, !0, Z);
    }, o.prototype.writeDoubleBE = function(M, N, Z) {
      return oe(this, M, N, !1, Z);
    }, o.prototype.copy = function(M, N, Z, de) {
      if (!o.isBuffer(M)) throw new TypeError("argument should be a Buffer");
      if (Z || (Z = 0), !de && de !== 0 && (de = this.length), N >= M.length && (N = M.length), N || (N = 0), de > 0 && de < Z && (de = Z), de === Z || M.length === 0 || this.length === 0) return 0;
      if (N < 0)
        throw new RangeError("targetStart out of bounds");
      if (Z < 0 || Z >= this.length) throw new RangeError("Index out of range");
      if (de < 0) throw new RangeError("sourceEnd out of bounds");
      de > this.length && (de = this.length), M.length - N < de - Z && (de = M.length - N + Z);
      const Te = de - Z;
      return this === M && typeof Uint8Array.prototype.copyWithin == "function" ? this.copyWithin(N, Z, de) : Uint8Array.prototype.set.call(
        M,
        this.subarray(Z, de),
        N
      ), Te;
    }, o.prototype.fill = function(M, N, Z, de) {
      if (typeof M == "string") {
        if (typeof N == "string" ? (de = N, N = 0, Z = this.length) : typeof Z == "string" && (de = Z, Z = this.length), de !== void 0 && typeof de != "string")
          throw new TypeError("encoding must be a string");
        if (typeof de == "string" && !o.isEncoding(de))
          throw new TypeError("Unknown encoding: " + de);
        if (M.length === 1) {
          const Ie = M.charCodeAt(0);
          (de === "utf8" && Ie < 128 || de === "latin1") && (M = Ie);
        }
      } else typeof M == "number" ? M = M & 255 : typeof M == "boolean" && (M = Number(M));
      if (N < 0 || this.length < N || this.length < Z)
        throw new RangeError("Out of range index");
      if (Z <= N)
        return this;
      N = N >>> 0, Z = Z === void 0 ? this.length : Z >>> 0, M || (M = 0);
      let Te;
      if (typeof M == "number")
        for (Te = N; Te < Z; ++Te)
          this[Te] = M;
      else {
        const Ie = o.isBuffer(M) ? M : o.from(M, de), je = Ie.length;
        if (je === 0)
          throw new TypeError('The value "' + M + '" is invalid for argument "value"');
        for (Te = 0; Te < Z - N; ++Te)
          this[Te + N] = Ie[Te % je];
      }
      return this;
    };
    const De = {};
    function Re(Q, M, N) {
      De[Q] = class extends N {
        constructor() {
          super(), Object.defineProperty(this, "message", {
            value: M.apply(this, arguments),
            writable: !0,
            configurable: !0
          }), this.name = `${this.name} [${Q}]`, this.stack, delete this.name;
        }
        get code() {
          return Q;
        }
        set code(de) {
          Object.defineProperty(this, "code", {
            configurable: !0,
            enumerable: !0,
            value: de,
            writable: !0
          });
        }
        toString() {
          return `${this.name} [${Q}]: ${this.message}`;
        }
      };
    }
    Re(
      "ERR_BUFFER_OUT_OF_BOUNDS",
      function(Q) {
        return Q ? `${Q} is outside of buffer bounds` : "Attempt to access memory outside buffer bounds";
      },
      RangeError
    ), Re(
      "ERR_INVALID_ARG_TYPE",
      function(Q, M) {
        return `The "${Q}" argument must be of type number. Received type ${typeof M}`;
      },
      TypeError
    ), Re(
      "ERR_OUT_OF_RANGE",
      function(Q, M, N) {
        let Z = `The value of "${Q}" is out of range.`, de = N;
        return Number.isInteger(N) && Math.abs(N) > 2 ** 32 ? de = Me(String(N)) : typeof N == "bigint" && (de = String(N), (N > BigInt(2) ** BigInt(32) || N < -(BigInt(2) ** BigInt(32))) && (de = Me(de)), de += "n"), Z += ` It must be ${M}. Received ${de}`, Z;
      },
      RangeError
    );
    function Me(Q) {
      let M = "", N = Q.length;
      const Z = Q[0] === "-" ? 1 : 0;
      for (; N >= Z + 4; N -= 3)
        M = `_${Q.slice(N - 3, N)}${M}`;
      return `${Q.slice(0, N)}${M}`;
    }
    function F(Q, M, N) {
      ne(M, "offset"), (Q[M] === void 0 || Q[M + N] === void 0) && S(M, Q.length - (N + 1));
    }
    function P(Q, M, N, Z, de, Te) {
      if (Q > N || Q < M) {
        const Ie = typeof M == "bigint" ? "n" : "";
        let je;
        throw M === 0 || M === BigInt(0) ? je = `>= 0${Ie} and < 2${Ie} ** ${(Te + 1) * 8}${Ie}` : je = `>= -(2${Ie} ** ${(Te + 1) * 8 - 1}${Ie}) and < 2 ** ${(Te + 1) * 8 - 1}${Ie}`, new De.ERR_OUT_OF_RANGE("value", je, Q);
      }
      F(Z, de, Te);
    }
    function ne(Q, M) {
      if (typeof Q != "number")
        throw new De.ERR_INVALID_ARG_TYPE(M, "number", Q);
    }
    function S(Q, M, N) {
      throw Math.floor(Q) !== Q ? (ne(Q, N), new De.ERR_OUT_OF_RANGE("offset", "an integer", Q)) : M < 0 ? new De.ERR_BUFFER_OUT_OF_BOUNDS() : new De.ERR_OUT_OF_RANGE(
        "offset",
        `>= 0 and <= ${M}`,
        Q
      );
    }
    const he = /[^+/0-9A-Za-z-_]/g;
    function ae(Q) {
      if (Q = Q.split("=")[0], Q = Q.trim().replace(he, ""), Q.length < 2) return "";
      for (; Q.length % 4 !== 0; )
        Q = Q + "=";
      return Q;
    }
    function te(Q, M) {
      M = M || 1 / 0;
      let N;
      const Z = Q.length;
      let de = null;
      const Te = [];
      for (let Ie = 0; Ie < Z; ++Ie) {
        if (N = Q.charCodeAt(Ie), N > 55295 && N < 57344) {
          if (!de) {
            if (N > 56319) {
              (M -= 3) > -1 && Te.push(239, 191, 189);
              continue;
            } else if (Ie + 1 === Z) {
              (M -= 3) > -1 && Te.push(239, 191, 189);
              continue;
            }
            de = N;
            continue;
          }
          if (N < 56320) {
            (M -= 3) > -1 && Te.push(239, 191, 189), de = N;
            continue;
          }
          N = (de - 55296 << 10 | N - 56320) + 65536;
        } else de && (M -= 3) > -1 && Te.push(239, 191, 189);
        if (de = null, N < 128) {
          if ((M -= 1) < 0) break;
          Te.push(N);
        } else if (N < 2048) {
          if ((M -= 2) < 0) break;
          Te.push(
            N >> 6 | 192,
            N & 63 | 128
          );
        } else if (N < 65536) {
          if ((M -= 3) < 0) break;
          Te.push(
            N >> 12 | 224,
            N >> 6 & 63 | 128,
            N & 63 | 128
          );
        } else if (N < 1114112) {
          if ((M -= 4) < 0) break;
          Te.push(
            N >> 18 | 240,
            N >> 12 & 63 | 128,
            N >> 6 & 63 | 128,
            N & 63 | 128
          );
        } else
          throw new Error("Invalid code point");
      }
      return Te;
    }
    function ee(Q) {
      const M = [];
      for (let N = 0; N < Q.length; ++N)
        M.push(Q.charCodeAt(N) & 255);
      return M;
    }
    function ve(Q, M) {
      let N, Z, de;
      const Te = [];
      for (let Ie = 0; Ie < Q.length && !((M -= 2) < 0); ++Ie)
        N = Q.charCodeAt(Ie), Z = N >> 8, de = N % 256, Te.push(de), Te.push(Z);
      return Te;
    }
    function Ee(Q) {
      return e.toByteArray(ae(Q));
    }
    function Se(Q, M, N, Z) {
      let de;
      for (de = 0; de < Z && !(de + N >= M.length || de >= Q.length); ++de)
        M[de + N] = Q[de];
      return de;
    }
    function xe(Q, M) {
      return Q instanceof M || Q != null && Q.constructor != null && Q.constructor.name != null && Q.constructor.name === M.name;
    }
    function le(Q) {
      return Q !== Q;
    }
    const ye = (function() {
      const Q = "0123456789abcdef", M = new Array(256);
      for (let N = 0; N < 16; ++N) {
        const Z = N * 16;
        for (let de = 0; de < 16; ++de)
          M[Z + de] = Q[N] + Q[de];
      }
      return M;
    })();
    function we(Q) {
      return typeof BigInt > "u" ? Ue : Q;
    }
    function Ue() {
      throw new Error("BigInt not supported");
    }
  })(ch)), ch;
}
var lh, F1;
function Ek() {
  if (F1) return lh;
  F1 = 1;
  function n(y, m) {
    var b = Object.keys(y);
    if (Object.getOwnPropertySymbols) {
      var p = Object.getOwnPropertySymbols(y);
      m && (p = p.filter(function(g) {
        return Object.getOwnPropertyDescriptor(y, g).enumerable;
      })), b.push.apply(b, p);
    }
    return b;
  }
  function e(y) {
    for (var m = 1; m < arguments.length; m++) {
      var b = arguments[m] != null ? arguments[m] : {};
      m % 2 ? n(Object(b), !0).forEach(function(p) {
        t(y, p, b[p]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(y, Object.getOwnPropertyDescriptors(b)) : n(Object(b)).forEach(function(p) {
        Object.defineProperty(y, p, Object.getOwnPropertyDescriptor(b, p));
      });
    }
    return y;
  }
  function t(y, m, b) {
    return m = s(m), m in y ? Object.defineProperty(y, m, { value: b, enumerable: !0, configurable: !0, writable: !0 }) : y[m] = b, y;
  }
  function i(y, m) {
    if (!(y instanceof m))
      throw new TypeError("Cannot call a class as a function");
  }
  function r(y, m) {
    for (var b = 0; b < m.length; b++) {
      var p = m[b];
      p.enumerable = p.enumerable || !1, p.configurable = !0, "value" in p && (p.writable = !0), Object.defineProperty(y, s(p.key), p);
    }
  }
  function a(y, m, b) {
    return m && r(y.prototype, m), Object.defineProperty(y, "prototype", { writable: !1 }), y;
  }
  function s(y) {
    var m = o(y, "string");
    return typeof m == "symbol" ? m : String(m);
  }
  function o(y, m) {
    if (typeof y != "object" || y === null) return y;
    var b = y[Symbol.toPrimitive];
    if (b !== void 0) {
      var p = b.call(y, m);
      if (typeof p != "object") return p;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return String(y);
  }
  var u = lo(), c = u.Buffer, l = ni, h = l.inspect, f = h && h.custom || "inspect";
  function d(y, m, b) {
    c.prototype.copy.call(y, m, b);
  }
  return lh = /* @__PURE__ */ (function() {
    function y() {
      i(this, y), this.head = null, this.tail = null, this.length = 0;
    }
    return a(y, [{
      key: "push",
      value: function(b) {
        var p = {
          data: b,
          next: null
        };
        this.length > 0 ? this.tail.next = p : this.head = p, this.tail = p, ++this.length;
      }
    }, {
      key: "unshift",
      value: function(b) {
        var p = {
          data: b,
          next: this.head
        };
        this.length === 0 && (this.tail = p), this.head = p, ++this.length;
      }
    }, {
      key: "shift",
      value: function() {
        if (this.length !== 0) {
          var b = this.head.data;
          return this.length === 1 ? this.head = this.tail = null : this.head = this.head.next, --this.length, b;
        }
      }
    }, {
      key: "clear",
      value: function() {
        this.head = this.tail = null, this.length = 0;
      }
    }, {
      key: "join",
      value: function(b) {
        if (this.length === 0) return "";
        for (var p = this.head, g = "" + p.data; p = p.next; ) g += b + p.data;
        return g;
      }
    }, {
      key: "concat",
      value: function(b) {
        if (this.length === 0) return c.alloc(0);
        for (var p = c.allocUnsafe(b >>> 0), g = this.head, v = 0; g; )
          d(g.data, p, v), v += g.data.length, g = g.next;
        return p;
      }
      // Consumes a specified amount of bytes or characters from the buffered data.
    }, {
      key: "consume",
      value: function(b, p) {
        var g;
        return b < this.head.data.length ? (g = this.head.data.slice(0, b), this.head.data = this.head.data.slice(b)) : b === this.head.data.length ? g = this.shift() : g = p ? this._getString(b) : this._getBuffer(b), g;
      }
    }, {
      key: "first",
      value: function() {
        return this.head.data;
      }
      // Consumes a specified amount of characters from the buffered data.
    }, {
      key: "_getString",
      value: function(b) {
        var p = this.head, g = 1, v = p.data;
        for (b -= v.length; p = p.next; ) {
          var _ = p.data, x = b > _.length ? _.length : b;
          if (x === _.length ? v += _ : v += _.slice(0, b), b -= x, b === 0) {
            x === _.length ? (++g, p.next ? this.head = p.next : this.head = this.tail = null) : (this.head = p, p.data = _.slice(x));
            break;
          }
          ++g;
        }
        return this.length -= g, v;
      }
      // Consumes a specified amount of bytes from the buffered data.
    }, {
      key: "_getBuffer",
      value: function(b) {
        var p = c.allocUnsafe(b), g = this.head, v = 1;
        for (g.data.copy(p), b -= g.data.length; g = g.next; ) {
          var _ = g.data, x = b > _.length ? _.length : b;
          if (_.copy(p, p.length - b, 0, x), b -= x, b === 0) {
            x === _.length ? (++v, g.next ? this.head = g.next : this.head = this.tail = null) : (this.head = g, g.data = _.slice(x));
            break;
          }
          ++v;
        }
        return this.length -= v, p;
      }
      // Make sure the linked list only shows the minimal necessary information.
    }, {
      key: f,
      value: function(b, p) {
        return h(this, e(e({}, p), {}, {
          // Only inspect one level.
          depth: 0,
          // It should not recurse.
          customInspect: !1
        }));
      }
    }]), y;
  })(), lh;
}
var dh, N1;
function RE() {
  if (N1) return dh;
  N1 = 1;
  function n(s, o) {
    var u = this, c = this._readableState && this._readableState.destroyed, l = this._writableState && this._writableState.destroyed;
    return c || l ? (o ? o(s) : s && (this._writableState ? this._writableState.errorEmitted || (this._writableState.errorEmitted = !0, process.nextTick(r, this, s)) : process.nextTick(r, this, s)), this) : (this._readableState && (this._readableState.destroyed = !0), this._writableState && (this._writableState.destroyed = !0), this._destroy(s || null, function(h) {
      !o && h ? u._writableState ? u._writableState.errorEmitted ? process.nextTick(t, u) : (u._writableState.errorEmitted = !0, process.nextTick(e, u, h)) : process.nextTick(e, u, h) : o ? (process.nextTick(t, u), o(h)) : process.nextTick(t, u);
    }), this);
  }
  function e(s, o) {
    r(s, o), t(s);
  }
  function t(s) {
    s._writableState && !s._writableState.emitClose || s._readableState && !s._readableState.emitClose || s.emit("close");
  }
  function i() {
    this._readableState && (this._readableState.destroyed = !1, this._readableState.reading = !1, this._readableState.ended = !1, this._readableState.endEmitted = !1), this._writableState && (this._writableState.destroyed = !1, this._writableState.ended = !1, this._writableState.ending = !1, this._writableState.finalCalled = !1, this._writableState.prefinished = !1, this._writableState.finished = !1, this._writableState.errorEmitted = !1);
  }
  function r(s, o) {
    s.emit("error", o);
  }
  function a(s, o) {
    var u = s._readableState, c = s._writableState;
    u && u.autoDestroy || c && c.autoDestroy ? s.destroy(o) : s.emit("error", o);
  }
  return dh = {
    destroy: n,
    undestroy: i,
    errorOrDestroy: a
  }, dh;
}
var fh = {}, M1;
function Oa() {
  if (M1) return fh;
  M1 = 1;
  function n(o, u) {
    o.prototype = Object.create(u.prototype), o.prototype.constructor = o, o.__proto__ = u;
  }
  var e = {};
  function t(o, u, c) {
    c || (c = Error);
    function l(f, d, y) {
      return typeof u == "string" ? u : u(f, d, y);
    }
    var h = /* @__PURE__ */ (function(f) {
      n(d, f);
      function d(y, m, b) {
        return f.call(this, l(y, m, b)) || this;
      }
      return d;
    })(c);
    h.prototype.name = c.name, h.prototype.code = o, e[o] = h;
  }
  function i(o, u) {
    if (Array.isArray(o)) {
      var c = o.length;
      return o = o.map(function(l) {
        return String(l);
      }), c > 2 ? "one of ".concat(u, " ").concat(o.slice(0, c - 1).join(", "), ", or ") + o[c - 1] : c === 2 ? "one of ".concat(u, " ").concat(o[0], " or ").concat(o[1]) : "of ".concat(u, " ").concat(o[0]);
    } else
      return "of ".concat(u, " ").concat(String(o));
  }
  function r(o, u, c) {
    return o.substr(0, u.length) === u;
  }
  function a(o, u, c) {
    return (c === void 0 || c > o.length) && (c = o.length), o.substring(c - u.length, c) === u;
  }
  function s(o, u, c) {
    return typeof c != "number" && (c = 0), c + u.length > o.length ? !1 : o.indexOf(u, c) !== -1;
  }
  return t("ERR_INVALID_OPT_VALUE", function(o, u) {
    return 'The value "' + u + '" is invalid for option "' + o + '"';
  }, TypeError), t("ERR_INVALID_ARG_TYPE", function(o, u, c) {
    var l;
    typeof u == "string" && r(u, "not ") ? (l = "must not be", u = u.replace(/^not /, "")) : l = "must be";
    var h;
    if (a(o, " argument"))
      h = "The ".concat(o, " ").concat(l, " ").concat(i(u, "type"));
    else {
      var f = s(o, ".") ? "property" : "argument";
      h = 'The "'.concat(o, '" ').concat(f, " ").concat(l, " ").concat(i(u, "type"));
    }
    return h += ". Received type ".concat(typeof c), h;
  }, TypeError), t("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF"), t("ERR_METHOD_NOT_IMPLEMENTED", function(o) {
    return "The " + o + " method is not implemented";
  }), t("ERR_STREAM_PREMATURE_CLOSE", "Premature close"), t("ERR_STREAM_DESTROYED", function(o) {
    return "Cannot call " + o + " after a stream was destroyed";
  }), t("ERR_MULTIPLE_CALLBACK", "Callback called multiple times"), t("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable"), t("ERR_STREAM_WRITE_AFTER_END", "write after end"), t("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError), t("ERR_UNKNOWN_ENCODING", function(o) {
    return "Unknown encoding: " + o;
  }, TypeError), t("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event"), fh.codes = e, fh;
}
var hh, B1;
function OE() {
  if (B1) return hh;
  B1 = 1;
  var n = Oa().codes.ERR_INVALID_OPT_VALUE;
  function e(i, r, a) {
    return i.highWaterMark != null ? i.highWaterMark : r ? i[a] : null;
  }
  function t(i, r, a, s) {
    var o = e(r, s, a);
    if (o != null) {
      if (!(isFinite(o) && Math.floor(o) === o) || o < 0) {
        var u = s ? a : "highWaterMark";
        throw new n(u, o);
      }
      return Math.floor(o);
    }
    return i.objectMode ? 16 : 16 * 1024;
  }
  return hh = {
    getHighWaterMark: t
  }, hh;
}
var ph, j1;
function Dk() {
  if (j1) return ph;
  j1 = 1, ph = n;
  function n(t, i) {
    if (e("noDeprecation"))
      return t;
    var r = !1;
    function a() {
      if (!r) {
        if (e("throwDeprecation"))
          throw new Error(i);
        e("traceDeprecation") ? console.trace(i) : console.warn(i), r = !0;
      }
      return t.apply(this, arguments);
    }
    return a;
  }
  function e(t) {
    try {
      if (!At.localStorage) return !1;
    } catch {
      return !1;
    }
    var i = At.localStorage[t];
    return i == null ? !1 : String(i).toLowerCase() === "true";
  }
  return ph;
}
var mh, q1;
function LE() {
  if (q1) return mh;
  q1 = 1, mh = U;
  function n(ce) {
    var oe = this;
    this.next = null, this.entry = null, this.finish = function() {
      pe(oe, ce);
    };
  }
  var e;
  U.WritableState = T;
  var t = {
    deprecate: Dk()
  }, i = UE(), r = lo().Buffer, a = (typeof At < "u" ? At : typeof window < "u" ? window : typeof self < "u" ? self : {}).Uint8Array || function() {
  };
  function s(ce) {
    return r.from(ce);
  }
  function o(ce) {
    return r.isBuffer(ce) || ce instanceof a;
  }
  var u = RE(), c = OE(), l = c.getHighWaterMark, h = Oa().codes, f = h.ERR_INVALID_ARG_TYPE, d = h.ERR_METHOD_NOT_IMPLEMENTED, y = h.ERR_MULTIPLE_CALLBACK, m = h.ERR_STREAM_CANNOT_PIPE, b = h.ERR_STREAM_DESTROYED, p = h.ERR_STREAM_NULL_VALUES, g = h.ERR_STREAM_WRITE_AFTER_END, v = h.ERR_UNKNOWN_ENCODING, _ = u.errorOrDestroy;
  Ra()(U, i);
  function x() {
  }
  function T(ce, oe, De) {
    e = e || va(), ce = ce || {}, typeof De != "boolean" && (De = oe instanceof e), this.objectMode = !!ce.objectMode, De && (this.objectMode = this.objectMode || !!ce.writableObjectMode), this.highWaterMark = l(this, ce, "writableHighWaterMark", De), this.finalCalled = !1, this.needDrain = !1, this.ending = !1, this.ended = !1, this.finished = !1, this.destroyed = !1;
    var Re = ce.decodeStrings === !1;
    this.decodeStrings = !Re, this.defaultEncoding = ce.defaultEncoding || "utf8", this.length = 0, this.writing = !1, this.corked = 0, this.sync = !0, this.bufferProcessing = !1, this.onwrite = function(Me) {
      W(oe, Me);
    }, this.writecb = null, this.writelen = 0, this.bufferedRequest = null, this.lastBufferedRequest = null, this.pendingcb = 0, this.prefinished = !1, this.errorEmitted = !1, this.emitClose = ce.emitClose !== !1, this.autoDestroy = !!ce.autoDestroy, this.bufferedRequestCount = 0, this.corkedRequestsFree = new n(this);
  }
  T.prototype.getBuffer = function() {
    for (var oe = this.bufferedRequest, De = []; oe; )
      De.push(oe), oe = oe.next;
    return De;
  }, (function() {
    try {
      Object.defineProperty(T.prototype, "buffer", {
        get: t.deprecate(function() {
          return this.getBuffer();
        }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
      });
    } catch {
    }
  })();
  var E;
  typeof Symbol == "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] == "function" ? (E = Function.prototype[Symbol.hasInstance], Object.defineProperty(U, Symbol.hasInstance, {
    value: function(oe) {
      return E.call(this, oe) ? !0 : this !== U ? !1 : oe && oe._writableState instanceof T;
    }
  })) : E = function(oe) {
    return oe instanceof this;
  };
  function U(ce) {
    e = e || va();
    var oe = this instanceof e;
    if (!oe && !E.call(U, this)) return new U(ce);
    this._writableState = new T(ce, this, oe), this.writable = !0, ce && (typeof ce.write == "function" && (this._write = ce.write), typeof ce.writev == "function" && (this._writev = ce.writev), typeof ce.destroy == "function" && (this._destroy = ce.destroy), typeof ce.final == "function" && (this._final = ce.final)), i.call(this);
  }
  U.prototype.pipe = function() {
    _(this, new m());
  };
  function D(ce, oe) {
    var De = new g();
    _(ce, De), process.nextTick(oe, De);
  }
  function L(ce, oe, De, Re) {
    var Me;
    return De === null ? Me = new p() : typeof De != "string" && !oe.objectMode && (Me = new f("chunk", ["string", "Buffer"], De)), Me ? (_(ce, Me), process.nextTick(Re, Me), !1) : !0;
  }
  U.prototype.write = function(ce, oe, De) {
    var Re = this._writableState, Me = !1, F = !Re.objectMode && o(ce);
    return F && !r.isBuffer(ce) && (ce = s(ce)), typeof oe == "function" && (De = oe, oe = null), F ? oe = "buffer" : oe || (oe = Re.defaultEncoding), typeof De != "function" && (De = x), Re.ending ? D(this, De) : (F || L(this, Re, ce, De)) && (Re.pendingcb++, Me = C(this, Re, F, ce, oe, De)), Me;
  }, U.prototype.cork = function() {
    this._writableState.corked++;
  }, U.prototype.uncork = function() {
    var ce = this._writableState;
    ce.corked && (ce.corked--, !ce.writing && !ce.corked && !ce.bufferProcessing && ce.bufferedRequest && q(this, ce));
  }, U.prototype.setDefaultEncoding = function(oe) {
    if (typeof oe == "string" && (oe = oe.toLowerCase()), !(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((oe + "").toLowerCase()) > -1)) throw new v(oe);
    return this._writableState.defaultEncoding = oe, this;
  }, Object.defineProperty(U.prototype, "writableBuffer", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState && this._writableState.getBuffer();
    }
  });
  function j(ce, oe, De) {
    return !ce.objectMode && ce.decodeStrings !== !1 && typeof oe == "string" && (oe = r.from(oe, De)), oe;
  }
  Object.defineProperty(U.prototype, "writableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.highWaterMark;
    }
  });
  function C(ce, oe, De, Re, Me, F) {
    if (!De) {
      var P = j(oe, Re, Me);
      Re !== P && (De = !0, Me = "buffer", Re = P);
    }
    var ne = oe.objectMode ? 1 : Re.length;
    oe.length += ne;
    var S = oe.length < oe.highWaterMark;
    if (S || (oe.needDrain = !0), oe.writing || oe.corked) {
      var he = oe.lastBufferedRequest;
      oe.lastBufferedRequest = {
        chunk: Re,
        encoding: Me,
        isBuf: De,
        callback: F,
        next: null
      }, he ? he.next = oe.lastBufferedRequest : oe.bufferedRequest = oe.lastBufferedRequest, oe.bufferedRequestCount += 1;
    } else
      k(ce, oe, !1, ne, Re, Me, F);
    return S;
  }
  function k(ce, oe, De, Re, Me, F, P) {
    oe.writelen = Re, oe.writecb = P, oe.writing = !0, oe.sync = !0, oe.destroyed ? oe.onwrite(new b("write")) : De ? ce._writev(Me, oe.onwrite) : ce._write(Me, F, oe.onwrite), oe.sync = !1;
  }
  function I(ce, oe, De, Re, Me) {
    --oe.pendingcb, De ? (process.nextTick(Me, Re), process.nextTick(ie, ce, oe), ce._writableState.errorEmitted = !0, _(ce, Re)) : (Me(Re), ce._writableState.errorEmitted = !0, _(ce, Re), ie(ce, oe));
  }
  function $(ce) {
    ce.writing = !1, ce.writecb = null, ce.length -= ce.writelen, ce.writelen = 0;
  }
  function W(ce, oe) {
    var De = ce._writableState, Re = De.sync, Me = De.writecb;
    if (typeof Me != "function") throw new y();
    if ($(De), oe) I(ce, De, Re, oe, Me);
    else {
      var F = Y(De) || ce.destroyed;
      !F && !De.corked && !De.bufferProcessing && De.bufferedRequest && q(ce, De), Re ? process.nextTick(B, ce, De, F, Me) : B(ce, De, F, Me);
    }
  }
  function B(ce, oe, De, Re) {
    De || z(ce, oe), oe.pendingcb--, Re(), ie(ce, oe);
  }
  function z(ce, oe) {
    oe.length === 0 && oe.needDrain && (oe.needDrain = !1, ce.emit("drain"));
  }
  function q(ce, oe) {
    oe.bufferProcessing = !0;
    var De = oe.bufferedRequest;
    if (ce._writev && De && De.next) {
      var Re = oe.bufferedRequestCount, Me = new Array(Re), F = oe.corkedRequestsFree;
      F.entry = De;
      for (var P = 0, ne = !0; De; )
        Me[P] = De, De.isBuf || (ne = !1), De = De.next, P += 1;
      Me.allBuffers = ne, k(ce, oe, !0, oe.length, Me, "", F.finish), oe.pendingcb++, oe.lastBufferedRequest = null, F.next ? (oe.corkedRequestsFree = F.next, F.next = null) : oe.corkedRequestsFree = new n(oe), oe.bufferedRequestCount = 0;
    } else {
      for (; De; ) {
        var S = De.chunk, he = De.encoding, ae = De.callback, te = oe.objectMode ? 1 : S.length;
        if (k(ce, oe, !1, te, S, he, ae), De = De.next, oe.bufferedRequestCount--, oe.writing)
          break;
      }
      De === null && (oe.lastBufferedRequest = null);
    }
    oe.bufferedRequest = De, oe.bufferProcessing = !1;
  }
  U.prototype._write = function(ce, oe, De) {
    De(new d("_write()"));
  }, U.prototype._writev = null, U.prototype.end = function(ce, oe, De) {
    var Re = this._writableState;
    return typeof ce == "function" ? (De = ce, ce = null, oe = null) : typeof oe == "function" && (De = oe, oe = null), ce != null && this.write(ce, oe), Re.corked && (Re.corked = 1, this.uncork()), Re.ending || ge(this, Re, De), this;
  }, Object.defineProperty(U.prototype, "writableLength", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.length;
    }
  });
  function Y(ce) {
    return ce.ending && ce.length === 0 && ce.bufferedRequest === null && !ce.finished && !ce.writing;
  }
  function H(ce, oe) {
    ce._final(function(De) {
      oe.pendingcb--, De && _(ce, De), oe.prefinished = !0, ce.emit("prefinish"), ie(ce, oe);
    });
  }
  function K(ce, oe) {
    !oe.prefinished && !oe.finalCalled && (typeof ce._final == "function" && !oe.destroyed ? (oe.pendingcb++, oe.finalCalled = !0, process.nextTick(H, ce, oe)) : (oe.prefinished = !0, ce.emit("prefinish")));
  }
  function ie(ce, oe) {
    var De = Y(oe);
    if (De && (K(ce, oe), oe.pendingcb === 0 && (oe.finished = !0, ce.emit("finish"), oe.autoDestroy))) {
      var Re = ce._readableState;
      (!Re || Re.autoDestroy && Re.endEmitted) && ce.destroy();
    }
    return De;
  }
  function ge(ce, oe, De) {
    oe.ending = !0, ie(ce, oe), De && (oe.finished ? process.nextTick(De) : ce.once("finish", De)), oe.ended = !0, ce.writable = !1;
  }
  function pe(ce, oe, De) {
    var Re = ce.entry;
    for (ce.entry = null; Re; ) {
      var Me = Re.callback;
      oe.pendingcb--, Me(De), Re = Re.next;
    }
    oe.corkedRequestsFree.next = ce;
  }
  return Object.defineProperty(U.prototype, "destroyed", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState === void 0 ? !1 : this._writableState.destroyed;
    },
    set: function(oe) {
      this._writableState && (this._writableState.destroyed = oe);
    }
  }), U.prototype.destroy = u.destroy, U.prototype._undestroy = u.undestroy, U.prototype._destroy = function(ce, oe) {
    oe(ce);
  }, mh;
}
var gh, W1;
function va() {
  if (W1) return gh;
  W1 = 1;
  var n = Object.keys || function(c) {
    var l = [];
    for (var h in c) l.push(h);
    return l;
  };
  gh = s;
  var e = PE(), t = LE();
  Ra()(s, e);
  for (var i = n(t.prototype), r = 0; r < i.length; r++) {
    var a = i[r];
    s.prototype[a] || (s.prototype[a] = t.prototype[a]);
  }
  function s(c) {
    if (!(this instanceof s)) return new s(c);
    e.call(this, c), t.call(this, c), this.allowHalfOpen = !0, c && (c.readable === !1 && (this.readable = !1), c.writable === !1 && (this.writable = !1), c.allowHalfOpen === !1 && (this.allowHalfOpen = !1, this.once("end", o)));
  }
  Object.defineProperty(s.prototype, "writableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.highWaterMark;
    }
  }), Object.defineProperty(s.prototype, "writableBuffer", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState && this._writableState.getBuffer();
    }
  }), Object.defineProperty(s.prototype, "writableLength", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.length;
    }
  });
  function o() {
    this._writableState.ended || process.nextTick(u, this);
  }
  function u(c) {
    c.end();
  }
  return Object.defineProperty(s.prototype, "destroyed", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState === void 0 || this._writableState === void 0 ? !1 : this._readableState.destroyed && this._writableState.destroyed;
    },
    set: function(l) {
      this._readableState === void 0 || this._writableState === void 0 || (this._readableState.destroyed = l, this._writableState.destroyed = l);
    }
  }), gh;
}
var bh = {}, ou = { exports: {} };
/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
var V1;
function Sk() {
  return V1 || (V1 = 1, (function(n, e) {
    var t = lo(), i = t.Buffer;
    function r(s, o) {
      for (var u in s)
        o[u] = s[u];
    }
    i.from && i.alloc && i.allocUnsafe && i.allocUnsafeSlow ? n.exports = t : (r(t, e), e.Buffer = a);
    function a(s, o, u) {
      return i(s, o, u);
    }
    a.prototype = Object.create(i.prototype), r(i, a), a.from = function(s, o, u) {
      if (typeof s == "number")
        throw new TypeError("Argument must not be a number");
      return i(s, o, u);
    }, a.alloc = function(s, o, u) {
      if (typeof s != "number")
        throw new TypeError("Argument must be a number");
      var c = i(s);
      return o !== void 0 ? typeof u == "string" ? c.fill(o, u) : c.fill(o) : c.fill(0), c;
    }, a.allocUnsafe = function(s) {
      if (typeof s != "number")
        throw new TypeError("Argument must be a number");
      return i(s);
    }, a.allocUnsafeSlow = function(s) {
      if (typeof s != "number")
        throw new TypeError("Argument must be a number");
      return t.SlowBuffer(s);
    };
  })(ou, ou.exports)), ou.exports;
}
var H1;
function z1() {
  if (H1) return bh;
  H1 = 1;
  var n = Sk().Buffer, e = n.isEncoding || function(p) {
    switch (p = "" + p, p && p.toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
      case "raw":
        return !0;
      default:
        return !1;
    }
  };
  function t(p) {
    if (!p) return "utf8";
    for (var g; ; )
      switch (p) {
        case "utf8":
        case "utf-8":
          return "utf8";
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return "utf16le";
        case "latin1":
        case "binary":
          return "latin1";
        case "base64":
        case "ascii":
        case "hex":
          return p;
        default:
          if (g) return;
          p = ("" + p).toLowerCase(), g = !0;
      }
  }
  function i(p) {
    var g = t(p);
    if (typeof g != "string" && (n.isEncoding === e || !e(p))) throw new Error("Unknown encoding: " + p);
    return g || p;
  }
  bh.StringDecoder = r;
  function r(p) {
    this.encoding = i(p);
    var g;
    switch (this.encoding) {
      case "utf16le":
        this.text = h, this.end = f, g = 4;
        break;
      case "utf8":
        this.fillLast = u, g = 4;
        break;
      case "base64":
        this.text = d, this.end = y, g = 3;
        break;
      default:
        this.write = m, this.end = b;
        return;
    }
    this.lastNeed = 0, this.lastTotal = 0, this.lastChar = n.allocUnsafe(g);
  }
  r.prototype.write = function(p) {
    if (p.length === 0) return "";
    var g, v;
    if (this.lastNeed) {
      if (g = this.fillLast(p), g === void 0) return "";
      v = this.lastNeed, this.lastNeed = 0;
    } else
      v = 0;
    return v < p.length ? g ? g + this.text(p, v) : this.text(p, v) : g || "";
  }, r.prototype.end = l, r.prototype.text = c, r.prototype.fillLast = function(p) {
    if (this.lastNeed <= p.length)
      return p.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal);
    p.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, p.length), this.lastNeed -= p.length;
  };
  function a(p) {
    return p <= 127 ? 0 : p >> 5 === 6 ? 2 : p >> 4 === 14 ? 3 : p >> 3 === 30 ? 4 : p >> 6 === 2 ? -1 : -2;
  }
  function s(p, g, v) {
    var _ = g.length - 1;
    if (_ < v) return 0;
    var x = a(g[_]);
    return x >= 0 ? (x > 0 && (p.lastNeed = x - 1), x) : --_ < v || x === -2 ? 0 : (x = a(g[_]), x >= 0 ? (x > 0 && (p.lastNeed = x - 2), x) : --_ < v || x === -2 ? 0 : (x = a(g[_]), x >= 0 ? (x > 0 && (x === 2 ? x = 0 : p.lastNeed = x - 3), x) : 0));
  }
  function o(p, g, v) {
    if ((g[0] & 192) !== 128)
      return p.lastNeed = 0, "";
    if (p.lastNeed > 1 && g.length > 1) {
      if ((g[1] & 192) !== 128)
        return p.lastNeed = 1, "";
      if (p.lastNeed > 2 && g.length > 2 && (g[2] & 192) !== 128)
        return p.lastNeed = 2, "";
    }
  }
  function u(p) {
    var g = this.lastTotal - this.lastNeed, v = o(this, p);
    if (v !== void 0) return v;
    if (this.lastNeed <= p.length)
      return p.copy(this.lastChar, g, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal);
    p.copy(this.lastChar, g, 0, p.length), this.lastNeed -= p.length;
  }
  function c(p, g) {
    var v = s(this, p, g);
    if (!this.lastNeed) return p.toString("utf8", g);
    this.lastTotal = v;
    var _ = p.length - (v - this.lastNeed);
    return p.copy(this.lastChar, 0, _), p.toString("utf8", g, _);
  }
  function l(p) {
    var g = p && p.length ? this.write(p) : "";
    return this.lastNeed ? g + "" : g;
  }
  function h(p, g) {
    if ((p.length - g) % 2 === 0) {
      var v = p.toString("utf16le", g);
      if (v) {
        var _ = v.charCodeAt(v.length - 1);
        if (_ >= 55296 && _ <= 56319)
          return this.lastNeed = 2, this.lastTotal = 4, this.lastChar[0] = p[p.length - 2], this.lastChar[1] = p[p.length - 1], v.slice(0, -1);
      }
      return v;
    }
    return this.lastNeed = 1, this.lastTotal = 2, this.lastChar[0] = p[p.length - 1], p.toString("utf16le", g, p.length - 1);
  }
  function f(p) {
    var g = p && p.length ? this.write(p) : "";
    if (this.lastNeed) {
      var v = this.lastTotal - this.lastNeed;
      return g + this.lastChar.toString("utf16le", 0, v);
    }
    return g;
  }
  function d(p, g) {
    var v = (p.length - g) % 3;
    return v === 0 ? p.toString("base64", g) : (this.lastNeed = 3 - v, this.lastTotal = 3, v === 1 ? this.lastChar[0] = p[p.length - 1] : (this.lastChar[0] = p[p.length - 2], this.lastChar[1] = p[p.length - 1]), p.toString("base64", g, p.length - v));
  }
  function y(p) {
    var g = p && p.length ? this.write(p) : "";
    return this.lastNeed ? g + this.lastChar.toString("base64", 0, 3 - this.lastNeed) : g;
  }
  function m(p) {
    return p.toString(this.encoding);
  }
  function b(p) {
    return p && p.length ? this.write(p) : "";
  }
  return bh;
}
var yh, $1;
function Fg() {
  if ($1) return yh;
  $1 = 1;
  var n = Oa().codes.ERR_STREAM_PREMATURE_CLOSE;
  function e(a) {
    var s = !1;
    return function() {
      if (!s) {
        s = !0;
        for (var o = arguments.length, u = new Array(o), c = 0; c < o; c++)
          u[c] = arguments[c];
        a.apply(this, u);
      }
    };
  }
  function t() {
  }
  function i(a) {
    return a.setHeader && typeof a.abort == "function";
  }
  function r(a, s, o) {
    if (typeof s == "function") return r(a, null, s);
    s || (s = {}), o = e(o || t);
    var u = s.readable || s.readable !== !1 && a.readable, c = s.writable || s.writable !== !1 && a.writable, l = function() {
      a.writable || f();
    }, h = a._writableState && a._writableState.finished, f = function() {
      c = !1, h = !0, u || o.call(a);
    }, d = a._readableState && a._readableState.endEmitted, y = function() {
      u = !1, d = !0, c || o.call(a);
    }, m = function(v) {
      o.call(a, v);
    }, b = function() {
      var v;
      if (u && !d)
        return (!a._readableState || !a._readableState.ended) && (v = new n()), o.call(a, v);
      if (c && !h)
        return (!a._writableState || !a._writableState.ended) && (v = new n()), o.call(a, v);
    }, p = function() {
      a.req.on("finish", f);
    };
    return i(a) ? (a.on("complete", f), a.on("abort", b), a.req ? p() : a.on("request", p)) : c && !a._writableState && (a.on("end", l), a.on("close", l)), a.on("end", y), a.on("finish", f), s.error !== !1 && a.on("error", m), a.on("close", b), function() {
      a.removeListener("complete", f), a.removeListener("abort", b), a.removeListener("request", p), a.req && a.req.removeListener("finish", f), a.removeListener("end", l), a.removeListener("close", l), a.removeListener("finish", f), a.removeListener("end", y), a.removeListener("error", m), a.removeListener("close", b);
    };
  }
  return yh = r, yh;
}
var vh, G1;
function Ck() {
  if (G1) return vh;
  G1 = 1;
  var n;
  function e(v, _, x) {
    return _ = t(_), _ in v ? Object.defineProperty(v, _, { value: x, enumerable: !0, configurable: !0, writable: !0 }) : v[_] = x, v;
  }
  function t(v) {
    var _ = i(v, "string");
    return typeof _ == "symbol" ? _ : String(_);
  }
  function i(v, _) {
    if (typeof v != "object" || v === null) return v;
    var x = v[Symbol.toPrimitive];
    if (x !== void 0) {
      var T = x.call(v, _);
      if (typeof T != "object") return T;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (_ === "string" ? String : Number)(v);
  }
  var r = Fg(), a = Symbol("lastResolve"), s = Symbol("lastReject"), o = Symbol("error"), u = Symbol("ended"), c = Symbol("lastPromise"), l = Symbol("handlePromise"), h = Symbol("stream");
  function f(v, _) {
    return {
      value: v,
      done: _
    };
  }
  function d(v) {
    var _ = v[a];
    if (_ !== null) {
      var x = v[h].read();
      x !== null && (v[c] = null, v[a] = null, v[s] = null, _(f(x, !1)));
    }
  }
  function y(v) {
    process.nextTick(d, v);
  }
  function m(v, _) {
    return function(x, T) {
      v.then(function() {
        if (_[u]) {
          x(f(void 0, !0));
          return;
        }
        _[l](x, T);
      }, T);
    };
  }
  var b = Object.getPrototypeOf(function() {
  }), p = Object.setPrototypeOf((n = {
    get stream() {
      return this[h];
    },
    next: function() {
      var _ = this, x = this[o];
      if (x !== null)
        return Promise.reject(x);
      if (this[u])
        return Promise.resolve(f(void 0, !0));
      if (this[h].destroyed)
        return new Promise(function(D, L) {
          process.nextTick(function() {
            _[o] ? L(_[o]) : D(f(void 0, !0));
          });
        });
      var T = this[c], E;
      if (T)
        E = new Promise(m(T, this));
      else {
        var U = this[h].read();
        if (U !== null)
          return Promise.resolve(f(U, !1));
        E = new Promise(this[l]);
      }
      return this[c] = E, E;
    }
  }, e(n, Symbol.asyncIterator, function() {
    return this;
  }), e(n, "return", function() {
    var _ = this;
    return new Promise(function(x, T) {
      _[h].destroy(null, function(E) {
        if (E) {
          T(E);
          return;
        }
        x(f(void 0, !0));
      });
    });
  }), n), b), g = function(_) {
    var x, T = Object.create(p, (x = {}, e(x, h, {
      value: _,
      writable: !0
    }), e(x, a, {
      value: null,
      writable: !0
    }), e(x, s, {
      value: null,
      writable: !0
    }), e(x, o, {
      value: null,
      writable: !0
    }), e(x, u, {
      value: _._readableState.endEmitted,
      writable: !0
    }), e(x, l, {
      value: function(U, D) {
        var L = T[h].read();
        L ? (T[c] = null, T[a] = null, T[s] = null, U(f(L, !1))) : (T[a] = U, T[s] = D);
      },
      writable: !0
    }), x));
    return T[c] = null, r(_, function(E) {
      if (E && E.code !== "ERR_STREAM_PREMATURE_CLOSE") {
        var U = T[s];
        U !== null && (T[c] = null, T[a] = null, T[s] = null, U(E)), T[o] = E;
        return;
      }
      var D = T[a];
      D !== null && (T[c] = null, T[a] = null, T[s] = null, D(f(void 0, !0))), T[u] = !0;
    }), _.on("readable", y.bind(null, T)), T;
  };
  return vh = g, vh;
}
var xh, X1;
function Ak() {
  return X1 || (X1 = 1, xh = function() {
    throw new Error("Readable.from is not available in the browser");
  }), xh;
}
var _h, K1;
function PE() {
  if (K1) return _h;
  K1 = 1, _h = D;
  var n;
  D.ReadableState = U, Pg().EventEmitter;
  var e = function(P, ne) {
    return P.listeners(ne).length;
  }, t = UE(), i = lo().Buffer, r = (typeof At < "u" ? At : typeof window < "u" ? window : typeof self < "u" ? self : {}).Uint8Array || function() {
  };
  function a(F) {
    return i.from(F);
  }
  function s(F) {
    return i.isBuffer(F) || F instanceof r;
  }
  var o = ni, u;
  o && o.debuglog ? u = o.debuglog("stream") : u = function() {
  };
  var c = Ek(), l = RE(), h = OE(), f = h.getHighWaterMark, d = Oa().codes, y = d.ERR_INVALID_ARG_TYPE, m = d.ERR_STREAM_PUSH_AFTER_EOF, b = d.ERR_METHOD_NOT_IMPLEMENTED, p = d.ERR_STREAM_UNSHIFT_AFTER_END_EVENT, g, v, _;
  Ra()(D, t);
  var x = l.errorOrDestroy, T = ["error", "close", "destroy", "pause", "resume"];
  function E(F, P, ne) {
    if (typeof F.prependListener == "function") return F.prependListener(P, ne);
    !F._events || !F._events[P] ? F.on(P, ne) : Array.isArray(F._events[P]) ? F._events[P].unshift(ne) : F._events[P] = [ne, F._events[P]];
  }
  function U(F, P, ne) {
    n = n || va(), F = F || {}, typeof ne != "boolean" && (ne = P instanceof n), this.objectMode = !!F.objectMode, ne && (this.objectMode = this.objectMode || !!F.readableObjectMode), this.highWaterMark = f(this, F, "readableHighWaterMark", ne), this.buffer = new c(), this.length = 0, this.pipes = null, this.pipesCount = 0, this.flowing = null, this.ended = !1, this.endEmitted = !1, this.reading = !1, this.sync = !0, this.needReadable = !1, this.emittedReadable = !1, this.readableListening = !1, this.resumeScheduled = !1, this.paused = !0, this.emitClose = F.emitClose !== !1, this.autoDestroy = !!F.autoDestroy, this.destroyed = !1, this.defaultEncoding = F.defaultEncoding || "utf8", this.awaitDrain = 0, this.readingMore = !1, this.decoder = null, this.encoding = null, F.encoding && (g || (g = z1().StringDecoder), this.decoder = new g(F.encoding), this.encoding = F.encoding);
  }
  function D(F) {
    if (n = n || va(), !(this instanceof D)) return new D(F);
    var P = this instanceof n;
    this._readableState = new U(F, this, P), this.readable = !0, F && (typeof F.read == "function" && (this._read = F.read), typeof F.destroy == "function" && (this._destroy = F.destroy)), t.call(this);
  }
  Object.defineProperty(D.prototype, "destroyed", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState === void 0 ? !1 : this._readableState.destroyed;
    },
    set: function(P) {
      this._readableState && (this._readableState.destroyed = P);
    }
  }), D.prototype.destroy = l.destroy, D.prototype._undestroy = l.undestroy, D.prototype._destroy = function(F, P) {
    P(F);
  }, D.prototype.push = function(F, P) {
    var ne = this._readableState, S;
    return ne.objectMode ? S = !0 : typeof F == "string" && (P = P || ne.defaultEncoding, P !== ne.encoding && (F = i.from(F, P), P = ""), S = !0), L(this, F, P, !1, S);
  }, D.prototype.unshift = function(F) {
    return L(this, F, null, !0, !1);
  };
  function L(F, P, ne, S, he) {
    u("readableAddChunk", P);
    var ae = F._readableState;
    if (P === null)
      ae.reading = !1, W(F, ae);
    else {
      var te;
      if (he || (te = C(ae, P)), te)
        x(F, te);
      else if (ae.objectMode || P && P.length > 0)
        if (typeof P != "string" && !ae.objectMode && Object.getPrototypeOf(P) !== i.prototype && (P = a(P)), S)
          ae.endEmitted ? x(F, new p()) : j(F, ae, P, !0);
        else if (ae.ended)
          x(F, new m());
        else {
          if (ae.destroyed)
            return !1;
          ae.reading = !1, ae.decoder && !ne ? (P = ae.decoder.write(P), ae.objectMode || P.length !== 0 ? j(F, ae, P, !1) : q(F, ae)) : j(F, ae, P, !1);
        }
      else S || (ae.reading = !1, q(F, ae));
    }
    return !ae.ended && (ae.length < ae.highWaterMark || ae.length === 0);
  }
  function j(F, P, ne, S) {
    P.flowing && P.length === 0 && !P.sync ? (P.awaitDrain = 0, F.emit("data", ne)) : (P.length += P.objectMode ? 1 : ne.length, S ? P.buffer.unshift(ne) : P.buffer.push(ne), P.needReadable && B(F)), q(F, P);
  }
  function C(F, P) {
    var ne;
    return !s(P) && typeof P != "string" && P !== void 0 && !F.objectMode && (ne = new y("chunk", ["string", "Buffer", "Uint8Array"], P)), ne;
  }
  D.prototype.isPaused = function() {
    return this._readableState.flowing === !1;
  }, D.prototype.setEncoding = function(F) {
    g || (g = z1().StringDecoder);
    var P = new g(F);
    this._readableState.decoder = P, this._readableState.encoding = this._readableState.decoder.encoding;
    for (var ne = this._readableState.buffer.head, S = ""; ne !== null; )
      S += P.write(ne.data), ne = ne.next;
    return this._readableState.buffer.clear(), S !== "" && this._readableState.buffer.push(S), this._readableState.length = S.length, this;
  };
  var k = 1073741824;
  function I(F) {
    return F >= k ? F = k : (F--, F |= F >>> 1, F |= F >>> 2, F |= F >>> 4, F |= F >>> 8, F |= F >>> 16, F++), F;
  }
  function $(F, P) {
    return F <= 0 || P.length === 0 && P.ended ? 0 : P.objectMode ? 1 : F !== F ? P.flowing && P.length ? P.buffer.head.data.length : P.length : (F > P.highWaterMark && (P.highWaterMark = I(F)), F <= P.length ? F : P.ended ? P.length : (P.needReadable = !0, 0));
  }
  D.prototype.read = function(F) {
    u("read", F), F = parseInt(F, 10);
    var P = this._readableState, ne = F;
    if (F !== 0 && (P.emittedReadable = !1), F === 0 && P.needReadable && ((P.highWaterMark !== 0 ? P.length >= P.highWaterMark : P.length > 0) || P.ended))
      return u("read: emitReadable", P.length, P.ended), P.length === 0 && P.ended ? De(this) : B(this), null;
    if (F = $(F, P), F === 0 && P.ended)
      return P.length === 0 && De(this), null;
    var S = P.needReadable;
    u("need readable", S), (P.length === 0 || P.length - F < P.highWaterMark) && (S = !0, u("length less than watermark", S)), P.ended || P.reading ? (S = !1, u("reading or ended", S)) : S && (u("do read"), P.reading = !0, P.sync = !0, P.length === 0 && (P.needReadable = !0), this._read(P.highWaterMark), P.sync = !1, P.reading || (F = $(ne, P)));
    var he;
    return F > 0 ? he = oe(F, P) : he = null, he === null ? (P.needReadable = P.length <= P.highWaterMark, F = 0) : (P.length -= F, P.awaitDrain = 0), P.length === 0 && (P.ended || (P.needReadable = !0), ne !== F && P.ended && De(this)), he !== null && this.emit("data", he), he;
  };
  function W(F, P) {
    if (u("onEofChunk"), !P.ended) {
      if (P.decoder) {
        var ne = P.decoder.end();
        ne && ne.length && (P.buffer.push(ne), P.length += P.objectMode ? 1 : ne.length);
      }
      P.ended = !0, P.sync ? B(F) : (P.needReadable = !1, P.emittedReadable || (P.emittedReadable = !0, z(F)));
    }
  }
  function B(F) {
    var P = F._readableState;
    u("emitReadable", P.needReadable, P.emittedReadable), P.needReadable = !1, P.emittedReadable || (u("emitReadable", P.flowing), P.emittedReadable = !0, process.nextTick(z, F));
  }
  function z(F) {
    var P = F._readableState;
    u("emitReadable_", P.destroyed, P.length, P.ended), !P.destroyed && (P.length || P.ended) && (F.emit("readable"), P.emittedReadable = !1), P.needReadable = !P.flowing && !P.ended && P.length <= P.highWaterMark, ce(F);
  }
  function q(F, P) {
    P.readingMore || (P.readingMore = !0, process.nextTick(Y, F, P));
  }
  function Y(F, P) {
    for (; !P.reading && !P.ended && (P.length < P.highWaterMark || P.flowing && P.length === 0); ) {
      var ne = P.length;
      if (u("maybeReadMore read 0"), F.read(0), ne === P.length)
        break;
    }
    P.readingMore = !1;
  }
  D.prototype._read = function(F) {
    x(this, new b("_read()"));
  }, D.prototype.pipe = function(F, P) {
    var ne = this, S = this._readableState;
    switch (S.pipesCount) {
      case 0:
        S.pipes = F;
        break;
      case 1:
        S.pipes = [S.pipes, F];
        break;
      default:
        S.pipes.push(F);
        break;
    }
    S.pipesCount += 1, u("pipe count=%d opts=%j", S.pipesCount, P);
    var he = (!P || P.end !== !1) && F !== process.stdout && F !== process.stderr, ae = he ? ee : Ue;
    S.endEmitted ? process.nextTick(ae) : ne.once("end", ae), F.on("unpipe", te);
    function te(Q, M) {
      u("onunpipe"), Q === ne && M && M.hasUnpiped === !1 && (M.hasUnpiped = !0, Se());
    }
    function ee() {
      u("onend"), F.end();
    }
    var ve = H(ne);
    F.on("drain", ve);
    var Ee = !1;
    function Se() {
      u("cleanup"), F.removeListener("close", ye), F.removeListener("finish", we), F.removeListener("drain", ve), F.removeListener("error", le), F.removeListener("unpipe", te), ne.removeListener("end", ee), ne.removeListener("end", Ue), ne.removeListener("data", xe), Ee = !0, S.awaitDrain && (!F._writableState || F._writableState.needDrain) && ve();
    }
    ne.on("data", xe);
    function xe(Q) {
      u("ondata");
      var M = F.write(Q);
      u("dest.write", M), M === !1 && ((S.pipesCount === 1 && S.pipes === F || S.pipesCount > 1 && Me(S.pipes, F) !== -1) && !Ee && (u("false write response, pause", S.awaitDrain), S.awaitDrain++), ne.pause());
    }
    function le(Q) {
      u("onerror", Q), Ue(), F.removeListener("error", le), e(F, "error") === 0 && x(F, Q);
    }
    E(F, "error", le);
    function ye() {
      F.removeListener("finish", we), Ue();
    }
    F.once("close", ye);
    function we() {
      u("onfinish"), F.removeListener("close", ye), Ue();
    }
    F.once("finish", we);
    function Ue() {
      u("unpipe"), ne.unpipe(F);
    }
    return F.emit("pipe", ne), S.flowing || (u("pipe resume"), ne.resume()), F;
  };
  function H(F) {
    return function() {
      var ne = F._readableState;
      u("pipeOnDrain", ne.awaitDrain), ne.awaitDrain && ne.awaitDrain--, ne.awaitDrain === 0 && e(F, "data") && (ne.flowing = !0, ce(F));
    };
  }
  D.prototype.unpipe = function(F) {
    var P = this._readableState, ne = {
      hasUnpiped: !1
    };
    if (P.pipesCount === 0) return this;
    if (P.pipesCount === 1)
      return F && F !== P.pipes ? this : (F || (F = P.pipes), P.pipes = null, P.pipesCount = 0, P.flowing = !1, F && F.emit("unpipe", this, ne), this);
    if (!F) {
      var S = P.pipes, he = P.pipesCount;
      P.pipes = null, P.pipesCount = 0, P.flowing = !1;
      for (var ae = 0; ae < he; ae++) S[ae].emit("unpipe", this, {
        hasUnpiped: !1
      });
      return this;
    }
    var te = Me(P.pipes, F);
    return te === -1 ? this : (P.pipes.splice(te, 1), P.pipesCount -= 1, P.pipesCount === 1 && (P.pipes = P.pipes[0]), F.emit("unpipe", this, ne), this);
  }, D.prototype.on = function(F, P) {
    var ne = t.prototype.on.call(this, F, P), S = this._readableState;
    return F === "data" ? (S.readableListening = this.listenerCount("readable") > 0, S.flowing !== !1 && this.resume()) : F === "readable" && !S.endEmitted && !S.readableListening && (S.readableListening = S.needReadable = !0, S.flowing = !1, S.emittedReadable = !1, u("on readable", S.length, S.reading), S.length ? B(this) : S.reading || process.nextTick(ie, this)), ne;
  }, D.prototype.addListener = D.prototype.on, D.prototype.removeListener = function(F, P) {
    var ne = t.prototype.removeListener.call(this, F, P);
    return F === "readable" && process.nextTick(K, this), ne;
  }, D.prototype.removeAllListeners = function(F) {
    var P = t.prototype.removeAllListeners.apply(this, arguments);
    return (F === "readable" || F === void 0) && process.nextTick(K, this), P;
  };
  function K(F) {
    var P = F._readableState;
    P.readableListening = F.listenerCount("readable") > 0, P.resumeScheduled && !P.paused ? P.flowing = !0 : F.listenerCount("data") > 0 && F.resume();
  }
  function ie(F) {
    u("readable nexttick read 0"), F.read(0);
  }
  D.prototype.resume = function() {
    var F = this._readableState;
    return F.flowing || (u("resume"), F.flowing = !F.readableListening, ge(this, F)), F.paused = !1, this;
  };
  function ge(F, P) {
    P.resumeScheduled || (P.resumeScheduled = !0, process.nextTick(pe, F, P));
  }
  function pe(F, P) {
    u("resume", P.reading), P.reading || F.read(0), P.resumeScheduled = !1, F.emit("resume"), ce(F), P.flowing && !P.reading && F.read(0);
  }
  D.prototype.pause = function() {
    return u("call pause flowing=%j", this._readableState.flowing), this._readableState.flowing !== !1 && (u("pause"), this._readableState.flowing = !1, this.emit("pause")), this._readableState.paused = !0, this;
  };
  function ce(F) {
    var P = F._readableState;
    for (u("flow", P.flowing); P.flowing && F.read() !== null; ) ;
  }
  D.prototype.wrap = function(F) {
    var P = this, ne = this._readableState, S = !1;
    F.on("end", function() {
      if (u("wrapped end"), ne.decoder && !ne.ended) {
        var te = ne.decoder.end();
        te && te.length && P.push(te);
      }
      P.push(null);
    }), F.on("data", function(te) {
      if (u("wrapped data"), ne.decoder && (te = ne.decoder.write(te)), !(ne.objectMode && te == null) && !(!ne.objectMode && (!te || !te.length))) {
        var ee = P.push(te);
        ee || (S = !0, F.pause());
      }
    });
    for (var he in F)
      this[he] === void 0 && typeof F[he] == "function" && (this[he] = /* @__PURE__ */ (function(ee) {
        return function() {
          return F[ee].apply(F, arguments);
        };
      })(he));
    for (var ae = 0; ae < T.length; ae++)
      F.on(T[ae], this.emit.bind(this, T[ae]));
    return this._read = function(te) {
      u("wrapped _read", te), S && (S = !1, F.resume());
    }, this;
  }, typeof Symbol == "function" && (D.prototype[Symbol.asyncIterator] = function() {
    return v === void 0 && (v = Ck()), v(this);
  }), Object.defineProperty(D.prototype, "readableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState.highWaterMark;
    }
  }), Object.defineProperty(D.prototype, "readableBuffer", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState && this._readableState.buffer;
    }
  }), Object.defineProperty(D.prototype, "readableFlowing", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState.flowing;
    },
    set: function(P) {
      this._readableState && (this._readableState.flowing = P);
    }
  }), D._fromList = oe, Object.defineProperty(D.prototype, "readableLength", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState.length;
    }
  });
  function oe(F, P) {
    if (P.length === 0) return null;
    var ne;
    return P.objectMode ? ne = P.buffer.shift() : !F || F >= P.length ? (P.decoder ? ne = P.buffer.join("") : P.buffer.length === 1 ? ne = P.buffer.first() : ne = P.buffer.concat(P.length), P.buffer.clear()) : ne = P.buffer.consume(F, P.decoder), ne;
  }
  function De(F) {
    var P = F._readableState;
    u("endReadable", P.endEmitted), P.endEmitted || (P.ended = !0, process.nextTick(Re, P, F));
  }
  function Re(F, P) {
    if (u("endReadableNT", F.endEmitted, F.length), !F.endEmitted && F.length === 0 && (F.endEmitted = !0, P.readable = !1, P.emit("end"), F.autoDestroy)) {
      var ne = P._writableState;
      (!ne || ne.autoDestroy && ne.finished) && P.destroy();
    }
  }
  typeof Symbol == "function" && (D.from = function(F, P) {
    return _ === void 0 && (_ = Ak()), _(D, F, P);
  });
  function Me(F, P) {
    for (var ne = 0, S = F.length; ne < S; ne++)
      if (F[ne] === P) return ne;
    return -1;
  }
  return _h;
}
var Th, Y1;
function FE() {
  if (Y1) return Th;
  Y1 = 1, Th = o;
  var n = Oa().codes, e = n.ERR_METHOD_NOT_IMPLEMENTED, t = n.ERR_MULTIPLE_CALLBACK, i = n.ERR_TRANSFORM_ALREADY_TRANSFORMING, r = n.ERR_TRANSFORM_WITH_LENGTH_0, a = va();
  Ra()(o, a);
  function s(l, h) {
    var f = this._transformState;
    f.transforming = !1;
    var d = f.writecb;
    if (d === null)
      return this.emit("error", new t());
    f.writechunk = null, f.writecb = null, h != null && this.push(h), d(l);
    var y = this._readableState;
    y.reading = !1, (y.needReadable || y.length < y.highWaterMark) && this._read(y.highWaterMark);
  }
  function o(l) {
    if (!(this instanceof o)) return new o(l);
    a.call(this, l), this._transformState = {
      afterTransform: s.bind(this),
      needTransform: !1,
      transforming: !1,
      writecb: null,
      writechunk: null,
      writeencoding: null
    }, this._readableState.needReadable = !0, this._readableState.sync = !1, l && (typeof l.transform == "function" && (this._transform = l.transform), typeof l.flush == "function" && (this._flush = l.flush)), this.on("prefinish", u);
  }
  function u() {
    var l = this;
    typeof this._flush == "function" && !this._readableState.destroyed ? this._flush(function(h, f) {
      c(l, h, f);
    }) : c(this, null, null);
  }
  o.prototype.push = function(l, h) {
    return this._transformState.needTransform = !1, a.prototype.push.call(this, l, h);
  }, o.prototype._transform = function(l, h, f) {
    f(new e("_transform()"));
  }, o.prototype._write = function(l, h, f) {
    var d = this._transformState;
    if (d.writecb = f, d.writechunk = l, d.writeencoding = h, !d.transforming) {
      var y = this._readableState;
      (d.needTransform || y.needReadable || y.length < y.highWaterMark) && this._read(y.highWaterMark);
    }
  }, o.prototype._read = function(l) {
    var h = this._transformState;
    h.writechunk !== null && !h.transforming ? (h.transforming = !0, this._transform(h.writechunk, h.writeencoding, h.afterTransform)) : h.needTransform = !0;
  }, o.prototype._destroy = function(l, h) {
    a.prototype._destroy.call(this, l, function(f) {
      h(f);
    });
  };
  function c(l, h, f) {
    if (h) return l.emit("error", h);
    if (f != null && l.push(f), l._writableState.length) throw new r();
    if (l._transformState.transforming) throw new i();
    return l.push(null);
  }
  return Th;
}
var wh, Q1;
function kk() {
  if (Q1) return wh;
  Q1 = 1, wh = e;
  var n = FE();
  Ra()(e, n);
  function e(t) {
    if (!(this instanceof e)) return new e(t);
    n.call(this, t);
  }
  return e.prototype._transform = function(t, i, r) {
    r(null, t);
  }, wh;
}
var Eh, Z1;
function Ik() {
  if (Z1) return Eh;
  Z1 = 1;
  var n;
  function e(f) {
    var d = !1;
    return function() {
      d || (d = !0, f.apply(void 0, arguments));
    };
  }
  var t = Oa().codes, i = t.ERR_MISSING_ARGS, r = t.ERR_STREAM_DESTROYED;
  function a(f) {
    if (f) throw f;
  }
  function s(f) {
    return f.setHeader && typeof f.abort == "function";
  }
  function o(f, d, y, m) {
    m = e(m);
    var b = !1;
    f.on("close", function() {
      b = !0;
    }), n === void 0 && (n = Fg()), n(f, {
      readable: d,
      writable: y
    }, function(g) {
      if (g) return m(g);
      b = !0, m();
    });
    var p = !1;
    return function(g) {
      if (!b && !p) {
        if (p = !0, s(f)) return f.abort();
        if (typeof f.destroy == "function") return f.destroy();
        m(g || new r("pipe"));
      }
    };
  }
  function u(f) {
    f();
  }
  function c(f, d) {
    return f.pipe(d);
  }
  function l(f) {
    return !f.length || typeof f[f.length - 1] != "function" ? a : f.pop();
  }
  function h() {
    for (var f = arguments.length, d = new Array(f), y = 0; y < f; y++)
      d[y] = arguments[y];
    var m = l(d);
    if (Array.isArray(d[0]) && (d = d[0]), d.length < 2)
      throw new i("streams");
    var b, p = d.map(function(g, v) {
      var _ = v < d.length - 1, x = v > 0;
      return o(g, _, x, function(T) {
        b || (b = T), T && p.forEach(u), !_ && (p.forEach(u), m(b));
      });
    });
    return d.reduce(c);
  }
  return Eh = h, Eh;
}
var Dh, J1;
function Uk() {
  if (J1) return Dh;
  J1 = 1, Dh = t;
  var n = Pg().EventEmitter, e = Ra();
  e(t, n), t.Readable = PE(), t.Writable = LE(), t.Duplex = va(), t.Transform = FE(), t.PassThrough = kk(), t.finished = Fg(), t.pipeline = Ik(), t.Stream = t;
  function t() {
    n.call(this);
  }
  return t.prototype.pipe = function(i, r) {
    var a = this;
    function s(d) {
      i.writable && i.write(d) === !1 && a.pause && a.pause();
    }
    a.on("data", s);
    function o() {
      a.readable && a.resume && a.resume();
    }
    i.on("drain", o), !i._isStdio && (!r || r.end !== !1) && (a.on("end", c), a.on("close", l));
    var u = !1;
    function c() {
      u || (u = !0, i.end());
    }
    function l() {
      u || (u = !0, typeof i.destroy == "function" && i.destroy());
    }
    function h(d) {
      if (f(), n.listenerCount(this, "error") === 0)
        throw d;
    }
    a.on("error", h), i.on("error", h);
    function f() {
      a.removeListener("data", s), i.removeListener("drain", o), a.removeListener("end", c), a.removeListener("close", l), a.removeListener("error", h), i.removeListener("error", h), a.removeListener("end", f), a.removeListener("close", f), i.removeListener("close", f);
    }
    return a.on("end", f), a.on("close", f), i.on("close", f), i.emit("pipe", a), i;
  }, Dh;
}
var Sh = {}, uu = { exports: {} }, ex;
function Rk() {
  return ex || (ex = 1, (function(n, e) {
    var t = lo(), i = t.Buffer;
    function r(s, o) {
      for (var u in s)
        o[u] = s[u];
    }
    i.from && i.alloc && i.allocUnsafe && i.allocUnsafeSlow ? n.exports = t : (r(t, e), e.Buffer = a);
    function a(s, o, u) {
      return i(s, o, u);
    }
    r(i, a), a.from = function(s, o, u) {
      if (typeof s == "number")
        throw new TypeError("Argument must not be a number");
      return i(s, o, u);
    }, a.alloc = function(s, o, u) {
      if (typeof s != "number")
        throw new TypeError("Argument must be a number");
      var c = i(s);
      return o !== void 0 ? typeof u == "string" ? c.fill(o, u) : c.fill(o) : c.fill(0), c;
    }, a.allocUnsafe = function(s) {
      if (typeof s != "number")
        throw new TypeError("Argument must be a number");
      return i(s);
    }, a.allocUnsafeSlow = function(s) {
      if (typeof s != "number")
        throw new TypeError("Argument must be a number");
      return t.SlowBuffer(s);
    };
  })(uu, uu.exports)), uu.exports;
}
var tx;
function Ok() {
  if (tx) return Sh;
  tx = 1;
  var n = Rk().Buffer, e = n.isEncoding || function(p) {
    switch (p = "" + p, p && p.toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
      case "raw":
        return !0;
      default:
        return !1;
    }
  };
  function t(p) {
    if (!p) return "utf8";
    for (var g; ; )
      switch (p) {
        case "utf8":
        case "utf-8":
          return "utf8";
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return "utf16le";
        case "latin1":
        case "binary":
          return "latin1";
        case "base64":
        case "ascii":
        case "hex":
          return p;
        default:
          if (g) return;
          p = ("" + p).toLowerCase(), g = !0;
      }
  }
  function i(p) {
    var g = t(p);
    if (typeof g != "string" && (n.isEncoding === e || !e(p))) throw new Error("Unknown encoding: " + p);
    return g || p;
  }
  Sh.StringDecoder = r;
  function r(p) {
    this.encoding = i(p);
    var g;
    switch (this.encoding) {
      case "utf16le":
        this.text = h, this.end = f, g = 4;
        break;
      case "utf8":
        this.fillLast = u, g = 4;
        break;
      case "base64":
        this.text = d, this.end = y, g = 3;
        break;
      default:
        this.write = m, this.end = b;
        return;
    }
    this.lastNeed = 0, this.lastTotal = 0, this.lastChar = n.allocUnsafe(g);
  }
  r.prototype.write = function(p) {
    if (p.length === 0) return "";
    var g, v;
    if (this.lastNeed) {
      if (g = this.fillLast(p), g === void 0) return "";
      v = this.lastNeed, this.lastNeed = 0;
    } else
      v = 0;
    return v < p.length ? g ? g + this.text(p, v) : this.text(p, v) : g || "";
  }, r.prototype.end = l, r.prototype.text = c, r.prototype.fillLast = function(p) {
    if (this.lastNeed <= p.length)
      return p.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal);
    p.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, p.length), this.lastNeed -= p.length;
  };
  function a(p) {
    return p <= 127 ? 0 : p >> 5 === 6 ? 2 : p >> 4 === 14 ? 3 : p >> 3 === 30 ? 4 : p >> 6 === 2 ? -1 : -2;
  }
  function s(p, g, v) {
    var _ = g.length - 1;
    if (_ < v) return 0;
    var x = a(g[_]);
    return x >= 0 ? (x > 0 && (p.lastNeed = x - 1), x) : --_ < v || x === -2 ? 0 : (x = a(g[_]), x >= 0 ? (x > 0 && (p.lastNeed = x - 2), x) : --_ < v || x === -2 ? 0 : (x = a(g[_]), x >= 0 ? (x > 0 && (x === 2 ? x = 0 : p.lastNeed = x - 3), x) : 0));
  }
  function o(p, g, v) {
    if ((g[0] & 192) !== 128)
      return p.lastNeed = 0, "";
    if (p.lastNeed > 1 && g.length > 1) {
      if ((g[1] & 192) !== 128)
        return p.lastNeed = 1, "";
      if (p.lastNeed > 2 && g.length > 2 && (g[2] & 192) !== 128)
        return p.lastNeed = 2, "";
    }
  }
  function u(p) {
    var g = this.lastTotal - this.lastNeed, v = o(this, p);
    if (v !== void 0) return v;
    if (this.lastNeed <= p.length)
      return p.copy(this.lastChar, g, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal);
    p.copy(this.lastChar, g, 0, p.length), this.lastNeed -= p.length;
  }
  function c(p, g) {
    var v = s(this, p, g);
    if (!this.lastNeed) return p.toString("utf8", g);
    this.lastTotal = v;
    var _ = p.length - (v - this.lastNeed);
    return p.copy(this.lastChar, 0, _), p.toString("utf8", g, _);
  }
  function l(p) {
    var g = p && p.length ? this.write(p) : "";
    return this.lastNeed ? g + "" : g;
  }
  function h(p, g) {
    if ((p.length - g) % 2 === 0) {
      var v = p.toString("utf16le", g);
      if (v) {
        var _ = v.charCodeAt(v.length - 1);
        if (_ >= 55296 && _ <= 56319)
          return this.lastNeed = 2, this.lastTotal = 4, this.lastChar[0] = p[p.length - 2], this.lastChar[1] = p[p.length - 1], v.slice(0, -1);
      }
      return v;
    }
    return this.lastNeed = 1, this.lastTotal = 2, this.lastChar[0] = p[p.length - 1], p.toString("utf16le", g, p.length - 1);
  }
  function f(p) {
    var g = p && p.length ? this.write(p) : "";
    if (this.lastNeed) {
      var v = this.lastTotal - this.lastNeed;
      return g + this.lastChar.toString("utf16le", 0, v);
    }
    return g;
  }
  function d(p, g) {
    var v = (p.length - g) % 3;
    return v === 0 ? p.toString("base64", g) : (this.lastNeed = 3 - v, this.lastTotal = 3, v === 1 ? this.lastChar[0] = p[p.length - 1] : (this.lastChar[0] = p[p.length - 2], this.lastChar[1] = p[p.length - 1]), p.toString("base64", g, p.length - v));
  }
  function y(p) {
    var g = p && p.length ? this.write(p) : "";
    return this.lastNeed ? g + this.lastChar.toString("base64", 0, 3 - this.lastNeed) : g;
  }
  function m(p) {
    return p.toString(this.encoding);
  }
  function b(p) {
    return p && p.length ? this.write(p) : "";
  }
  return Sh;
}
var nx;
function Lk() {
  return nx || (nx = 1, (function(n) {
    (function(e) {
      e.parser = function(F, P) {
        return new i(F, P);
      }, e.SAXParser = i, e.SAXStream = l, e.createStream = c, e.MAX_BUFFER_LENGTH = 64 * 1024;
      var t = [
        "comment",
        "sgmlDecl",
        "textNode",
        "tagName",
        "doctype",
        "procInstName",
        "procInstBody",
        "entity",
        "attribName",
        "attribValue",
        "cdata",
        "script"
      ];
      e.EVENTS = [
        "text",
        "processinginstruction",
        "sgmldeclaration",
        "doctype",
        "comment",
        "attribute",
        "opentag",
        "closetag",
        "opencdata",
        "cdata",
        "closecdata",
        "error",
        "end",
        "ready",
        "script",
        "opennamespace",
        "closenamespace"
      ];
      function i(F, P) {
        if (!(this instanceof i))
          return new i(F, P);
        var ne = this;
        a(ne), ne.q = ne.c = "", ne.bufferCheckPosition = e.MAX_BUFFER_LENGTH, ne.opt = P || {}, ne.opt.lowercase = ne.opt.lowercase || ne.opt.lowercasetags, ne.looseCase = ne.opt.lowercase ? "toLowerCase" : "toUpperCase", ne.tags = [], ne.closed = ne.closedRoot = ne.sawRoot = !1, ne.tag = ne.error = null, ne.strict = !!F, ne.noscript = !!(F || ne.opt.noscript), ne.state = k.BEGIN, ne.strictEntities = ne.opt.strictEntities, ne.ENTITIES = ne.strictEntities ? Object.create(e.XML_ENTITIES) : Object.create(e.ENTITIES), ne.attribList = [], ne.opt.xmlns && (ne.ns = Object.create(_)), ne.trackPosition = ne.opt.position !== !1, ne.trackPosition && (ne.position = ne.line = ne.column = 0), $(ne, "onready");
      }
      Object.create || (Object.create = function(F) {
        function P() {
        }
        P.prototype = F;
        var ne = new P();
        return ne;
      }), Object.keys || (Object.keys = function(F) {
        var P = [];
        for (var ne in F) F.hasOwnProperty(ne) && P.push(ne);
        return P;
      });
      function r(F) {
        for (var P = Math.max(e.MAX_BUFFER_LENGTH, 10), ne = 0, S = 0, he = t.length; S < he; S++) {
          var ae = F[t[S]].length;
          if (ae > P)
            switch (t[S]) {
              case "textNode":
                B(F);
                break;
              case "cdata":
                W(F, "oncdata", F.cdata), F.cdata = "";
                break;
              case "script":
                W(F, "onscript", F.script), F.script = "";
                break;
              default:
                q(F, "Max buffer length exceeded: " + t[S]);
            }
          ne = Math.max(ne, ae);
        }
        var te = e.MAX_BUFFER_LENGTH - ne;
        F.bufferCheckPosition = te + F.position;
      }
      function a(F) {
        for (var P = 0, ne = t.length; P < ne; P++)
          F[t[P]] = "";
      }
      function s(F) {
        B(F), F.cdata !== "" && (W(F, "oncdata", F.cdata), F.cdata = ""), F.script !== "" && (W(F, "onscript", F.script), F.script = "");
      }
      i.prototype = {
        end: function() {
          Y(this);
        },
        write: Me,
        resume: function() {
          return this.error = null, this;
        },
        close: function() {
          return this.write(null);
        },
        flush: function() {
          s(this);
        }
      };
      var o;
      try {
        o = Uk().Stream;
      } catch {
        o = function() {
        };
      }
      var u = e.EVENTS.filter(function(F) {
        return F !== "error" && F !== "end";
      });
      function c(F, P) {
        return new l(F, P);
      }
      function l(F, P) {
        if (!(this instanceof l))
          return new l(F, P);
        o.apply(this), this._parser = new i(F, P), this.writable = !0, this.readable = !0;
        var ne = this;
        this._parser.onend = function() {
          ne.emit("end");
        }, this._parser.onerror = function(S) {
          ne.emit("error", S), ne._parser.error = null;
        }, this._decoder = null, u.forEach(function(S) {
          Object.defineProperty(ne, "on" + S, {
            get: function() {
              return ne._parser["on" + S];
            },
            set: function(he) {
              if (!he)
                return ne.removeAllListeners(S), ne._parser["on" + S] = he, he;
              ne.on(S, he);
            },
            enumerable: !0,
            configurable: !1
          });
        });
      }
      l.prototype = Object.create(o.prototype, {
        constructor: {
          value: l
        }
      }), l.prototype.write = function(F) {
        if (typeof Buffer == "function" && typeof Buffer.isBuffer == "function" && Buffer.isBuffer(F)) {
          if (!this._decoder) {
            var P = Ok().StringDecoder;
            this._decoder = new P("utf8");
          }
          F = this._decoder.write(F);
        }
        return this._parser.write(F.toString()), this.emit("data", F), !0;
      }, l.prototype.end = function(F) {
        return F && F.length && this.write(F), this._parser.end(), !0;
      }, l.prototype.on = function(F, P) {
        var ne = this;
        return !ne._parser["on" + F] && u.indexOf(F) !== -1 && (ne._parser["on" + F] = function() {
          var S = arguments.length === 1 ? [arguments[0]] : Array.apply(null, arguments);
          S.splice(0, 0, F), ne.emit.apply(ne, S);
        }), o.prototype.on.call(ne, F, P);
      };
      var h = `\r
	 `, f = "0124356789", d = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ", y = `'"`, m = h + ">", b = "[CDATA[", p = "DOCTYPE", g = "http://www.w3.org/XML/1998/namespace", v = "http://www.w3.org/2000/xmlns/", _ = { xml: g, xmlns: v };
      h = D(h), f = D(f), d = D(d);
      var x = /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/, T = /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u00B7\u0300-\u036F\u203F-\u2040\.\d-]/, E = /[#:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/, U = /[#:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u00B7\u0300-\u036F\u203F-\u2040\.\d-]/;
      y = D(y), m = D(m);
      function D(F) {
        return F.split("").reduce(function(P, ne) {
          return P[ne] = !0, P;
        }, {});
      }
      function L(F) {
        return Object.prototype.toString.call(F) === "[object RegExp]";
      }
      function j(F, P) {
        return L(F) ? !!P.match(F) : F[P];
      }
      function C(F, P) {
        return !j(F, P);
      }
      var k = 0;
      e.STATE = {
        BEGIN: k++,
        // leading byte order mark or whitespace
        BEGIN_WHITESPACE: k++,
        // leading whitespace
        TEXT: k++,
        // general stuff
        TEXT_ENTITY: k++,
        // &amp and such.
        OPEN_WAKA: k++,
        // <
        SGML_DECL: k++,
        // <!BLARG
        SGML_DECL_QUOTED: k++,
        // <!BLARG foo "bar
        DOCTYPE: k++,
        // <!DOCTYPE
        DOCTYPE_QUOTED: k++,
        // <!DOCTYPE "//blah
        DOCTYPE_DTD: k++,
        // <!DOCTYPE "//blah" [ ...
        DOCTYPE_DTD_QUOTED: k++,
        // <!DOCTYPE "//blah" [ "foo
        COMMENT_STARTING: k++,
        // <!-
        COMMENT: k++,
        // <!--
        COMMENT_ENDING: k++,
        // <!-- blah -
        COMMENT_ENDED: k++,
        // <!-- blah --
        CDATA: k++,
        // <![CDATA[ something
        CDATA_ENDING: k++,
        // ]
        CDATA_ENDING_2: k++,
        // ]]
        PROC_INST: k++,
        // <?hi
        PROC_INST_BODY: k++,
        // <?hi there
        PROC_INST_ENDING: k++,
        // <?hi "there" ?
        OPEN_TAG: k++,
        // <strong
        OPEN_TAG_SLASH: k++,
        // <strong /
        ATTRIB: k++,
        // <a
        ATTRIB_NAME: k++,
        // <a foo
        ATTRIB_NAME_SAW_WHITE: k++,
        // <a foo _
        ATTRIB_VALUE: k++,
        // <a foo=
        ATTRIB_VALUE_QUOTED: k++,
        // <a foo="bar
        ATTRIB_VALUE_CLOSED: k++,
        // <a foo="bar"
        ATTRIB_VALUE_UNQUOTED: k++,
        // <a foo=bar
        ATTRIB_VALUE_ENTITY_Q: k++,
        // <foo bar="&quot;"
        ATTRIB_VALUE_ENTITY_U: k++,
        // <foo bar=&quot
        CLOSE_TAG: k++,
        // </a
        CLOSE_TAG_SAW_WHITE: k++,
        // </a   >
        SCRIPT: k++,
        // <script> ...
        SCRIPT_ENDING: k++
        // <script> ... <
      }, e.XML_ENTITIES = {
        amp: "&",
        gt: ">",
        lt: "<",
        quot: '"',
        apos: "'"
      }, e.ENTITIES = {
        amp: "&",
        gt: ">",
        lt: "<",
        quot: '"',
        apos: "'",
        AElig: 198,
        Aacute: 193,
        Acirc: 194,
        Agrave: 192,
        Aring: 197,
        Atilde: 195,
        Auml: 196,
        Ccedil: 199,
        ETH: 208,
        Eacute: 201,
        Ecirc: 202,
        Egrave: 200,
        Euml: 203,
        Iacute: 205,
        Icirc: 206,
        Igrave: 204,
        Iuml: 207,
        Ntilde: 209,
        Oacute: 211,
        Ocirc: 212,
        Ograve: 210,
        Oslash: 216,
        Otilde: 213,
        Ouml: 214,
        THORN: 222,
        Uacute: 218,
        Ucirc: 219,
        Ugrave: 217,
        Uuml: 220,
        Yacute: 221,
        aacute: 225,
        acirc: 226,
        aelig: 230,
        agrave: 224,
        aring: 229,
        atilde: 227,
        auml: 228,
        ccedil: 231,
        eacute: 233,
        ecirc: 234,
        egrave: 232,
        eth: 240,
        euml: 235,
        iacute: 237,
        icirc: 238,
        igrave: 236,
        iuml: 239,
        ntilde: 241,
        oacute: 243,
        ocirc: 244,
        ograve: 242,
        oslash: 248,
        otilde: 245,
        ouml: 246,
        szlig: 223,
        thorn: 254,
        uacute: 250,
        ucirc: 251,
        ugrave: 249,
        uuml: 252,
        yacute: 253,
        yuml: 255,
        copy: 169,
        reg: 174,
        nbsp: 160,
        iexcl: 161,
        cent: 162,
        pound: 163,
        curren: 164,
        yen: 165,
        brvbar: 166,
        sect: 167,
        uml: 168,
        ordf: 170,
        laquo: 171,
        not: 172,
        shy: 173,
        macr: 175,
        deg: 176,
        plusmn: 177,
        sup1: 185,
        sup2: 178,
        sup3: 179,
        acute: 180,
        micro: 181,
        para: 182,
        middot: 183,
        cedil: 184,
        ordm: 186,
        raquo: 187,
        frac14: 188,
        frac12: 189,
        frac34: 190,
        iquest: 191,
        times: 215,
        divide: 247,
        OElig: 338,
        oelig: 339,
        Scaron: 352,
        scaron: 353,
        Yuml: 376,
        fnof: 402,
        circ: 710,
        tilde: 732,
        Alpha: 913,
        Beta: 914,
        Gamma: 915,
        Delta: 916,
        Epsilon: 917,
        Zeta: 918,
        Eta: 919,
        Theta: 920,
        Iota: 921,
        Kappa: 922,
        Lambda: 923,
        Mu: 924,
        Nu: 925,
        Xi: 926,
        Omicron: 927,
        Pi: 928,
        Rho: 929,
        Sigma: 931,
        Tau: 932,
        Upsilon: 933,
        Phi: 934,
        Chi: 935,
        Psi: 936,
        Omega: 937,
        alpha: 945,
        beta: 946,
        gamma: 947,
        delta: 948,
        epsilon: 949,
        zeta: 950,
        eta: 951,
        theta: 952,
        iota: 953,
        kappa: 954,
        lambda: 955,
        mu: 956,
        nu: 957,
        xi: 958,
        omicron: 959,
        pi: 960,
        rho: 961,
        sigmaf: 962,
        sigma: 963,
        tau: 964,
        upsilon: 965,
        phi: 966,
        chi: 967,
        psi: 968,
        omega: 969,
        thetasym: 977,
        upsih: 978,
        piv: 982,
        ensp: 8194,
        emsp: 8195,
        thinsp: 8201,
        zwnj: 8204,
        zwj: 8205,
        lrm: 8206,
        rlm: 8207,
        ndash: 8211,
        mdash: 8212,
        lsquo: 8216,
        rsquo: 8217,
        sbquo: 8218,
        ldquo: 8220,
        rdquo: 8221,
        bdquo: 8222,
        dagger: 8224,
        Dagger: 8225,
        bull: 8226,
        hellip: 8230,
        permil: 8240,
        prime: 8242,
        Prime: 8243,
        lsaquo: 8249,
        rsaquo: 8250,
        oline: 8254,
        frasl: 8260,
        euro: 8364,
        image: 8465,
        weierp: 8472,
        real: 8476,
        trade: 8482,
        alefsym: 8501,
        larr: 8592,
        uarr: 8593,
        rarr: 8594,
        darr: 8595,
        harr: 8596,
        crarr: 8629,
        lArr: 8656,
        uArr: 8657,
        rArr: 8658,
        dArr: 8659,
        hArr: 8660,
        forall: 8704,
        part: 8706,
        exist: 8707,
        empty: 8709,
        nabla: 8711,
        isin: 8712,
        notin: 8713,
        ni: 8715,
        prod: 8719,
        sum: 8721,
        minus: 8722,
        lowast: 8727,
        radic: 8730,
        prop: 8733,
        infin: 8734,
        ang: 8736,
        and: 8743,
        or: 8744,
        cap: 8745,
        cup: 8746,
        int: 8747,
        there4: 8756,
        sim: 8764,
        cong: 8773,
        asymp: 8776,
        ne: 8800,
        equiv: 8801,
        le: 8804,
        ge: 8805,
        sub: 8834,
        sup: 8835,
        nsub: 8836,
        sube: 8838,
        supe: 8839,
        oplus: 8853,
        otimes: 8855,
        perp: 8869,
        sdot: 8901,
        lceil: 8968,
        rceil: 8969,
        lfloor: 8970,
        rfloor: 8971,
        lang: 9001,
        rang: 9002,
        loz: 9674,
        spades: 9824,
        clubs: 9827,
        hearts: 9829,
        diams: 9830
      }, Object.keys(e.ENTITIES).forEach(function(F) {
        var P = e.ENTITIES[F], ne = typeof P == "number" ? String.fromCharCode(P) : P;
        e.ENTITIES[F] = ne;
      });
      for (var I in e.STATE)
        e.STATE[e.STATE[I]] = I;
      k = e.STATE;
      function $(F, P, ne) {
        F[P] && F[P](ne);
      }
      function W(F, P, ne) {
        F.textNode && B(F), $(F, P, ne);
      }
      function B(F) {
        F.textNode = z(F.opt, F.textNode), F.textNode && $(F, "ontext", F.textNode), F.textNode = "";
      }
      function z(F, P) {
        return F.trim && (P = P.trim()), F.normalize && (P = P.replace(/\s+/g, " ")), P;
      }
      function q(F, P) {
        return B(F), F.trackPosition && (P += `
Line: ` + F.line + `
Column: ` + F.column + `
Char: ` + F.c), P = new Error(P), F.error = P, $(F, "onerror", P), F;
      }
      function Y(F) {
        return F.sawRoot && !F.closedRoot && H(F, "Unclosed root tag"), F.state !== k.BEGIN && F.state !== k.BEGIN_WHITESPACE && F.state !== k.TEXT && q(F, "Unexpected end"), B(F), F.c = "", F.closed = !0, $(F, "onend"), i.call(F, F.strict, F.opt), F;
      }
      function H(F, P) {
        if (typeof F != "object" || !(F instanceof i))
          throw new Error("bad call to strictFail");
        F.strict && q(F, P);
      }
      function K(F) {
        F.strict || (F.tagName = F.tagName[F.looseCase]());
        var P = F.tags[F.tags.length - 1] || F, ne = F.tag = { name: F.tagName, attributes: {} };
        F.opt.xmlns && (ne.ns = P.ns), F.attribList.length = 0;
      }
      function ie(F, P) {
        var ne = F.indexOf(":"), S = ne < 0 ? ["", F] : F.split(":"), he = S[0], ae = S[1];
        return P && F === "xmlns" && (he = "xmlns", ae = ""), { prefix: he, local: ae };
      }
      function ge(F) {
        if (F.strict || (F.attribName = F.attribName[F.looseCase]()), F.attribList.indexOf(F.attribName) !== -1 || F.tag.attributes.hasOwnProperty(F.attribName)) {
          F.attribName = F.attribValue = "";
          return;
        }
        if (F.opt.xmlns) {
          var P = ie(F.attribName, !0), ne = P.prefix, S = P.local;
          if (ne === "xmlns")
            if (S === "xml" && F.attribValue !== g)
              H(
                F,
                "xml: prefix must be bound to " + g + `
Actual: ` + F.attribValue
              );
            else if (S === "xmlns" && F.attribValue !== v)
              H(
                F,
                "xmlns: prefix must be bound to " + v + `
Actual: ` + F.attribValue
              );
            else {
              var he = F.tag, ae = F.tags[F.tags.length - 1] || F;
              he.ns === ae.ns && (he.ns = Object.create(ae.ns)), he.ns[S] = F.attribValue;
            }
          F.attribList.push([F.attribName, F.attribValue]);
        } else
          F.tag.attributes[F.attribName] = F.attribValue, W(F, "onattribute", {
            name: F.attribName,
            value: F.attribValue
          });
        F.attribName = F.attribValue = "";
      }
      function pe(F, P) {
        if (F.opt.xmlns) {
          var ne = F.tag, S = ie(F.tagName);
          ne.prefix = S.prefix, ne.local = S.local, ne.uri = ne.ns[S.prefix] || "", ne.prefix && !ne.uri && (H(F, "Unbound namespace prefix: " + JSON.stringify(F.tagName)), ne.uri = S.prefix);
          var he = F.tags[F.tags.length - 1] || F;
          ne.ns && he.ns !== ne.ns && Object.keys(ne.ns).forEach(function(Ue) {
            W(F, "onopennamespace", {
              prefix: Ue,
              uri: ne.ns[Ue]
            });
          });
          for (var ae = 0, te = F.attribList.length; ae < te; ae++) {
            var ee = F.attribList[ae], ve = ee[0], Ee = ee[1], Se = ie(ve, !0), xe = Se.prefix, le = Se.local, ye = xe === "" ? "" : ne.ns[xe] || "", we = {
              name: ve,
              value: Ee,
              prefix: xe,
              local: le,
              uri: ye
            };
            xe && xe !== "xmlns" && !ye && (H(F, "Unbound namespace prefix: " + JSON.stringify(xe)), we.uri = xe), F.tag.attributes[ve] = we, W(F, "onattribute", we);
          }
          F.attribList.length = 0;
        }
        F.tag.isSelfClosing = !!P, F.sawRoot = !0, F.tags.push(F.tag), W(F, "onopentag", F.tag), P || (!F.noscript && F.tagName.toLowerCase() === "script" ? F.state = k.SCRIPT : F.state = k.TEXT, F.tag = null, F.tagName = ""), F.attribName = F.attribValue = "", F.attribList.length = 0;
      }
      function ce(F) {
        if (!F.tagName) {
          H(F, "Weird empty close tag."), F.textNode += "</>", F.state = k.TEXT;
          return;
        }
        if (F.script) {
          if (F.tagName !== "script") {
            F.script += "</" + F.tagName + ">", F.tagName = "", F.state = k.SCRIPT;
            return;
          }
          W(F, "onscript", F.script), F.script = "";
        }
        var P = F.tags.length, ne = F.tagName;
        F.strict || (ne = ne[F.looseCase]());
        for (var S = ne; P--; ) {
          var he = F.tags[P];
          if (he.name !== S)
            H(F, "Unexpected close tag");
          else
            break;
        }
        if (P < 0) {
          H(F, "Unmatched closing tag: " + F.tagName), F.textNode += "</" + F.tagName + ">", F.state = k.TEXT;
          return;
        }
        F.tagName = ne;
        for (var ae = F.tags.length; ae-- > P; ) {
          var te = F.tag = F.tags.pop();
          F.tagName = F.tag.name, W(F, "onclosetag", F.tagName);
          var ee = {};
          for (var ve in te.ns)
            ee[ve] = te.ns[ve];
          var Ee = F.tags[F.tags.length - 1] || F;
          F.opt.xmlns && te.ns !== Ee.ns && Object.keys(te.ns).forEach(function(Se) {
            var xe = te.ns[Se];
            W(F, "onclosenamespace", { prefix: Se, uri: xe });
          });
        }
        P === 0 && (F.closedRoot = !0), F.tagName = F.attribValue = F.attribName = "", F.attribList.length = 0, F.state = k.TEXT;
      }
      function oe(F) {
        var P = F.entity, ne = P.toLowerCase(), S, he = "";
        return F.ENTITIES[P] ? F.ENTITIES[P] : F.ENTITIES[ne] ? F.ENTITIES[ne] : (P = ne, P.charAt(0) === "#" && (P.charAt(1) === "x" ? (P = P.slice(2), S = parseInt(P, 16), he = S.toString(16)) : (P = P.slice(1), S = parseInt(P, 10), he = S.toString(10))), P = P.replace(/^0+/, ""), he.toLowerCase() !== P ? (H(F, "Invalid character entity"), "&" + F.entity + ";") : String.fromCodePoint(S));
      }
      function De(F, P) {
        P === "<" ? (F.state = k.OPEN_WAKA, F.startTagPosition = F.position) : C(h, P) && (H(F, "Non-whitespace before first tag."), F.textNode = P, F.state = k.TEXT);
      }
      function Re(F, P) {
        var ne = "";
        return P < F.length && (ne = F.charAt(P)), ne;
      }
      function Me(F) {
        var P = this;
        if (this.error)
          throw this.error;
        if (P.closed)
          return q(
            P,
            "Cannot write after close. Assign an onready handler."
          );
        if (F === null)
          return Y(P);
        typeof F == "object" && (F = F.toString());
        for (var ne = 0, S = ""; S = Re(F, ne++), P.c = S, !!S; )
          switch (P.trackPosition && (P.position++, S === `
` ? (P.line++, P.column = 0) : P.column++), P.state) {
            case k.BEGIN:
              if (P.state = k.BEGIN_WHITESPACE, S === "\uFEFF")
                continue;
              De(P, S);
              continue;
            case k.BEGIN_WHITESPACE:
              De(P, S);
              continue;
            case k.TEXT:
              if (P.sawRoot && !P.closedRoot) {
                for (var he = ne - 1; S && S !== "<" && S !== "&"; )
                  S = Re(F, ne++), S && P.trackPosition && (P.position++, S === `
` ? (P.line++, P.column = 0) : P.column++);
                P.textNode += F.substring(he, ne - 1);
              }
              S === "<" && !(P.sawRoot && P.closedRoot && !P.strict) ? (P.state = k.OPEN_WAKA, P.startTagPosition = P.position) : (C(h, S) && (!P.sawRoot || P.closedRoot) && H(P, "Text data outside of root node."), S === "&" ? P.state = k.TEXT_ENTITY : P.textNode += S);
              continue;
            case k.SCRIPT:
              S === "<" ? P.state = k.SCRIPT_ENDING : P.script += S;
              continue;
            case k.SCRIPT_ENDING:
              S === "/" ? P.state = k.CLOSE_TAG : (P.script += "<" + S, P.state = k.SCRIPT);
              continue;
            case k.OPEN_WAKA:
              if (S === "!")
                P.state = k.SGML_DECL, P.sgmlDecl = "";
              else if (!j(h, S)) if (j(x, S))
                P.state = k.OPEN_TAG, P.tagName = S;
              else if (S === "/")
                P.state = k.CLOSE_TAG, P.tagName = "";
              else if (S === "?")
                P.state = k.PROC_INST, P.procInstName = P.procInstBody = "";
              else {
                if (H(P, "Unencoded <"), P.startTagPosition + 1 < P.position) {
                  var ae = P.position - P.startTagPosition;
                  S = new Array(ae).join(" ") + S;
                }
                P.textNode += "<" + S, P.state = k.TEXT;
              }
              continue;
            case k.SGML_DECL:
              (P.sgmlDecl + S).toUpperCase() === b ? (W(P, "onopencdata"), P.state = k.CDATA, P.sgmlDecl = "", P.cdata = "") : P.sgmlDecl + S === "--" ? (P.state = k.COMMENT, P.comment = "", P.sgmlDecl = "") : (P.sgmlDecl + S).toUpperCase() === p ? (P.state = k.DOCTYPE, (P.doctype || P.sawRoot) && H(
                P,
                "Inappropriately located doctype declaration"
              ), P.doctype = "", P.sgmlDecl = "") : S === ">" ? (W(P, "onsgmldeclaration", P.sgmlDecl), P.sgmlDecl = "", P.state = k.TEXT) : (j(y, S) && (P.state = k.SGML_DECL_QUOTED), P.sgmlDecl += S);
              continue;
            case k.SGML_DECL_QUOTED:
              S === P.q && (P.state = k.SGML_DECL, P.q = ""), P.sgmlDecl += S;
              continue;
            case k.DOCTYPE:
              S === ">" ? (P.state = k.TEXT, W(P, "ondoctype", P.doctype), P.doctype = !0) : (P.doctype += S, S === "[" ? P.state = k.DOCTYPE_DTD : j(y, S) && (P.state = k.DOCTYPE_QUOTED, P.q = S));
              continue;
            case k.DOCTYPE_QUOTED:
              P.doctype += S, S === P.q && (P.q = "", P.state = k.DOCTYPE);
              continue;
            case k.DOCTYPE_DTD:
              P.doctype += S, S === "]" ? P.state = k.DOCTYPE : j(y, S) && (P.state = k.DOCTYPE_DTD_QUOTED, P.q = S);
              continue;
            case k.DOCTYPE_DTD_QUOTED:
              P.doctype += S, S === P.q && (P.state = k.DOCTYPE_DTD, P.q = "");
              continue;
            case k.COMMENT:
              S === "-" ? P.state = k.COMMENT_ENDING : P.comment += S;
              continue;
            case k.COMMENT_ENDING:
              S === "-" ? (P.state = k.COMMENT_ENDED, P.comment = z(P.opt, P.comment), P.comment && W(P, "oncomment", P.comment), P.comment = "") : (P.comment += "-" + S, P.state = k.COMMENT);
              continue;
            case k.COMMENT_ENDED:
              S !== ">" ? (H(P, "Malformed comment"), P.comment += "--" + S, P.state = k.COMMENT) : P.state = k.TEXT;
              continue;
            case k.CDATA:
              S === "]" ? P.state = k.CDATA_ENDING : P.cdata += S;
              continue;
            case k.CDATA_ENDING:
              S === "]" ? P.state = k.CDATA_ENDING_2 : (P.cdata += "]" + S, P.state = k.CDATA);
              continue;
            case k.CDATA_ENDING_2:
              S === ">" ? (P.cdata && W(P, "oncdata", P.cdata), W(P, "onclosecdata"), P.cdata = "", P.state = k.TEXT) : S === "]" ? P.cdata += "]" : (P.cdata += "]]" + S, P.state = k.CDATA);
              continue;
            case k.PROC_INST:
              S === "?" ? P.state = k.PROC_INST_ENDING : j(h, S) ? P.state = k.PROC_INST_BODY : P.procInstName += S;
              continue;
            case k.PROC_INST_BODY:
              if (!P.procInstBody && j(h, S))
                continue;
              S === "?" ? P.state = k.PROC_INST_ENDING : P.procInstBody += S;
              continue;
            case k.PROC_INST_ENDING:
              S === ">" ? (W(P, "onprocessinginstruction", {
                name: P.procInstName,
                body: P.procInstBody
              }), P.procInstName = P.procInstBody = "", P.state = k.TEXT) : (P.procInstBody += "?" + S, P.state = k.PROC_INST_BODY);
              continue;
            case k.OPEN_TAG:
              j(T, S) ? P.tagName += S : (K(P), S === ">" ? pe(P) : S === "/" ? P.state = k.OPEN_TAG_SLASH : (C(h, S) && H(P, "Invalid character in tag name"), P.state = k.ATTRIB));
              continue;
            case k.OPEN_TAG_SLASH:
              S === ">" ? (pe(P, !0), ce(P)) : (H(P, "Forward-slash in opening tag not followed by >"), P.state = k.ATTRIB);
              continue;
            case k.ATTRIB:
              if (j(h, S))
                continue;
              S === ">" ? pe(P) : S === "/" ? P.state = k.OPEN_TAG_SLASH : j(x, S) ? (P.attribName = S, P.attribValue = "", P.state = k.ATTRIB_NAME) : H(P, "Invalid attribute name");
              continue;
            case k.ATTRIB_NAME:
              S === "=" ? P.state = k.ATTRIB_VALUE : S === ">" ? (H(P, "Attribute without value"), P.attribValue = P.attribName, ge(P), pe(P)) : j(h, S) ? P.state = k.ATTRIB_NAME_SAW_WHITE : j(T, S) ? P.attribName += S : H(P, "Invalid attribute name");
              continue;
            case k.ATTRIB_NAME_SAW_WHITE:
              if (S === "=")
                P.state = k.ATTRIB_VALUE;
              else {
                if (j(h, S))
                  continue;
                H(P, "Attribute without value"), P.tag.attributes[P.attribName] = "", P.attribValue = "", W(P, "onattribute", {
                  name: P.attribName,
                  value: ""
                }), P.attribName = "", S === ">" ? pe(P) : j(x, S) ? (P.attribName = S, P.state = k.ATTRIB_NAME) : (H(P, "Invalid attribute name"), P.state = k.ATTRIB);
              }
              continue;
            case k.ATTRIB_VALUE:
              if (j(h, S))
                continue;
              j(y, S) ? (P.q = S, P.state = k.ATTRIB_VALUE_QUOTED) : (H(P, "Unquoted attribute value"), P.state = k.ATTRIB_VALUE_UNQUOTED, P.attribValue = S);
              continue;
            case k.ATTRIB_VALUE_QUOTED:
              if (S !== P.q) {
                S === "&" ? P.state = k.ATTRIB_VALUE_ENTITY_Q : P.attribValue += S;
                continue;
              }
              ge(P), P.q = "", P.state = k.ATTRIB_VALUE_CLOSED;
              continue;
            case k.ATTRIB_VALUE_CLOSED:
              j(h, S) ? P.state = k.ATTRIB : S === ">" ? pe(P) : S === "/" ? P.state = k.OPEN_TAG_SLASH : j(x, S) ? (H(P, "No whitespace between attributes"), P.attribName = S, P.attribValue = "", P.state = k.ATTRIB_NAME) : H(P, "Invalid attribute name");
              continue;
            case k.ATTRIB_VALUE_UNQUOTED:
              if (C(m, S)) {
                S === "&" ? P.state = k.ATTRIB_VALUE_ENTITY_U : P.attribValue += S;
                continue;
              }
              ge(P), S === ">" ? pe(P) : P.state = k.ATTRIB;
              continue;
            case k.CLOSE_TAG:
              if (P.tagName)
                S === ">" ? ce(P) : j(T, S) ? P.tagName += S : P.script ? (P.script += "</" + P.tagName, P.tagName = "", P.state = k.SCRIPT) : (C(h, S) && H(P, "Invalid tagname in closing tag"), P.state = k.CLOSE_TAG_SAW_WHITE);
              else {
                if (j(h, S))
                  continue;
                C(x, S) ? P.script ? (P.script += "</" + S, P.state = k.SCRIPT) : H(P, "Invalid tagname in closing tag.") : P.tagName = S;
              }
              continue;
            case k.CLOSE_TAG_SAW_WHITE:
              if (j(h, S))
                continue;
              S === ">" ? ce(P) : H(P, "Invalid characters in closing tag");
              continue;
            case k.TEXT_ENTITY:
            case k.ATTRIB_VALUE_ENTITY_Q:
            case k.ATTRIB_VALUE_ENTITY_U:
              var te, ee;
              switch (P.state) {
                case k.TEXT_ENTITY:
                  te = k.TEXT, ee = "textNode";
                  break;
                case k.ATTRIB_VALUE_ENTITY_Q:
                  te = k.ATTRIB_VALUE_QUOTED, ee = "attribValue";
                  break;
                case k.ATTRIB_VALUE_ENTITY_U:
                  te = k.ATTRIB_VALUE_UNQUOTED, ee = "attribValue";
                  break;
              }
              S === ";" ? (P[ee] += oe(P), P.entity = "", P.state = te) : j(P.entity.length ? U : E, S) ? P.entity += S : (H(P, "Invalid character in entity name"), P[ee] += "&" + P.entity + S, P.entity = "", P.state = te);
              continue;
            default:
              throw new Error(P, "Unknown state: " + P.state);
          }
        return P.position >= P.bufferCheckPosition && r(P), P;
      }
      /*! http://mths.be/fromcodepoint v0.1.0 by @mathias */
      String.fromCodePoint || (function() {
        var F = String.fromCharCode, P = Math.floor, ne = function() {
          var S = 16384, he = [], ae, te, ee = -1, ve = arguments.length;
          if (!ve)
            return "";
          for (var Ee = ""; ++ee < ve; ) {
            var Se = Number(arguments[ee]);
            if (!isFinite(Se) || // `NaN`, `+Infinity`, or `-Infinity`
            Se < 0 || // not a valid Unicode code point
            Se > 1114111 || // not a valid Unicode code point
            P(Se) !== Se)
              throw RangeError("Invalid code point: " + Se);
            Se <= 65535 ? he.push(Se) : (Se -= 65536, ae = (Se >> 10) + 55296, te = Se % 1024 + 56320, he.push(ae, te)), (ee + 1 === ve || he.length > S) && (Ee += F.apply(null, he), he.length = 0);
          }
          return Ee;
        };
        Object.defineProperty ? Object.defineProperty(String, "fromCodePoint", {
          value: ne,
          configurable: !0,
          writable: !0
        }) : String.fromCodePoint = ne;
      })();
    })(n);
  })(oh)), oh;
}
var ix;
function Pk() {
  if (ix) return sh;
  ix = 1;
  var n = ur(), e = Lk(), t = Pt, i = IE(), r = i.Element;
  sh.readString = a;
  function a(o, u) {
    u = u || {};
    var c = !1, l = e.parser(!0, { xmlns: !0, position: !1 }), h = { children: [] }, f = h, d = [], y = n.defer();
    l.onopentag = function(b) {
      var p = s(b.attributes, function(v) {
        return v.value;
      }, m), g = new r(m(b), p);
      f.children.push(g), d.push(f), f = g;
    };
    function m(b) {
      if (b.uri) {
        var p = u[b.uri], g;
        return p ? g = p + ":" : g = "{" + b.uri + "}", g + b.local;
      } else
        return b.local;
    }
    return l.onclosetag = function(b) {
      f = d.pop();
    }, l.ontext = function(b) {
      f !== h && f.children.push(i.text(b));
    }, l.onend = function() {
      c || (c = !0, y.resolve(h.children[0]));
    }, l.onerror = function(b) {
      c || (c = !0, y.reject(b));
    }, l.write(o).close(), y.promise;
  }
  function s(o, u, c) {
    return t.reduce(o, function(l, h, f) {
      var d = c(h, f, o);
      return l[d] = u(h, f, o), l;
    }, {});
  }
  return sh;
}
var Ch = {}, xr = {}, di = {}, rx;
function cr() {
  return rx || (rx = 1, (function() {
    var n, e, t, i, r, a, s, o = [].slice, u = {}.hasOwnProperty;
    n = function() {
      var c, l, h, f, d, y;
      if (y = arguments[0], d = 2 <= arguments.length ? o.call(arguments, 1) : [], r(Object.assign))
        Object.assign.apply(null, arguments);
      else
        for (c = 0, h = d.length; c < h; c++)
          if (f = d[c], f != null)
            for (l in f)
              u.call(f, l) && (y[l] = f[l]);
      return y;
    }, r = function(c) {
      return !!c && Object.prototype.toString.call(c) === "[object Function]";
    }, a = function(c) {
      var l;
      return !!c && ((l = typeof c) == "function" || l === "object");
    }, t = function(c) {
      return r(Array.isArray) ? Array.isArray(c) : Object.prototype.toString.call(c) === "[object Array]";
    }, i = function(c) {
      var l;
      if (t(c))
        return !c.length;
      for (l in c)
        if (u.call(c, l))
          return !1;
      return !0;
    }, s = function(c) {
      var l, h;
      return a(c) && (h = Object.getPrototypeOf(c)) && (l = h.constructor) && typeof l == "function" && l instanceof l && Function.prototype.toString.call(l) === Function.prototype.toString.call(Object);
    }, e = function(c) {
      return r(c.valueOf) ? c.valueOf() : c;
    }, di.assign = n, di.isFunction = r, di.isObject = a, di.isArray = t, di.isEmpty = i, di.isPlainObject = s, di.getValue = e;
  }).call(di)), di;
}
var Su = { exports: {} }, Cu = { exports: {} }, Au = { exports: {} }, ku = { exports: {} }, Fk = ku.exports, ax;
function NE() {
  return ax || (ax = 1, (function() {
    ku.exports = (function() {
      function n(e, t, i) {
        if (this.options = e.options, this.stringify = e.stringify, this.parent = e, t == null)
          throw new Error("Missing attribute name. " + this.debugInfo(t));
        if (i == null)
          throw new Error("Missing attribute value. " + this.debugInfo(t));
        this.name = this.stringify.attName(t), this.value = this.stringify.attValue(i);
      }
      return n.prototype.clone = function() {
        return Object.create(this);
      }, n.prototype.toString = function(e) {
        return this.options.writer.set(e).attribute(this);
      }, n.prototype.debugInfo = function(e) {
        return e = e || this.name, e == null ? "parent: <" + this.parent.name + ">" : "attribute: {" + e + "}, parent: <" + this.parent.name + ">";
      }, n;
    })();
  }).call(Fk)), ku.exports;
}
var Nk = Au.exports, sx;
function Xc() {
  return sx || (sx = 1, (function() {
    var n, e, t, i, r, a, s = function(u, c) {
      for (var l in c)
        o.call(c, l) && (u[l] = c[l]);
      function h() {
        this.constructor = u;
      }
      return h.prototype = c.prototype, u.prototype = new h(), u.__super__ = c.prototype, u;
    }, o = {}.hasOwnProperty;
    a = cr(), r = a.isObject, i = a.isFunction, t = a.getValue, e = yn(), n = NE(), Au.exports = (function(u) {
      s(c, u);
      function c(l, h, f) {
        if (c.__super__.constructor.call(this, l), h == null)
          throw new Error("Missing element name. " + this.debugInfo());
        this.name = this.stringify.eleName(h), this.attributes = {}, f != null && this.attribute(f), l.isDocument && (this.isRoot = !0, this.documentObject = l, l.rootObject = this);
      }
      return c.prototype.clone = function() {
        var l, h, f, d;
        f = Object.create(this), f.isRoot && (f.documentObject = null), f.attributes = {}, d = this.attributes;
        for (h in d)
          o.call(d, h) && (l = d[h], f.attributes[h] = l.clone());
        return f.children = [], this.children.forEach(function(y) {
          var m;
          return m = y.clone(), m.parent = f, f.children.push(m);
        }), f;
      }, c.prototype.attribute = function(l, h) {
        var f, d;
        if (l != null && (l = t(l)), r(l))
          for (f in l)
            o.call(l, f) && (d = l[f], this.attribute(f, d));
        else
          i(h) && (h = h.apply()), (!this.options.skipNullAttributes || h != null) && (this.attributes[l] = new n(this, l, h));
        return this;
      }, c.prototype.removeAttribute = function(l) {
        var h, f, d;
        if (l == null)
          throw new Error("Missing attribute name. " + this.debugInfo());
        if (l = t(l), Array.isArray(l))
          for (f = 0, d = l.length; f < d; f++)
            h = l[f], delete this.attributes[h];
        else
          delete this.attributes[l];
        return this;
      }, c.prototype.toString = function(l) {
        return this.options.writer.set(l).element(this);
      }, c.prototype.att = function(l, h) {
        return this.attribute(l, h);
      }, c.prototype.a = function(l, h) {
        return this.attribute(l, h);
      }, c;
    })(e);
  }).call(Nk)), Au.exports;
}
var Iu = { exports: {} }, Mk = Iu.exports, ox;
function Kc() {
  return ox || (ox = 1, (function() {
    var n, e = function(i, r) {
      for (var a in r)
        t.call(r, a) && (i[a] = r[a]);
      function s() {
        this.constructor = i;
      }
      return s.prototype = r.prototype, i.prototype = new s(), i.__super__ = r.prototype, i;
    }, t = {}.hasOwnProperty;
    n = yn(), Iu.exports = (function(i) {
      e(r, i);
      function r(a, s) {
        if (r.__super__.constructor.call(this, a), s == null)
          throw new Error("Missing CDATA text. " + this.debugInfo());
        this.text = this.stringify.cdata(s);
      }
      return r.prototype.clone = function() {
        return Object.create(this);
      }, r.prototype.toString = function(a) {
        return this.options.writer.set(a).cdata(this);
      }, r;
    })(n);
  }).call(Mk)), Iu.exports;
}
var Uu = { exports: {} }, Bk = Uu.exports, ux;
function Yc() {
  return ux || (ux = 1, (function() {
    var n, e = function(i, r) {
      for (var a in r)
        t.call(r, a) && (i[a] = r[a]);
      function s() {
        this.constructor = i;
      }
      return s.prototype = r.prototype, i.prototype = new s(), i.__super__ = r.prototype, i;
    }, t = {}.hasOwnProperty;
    n = yn(), Uu.exports = (function(i) {
      e(r, i);
      function r(a, s) {
        if (r.__super__.constructor.call(this, a), s == null)
          throw new Error("Missing comment text. " + this.debugInfo());
        this.text = this.stringify.comment(s);
      }
      return r.prototype.clone = function() {
        return Object.create(this);
      }, r.prototype.toString = function(a) {
        return this.options.writer.set(a).comment(this);
      }, r;
    })(n);
  }).call(Bk)), Uu.exports;
}
var Ru = { exports: {} }, jk = Ru.exports, cx;
function Qc() {
  return cx || (cx = 1, (function() {
    var n, e, t = function(r, a) {
      for (var s in a)
        i.call(a, s) && (r[s] = a[s]);
      function o() {
        this.constructor = r;
      }
      return o.prototype = a.prototype, r.prototype = new o(), r.__super__ = a.prototype, r;
    }, i = {}.hasOwnProperty;
    e = cr().isObject, n = yn(), Ru.exports = (function(r) {
      t(a, r);
      function a(s, o, u, c) {
        var l;
        a.__super__.constructor.call(this, s), e(o) && (l = o, o = l.version, u = l.encoding, c = l.standalone), o || (o = "1.0"), this.version = this.stringify.xmlVersion(o), u != null && (this.encoding = this.stringify.xmlEncoding(u)), c != null && (this.standalone = this.stringify.xmlStandalone(c));
      }
      return a.prototype.toString = function(s) {
        return this.options.writer.set(s).declaration(this);
      }, a;
    })(n);
  }).call(jk)), Ru.exports;
}
var Ou = { exports: {} }, Lu = { exports: {} }, qk = Lu.exports, lx;
function Zc() {
  return lx || (lx = 1, (function() {
    var n, e = function(i, r) {
      for (var a in r)
        t.call(r, a) && (i[a] = r[a]);
      function s() {
        this.constructor = i;
      }
      return s.prototype = r.prototype, i.prototype = new s(), i.__super__ = r.prototype, i;
    }, t = {}.hasOwnProperty;
    n = yn(), Lu.exports = (function(i) {
      e(r, i);
      function r(a, s, o, u, c, l) {
        if (r.__super__.constructor.call(this, a), s == null)
          throw new Error("Missing DTD element name. " + this.debugInfo());
        if (o == null)
          throw new Error("Missing DTD attribute name. " + this.debugInfo(s));
        if (!u)
          throw new Error("Missing DTD attribute type. " + this.debugInfo(s));
        if (!c)
          throw new Error("Missing DTD attribute default. " + this.debugInfo(s));
        if (c.indexOf("#") !== 0 && (c = "#" + c), !c.match(/^(#REQUIRED|#IMPLIED|#FIXED|#DEFAULT)$/))
          throw new Error("Invalid default value type; expected: #REQUIRED, #IMPLIED, #FIXED or #DEFAULT. " + this.debugInfo(s));
        if (l && !c.match(/^(#FIXED|#DEFAULT)$/))
          throw new Error("Default value only applies to #FIXED or #DEFAULT. " + this.debugInfo(s));
        this.elementName = this.stringify.eleName(s), this.attributeName = this.stringify.attName(o), this.attributeType = this.stringify.dtdAttType(u), this.defaultValue = this.stringify.dtdAttDefault(l), this.defaultValueType = c;
      }
      return r.prototype.toString = function(a) {
        return this.options.writer.set(a).dtdAttList(this);
      }, r;
    })(n);
  }).call(qk)), Lu.exports;
}
var Pu = { exports: {} }, Wk = Pu.exports, dx;
function Jc() {
  return dx || (dx = 1, (function() {
    var n, e, t = function(r, a) {
      for (var s in a)
        i.call(a, s) && (r[s] = a[s]);
      function o() {
        this.constructor = r;
      }
      return o.prototype = a.prototype, r.prototype = new o(), r.__super__ = a.prototype, r;
    }, i = {}.hasOwnProperty;
    e = cr().isObject, n = yn(), Pu.exports = (function(r) {
      t(a, r);
      function a(s, o, u, c) {
        if (a.__super__.constructor.call(this, s), u == null)
          throw new Error("Missing DTD entity name. " + this.debugInfo(u));
        if (c == null)
          throw new Error("Missing DTD entity value. " + this.debugInfo(u));
        if (this.pe = !!o, this.name = this.stringify.eleName(u), !e(c))
          this.value = this.stringify.dtdEntityValue(c);
        else {
          if (!c.pubID && !c.sysID)
            throw new Error("Public and/or system identifiers are required for an external entity. " + this.debugInfo(u));
          if (c.pubID && !c.sysID)
            throw new Error("System identifier is required for a public external entity. " + this.debugInfo(u));
          if (c.pubID != null && (this.pubID = this.stringify.dtdPubID(c.pubID)), c.sysID != null && (this.sysID = this.stringify.dtdSysID(c.sysID)), c.nData != null && (this.nData = this.stringify.dtdNData(c.nData)), this.pe && this.nData)
            throw new Error("Notation declaration is not allowed in a parameter entity. " + this.debugInfo(u));
        }
      }
      return a.prototype.toString = function(s) {
        return this.options.writer.set(s).dtdEntity(this);
      }, a;
    })(n);
  }).call(Wk)), Pu.exports;
}
var Fu = { exports: {} }, Vk = Fu.exports, fx;
function el() {
  return fx || (fx = 1, (function() {
    var n, e = function(i, r) {
      for (var a in r)
        t.call(r, a) && (i[a] = r[a]);
      function s() {
        this.constructor = i;
      }
      return s.prototype = r.prototype, i.prototype = new s(), i.__super__ = r.prototype, i;
    }, t = {}.hasOwnProperty;
    n = yn(), Fu.exports = (function(i) {
      e(r, i);
      function r(a, s, o) {
        if (r.__super__.constructor.call(this, a), s == null)
          throw new Error("Missing DTD element name. " + this.debugInfo());
        o || (o = "(#PCDATA)"), Array.isArray(o) && (o = "(" + o.join(",") + ")"), this.name = this.stringify.eleName(s), this.value = this.stringify.dtdElementValue(o);
      }
      return r.prototype.toString = function(a) {
        return this.options.writer.set(a).dtdElement(this);
      }, r;
    })(n);
  }).call(Vk)), Fu.exports;
}
var Nu = { exports: {} }, Hk = Nu.exports, hx;
function tl() {
  return hx || (hx = 1, (function() {
    var n, e = function(i, r) {
      for (var a in r)
        t.call(r, a) && (i[a] = r[a]);
      function s() {
        this.constructor = i;
      }
      return s.prototype = r.prototype, i.prototype = new s(), i.__super__ = r.prototype, i;
    }, t = {}.hasOwnProperty;
    n = yn(), Nu.exports = (function(i) {
      e(r, i);
      function r(a, s, o) {
        if (r.__super__.constructor.call(this, a), s == null)
          throw new Error("Missing DTD notation name. " + this.debugInfo(s));
        if (!o.pubID && !o.sysID)
          throw new Error("Public or system identifiers are required for an external entity. " + this.debugInfo(s));
        this.name = this.stringify.eleName(s), o.pubID != null && (this.pubID = this.stringify.dtdPubID(o.pubID)), o.sysID != null && (this.sysID = this.stringify.dtdSysID(o.sysID));
      }
      return r.prototype.toString = function(a) {
        return this.options.writer.set(a).dtdNotation(this);
      }, r;
    })(n);
  }).call(Hk)), Nu.exports;
}
var zk = Ou.exports, px;
function nl() {
  return px || (px = 1, (function() {
    var n, e, t, i, r, a, s = function(u, c) {
      for (var l in c)
        o.call(c, l) && (u[l] = c[l]);
      function h() {
        this.constructor = u;
      }
      return h.prototype = c.prototype, u.prototype = new h(), u.__super__ = c.prototype, u;
    }, o = {}.hasOwnProperty;
    a = cr().isObject, r = yn(), n = Zc(), t = Jc(), e = el(), i = tl(), Ou.exports = (function(u) {
      s(c, u);
      function c(l, h, f) {
        var d, y;
        c.__super__.constructor.call(this, l), this.name = "!DOCTYPE", this.documentObject = l, a(h) && (d = h, h = d.pubID, f = d.sysID), f == null && (y = [h, f], f = y[0], h = y[1]), h != null && (this.pubID = this.stringify.dtdPubID(h)), f != null && (this.sysID = this.stringify.dtdSysID(f));
      }
      return c.prototype.element = function(l, h) {
        var f;
        return f = new e(this, l, h), this.children.push(f), this;
      }, c.prototype.attList = function(l, h, f, d, y) {
        var m;
        return m = new n(this, l, h, f, d, y), this.children.push(m), this;
      }, c.prototype.entity = function(l, h) {
        var f;
        return f = new t(this, !1, l, h), this.children.push(f), this;
      }, c.prototype.pEntity = function(l, h) {
        var f;
        return f = new t(this, !0, l, h), this.children.push(f), this;
      }, c.prototype.notation = function(l, h) {
        var f;
        return f = new i(this, l, h), this.children.push(f), this;
      }, c.prototype.toString = function(l) {
        return this.options.writer.set(l).docType(this);
      }, c.prototype.ele = function(l, h) {
        return this.element(l, h);
      }, c.prototype.att = function(l, h, f, d, y) {
        return this.attList(l, h, f, d, y);
      }, c.prototype.ent = function(l, h) {
        return this.entity(l, h);
      }, c.prototype.pent = function(l, h) {
        return this.pEntity(l, h);
      }, c.prototype.not = function(l, h) {
        return this.notation(l, h);
      }, c.prototype.up = function() {
        return this.root() || this.documentObject;
      }, c;
    })(r);
  }).call(zk)), Ou.exports;
}
var Mu = { exports: {} }, $k = Mu.exports, mx;
function il() {
  return mx || (mx = 1, (function() {
    var n, e = function(i, r) {
      for (var a in r)
        t.call(r, a) && (i[a] = r[a]);
      function s() {
        this.constructor = i;
      }
      return s.prototype = r.prototype, i.prototype = new s(), i.__super__ = r.prototype, i;
    }, t = {}.hasOwnProperty;
    n = yn(), Mu.exports = (function(i) {
      e(r, i);
      function r(a, s) {
        if (r.__super__.constructor.call(this, a), s == null)
          throw new Error("Missing raw text. " + this.debugInfo());
        this.value = this.stringify.raw(s);
      }
      return r.prototype.clone = function() {
        return Object.create(this);
      }, r.prototype.toString = function(a) {
        return this.options.writer.set(a).raw(this);
      }, r;
    })(n);
  }).call($k)), Mu.exports;
}
var Bu = { exports: {} }, Gk = Bu.exports, gx;
function rl() {
  return gx || (gx = 1, (function() {
    var n, e = function(i, r) {
      for (var a in r)
        t.call(r, a) && (i[a] = r[a]);
      function s() {
        this.constructor = i;
      }
      return s.prototype = r.prototype, i.prototype = new s(), i.__super__ = r.prototype, i;
    }, t = {}.hasOwnProperty;
    n = yn(), Bu.exports = (function(i) {
      e(r, i);
      function r(a, s) {
        if (r.__super__.constructor.call(this, a), s == null)
          throw new Error("Missing element text. " + this.debugInfo());
        this.value = this.stringify.eleText(s);
      }
      return r.prototype.clone = function() {
        return Object.create(this);
      }, r.prototype.toString = function(a) {
        return this.options.writer.set(a).text(this);
      }, r;
    })(n);
  }).call(Gk)), Bu.exports;
}
var ju = { exports: {} }, Xk = ju.exports, bx;
function al() {
  return bx || (bx = 1, (function() {
    var n, e = function(i, r) {
      for (var a in r)
        t.call(r, a) && (i[a] = r[a]);
      function s() {
        this.constructor = i;
      }
      return s.prototype = r.prototype, i.prototype = new s(), i.__super__ = r.prototype, i;
    }, t = {}.hasOwnProperty;
    n = yn(), ju.exports = (function(i) {
      e(r, i);
      function r(a, s, o) {
        if (r.__super__.constructor.call(this, a), s == null)
          throw new Error("Missing instruction target. " + this.debugInfo());
        this.target = this.stringify.insTarget(s), o && (this.value = this.stringify.insValue(o));
      }
      return r.prototype.clone = function() {
        return Object.create(this);
      }, r.prototype.toString = function(a) {
        return this.options.writer.set(a).processingInstruction(this);
      }, r;
    })(n);
  }).call(Xk)), ju.exports;
}
var qu = { exports: {} }, Kk = qu.exports, yx;
function Ng() {
  return yx || (yx = 1, (function() {
    var n, e = function(i, r) {
      for (var a in r)
        t.call(r, a) && (i[a] = r[a]);
      function s() {
        this.constructor = i;
      }
      return s.prototype = r.prototype, i.prototype = new s(), i.__super__ = r.prototype, i;
    }, t = {}.hasOwnProperty;
    n = yn(), qu.exports = (function(i) {
      e(r, i);
      function r(a) {
        r.__super__.constructor.call(this, a), this.isDummy = !0;
      }
      return r.prototype.clone = function() {
        return Object.create(this);
      }, r.prototype.toString = function(a) {
        return "";
      }, r;
    })(n);
  }).call(Kk)), qu.exports;
}
var Yk = Cu.exports, vx;
function yn() {
  return vx || (vx = 1, (function() {
    var n, e, t, i, r, a, s, o, u, c, l, h, f, d, y = {}.hasOwnProperty;
    d = cr(), f = d.isObject, h = d.isFunction, l = d.isEmpty, c = d.getValue, a = null, n = null, e = null, t = null, i = null, o = null, u = null, s = null, r = null, Cu.exports = (function() {
      function m(b) {
        this.parent = b, this.parent && (this.options = this.parent.options, this.stringify = this.parent.stringify), this.children = [], a || (a = Xc(), n = Kc(), e = Yc(), t = Qc(), i = nl(), o = il(), u = rl(), s = al(), r = Ng());
      }
      return m.prototype.element = function(b, p, g) {
        var v, _, x, T, E, U, D, L, j, C, k;
        if (U = null, p === null && g == null && (j = [{}, null], p = j[0], g = j[1]), p == null && (p = {}), p = c(p), f(p) || (C = [p, g], g = C[0], p = C[1]), b != null && (b = c(b)), Array.isArray(b))
          for (x = 0, D = b.length; x < D; x++)
            _ = b[x], U = this.element(_);
        else if (h(b))
          U = this.element(b.apply());
        else if (f(b)) {
          for (E in b)
            if (y.call(b, E))
              if (k = b[E], h(k) && (k = k.apply()), f(k) && l(k) && (k = null), !this.options.ignoreDecorators && this.stringify.convertAttKey && E.indexOf(this.stringify.convertAttKey) === 0)
                U = this.attribute(E.substr(this.stringify.convertAttKey.length), k);
              else if (!this.options.separateArrayItems && Array.isArray(k))
                for (T = 0, L = k.length; T < L; T++)
                  _ = k[T], v = {}, v[E] = _, U = this.element(v);
              else f(k) ? (U = this.element(E), U.element(k)) : U = this.element(E, k);
        } else this.options.skipNullNodes && g === null ? U = this.dummy() : !this.options.ignoreDecorators && this.stringify.convertTextKey && b.indexOf(this.stringify.convertTextKey) === 0 ? U = this.text(g) : !this.options.ignoreDecorators && this.stringify.convertCDataKey && b.indexOf(this.stringify.convertCDataKey) === 0 ? U = this.cdata(g) : !this.options.ignoreDecorators && this.stringify.convertCommentKey && b.indexOf(this.stringify.convertCommentKey) === 0 ? U = this.comment(g) : !this.options.ignoreDecorators && this.stringify.convertRawKey && b.indexOf(this.stringify.convertRawKey) === 0 ? U = this.raw(g) : !this.options.ignoreDecorators && this.stringify.convertPIKey && b.indexOf(this.stringify.convertPIKey) === 0 ? U = this.instruction(b.substr(this.stringify.convertPIKey.length), g) : U = this.node(b, p, g);
        if (U == null)
          throw new Error("Could not create any elements with: " + b + ". " + this.debugInfo());
        return U;
      }, m.prototype.insertBefore = function(b, p, g) {
        var v, _, x;
        if (this.isRoot)
          throw new Error("Cannot insert elements at root level. " + this.debugInfo(b));
        return _ = this.parent.children.indexOf(this), x = this.parent.children.splice(_), v = this.parent.element(b, p, g), Array.prototype.push.apply(this.parent.children, x), v;
      }, m.prototype.insertAfter = function(b, p, g) {
        var v, _, x;
        if (this.isRoot)
          throw new Error("Cannot insert elements at root level. " + this.debugInfo(b));
        return _ = this.parent.children.indexOf(this), x = this.parent.children.splice(_ + 1), v = this.parent.element(b, p, g), Array.prototype.push.apply(this.parent.children, x), v;
      }, m.prototype.remove = function() {
        var b;
        if (this.isRoot)
          throw new Error("Cannot remove the root element. " + this.debugInfo());
        return b = this.parent.children.indexOf(this), [].splice.apply(this.parent.children, [b, b - b + 1].concat([])), this.parent;
      }, m.prototype.node = function(b, p, g) {
        var v, _;
        return b != null && (b = c(b)), p || (p = {}), p = c(p), f(p) || (_ = [p, g], g = _[0], p = _[1]), v = new a(this, b, p), g != null && v.text(g), this.children.push(v), v;
      }, m.prototype.text = function(b) {
        var p;
        return p = new u(this, b), this.children.push(p), this;
      }, m.prototype.cdata = function(b) {
        var p;
        return p = new n(this, b), this.children.push(p), this;
      }, m.prototype.comment = function(b) {
        var p;
        return p = new e(this, b), this.children.push(p), this;
      }, m.prototype.commentBefore = function(b) {
        var p, g;
        return p = this.parent.children.indexOf(this), g = this.parent.children.splice(p), this.parent.comment(b), Array.prototype.push.apply(this.parent.children, g), this;
      }, m.prototype.commentAfter = function(b) {
        var p, g;
        return p = this.parent.children.indexOf(this), g = this.parent.children.splice(p + 1), this.parent.comment(b), Array.prototype.push.apply(this.parent.children, g), this;
      }, m.prototype.raw = function(b) {
        var p;
        return p = new o(this, b), this.children.push(p), this;
      }, m.prototype.dummy = function() {
        var b;
        return b = new r(this), this.children.push(b), b;
      }, m.prototype.instruction = function(b, p) {
        var g, v, _, x, T;
        if (b != null && (b = c(b)), p != null && (p = c(p)), Array.isArray(b))
          for (x = 0, T = b.length; x < T; x++)
            g = b[x], this.instruction(g);
        else if (f(b))
          for (g in b)
            y.call(b, g) && (v = b[g], this.instruction(g, v));
        else
          h(p) && (p = p.apply()), _ = new s(this, b, p), this.children.push(_);
        return this;
      }, m.prototype.instructionBefore = function(b, p) {
        var g, v;
        return g = this.parent.children.indexOf(this), v = this.parent.children.splice(g), this.parent.instruction(b, p), Array.prototype.push.apply(this.parent.children, v), this;
      }, m.prototype.instructionAfter = function(b, p) {
        var g, v;
        return g = this.parent.children.indexOf(this), v = this.parent.children.splice(g + 1), this.parent.instruction(b, p), Array.prototype.push.apply(this.parent.children, v), this;
      }, m.prototype.declaration = function(b, p, g) {
        var v, _;
        return v = this.document(), _ = new t(v, b, p, g), v.children[0] instanceof t ? v.children[0] = _ : v.children.unshift(_), v.root() || v;
      }, m.prototype.doctype = function(b, p) {
        var g, v, _, x, T, E, U, D, L, j;
        for (v = this.document(), _ = new i(v, b, p), L = v.children, x = T = 0, U = L.length; T < U; x = ++T)
          if (g = L[x], g instanceof i)
            return v.children[x] = _, _;
        for (j = v.children, x = E = 0, D = j.length; E < D; x = ++E)
          if (g = j[x], g.isRoot)
            return v.children.splice(x, 0, _), _;
        return v.children.push(_), _;
      }, m.prototype.up = function() {
        if (this.isRoot)
          throw new Error("The root node has no parent. Use doc() if you need to get the document object.");
        return this.parent;
      }, m.prototype.root = function() {
        var b;
        for (b = this; b; ) {
          if (b.isDocument)
            return b.rootObject;
          if (b.isRoot)
            return b;
          b = b.parent;
        }
      }, m.prototype.document = function() {
        var b;
        for (b = this; b; ) {
          if (b.isDocument)
            return b;
          b = b.parent;
        }
      }, m.prototype.end = function(b) {
        return this.document().end(b);
      }, m.prototype.prev = function() {
        var b;
        for (b = this.parent.children.indexOf(this); b > 0 && this.parent.children[b - 1].isDummy; )
          b = b - 1;
        if (b < 1)
          throw new Error("Already at the first node. " + this.debugInfo());
        return this.parent.children[b - 1];
      }, m.prototype.next = function() {
        var b;
        for (b = this.parent.children.indexOf(this); b < this.parent.children.length - 1 && this.parent.children[b + 1].isDummy; )
          b = b + 1;
        if (b === -1 || b === this.parent.children.length - 1)
          throw new Error("Already at the last node. " + this.debugInfo());
        return this.parent.children[b + 1];
      }, m.prototype.importDocument = function(b) {
        var p;
        return p = b.root().clone(), p.parent = this, p.isRoot = !1, this.children.push(p), this;
      }, m.prototype.debugInfo = function(b) {
        var p, g;
        return b = b || this.name, b == null && !((p = this.parent) != null && p.name) ? "" : b == null ? "parent: <" + this.parent.name + ">" : (g = this.parent) != null && g.name ? "node: <" + b + ">, parent: <" + this.parent.name + ">" : "node: <" + b + ">";
      }, m.prototype.ele = function(b, p, g) {
        return this.element(b, p, g);
      }, m.prototype.nod = function(b, p, g) {
        return this.node(b, p, g);
      }, m.prototype.txt = function(b) {
        return this.text(b);
      }, m.prototype.dat = function(b) {
        return this.cdata(b);
      }, m.prototype.com = function(b) {
        return this.comment(b);
      }, m.prototype.ins = function(b, p) {
        return this.instruction(b, p);
      }, m.prototype.doc = function() {
        return this.document();
      }, m.prototype.dec = function(b, p, g) {
        return this.declaration(b, p, g);
      }, m.prototype.dtd = function(b, p) {
        return this.doctype(b, p);
      }, m.prototype.e = function(b, p, g) {
        return this.element(b, p, g);
      }, m.prototype.n = function(b, p, g) {
        return this.node(b, p, g);
      }, m.prototype.t = function(b) {
        return this.text(b);
      }, m.prototype.d = function(b) {
        return this.cdata(b);
      }, m.prototype.c = function(b) {
        return this.comment(b);
      }, m.prototype.r = function(b) {
        return this.raw(b);
      }, m.prototype.i = function(b, p) {
        return this.instruction(b, p);
      }, m.prototype.u = function() {
        return this.up();
      }, m.prototype.importXMLBuilder = function(b) {
        return this.importDocument(b);
      }, m;
    })();
  }).call(Yk)), Cu.exports;
}
var Wu = { exports: {} }, Qk = Wu.exports, xx;
function ME() {
  return xx || (xx = 1, (function() {
    var n = function(t, i) {
      return function() {
        return t.apply(i, arguments);
      };
    }, e = {}.hasOwnProperty;
    Wu.exports = (function() {
      function t(i) {
        this.assertLegalChar = n(this.assertLegalChar, this);
        var r, a, s;
        i || (i = {}), this.noDoubleEncoding = i.noDoubleEncoding, a = i.stringify || {};
        for (r in a)
          e.call(a, r) && (s = a[r], this[r] = s);
      }
      return t.prototype.eleName = function(i) {
        return i = "" + i || "", this.assertLegalChar(i);
      }, t.prototype.eleText = function(i) {
        return i = "" + i || "", this.assertLegalChar(this.elEscape(i));
      }, t.prototype.cdata = function(i) {
        return i = "" + i || "", i = i.replace("]]>", "]]]]><![CDATA[>"), this.assertLegalChar(i);
      }, t.prototype.comment = function(i) {
        if (i = "" + i || "", i.match(/--/))
          throw new Error("Comment text cannot contain double-hypen: " + i);
        return this.assertLegalChar(i);
      }, t.prototype.raw = function(i) {
        return "" + i || "";
      }, t.prototype.attName = function(i) {
        return i = "" + i || "";
      }, t.prototype.attValue = function(i) {
        return i = "" + i || "", this.attEscape(i);
      }, t.prototype.insTarget = function(i) {
        return "" + i || "";
      }, t.prototype.insValue = function(i) {
        if (i = "" + i || "", i.match(/\?>/))
          throw new Error("Invalid processing instruction value: " + i);
        return i;
      }, t.prototype.xmlVersion = function(i) {
        if (i = "" + i || "", !i.match(/1\.[0-9]+/))
          throw new Error("Invalid version number: " + i);
        return i;
      }, t.prototype.xmlEncoding = function(i) {
        if (i = "" + i || "", !i.match(/^[A-Za-z](?:[A-Za-z0-9._-])*$/))
          throw new Error("Invalid encoding: " + i);
        return i;
      }, t.prototype.xmlStandalone = function(i) {
        return i ? "yes" : "no";
      }, t.prototype.dtdPubID = function(i) {
        return "" + i || "";
      }, t.prototype.dtdSysID = function(i) {
        return "" + i || "";
      }, t.prototype.dtdElementValue = function(i) {
        return "" + i || "";
      }, t.prototype.dtdAttType = function(i) {
        return "" + i || "";
      }, t.prototype.dtdAttDefault = function(i) {
        return i != null ? "" + i || "" : i;
      }, t.prototype.dtdEntityValue = function(i) {
        return "" + i || "";
      }, t.prototype.dtdNData = function(i) {
        return "" + i || "";
      }, t.prototype.convertAttKey = "@", t.prototype.convertPIKey = "?", t.prototype.convertTextKey = "#text", t.prototype.convertCDataKey = "#cdata", t.prototype.convertCommentKey = "#comment", t.prototype.convertRawKey = "#raw", t.prototype.assertLegalChar = function(i) {
        var r;
        if (r = i.match(/[\0\uFFFE\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/), r)
          throw new Error("Invalid character in string: " + i + " at index " + r.index);
        return i;
      }, t.prototype.elEscape = function(i) {
        var r;
        return r = this.noDoubleEncoding ? /(?!&\S+;)&/g : /&/g, i.replace(r, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/\r/g, "&#xD;");
      }, t.prototype.attEscape = function(i) {
        var r;
        return r = this.noDoubleEncoding ? /(?!&\S+;)&/g : /&/g, i.replace(r, "&amp;").replace(/</g, "&lt;").replace(/"/g, "&quot;").replace(/\t/g, "&#x9;").replace(/\n/g, "&#xA;").replace(/\r/g, "&#xD;");
      }, t;
    })();
  }).call(Qk)), Wu.exports;
}
var Vu = { exports: {} }, Hu = { exports: {} }, Zk = Hu.exports, _x;
function BE() {
  return _x || (_x = 1, (function() {
    var n = {}.hasOwnProperty;
    Hu.exports = (function() {
      function e(t) {
        var i, r, a, s, o, u, c, l, h;
        t || (t = {}), this.pretty = t.pretty || !1, this.allowEmpty = (r = t.allowEmpty) != null ? r : !1, this.pretty ? (this.indent = (a = t.indent) != null ? a : "  ", this.newline = (s = t.newline) != null ? s : `
`, this.offset = (o = t.offset) != null ? o : 0, this.dontprettytextnodes = (u = t.dontprettytextnodes) != null ? u : 0) : (this.indent = "", this.newline = "", this.offset = 0, this.dontprettytextnodes = 0), this.spacebeforeslash = (c = t.spacebeforeslash) != null ? c : "", this.spacebeforeslash === !0 && (this.spacebeforeslash = " "), this.newlinedefault = this.newline, this.prettydefault = this.pretty, l = t.writer || {};
        for (i in l)
          n.call(l, i) && (h = l[i], this[i] = h);
      }
      return e.prototype.set = function(t) {
        var i, r, a;
        t || (t = {}), "pretty" in t && (this.pretty = t.pretty), "allowEmpty" in t && (this.allowEmpty = t.allowEmpty), this.pretty ? (this.indent = "indent" in t ? t.indent : "  ", this.newline = "newline" in t ? t.newline : `
`, this.offset = "offset" in t ? t.offset : 0, this.dontprettytextnodes = "dontprettytextnodes" in t ? t.dontprettytextnodes : 0) : (this.indent = "", this.newline = "", this.offset = 0, this.dontprettytextnodes = 0), this.spacebeforeslash = "spacebeforeslash" in t ? t.spacebeforeslash : "", this.spacebeforeslash === !0 && (this.spacebeforeslash = " "), this.newlinedefault = this.newline, this.prettydefault = this.pretty, r = t.writer || {};
        for (i in r)
          n.call(r, i) && (a = r[i], this[i] = a);
        return this;
      }, e.prototype.space = function(t) {
        var i;
        return this.pretty ? (i = (t || 0) + this.offset + 1, i > 0 ? new Array(i).join(this.indent) : "") : "";
      }, e;
    })();
  }).call(Zk)), Hu.exports;
}
var Jk = Vu.exports, Tx;
function Mg() {
  return Tx || (Tx = 1, (function() {
    var n, e, t, i, r, a, s, o, u, c, l, h, f, d, y = function(b, p) {
      for (var g in p)
        m.call(p, g) && (b[g] = p[g]);
      function v() {
        this.constructor = b;
      }
      return v.prototype = p.prototype, b.prototype = new v(), b.__super__ = p.prototype, b;
    }, m = {}.hasOwnProperty;
    s = Qc(), o = nl(), n = Kc(), e = Yc(), c = Xc(), h = il(), f = rl(), l = al(), u = Ng(), t = Zc(), i = el(), r = Jc(), a = tl(), d = BE(), Vu.exports = (function(b) {
      y(p, b);
      function p(g) {
        p.__super__.constructor.call(this, g);
      }
      return p.prototype.document = function(g) {
        var v, _, x, T, E;
        for (this.textispresent = !1, T = "", E = g.children, _ = 0, x = E.length; _ < x; _++)
          v = E[_], !(v instanceof u) && (T += (function() {
            switch (!1) {
              case !(v instanceof s):
                return this.declaration(v);
              case !(v instanceof o):
                return this.docType(v);
              case !(v instanceof e):
                return this.comment(v);
              case !(v instanceof l):
                return this.processingInstruction(v);
              default:
                return this.element(v, 0);
            }
          }).call(this));
        return this.pretty && T.slice(-this.newline.length) === this.newline && (T = T.slice(0, -this.newline.length)), T;
      }, p.prototype.attribute = function(g) {
        return " " + g.name + '="' + g.value + '"';
      }, p.prototype.cdata = function(g, v) {
        return this.space(v) + "<![CDATA[" + g.text + "]]>" + this.newline;
      }, p.prototype.comment = function(g, v) {
        return this.space(v) + "<!-- " + g.text + " -->" + this.newline;
      }, p.prototype.declaration = function(g, v) {
        var _;
        return _ = this.space(v), _ += '<?xml version="' + g.version + '"', g.encoding != null && (_ += ' encoding="' + g.encoding + '"'), g.standalone != null && (_ += ' standalone="' + g.standalone + '"'), _ += this.spacebeforeslash + "?>", _ += this.newline, _;
      }, p.prototype.docType = function(g, v) {
        var _, x, T, E, U;
        if (v || (v = 0), E = this.space(v), E += "<!DOCTYPE " + g.root().name, g.pubID && g.sysID ? E += ' PUBLIC "' + g.pubID + '" "' + g.sysID + '"' : g.sysID && (E += ' SYSTEM "' + g.sysID + '"'), g.children.length > 0) {
          for (E += " [", E += this.newline, U = g.children, x = 0, T = U.length; x < T; x++)
            _ = U[x], E += (function() {
              switch (!1) {
                case !(_ instanceof t):
                  return this.dtdAttList(_, v + 1);
                case !(_ instanceof i):
                  return this.dtdElement(_, v + 1);
                case !(_ instanceof r):
                  return this.dtdEntity(_, v + 1);
                case !(_ instanceof a):
                  return this.dtdNotation(_, v + 1);
                case !(_ instanceof n):
                  return this.cdata(_, v + 1);
                case !(_ instanceof e):
                  return this.comment(_, v + 1);
                case !(_ instanceof l):
                  return this.processingInstruction(_, v + 1);
                default:
                  throw new Error("Unknown DTD node type: " + _.constructor.name);
              }
            }).call(this);
          E += "]";
        }
        return E += this.spacebeforeslash + ">", E += this.newline, E;
      }, p.prototype.element = function(g, v) {
        var _, x, T, E, U, D, L, j, C, k, I, $, W;
        v || (v = 0), W = !1, this.textispresent ? (this.newline = "", this.pretty = !1) : (this.newline = this.newlinedefault, this.pretty = this.prettydefault), $ = this.space(v), j = "", j += $ + "<" + g.name, C = g.attributes;
        for (L in C)
          m.call(C, L) && (_ = C[L], j += this.attribute(_));
        if (g.children.length === 0 || g.children.every(function(B) {
          return B.value === "";
        }))
          this.allowEmpty ? j += "></" + g.name + ">" + this.newline : j += this.spacebeforeslash + "/>" + this.newline;
        else if (this.pretty && g.children.length === 1 && g.children[0].value != null)
          j += ">", j += g.children[0].value, j += "</" + g.name + ">" + this.newline;
        else {
          if (this.dontprettytextnodes) {
            for (k = g.children, T = 0, U = k.length; T < U; T++)
              if (x = k[T], x.value != null) {
                this.textispresent++, W = !0;
                break;
              }
          }
          for (this.textispresent && (this.newline = "", this.pretty = !1, $ = this.space(v)), j += ">" + this.newline, I = g.children, E = 0, D = I.length; E < D; E++)
            x = I[E], j += (function() {
              switch (!1) {
                case !(x instanceof n):
                  return this.cdata(x, v + 1);
                case !(x instanceof e):
                  return this.comment(x, v + 1);
                case !(x instanceof c):
                  return this.element(x, v + 1);
                case !(x instanceof h):
                  return this.raw(x, v + 1);
                case !(x instanceof f):
                  return this.text(x, v + 1);
                case !(x instanceof l):
                  return this.processingInstruction(x, v + 1);
                case !(x instanceof u):
                  return "";
                default:
                  throw new Error("Unknown XML node type: " + x.constructor.name);
              }
            }).call(this);
          W && this.textispresent--, this.textispresent || (this.newline = this.newlinedefault, this.pretty = this.prettydefault), j += $ + "</" + g.name + ">" + this.newline;
        }
        return j;
      }, p.prototype.processingInstruction = function(g, v) {
        var _;
        return _ = this.space(v) + "<?" + g.target, g.value && (_ += " " + g.value), _ += this.spacebeforeslash + "?>" + this.newline, _;
      }, p.prototype.raw = function(g, v) {
        return this.space(v) + g.value + this.newline;
      }, p.prototype.text = function(g, v) {
        return this.space(v) + g.value + this.newline;
      }, p.prototype.dtdAttList = function(g, v) {
        var _;
        return _ = this.space(v) + "<!ATTLIST " + g.elementName + " " + g.attributeName + " " + g.attributeType, g.defaultValueType !== "#DEFAULT" && (_ += " " + g.defaultValueType), g.defaultValue && (_ += ' "' + g.defaultValue + '"'), _ += this.spacebeforeslash + ">" + this.newline, _;
      }, p.prototype.dtdElement = function(g, v) {
        return this.space(v) + "<!ELEMENT " + g.name + " " + g.value + this.spacebeforeslash + ">" + this.newline;
      }, p.prototype.dtdEntity = function(g, v) {
        var _;
        return _ = this.space(v) + "<!ENTITY", g.pe && (_ += " %"), _ += " " + g.name, g.value ? _ += ' "' + g.value + '"' : (g.pubID && g.sysID ? _ += ' PUBLIC "' + g.pubID + '" "' + g.sysID + '"' : g.sysID && (_ += ' SYSTEM "' + g.sysID + '"'), g.nData && (_ += " NDATA " + g.nData)), _ += this.spacebeforeslash + ">" + this.newline, _;
      }, p.prototype.dtdNotation = function(g, v) {
        var _;
        return _ = this.space(v) + "<!NOTATION " + g.name, g.pubID && g.sysID ? _ += ' PUBLIC "' + g.pubID + '" "' + g.sysID + '"' : g.pubID ? _ += ' PUBLIC "' + g.pubID + '"' : g.sysID && (_ += ' SYSTEM "' + g.sysID + '"'), _ += this.spacebeforeslash + ">" + this.newline, _;
      }, p.prototype.openNode = function(g, v) {
        var _, x, T, E;
        if (v || (v = 0), g instanceof c) {
          T = this.space(v) + "<" + g.name, E = g.attributes;
          for (x in E)
            m.call(E, x) && (_ = E[x], T += this.attribute(_));
          return T += (g.children ? ">" : "/>") + this.newline, T;
        } else
          return T = this.space(v) + "<!DOCTYPE " + g.rootNodeName, g.pubID && g.sysID ? T += ' PUBLIC "' + g.pubID + '" "' + g.sysID + '"' : g.sysID && (T += ' SYSTEM "' + g.sysID + '"'), T += (g.children ? " [" : ">") + this.newline, T;
      }, p.prototype.closeNode = function(g, v) {
        switch (v || (v = 0), !1) {
          case !(g instanceof c):
            return this.space(v) + "</" + g.name + ">" + this.newline;
          case !(g instanceof o):
            return this.space(v) + "]>" + this.newline;
        }
      }, p;
    })(d);
  }).call(Jk)), Vu.exports;
}
var e5 = Su.exports, wx;
function t5() {
  return wx || (wx = 1, (function() {
    var n, e, t, i, r = function(s, o) {
      for (var u in o)
        a.call(o, u) && (s[u] = o[u]);
      function c() {
        this.constructor = s;
      }
      return c.prototype = o.prototype, s.prototype = new c(), s.__super__ = o.prototype, s;
    }, a = {}.hasOwnProperty;
    i = cr().isPlainObject, n = yn(), t = ME(), e = Mg(), Su.exports = (function(s) {
      r(o, s);
      function o(u) {
        o.__super__.constructor.call(this, null), this.name = "?xml", u || (u = {}), u.writer || (u.writer = new e()), this.options = u, this.stringify = new t(u), this.isDocument = !0;
      }
      return o.prototype.end = function(u) {
        var c;
        return u ? i(u) && (c = u, u = this.options.writer.set(c)) : u = this.options.writer, u.document(this);
      }, o.prototype.toString = function(u) {
        return this.options.writer.set(u).document(this);
      }, o;
    })(n);
  }).call(e5)), Su.exports;
}
var zu = { exports: {} }, n5 = zu.exports, Ex;
function i5() {
  return Ex || (Ex = 1, (function() {
    var n, e, t, i, r, a, s, o, u, c, l, h, f, d, y, m, b, p, g, v, _ = {}.hasOwnProperty;
    v = cr(), p = v.isObject, b = v.isFunction, g = v.isPlainObject, m = v.getValue, c = Xc(), e = Kc(), t = Yc(), h = il(), y = rl(), l = al(), o = Qc(), u = nl(), i = Zc(), a = Jc(), r = el(), s = tl(), n = NE(), d = ME(), f = Mg(), zu.exports = (function() {
      function x(T, E, U) {
        var D;
        this.name = "?xml", T || (T = {}), T.writer ? g(T.writer) && (D = T.writer, T.writer = new f(D)) : T.writer = new f(T), this.options = T, this.writer = T.writer, this.stringify = new d(T), this.onDataCallback = E || function() {
        }, this.onEndCallback = U || function() {
        }, this.currentNode = null, this.currentLevel = -1, this.openTags = {}, this.documentStarted = !1, this.documentCompleted = !1, this.root = null;
      }
      return x.prototype.node = function(T, E, U) {
        var D, L;
        if (T == null)
          throw new Error("Missing node name.");
        if (this.root && this.currentLevel === -1)
          throw new Error("Document can only have one root node. " + this.debugInfo(T));
        return this.openCurrent(), T = m(T), E === null && U == null && (D = [{}, null], E = D[0], U = D[1]), E == null && (E = {}), E = m(E), p(E) || (L = [E, U], U = L[0], E = L[1]), this.currentNode = new c(this, T, E), this.currentNode.children = !1, this.currentLevel++, this.openTags[this.currentLevel] = this.currentNode, U != null && this.text(U), this;
      }, x.prototype.element = function(T, E, U) {
        return this.currentNode && this.currentNode instanceof u ? this.dtdElement.apply(this, arguments) : this.node(T, E, U);
      }, x.prototype.attribute = function(T, E) {
        var U, D;
        if (!this.currentNode || this.currentNode.children)
          throw new Error("att() can only be used immediately after an ele() call in callback mode. " + this.debugInfo(T));
        if (T != null && (T = m(T)), p(T))
          for (U in T)
            _.call(T, U) && (D = T[U], this.attribute(U, D));
        else
          b(E) && (E = E.apply()), (!this.options.skipNullAttributes || E != null) && (this.currentNode.attributes[T] = new n(this, T, E));
        return this;
      }, x.prototype.text = function(T) {
        var E;
        return this.openCurrent(), E = new y(this, T), this.onData(this.writer.text(E, this.currentLevel + 1), this.currentLevel + 1), this;
      }, x.prototype.cdata = function(T) {
        var E;
        return this.openCurrent(), E = new e(this, T), this.onData(this.writer.cdata(E, this.currentLevel + 1), this.currentLevel + 1), this;
      }, x.prototype.comment = function(T) {
        var E;
        return this.openCurrent(), E = new t(this, T), this.onData(this.writer.comment(E, this.currentLevel + 1), this.currentLevel + 1), this;
      }, x.prototype.raw = function(T) {
        var E;
        return this.openCurrent(), E = new h(this, T), this.onData(this.writer.raw(E, this.currentLevel + 1), this.currentLevel + 1), this;
      }, x.prototype.instruction = function(T, E) {
        var U, D, L, j, C;
        if (this.openCurrent(), T != null && (T = m(T)), E != null && (E = m(E)), Array.isArray(T))
          for (U = 0, j = T.length; U < j; U++)
            D = T[U], this.instruction(D);
        else if (p(T))
          for (D in T)
            _.call(T, D) && (L = T[D], this.instruction(D, L));
        else
          b(E) && (E = E.apply()), C = new l(this, T, E), this.onData(this.writer.processingInstruction(C, this.currentLevel + 1), this.currentLevel + 1);
        return this;
      }, x.prototype.declaration = function(T, E, U) {
        var D;
        if (this.openCurrent(), this.documentStarted)
          throw new Error("declaration() must be the first node.");
        return D = new o(this, T, E, U), this.onData(this.writer.declaration(D, this.currentLevel + 1), this.currentLevel + 1), this;
      }, x.prototype.doctype = function(T, E, U) {
        if (this.openCurrent(), T == null)
          throw new Error("Missing root node name.");
        if (this.root)
          throw new Error("dtd() must come before the root node.");
        return this.currentNode = new u(this, E, U), this.currentNode.rootNodeName = T, this.currentNode.children = !1, this.currentLevel++, this.openTags[this.currentLevel] = this.currentNode, this;
      }, x.prototype.dtdElement = function(T, E) {
        var U;
        return this.openCurrent(), U = new r(this, T, E), this.onData(this.writer.dtdElement(U, this.currentLevel + 1), this.currentLevel + 1), this;
      }, x.prototype.attList = function(T, E, U, D, L) {
        var j;
        return this.openCurrent(), j = new i(this, T, E, U, D, L), this.onData(this.writer.dtdAttList(j, this.currentLevel + 1), this.currentLevel + 1), this;
      }, x.prototype.entity = function(T, E) {
        var U;
        return this.openCurrent(), U = new a(this, !1, T, E), this.onData(this.writer.dtdEntity(U, this.currentLevel + 1), this.currentLevel + 1), this;
      }, x.prototype.pEntity = function(T, E) {
        var U;
        return this.openCurrent(), U = new a(this, !0, T, E), this.onData(this.writer.dtdEntity(U, this.currentLevel + 1), this.currentLevel + 1), this;
      }, x.prototype.notation = function(T, E) {
        var U;
        return this.openCurrent(), U = new s(this, T, E), this.onData(this.writer.dtdNotation(U, this.currentLevel + 1), this.currentLevel + 1), this;
      }, x.prototype.up = function() {
        if (this.currentLevel < 0)
          throw new Error("The document node has no parent.");
        return this.currentNode ? (this.currentNode.children ? this.closeNode(this.currentNode) : this.openNode(this.currentNode), this.currentNode = null) : this.closeNode(this.openTags[this.currentLevel]), delete this.openTags[this.currentLevel], this.currentLevel--, this;
      }, x.prototype.end = function() {
        for (; this.currentLevel >= 0; )
          this.up();
        return this.onEnd();
      }, x.prototype.openCurrent = function() {
        if (this.currentNode)
          return this.currentNode.children = !0, this.openNode(this.currentNode);
      }, x.prototype.openNode = function(T) {
        if (!T.isOpen)
          return !this.root && this.currentLevel === 0 && T instanceof c && (this.root = T), this.onData(this.writer.openNode(T, this.currentLevel), this.currentLevel), T.isOpen = !0;
      }, x.prototype.closeNode = function(T) {
        if (!T.isClosed)
          return this.onData(this.writer.closeNode(T, this.currentLevel), this.currentLevel), T.isClosed = !0;
      }, x.prototype.onData = function(T, E) {
        return this.documentStarted = !0, this.onDataCallback(T, E + 1);
      }, x.prototype.onEnd = function() {
        return this.documentCompleted = !0, this.onEndCallback();
      }, x.prototype.debugInfo = function(T) {
        return T == null ? "" : "node: <" + T + ">";
      }, x.prototype.ele = function() {
        return this.element.apply(this, arguments);
      }, x.prototype.nod = function(T, E, U) {
        return this.node(T, E, U);
      }, x.prototype.txt = function(T) {
        return this.text(T);
      }, x.prototype.dat = function(T) {
        return this.cdata(T);
      }, x.prototype.com = function(T) {
        return this.comment(T);
      }, x.prototype.ins = function(T, E) {
        return this.instruction(T, E);
      }, x.prototype.dec = function(T, E, U) {
        return this.declaration(T, E, U);
      }, x.prototype.dtd = function(T, E, U) {
        return this.doctype(T, E, U);
      }, x.prototype.e = function(T, E, U) {
        return this.element(T, E, U);
      }, x.prototype.n = function(T, E, U) {
        return this.node(T, E, U);
      }, x.prototype.t = function(T) {
        return this.text(T);
      }, x.prototype.d = function(T) {
        return this.cdata(T);
      }, x.prototype.c = function(T) {
        return this.comment(T);
      }, x.prototype.r = function(T) {
        return this.raw(T);
      }, x.prototype.i = function(T, E) {
        return this.instruction(T, E);
      }, x.prototype.att = function() {
        return this.currentNode && this.currentNode instanceof u ? this.attList.apply(this, arguments) : this.attribute.apply(this, arguments);
      }, x.prototype.a = function() {
        return this.currentNode && this.currentNode instanceof u ? this.attList.apply(this, arguments) : this.attribute.apply(this, arguments);
      }, x.prototype.ent = function(T, E) {
        return this.entity(T, E);
      }, x.prototype.pent = function(T, E) {
        return this.pEntity(T, E);
      }, x.prototype.not = function(T, E) {
        return this.notation(T, E);
      }, x;
    })();
  }).call(n5)), zu.exports;
}
var $u = { exports: {} }, r5 = $u.exports, Dx;
function a5() {
  return Dx || (Dx = 1, (function() {
    var n, e, t, i, r, a, s, o, u, c, l, h, f, d, y = function(b, p) {
      for (var g in p)
        m.call(p, g) && (b[g] = p[g]);
      function v() {
        this.constructor = b;
      }
      return v.prototype = p.prototype, b.prototype = new v(), b.__super__ = p.prototype, b;
    }, m = {}.hasOwnProperty;
    s = Qc(), o = nl(), n = Kc(), e = Yc(), c = Xc(), h = il(), f = rl(), l = al(), u = Ng(), t = Zc(), i = el(), r = Jc(), a = tl(), d = BE(), $u.exports = (function(b) {
      y(p, b);
      function p(g, v) {
        p.__super__.constructor.call(this, v), this.stream = g;
      }
      return p.prototype.document = function(g) {
        var v, _, x, T, E, U, D, L;
        for (U = g.children, _ = 0, T = U.length; _ < T; _++)
          v = U[_], v.isLastRootNode = !1;
        for (g.children[g.children.length - 1].isLastRootNode = !0, D = g.children, L = [], x = 0, E = D.length; x < E; x++)
          if (v = D[x], !(v instanceof u))
            switch (!1) {
              case !(v instanceof s):
                L.push(this.declaration(v));
                break;
              case !(v instanceof o):
                L.push(this.docType(v));
                break;
              case !(v instanceof e):
                L.push(this.comment(v));
                break;
              case !(v instanceof l):
                L.push(this.processingInstruction(v));
                break;
              default:
                L.push(this.element(v));
            }
        return L;
      }, p.prototype.attribute = function(g) {
        return this.stream.write(" " + g.name + '="' + g.value + '"');
      }, p.prototype.cdata = function(g, v) {
        return this.stream.write(this.space(v) + "<![CDATA[" + g.text + "]]>" + this.endline(g));
      }, p.prototype.comment = function(g, v) {
        return this.stream.write(this.space(v) + "<!-- " + g.text + " -->" + this.endline(g));
      }, p.prototype.declaration = function(g, v) {
        return this.stream.write(this.space(v)), this.stream.write('<?xml version="' + g.version + '"'), g.encoding != null && this.stream.write(' encoding="' + g.encoding + '"'), g.standalone != null && this.stream.write(' standalone="' + g.standalone + '"'), this.stream.write(this.spacebeforeslash + "?>"), this.stream.write(this.endline(g));
      }, p.prototype.docType = function(g, v) {
        var _, x, T, E;
        if (v || (v = 0), this.stream.write(this.space(v)), this.stream.write("<!DOCTYPE " + g.root().name), g.pubID && g.sysID ? this.stream.write(' PUBLIC "' + g.pubID + '" "' + g.sysID + '"') : g.sysID && this.stream.write(' SYSTEM "' + g.sysID + '"'), g.children.length > 0) {
          for (this.stream.write(" ["), this.stream.write(this.endline(g)), E = g.children, x = 0, T = E.length; x < T; x++)
            switch (_ = E[x], !1) {
              case !(_ instanceof t):
                this.dtdAttList(_, v + 1);
                break;
              case !(_ instanceof i):
                this.dtdElement(_, v + 1);
                break;
              case !(_ instanceof r):
                this.dtdEntity(_, v + 1);
                break;
              case !(_ instanceof a):
                this.dtdNotation(_, v + 1);
                break;
              case !(_ instanceof n):
                this.cdata(_, v + 1);
                break;
              case !(_ instanceof e):
                this.comment(_, v + 1);
                break;
              case !(_ instanceof l):
                this.processingInstruction(_, v + 1);
                break;
              default:
                throw new Error("Unknown DTD node type: " + _.constructor.name);
            }
          this.stream.write("]");
        }
        return this.stream.write(this.spacebeforeslash + ">"), this.stream.write(this.endline(g));
      }, p.prototype.element = function(g, v) {
        var _, x, T, E, U, D, L, j;
        v || (v = 0), j = this.space(v), this.stream.write(j + "<" + g.name), D = g.attributes;
        for (U in D)
          m.call(D, U) && (_ = D[U], this.attribute(_));
        if (g.children.length === 0 || g.children.every(function(C) {
          return C.value === "";
        }))
          this.allowEmpty ? this.stream.write("></" + g.name + ">") : this.stream.write(this.spacebeforeslash + "/>");
        else if (this.pretty && g.children.length === 1 && g.children[0].value != null)
          this.stream.write(">"), this.stream.write(g.children[0].value), this.stream.write("</" + g.name + ">");
        else {
          for (this.stream.write(">" + this.newline), L = g.children, T = 0, E = L.length; T < E; T++)
            switch (x = L[T], !1) {
              case !(x instanceof n):
                this.cdata(x, v + 1);
                break;
              case !(x instanceof e):
                this.comment(x, v + 1);
                break;
              case !(x instanceof c):
                this.element(x, v + 1);
                break;
              case !(x instanceof h):
                this.raw(x, v + 1);
                break;
              case !(x instanceof f):
                this.text(x, v + 1);
                break;
              case !(x instanceof l):
                this.processingInstruction(x, v + 1);
                break;
              case !(x instanceof u):
                break;
              default:
                throw new Error("Unknown XML node type: " + x.constructor.name);
            }
          this.stream.write(j + "</" + g.name + ">");
        }
        return this.stream.write(this.endline(g));
      }, p.prototype.processingInstruction = function(g, v) {
        return this.stream.write(this.space(v) + "<?" + g.target), g.value && this.stream.write(" " + g.value), this.stream.write(this.spacebeforeslash + "?>" + this.endline(g));
      }, p.prototype.raw = function(g, v) {
        return this.stream.write(this.space(v) + g.value + this.endline(g));
      }, p.prototype.text = function(g, v) {
        return this.stream.write(this.space(v) + g.value + this.endline(g));
      }, p.prototype.dtdAttList = function(g, v) {
        return this.stream.write(this.space(v) + "<!ATTLIST " + g.elementName + " " + g.attributeName + " " + g.attributeType), g.defaultValueType !== "#DEFAULT" && this.stream.write(" " + g.defaultValueType), g.defaultValue && this.stream.write(' "' + g.defaultValue + '"'), this.stream.write(this.spacebeforeslash + ">" + this.endline(g));
      }, p.prototype.dtdElement = function(g, v) {
        return this.stream.write(this.space(v) + "<!ELEMENT " + g.name + " " + g.value), this.stream.write(this.spacebeforeslash + ">" + this.endline(g));
      }, p.prototype.dtdEntity = function(g, v) {
        return this.stream.write(this.space(v) + "<!ENTITY"), g.pe && this.stream.write(" %"), this.stream.write(" " + g.name), g.value ? this.stream.write(' "' + g.value + '"') : (g.pubID && g.sysID ? this.stream.write(' PUBLIC "' + g.pubID + '" "' + g.sysID + '"') : g.sysID && this.stream.write(' SYSTEM "' + g.sysID + '"'), g.nData && this.stream.write(" NDATA " + g.nData)), this.stream.write(this.spacebeforeslash + ">" + this.endline(g));
      }, p.prototype.dtdNotation = function(g, v) {
        return this.stream.write(this.space(v) + "<!NOTATION " + g.name), g.pubID && g.sysID ? this.stream.write(' PUBLIC "' + g.pubID + '" "' + g.sysID + '"') : g.pubID ? this.stream.write(' PUBLIC "' + g.pubID + '"') : g.sysID && this.stream.write(' SYSTEM "' + g.sysID + '"'), this.stream.write(this.spacebeforeslash + ">" + this.endline(g));
      }, p.prototype.endline = function(g) {
        return g.isLastRootNode ? "" : this.newline;
      }, p;
    })(d);
  }).call(r5)), $u.exports;
}
var Sx;
function s5() {
  return Sx || (Sx = 1, (function() {
    var n, e, t, i, r, a, s;
    s = cr(), r = s.assign, a = s.isFunction, n = t5(), e = i5(), i = Mg(), t = a5(), xr.create = function(o, u, c, l) {
      var h, f;
      if (o == null)
        throw new Error("Root element needs a name.");
      return l = r({}, u, c, l), h = new n(l), f = h.element(o), l.headless || (h.declaration(l), (l.pubID != null || l.sysID != null) && h.doctype(l)), f;
    }, xr.begin = function(o, u, c) {
      var l;
      return a(o) && (l = [o, u], u = l[0], c = l[1], o = {}), u ? new e(o, u, c) : new n(o);
    }, xr.stringWriter = function(o) {
      return new i(o);
    }, xr.streamWriter = function(o, u) {
      return new t(o, u);
    };
  }).call(xr)), xr;
}
var Cx;
function o5() {
  if (Cx) return Ch;
  Cx = 1;
  var n = Pt, e = s5();
  Ch.writeString = t;
  function t(r, a) {
    var s = n.invert(a), o = {
      element: c,
      text: i
    };
    function u(f, d) {
      return o[d.type](f, d);
    }
    function c(f, d) {
      var y = f.element(l(d.name), d.attributes);
      d.children.forEach(function(m) {
        u(y, m);
      });
    }
    function l(f) {
      var d = /^\{(.*)\}(.*)$/.exec(f);
      if (d) {
        var y = s[d[1]];
        return y + (y === "" ? "" : ":") + d[2];
      } else
        return f;
    }
    function h(f) {
      var d = e.create(l(f.name), {
        version: "1.0",
        encoding: "UTF-8",
        standalone: !0
      });
      return n.forEach(a, function(y, m) {
        var b = "xmlns" + (m === "" ? "" : ":" + m);
        d.attribute(b, y);
      }), f.children.forEach(function(y) {
        u(d, y);
      }), d.end();
    }
    return h(r);
  }
  function i(r, a) {
    r.text(a.value);
  }
  return Ch;
}
var Ax;
function jE() {
  if (Ax) return vr;
  Ax = 1;
  var n = IE();
  return vr.Element = n.Element, vr.element = n.element, vr.text = n.text, vr.readString = Pk().readString, vr.writeString = o5().writeString, vr;
}
var kx;
function u5() {
  if (kx) return iu;
  kx = 1;
  var n = Pt, e = ur(), t = jE();
  iu.read = r, iu.readXmlFromZipFile = a;
  var i = {
    "http://schemas.openxmlformats.org/wordprocessingml/2006/main": "w",
    "http://schemas.openxmlformats.org/officeDocument/2006/relationships": "r",
    "http://schemas.openxmlformats.org/drawingml/2006/wordprocessingDrawing": "wp",
    "http://schemas.openxmlformats.org/drawingml/2006/main": "a",
    "http://schemas.openxmlformats.org/drawingml/2006/picture": "pic",
    "http://schemas.openxmlformats.org/package/2006/content-types": "content-types",
    "urn:schemas-microsoft-com:vml": "v",
    "http://schemas.openxmlformats.org/markup-compatibility/2006": "mc",
    "urn:schemas-microsoft-com:office:word": "office-word"
  };
  function r(u) {
    return t.readString(u, i).then(function(c) {
      return o(c)[0];
    });
  }
  function a(u, c) {
    return u.exists(c) ? u.read(c, "utf-8").then(s).then(r) : e.resolve(null);
  }
  function s(u) {
    return u.replace(/^\uFEFF/g, "");
  }
  function o(u) {
    return u.type === "element" ? u.name === "mc:AlternateContent" ? u.first("mc:Fallback").children : (u.children = n.flatten(u.children.map(o, !0)), [u]) : [u];
  }
  return iu;
}
var cu = {}, Kn = {}, lu = {}, Ix;
function c5() {
  if (Ix) return lu;
  Ix = 1, Object.defineProperty(lu, "__esModule", { value: !0 });
  var n = [
    { "Typeface name": "Symbol", "Dingbat dec": "32", "Dingbat hex": "20", "Unicode dec": "32", "Unicode hex": "20" },
    { "Typeface name": "Symbol", "Dingbat dec": "33", "Dingbat hex": "21", "Unicode dec": "33", "Unicode hex": "21" },
    { "Typeface name": "Symbol", "Dingbat dec": "34", "Dingbat hex": "22", "Unicode dec": "8704", "Unicode hex": "2200" },
    { "Typeface name": "Symbol", "Dingbat dec": "35", "Dingbat hex": "23", "Unicode dec": "35", "Unicode hex": "23" },
    { "Typeface name": "Symbol", "Dingbat dec": "36", "Dingbat hex": "24", "Unicode dec": "8707", "Unicode hex": "2203" },
    { "Typeface name": "Symbol", "Dingbat dec": "37", "Dingbat hex": "25", "Unicode dec": "37", "Unicode hex": "25" },
    { "Typeface name": "Symbol", "Dingbat dec": "38", "Dingbat hex": "26", "Unicode dec": "38", "Unicode hex": "26" },
    { "Typeface name": "Symbol", "Dingbat dec": "39", "Dingbat hex": "27", "Unicode dec": "8717", "Unicode hex": "220D" },
    { "Typeface name": "Symbol", "Dingbat dec": "40", "Dingbat hex": "28", "Unicode dec": "40", "Unicode hex": "28" },
    { "Typeface name": "Symbol", "Dingbat dec": "41", "Dingbat hex": "29", "Unicode dec": "41", "Unicode hex": "29" },
    { "Typeface name": "Symbol", "Dingbat dec": "42", "Dingbat hex": "2A", "Unicode dec": "42", "Unicode hex": "2A" },
    { "Typeface name": "Symbol", "Dingbat dec": "43", "Dingbat hex": "2B", "Unicode dec": "43", "Unicode hex": "2B" },
    { "Typeface name": "Symbol", "Dingbat dec": "44", "Dingbat hex": "2C", "Unicode dec": "44", "Unicode hex": "2C" },
    { "Typeface name": "Symbol", "Dingbat dec": "45", "Dingbat hex": "2D", "Unicode dec": "8722", "Unicode hex": "2212" },
    { "Typeface name": "Symbol", "Dingbat dec": "46", "Dingbat hex": "2E", "Unicode dec": "46", "Unicode hex": "2E" },
    { "Typeface name": "Symbol", "Dingbat dec": "47", "Dingbat hex": "2F", "Unicode dec": "47", "Unicode hex": "2F" },
    { "Typeface name": "Symbol", "Dingbat dec": "48", "Dingbat hex": "30", "Unicode dec": "48", "Unicode hex": "30" },
    { "Typeface name": "Symbol", "Dingbat dec": "49", "Dingbat hex": "31", "Unicode dec": "49", "Unicode hex": "31" },
    { "Typeface name": "Symbol", "Dingbat dec": "50", "Dingbat hex": "32", "Unicode dec": "50", "Unicode hex": "32" },
    { "Typeface name": "Symbol", "Dingbat dec": "51", "Dingbat hex": "33", "Unicode dec": "51", "Unicode hex": "33" },
    { "Typeface name": "Symbol", "Dingbat dec": "52", "Dingbat hex": "34", "Unicode dec": "52", "Unicode hex": "34" },
    { "Typeface name": "Symbol", "Dingbat dec": "53", "Dingbat hex": "35", "Unicode dec": "53", "Unicode hex": "35" },
    { "Typeface name": "Symbol", "Dingbat dec": "54", "Dingbat hex": "36", "Unicode dec": "54", "Unicode hex": "36" },
    { "Typeface name": "Symbol", "Dingbat dec": "55", "Dingbat hex": "37", "Unicode dec": "55", "Unicode hex": "37" },
    { "Typeface name": "Symbol", "Dingbat dec": "56", "Dingbat hex": "38", "Unicode dec": "56", "Unicode hex": "38" },
    { "Typeface name": "Symbol", "Dingbat dec": "57", "Dingbat hex": "39", "Unicode dec": "57", "Unicode hex": "39" },
    { "Typeface name": "Symbol", "Dingbat dec": "58", "Dingbat hex": "3A", "Unicode dec": "58", "Unicode hex": "3A" },
    { "Typeface name": "Symbol", "Dingbat dec": "59", "Dingbat hex": "3B", "Unicode dec": "59", "Unicode hex": "3B" },
    { "Typeface name": "Symbol", "Dingbat dec": "60", "Dingbat hex": "3C", "Unicode dec": "60", "Unicode hex": "3C" },
    { "Typeface name": "Symbol", "Dingbat dec": "61", "Dingbat hex": "3D", "Unicode dec": "61", "Unicode hex": "3D" },
    { "Typeface name": "Symbol", "Dingbat dec": "62", "Dingbat hex": "3E", "Unicode dec": "62", "Unicode hex": "3E" },
    { "Typeface name": "Symbol", "Dingbat dec": "63", "Dingbat hex": "3F", "Unicode dec": "63", "Unicode hex": "3F" },
    { "Typeface name": "Symbol", "Dingbat dec": "64", "Dingbat hex": "40", "Unicode dec": "8773", "Unicode hex": "2245" },
    { "Typeface name": "Symbol", "Dingbat dec": "65", "Dingbat hex": "41", "Unicode dec": "913", "Unicode hex": "391" },
    { "Typeface name": "Symbol", "Dingbat dec": "66", "Dingbat hex": "42", "Unicode dec": "914", "Unicode hex": "392" },
    { "Typeface name": "Symbol", "Dingbat dec": "67", "Dingbat hex": "43", "Unicode dec": "935", "Unicode hex": "3A7" },
    { "Typeface name": "Symbol", "Dingbat dec": "68", "Dingbat hex": "44", "Unicode dec": "916", "Unicode hex": "394" },
    { "Typeface name": "Symbol", "Dingbat dec": "69", "Dingbat hex": "45", "Unicode dec": "917", "Unicode hex": "395" },
    { "Typeface name": "Symbol", "Dingbat dec": "70", "Dingbat hex": "46", "Unicode dec": "934", "Unicode hex": "3A6" },
    { "Typeface name": "Symbol", "Dingbat dec": "71", "Dingbat hex": "47", "Unicode dec": "915", "Unicode hex": "393" },
    { "Typeface name": "Symbol", "Dingbat dec": "72", "Dingbat hex": "48", "Unicode dec": "919", "Unicode hex": "397" },
    { "Typeface name": "Symbol", "Dingbat dec": "73", "Dingbat hex": "49", "Unicode dec": "921", "Unicode hex": "399" },
    { "Typeface name": "Symbol", "Dingbat dec": "74", "Dingbat hex": "4A", "Unicode dec": "977", "Unicode hex": "3D1" },
    { "Typeface name": "Symbol", "Dingbat dec": "75", "Dingbat hex": "4B", "Unicode dec": "922", "Unicode hex": "39A" },
    { "Typeface name": "Symbol", "Dingbat dec": "76", "Dingbat hex": "4C", "Unicode dec": "923", "Unicode hex": "39B" },
    { "Typeface name": "Symbol", "Dingbat dec": "77", "Dingbat hex": "4D", "Unicode dec": "924", "Unicode hex": "39C" },
    { "Typeface name": "Symbol", "Dingbat dec": "78", "Dingbat hex": "4E", "Unicode dec": "925", "Unicode hex": "39D" },
    { "Typeface name": "Symbol", "Dingbat dec": "79", "Dingbat hex": "4F", "Unicode dec": "927", "Unicode hex": "39F" },
    { "Typeface name": "Symbol", "Dingbat dec": "80", "Dingbat hex": "50", "Unicode dec": "928", "Unicode hex": "3A0" },
    { "Typeface name": "Symbol", "Dingbat dec": "81", "Dingbat hex": "51", "Unicode dec": "920", "Unicode hex": "398" },
    { "Typeface name": "Symbol", "Dingbat dec": "82", "Dingbat hex": "52", "Unicode dec": "929", "Unicode hex": "3A1" },
    { "Typeface name": "Symbol", "Dingbat dec": "83", "Dingbat hex": "53", "Unicode dec": "931", "Unicode hex": "3A3" },
    { "Typeface name": "Symbol", "Dingbat dec": "84", "Dingbat hex": "54", "Unicode dec": "932", "Unicode hex": "3A4" },
    { "Typeface name": "Symbol", "Dingbat dec": "85", "Dingbat hex": "55", "Unicode dec": "933", "Unicode hex": "3A5" },
    { "Typeface name": "Symbol", "Dingbat dec": "86", "Dingbat hex": "56", "Unicode dec": "962", "Unicode hex": "3C2" },
    { "Typeface name": "Symbol", "Dingbat dec": "87", "Dingbat hex": "57", "Unicode dec": "937", "Unicode hex": "3A9" },
    { "Typeface name": "Symbol", "Dingbat dec": "88", "Dingbat hex": "58", "Unicode dec": "926", "Unicode hex": "39E" },
    { "Typeface name": "Symbol", "Dingbat dec": "89", "Dingbat hex": "59", "Unicode dec": "936", "Unicode hex": "3A8" },
    { "Typeface name": "Symbol", "Dingbat dec": "90", "Dingbat hex": "5A", "Unicode dec": "918", "Unicode hex": "396" },
    { "Typeface name": "Symbol", "Dingbat dec": "91", "Dingbat hex": "5B", "Unicode dec": "91", "Unicode hex": "5B" },
    { "Typeface name": "Symbol", "Dingbat dec": "92", "Dingbat hex": "5C", "Unicode dec": "8756", "Unicode hex": "2234" },
    { "Typeface name": "Symbol", "Dingbat dec": "93", "Dingbat hex": "5D", "Unicode dec": "93", "Unicode hex": "5D" },
    { "Typeface name": "Symbol", "Dingbat dec": "94", "Dingbat hex": "5E", "Unicode dec": "8869", "Unicode hex": "22A5" },
    { "Typeface name": "Symbol", "Dingbat dec": "95", "Dingbat hex": "5F", "Unicode dec": "95", "Unicode hex": "5F" },
    { "Typeface name": "Symbol", "Dingbat dec": "96", "Dingbat hex": "60", "Unicode dec": "8254", "Unicode hex": "203E" },
    { "Typeface name": "Symbol", "Dingbat dec": "97", "Dingbat hex": "61", "Unicode dec": "945", "Unicode hex": "3B1" },
    { "Typeface name": "Symbol", "Dingbat dec": "98", "Dingbat hex": "62", "Unicode dec": "946", "Unicode hex": "3B2" },
    { "Typeface name": "Symbol", "Dingbat dec": "99", "Dingbat hex": "63", "Unicode dec": "967", "Unicode hex": "3C7" },
    { "Typeface name": "Symbol", "Dingbat dec": "100", "Dingbat hex": "64", "Unicode dec": "948", "Unicode hex": "3B4" },
    { "Typeface name": "Symbol", "Dingbat dec": "101", "Dingbat hex": "65", "Unicode dec": "949", "Unicode hex": "3B5" },
    { "Typeface name": "Symbol", "Dingbat dec": "102", "Dingbat hex": "66", "Unicode dec": "966", "Unicode hex": "3C6" },
    { "Typeface name": "Symbol", "Dingbat dec": "103", "Dingbat hex": "67", "Unicode dec": "947", "Unicode hex": "3B3" },
    { "Typeface name": "Symbol", "Dingbat dec": "104", "Dingbat hex": "68", "Unicode dec": "951", "Unicode hex": "3B7" },
    { "Typeface name": "Symbol", "Dingbat dec": "105", "Dingbat hex": "69", "Unicode dec": "953", "Unicode hex": "3B9" },
    { "Typeface name": "Symbol", "Dingbat dec": "106", "Dingbat hex": "6A", "Unicode dec": "981", "Unicode hex": "3D5" },
    { "Typeface name": "Symbol", "Dingbat dec": "107", "Dingbat hex": "6B", "Unicode dec": "954", "Unicode hex": "3BA" },
    { "Typeface name": "Symbol", "Dingbat dec": "108", "Dingbat hex": "6C", "Unicode dec": "955", "Unicode hex": "3BB" },
    { "Typeface name": "Symbol", "Dingbat dec": "109", "Dingbat hex": "6D", "Unicode dec": "956", "Unicode hex": "3BC" },
    { "Typeface name": "Symbol", "Dingbat dec": "110", "Dingbat hex": "6E", "Unicode dec": "957", "Unicode hex": "3BD" },
    { "Typeface name": "Symbol", "Dingbat dec": "111", "Dingbat hex": "6F", "Unicode dec": "959", "Unicode hex": "3BF" },
    { "Typeface name": "Symbol", "Dingbat dec": "112", "Dingbat hex": "70", "Unicode dec": "960", "Unicode hex": "3C0" },
    { "Typeface name": "Symbol", "Dingbat dec": "113", "Dingbat hex": "71", "Unicode dec": "952", "Unicode hex": "3B8" },
    { "Typeface name": "Symbol", "Dingbat dec": "114", "Dingbat hex": "72", "Unicode dec": "961", "Unicode hex": "3C1" },
    { "Typeface name": "Symbol", "Dingbat dec": "115", "Dingbat hex": "73", "Unicode dec": "963", "Unicode hex": "3C3" },
    { "Typeface name": "Symbol", "Dingbat dec": "116", "Dingbat hex": "74", "Unicode dec": "964", "Unicode hex": "3C4" },
    { "Typeface name": "Symbol", "Dingbat dec": "117", "Dingbat hex": "75", "Unicode dec": "965", "Unicode hex": "3C5" },
    { "Typeface name": "Symbol", "Dingbat dec": "118", "Dingbat hex": "76", "Unicode dec": "982", "Unicode hex": "3D6" },
    { "Typeface name": "Symbol", "Dingbat dec": "119", "Dingbat hex": "77", "Unicode dec": "969", "Unicode hex": "3C9" },
    { "Typeface name": "Symbol", "Dingbat dec": "120", "Dingbat hex": "78", "Unicode dec": "958", "Unicode hex": "3BE" },
    { "Typeface name": "Symbol", "Dingbat dec": "121", "Dingbat hex": "79", "Unicode dec": "968", "Unicode hex": "3C8" },
    { "Typeface name": "Symbol", "Dingbat dec": "122", "Dingbat hex": "7A", "Unicode dec": "950", "Unicode hex": "3B6" },
    { "Typeface name": "Symbol", "Dingbat dec": "123", "Dingbat hex": "7B", "Unicode dec": "123", "Unicode hex": "7B" },
    { "Typeface name": "Symbol", "Dingbat dec": "124", "Dingbat hex": "7C", "Unicode dec": "124", "Unicode hex": "7C" },
    { "Typeface name": "Symbol", "Dingbat dec": "125", "Dingbat hex": "7D", "Unicode dec": "125", "Unicode hex": "7D" },
    { "Typeface name": "Symbol", "Dingbat dec": "126", "Dingbat hex": "7E", "Unicode dec": "126", "Unicode hex": "7E" },
    { "Typeface name": "Symbol", "Dingbat dec": "160", "Dingbat hex": "A0", "Unicode dec": "8364", "Unicode hex": "20AC" },
    { "Typeface name": "Symbol", "Dingbat dec": "161", "Dingbat hex": "A1", "Unicode dec": "978", "Unicode hex": "3D2" },
    { "Typeface name": "Symbol", "Dingbat dec": "162", "Dingbat hex": "A2", "Unicode dec": "8242", "Unicode hex": "2032" },
    { "Typeface name": "Symbol", "Dingbat dec": "163", "Dingbat hex": "A3", "Unicode dec": "8804", "Unicode hex": "2264" },
    { "Typeface name": "Symbol", "Dingbat dec": "164", "Dingbat hex": "A4", "Unicode dec": "8260", "Unicode hex": "2044" },
    { "Typeface name": "Symbol", "Dingbat dec": "165", "Dingbat hex": "A5", "Unicode dec": "8734", "Unicode hex": "221E" },
    { "Typeface name": "Symbol", "Dingbat dec": "166", "Dingbat hex": "A6", "Unicode dec": "402", "Unicode hex": "192" },
    { "Typeface name": "Symbol", "Dingbat dec": "167", "Dingbat hex": "A7", "Unicode dec": "9827", "Unicode hex": "2663" },
    { "Typeface name": "Symbol", "Dingbat dec": "168", "Dingbat hex": "A8", "Unicode dec": "9830", "Unicode hex": "2666" },
    { "Typeface name": "Symbol", "Dingbat dec": "169", "Dingbat hex": "A9", "Unicode dec": "9829", "Unicode hex": "2665" },
    { "Typeface name": "Symbol", "Dingbat dec": "170", "Dingbat hex": "AA", "Unicode dec": "9824", "Unicode hex": "2660" },
    { "Typeface name": "Symbol", "Dingbat dec": "171", "Dingbat hex": "AB", "Unicode dec": "8596", "Unicode hex": "2194" },
    { "Typeface name": "Symbol", "Dingbat dec": "172", "Dingbat hex": "AC", "Unicode dec": "8592", "Unicode hex": "2190" },
    { "Typeface name": "Symbol", "Dingbat dec": "173", "Dingbat hex": "AD", "Unicode dec": "8593", "Unicode hex": "2191" },
    { "Typeface name": "Symbol", "Dingbat dec": "174", "Dingbat hex": "AE", "Unicode dec": "8594", "Unicode hex": "2192" },
    { "Typeface name": "Symbol", "Dingbat dec": "175", "Dingbat hex": "AF", "Unicode dec": "8595", "Unicode hex": "2193" },
    { "Typeface name": "Symbol", "Dingbat dec": "176", "Dingbat hex": "B0", "Unicode dec": "176", "Unicode hex": "B0" },
    { "Typeface name": "Symbol", "Dingbat dec": "177", "Dingbat hex": "B1", "Unicode dec": "177", "Unicode hex": "B1" },
    { "Typeface name": "Symbol", "Dingbat dec": "178", "Dingbat hex": "B2", "Unicode dec": "8243", "Unicode hex": "2033" },
    { "Typeface name": "Symbol", "Dingbat dec": "179", "Dingbat hex": "B3", "Unicode dec": "8805", "Unicode hex": "2265" },
    { "Typeface name": "Symbol", "Dingbat dec": "180", "Dingbat hex": "B4", "Unicode dec": "215", "Unicode hex": "D7" },
    { "Typeface name": "Symbol", "Dingbat dec": "181", "Dingbat hex": "B5", "Unicode dec": "8733", "Unicode hex": "221D" },
    { "Typeface name": "Symbol", "Dingbat dec": "182", "Dingbat hex": "B6", "Unicode dec": "8706", "Unicode hex": "2202" },
    { "Typeface name": "Symbol", "Dingbat dec": "183", "Dingbat hex": "B7", "Unicode dec": "8226", "Unicode hex": "2022" },
    { "Typeface name": "Symbol", "Dingbat dec": "184", "Dingbat hex": "B8", "Unicode dec": "247", "Unicode hex": "F7" },
    { "Typeface name": "Symbol", "Dingbat dec": "185", "Dingbat hex": "B9", "Unicode dec": "8800", "Unicode hex": "2260" },
    { "Typeface name": "Symbol", "Dingbat dec": "186", "Dingbat hex": "BA", "Unicode dec": "8801", "Unicode hex": "2261" },
    { "Typeface name": "Symbol", "Dingbat dec": "187", "Dingbat hex": "BB", "Unicode dec": "8776", "Unicode hex": "2248" },
    { "Typeface name": "Symbol", "Dingbat dec": "188", "Dingbat hex": "BC", "Unicode dec": "8230", "Unicode hex": "2026" },
    { "Typeface name": "Symbol", "Dingbat dec": "189", "Dingbat hex": "BD", "Unicode dec": "9168", "Unicode hex": "23D0" },
    { "Typeface name": "Symbol", "Dingbat dec": "190", "Dingbat hex": "BE", "Unicode dec": "9135", "Unicode hex": "23AF" },
    { "Typeface name": "Symbol", "Dingbat dec": "191", "Dingbat hex": "BF", "Unicode dec": "8629", "Unicode hex": "21B5" },
    { "Typeface name": "Symbol", "Dingbat dec": "192", "Dingbat hex": "C0", "Unicode dec": "8501", "Unicode hex": "2135" },
    { "Typeface name": "Symbol", "Dingbat dec": "193", "Dingbat hex": "C1", "Unicode dec": "8465", "Unicode hex": "2111" },
    { "Typeface name": "Symbol", "Dingbat dec": "194", "Dingbat hex": "C2", "Unicode dec": "8476", "Unicode hex": "211C" },
    { "Typeface name": "Symbol", "Dingbat dec": "195", "Dingbat hex": "C3", "Unicode dec": "8472", "Unicode hex": "2118" },
    { "Typeface name": "Symbol", "Dingbat dec": "196", "Dingbat hex": "C4", "Unicode dec": "8855", "Unicode hex": "2297" },
    { "Typeface name": "Symbol", "Dingbat dec": "197", "Dingbat hex": "C5", "Unicode dec": "8853", "Unicode hex": "2295" },
    { "Typeface name": "Symbol", "Dingbat dec": "198", "Dingbat hex": "C6", "Unicode dec": "8709", "Unicode hex": "2205" },
    { "Typeface name": "Symbol", "Dingbat dec": "199", "Dingbat hex": "C7", "Unicode dec": "8745", "Unicode hex": "2229" },
    { "Typeface name": "Symbol", "Dingbat dec": "200", "Dingbat hex": "C8", "Unicode dec": "8746", "Unicode hex": "222A" },
    { "Typeface name": "Symbol", "Dingbat dec": "201", "Dingbat hex": "C9", "Unicode dec": "8835", "Unicode hex": "2283" },
    { "Typeface name": "Symbol", "Dingbat dec": "202", "Dingbat hex": "CA", "Unicode dec": "8839", "Unicode hex": "2287" },
    { "Typeface name": "Symbol", "Dingbat dec": "203", "Dingbat hex": "CB", "Unicode dec": "8836", "Unicode hex": "2284" },
    { "Typeface name": "Symbol", "Dingbat dec": "204", "Dingbat hex": "CC", "Unicode dec": "8834", "Unicode hex": "2282" },
    { "Typeface name": "Symbol", "Dingbat dec": "205", "Dingbat hex": "CD", "Unicode dec": "8838", "Unicode hex": "2286" },
    { "Typeface name": "Symbol", "Dingbat dec": "206", "Dingbat hex": "CE", "Unicode dec": "8712", "Unicode hex": "2208" },
    { "Typeface name": "Symbol", "Dingbat dec": "207", "Dingbat hex": "CF", "Unicode dec": "8713", "Unicode hex": "2209" },
    { "Typeface name": "Symbol", "Dingbat dec": "208", "Dingbat hex": "D0", "Unicode dec": "8736", "Unicode hex": "2220" },
    { "Typeface name": "Symbol", "Dingbat dec": "209", "Dingbat hex": "D1", "Unicode dec": "8711", "Unicode hex": "2207" },
    { "Typeface name": "Symbol", "Dingbat dec": "210", "Dingbat hex": "D2", "Unicode dec": "174", "Unicode hex": "AE" },
    { "Typeface name": "Symbol", "Dingbat dec": "211", "Dingbat hex": "D3", "Unicode dec": "169", "Unicode hex": "A9" },
    { "Typeface name": "Symbol", "Dingbat dec": "212", "Dingbat hex": "D4", "Unicode dec": "8482", "Unicode hex": "2122" },
    { "Typeface name": "Symbol", "Dingbat dec": "213", "Dingbat hex": "D5", "Unicode dec": "8719", "Unicode hex": "220F" },
    { "Typeface name": "Symbol", "Dingbat dec": "214", "Dingbat hex": "D6", "Unicode dec": "8730", "Unicode hex": "221A" },
    { "Typeface name": "Symbol", "Dingbat dec": "215", "Dingbat hex": "D7", "Unicode dec": "8901", "Unicode hex": "22C5" },
    { "Typeface name": "Symbol", "Dingbat dec": "216", "Dingbat hex": "D8", "Unicode dec": "172", "Unicode hex": "AC" },
    { "Typeface name": "Symbol", "Dingbat dec": "217", "Dingbat hex": "D9", "Unicode dec": "8743", "Unicode hex": "2227" },
    { "Typeface name": "Symbol", "Dingbat dec": "218", "Dingbat hex": "DA", "Unicode dec": "8744", "Unicode hex": "2228" },
    { "Typeface name": "Symbol", "Dingbat dec": "219", "Dingbat hex": "DB", "Unicode dec": "8660", "Unicode hex": "21D4" },
    { "Typeface name": "Symbol", "Dingbat dec": "220", "Dingbat hex": "DC", "Unicode dec": "8656", "Unicode hex": "21D0" },
    { "Typeface name": "Symbol", "Dingbat dec": "221", "Dingbat hex": "DD", "Unicode dec": "8657", "Unicode hex": "21D1" },
    { "Typeface name": "Symbol", "Dingbat dec": "222", "Dingbat hex": "DE", "Unicode dec": "8658", "Unicode hex": "21D2" },
    { "Typeface name": "Symbol", "Dingbat dec": "223", "Dingbat hex": "DF", "Unicode dec": "8659", "Unicode hex": "21D3" },
    { "Typeface name": "Symbol", "Dingbat dec": "224", "Dingbat hex": "E0", "Unicode dec": "9674", "Unicode hex": "25CA" },
    { "Typeface name": "Symbol", "Dingbat dec": "225", "Dingbat hex": "E1", "Unicode dec": "12296", "Unicode hex": "3008" },
    { "Typeface name": "Symbol", "Dingbat dec": "226", "Dingbat hex": "E2", "Unicode dec": "174", "Unicode hex": "AE" },
    { "Typeface name": "Symbol", "Dingbat dec": "227", "Dingbat hex": "E3", "Unicode dec": "169", "Unicode hex": "A9" },
    { "Typeface name": "Symbol", "Dingbat dec": "228", "Dingbat hex": "E4", "Unicode dec": "8482", "Unicode hex": "2122" },
    { "Typeface name": "Symbol", "Dingbat dec": "229", "Dingbat hex": "E5", "Unicode dec": "8721", "Unicode hex": "2211" },
    { "Typeface name": "Symbol", "Dingbat dec": "230", "Dingbat hex": "E6", "Unicode dec": "9115", "Unicode hex": "239B" },
    { "Typeface name": "Symbol", "Dingbat dec": "231", "Dingbat hex": "E7", "Unicode dec": "9116", "Unicode hex": "239C" },
    { "Typeface name": "Symbol", "Dingbat dec": "232", "Dingbat hex": "E8", "Unicode dec": "9117", "Unicode hex": "239D" },
    { "Typeface name": "Symbol", "Dingbat dec": "233", "Dingbat hex": "E9", "Unicode dec": "9121", "Unicode hex": "23A1" },
    { "Typeface name": "Symbol", "Dingbat dec": "234", "Dingbat hex": "EA", "Unicode dec": "9122", "Unicode hex": "23A2" },
    { "Typeface name": "Symbol", "Dingbat dec": "235", "Dingbat hex": "EB", "Unicode dec": "9123", "Unicode hex": "23A3" },
    { "Typeface name": "Symbol", "Dingbat dec": "236", "Dingbat hex": "EC", "Unicode dec": "9127", "Unicode hex": "23A7" },
    { "Typeface name": "Symbol", "Dingbat dec": "237", "Dingbat hex": "ED", "Unicode dec": "9128", "Unicode hex": "23A8" },
    { "Typeface name": "Symbol", "Dingbat dec": "238", "Dingbat hex": "EE", "Unicode dec": "9129", "Unicode hex": "23A9" },
    { "Typeface name": "Symbol", "Dingbat dec": "239", "Dingbat hex": "EF", "Unicode dec": "9130", "Unicode hex": "23AA" },
    { "Typeface name": "Symbol", "Dingbat dec": "240", "Dingbat hex": "F0", "Unicode dec": "63743", "Unicode hex": "F8FF" },
    { "Typeface name": "Symbol", "Dingbat dec": "241", "Dingbat hex": "F1", "Unicode dec": "12297", "Unicode hex": "3009" },
    { "Typeface name": "Symbol", "Dingbat dec": "242", "Dingbat hex": "F2", "Unicode dec": "8747", "Unicode hex": "222B" },
    { "Typeface name": "Symbol", "Dingbat dec": "243", "Dingbat hex": "F3", "Unicode dec": "8992", "Unicode hex": "2320" },
    { "Typeface name": "Symbol", "Dingbat dec": "244", "Dingbat hex": "F4", "Unicode dec": "9134", "Unicode hex": "23AE" },
    { "Typeface name": "Symbol", "Dingbat dec": "245", "Dingbat hex": "F5", "Unicode dec": "8993", "Unicode hex": "2321" },
    { "Typeface name": "Symbol", "Dingbat dec": "246", "Dingbat hex": "F6", "Unicode dec": "9118", "Unicode hex": "239E" },
    { "Typeface name": "Symbol", "Dingbat dec": "247", "Dingbat hex": "F7", "Unicode dec": "9119", "Unicode hex": "239F" },
    { "Typeface name": "Symbol", "Dingbat dec": "248", "Dingbat hex": "F8", "Unicode dec": "9120", "Unicode hex": "23A0" },
    { "Typeface name": "Symbol", "Dingbat dec": "249", "Dingbat hex": "F9", "Unicode dec": "9124", "Unicode hex": "23A4" },
    { "Typeface name": "Symbol", "Dingbat dec": "250", "Dingbat hex": "FA", "Unicode dec": "9125", "Unicode hex": "23A5" },
    { "Typeface name": "Symbol", "Dingbat dec": "251", "Dingbat hex": "FB", "Unicode dec": "9126", "Unicode hex": "23A6" },
    { "Typeface name": "Symbol", "Dingbat dec": "252", "Dingbat hex": "FC", "Unicode dec": "9131", "Unicode hex": "23AB" },
    { "Typeface name": "Symbol", "Dingbat dec": "253", "Dingbat hex": "FD", "Unicode dec": "9132", "Unicode hex": "23AC" },
    { "Typeface name": "Symbol", "Dingbat dec": "254", "Dingbat hex": "FE", "Unicode dec": "9133", "Unicode hex": "23AD" },
    { "Typeface name": "Webdings", "Dingbat dec": "32", "Dingbat hex": "20", "Unicode dec": "32", "Unicode hex": "20" },
    { "Typeface name": "Webdings", "Dingbat dec": "33", "Dingbat hex": "21", "Unicode dec": "128375", "Unicode hex": "1F577" },
    { "Typeface name": "Webdings", "Dingbat dec": "34", "Dingbat hex": "22", "Unicode dec": "128376", "Unicode hex": "1F578" },
    { "Typeface name": "Webdings", "Dingbat dec": "35", "Dingbat hex": "23", "Unicode dec": "128370", "Unicode hex": "1F572" },
    { "Typeface name": "Webdings", "Dingbat dec": "36", "Dingbat hex": "24", "Unicode dec": "128374", "Unicode hex": "1F576" },
    { "Typeface name": "Webdings", "Dingbat dec": "37", "Dingbat hex": "25", "Unicode dec": "127942", "Unicode hex": "1F3C6" },
    { "Typeface name": "Webdings", "Dingbat dec": "38", "Dingbat hex": "26", "Unicode dec": "127894", "Unicode hex": "1F396" },
    { "Typeface name": "Webdings", "Dingbat dec": "39", "Dingbat hex": "27", "Unicode dec": "128391", "Unicode hex": "1F587" },
    { "Typeface name": "Webdings", "Dingbat dec": "40", "Dingbat hex": "28", "Unicode dec": "128488", "Unicode hex": "1F5E8" },
    { "Typeface name": "Webdings", "Dingbat dec": "41", "Dingbat hex": "29", "Unicode dec": "128489", "Unicode hex": "1F5E9" },
    { "Typeface name": "Webdings", "Dingbat dec": "42", "Dingbat hex": "2A", "Unicode dec": "128496", "Unicode hex": "1F5F0" },
    { "Typeface name": "Webdings", "Dingbat dec": "43", "Dingbat hex": "2B", "Unicode dec": "128497", "Unicode hex": "1F5F1" },
    { "Typeface name": "Webdings", "Dingbat dec": "44", "Dingbat hex": "2C", "Unicode dec": "127798", "Unicode hex": "1F336" },
    { "Typeface name": "Webdings", "Dingbat dec": "45", "Dingbat hex": "2D", "Unicode dec": "127895", "Unicode hex": "1F397" },
    { "Typeface name": "Webdings", "Dingbat dec": "46", "Dingbat hex": "2E", "Unicode dec": "128638", "Unicode hex": "1F67E" },
    { "Typeface name": "Webdings", "Dingbat dec": "47", "Dingbat hex": "2F", "Unicode dec": "128636", "Unicode hex": "1F67C" },
    { "Typeface name": "Webdings", "Dingbat dec": "48", "Dingbat hex": "30", "Unicode dec": "128469", "Unicode hex": "1F5D5" },
    { "Typeface name": "Webdings", "Dingbat dec": "49", "Dingbat hex": "31", "Unicode dec": "128470", "Unicode hex": "1F5D6" },
    { "Typeface name": "Webdings", "Dingbat dec": "50", "Dingbat hex": "32", "Unicode dec": "128471", "Unicode hex": "1F5D7" },
    { "Typeface name": "Webdings", "Dingbat dec": "51", "Dingbat hex": "33", "Unicode dec": "9204", "Unicode hex": "23F4" },
    { "Typeface name": "Webdings", "Dingbat dec": "52", "Dingbat hex": "34", "Unicode dec": "9205", "Unicode hex": "23F5" },
    { "Typeface name": "Webdings", "Dingbat dec": "53", "Dingbat hex": "35", "Unicode dec": "9206", "Unicode hex": "23F6" },
    { "Typeface name": "Webdings", "Dingbat dec": "54", "Dingbat hex": "36", "Unicode dec": "9207", "Unicode hex": "23F7" },
    { "Typeface name": "Webdings", "Dingbat dec": "55", "Dingbat hex": "37", "Unicode dec": "9194", "Unicode hex": "23EA" },
    { "Typeface name": "Webdings", "Dingbat dec": "56", "Dingbat hex": "38", "Unicode dec": "9193", "Unicode hex": "23E9" },
    { "Typeface name": "Webdings", "Dingbat dec": "57", "Dingbat hex": "39", "Unicode dec": "9198", "Unicode hex": "23EE" },
    { "Typeface name": "Webdings", "Dingbat dec": "58", "Dingbat hex": "3A", "Unicode dec": "9197", "Unicode hex": "23ED" },
    { "Typeface name": "Webdings", "Dingbat dec": "59", "Dingbat hex": "3B", "Unicode dec": "9208", "Unicode hex": "23F8" },
    { "Typeface name": "Webdings", "Dingbat dec": "60", "Dingbat hex": "3C", "Unicode dec": "9209", "Unicode hex": "23F9" },
    { "Typeface name": "Webdings", "Dingbat dec": "61", "Dingbat hex": "3D", "Unicode dec": "9210", "Unicode hex": "23FA" },
    { "Typeface name": "Webdings", "Dingbat dec": "62", "Dingbat hex": "3E", "Unicode dec": "128474", "Unicode hex": "1F5DA" },
    { "Typeface name": "Webdings", "Dingbat dec": "63", "Dingbat hex": "3F", "Unicode dec": "128499", "Unicode hex": "1F5F3" },
    { "Typeface name": "Webdings", "Dingbat dec": "64", "Dingbat hex": "40", "Unicode dec": "128736", "Unicode hex": "1F6E0" },
    { "Typeface name": "Webdings", "Dingbat dec": "65", "Dingbat hex": "41", "Unicode dec": "127959", "Unicode hex": "1F3D7" },
    { "Typeface name": "Webdings", "Dingbat dec": "66", "Dingbat hex": "42", "Unicode dec": "127960", "Unicode hex": "1F3D8" },
    { "Typeface name": "Webdings", "Dingbat dec": "67", "Dingbat hex": "43", "Unicode dec": "127961", "Unicode hex": "1F3D9" },
    { "Typeface name": "Webdings", "Dingbat dec": "68", "Dingbat hex": "44", "Unicode dec": "127962", "Unicode hex": "1F3DA" },
    { "Typeface name": "Webdings", "Dingbat dec": "69", "Dingbat hex": "45", "Unicode dec": "127964", "Unicode hex": "1F3DC" },
    { "Typeface name": "Webdings", "Dingbat dec": "70", "Dingbat hex": "46", "Unicode dec": "127981", "Unicode hex": "1F3ED" },
    { "Typeface name": "Webdings", "Dingbat dec": "71", "Dingbat hex": "47", "Unicode dec": "127963", "Unicode hex": "1F3DB" },
    { "Typeface name": "Webdings", "Dingbat dec": "72", "Dingbat hex": "48", "Unicode dec": "127968", "Unicode hex": "1F3E0" },
    { "Typeface name": "Webdings", "Dingbat dec": "73", "Dingbat hex": "49", "Unicode dec": "127958", "Unicode hex": "1F3D6" },
    { "Typeface name": "Webdings", "Dingbat dec": "74", "Dingbat hex": "4A", "Unicode dec": "127965", "Unicode hex": "1F3DD" },
    { "Typeface name": "Webdings", "Dingbat dec": "75", "Dingbat hex": "4B", "Unicode dec": "128739", "Unicode hex": "1F6E3" },
    { "Typeface name": "Webdings", "Dingbat dec": "76", "Dingbat hex": "4C", "Unicode dec": "128269", "Unicode hex": "1F50D" },
    { "Typeface name": "Webdings", "Dingbat dec": "77", "Dingbat hex": "4D", "Unicode dec": "127956", "Unicode hex": "1F3D4" },
    { "Typeface name": "Webdings", "Dingbat dec": "78", "Dingbat hex": "4E", "Unicode dec": "128065", "Unicode hex": "1F441" },
    { "Typeface name": "Webdings", "Dingbat dec": "79", "Dingbat hex": "4F", "Unicode dec": "128066", "Unicode hex": "1F442" },
    { "Typeface name": "Webdings", "Dingbat dec": "80", "Dingbat hex": "50", "Unicode dec": "127966", "Unicode hex": "1F3DE" },
    { "Typeface name": "Webdings", "Dingbat dec": "81", "Dingbat hex": "51", "Unicode dec": "127957", "Unicode hex": "1F3D5" },
    { "Typeface name": "Webdings", "Dingbat dec": "82", "Dingbat hex": "52", "Unicode dec": "128740", "Unicode hex": "1F6E4" },
    { "Typeface name": "Webdings", "Dingbat dec": "83", "Dingbat hex": "53", "Unicode dec": "127967", "Unicode hex": "1F3DF" },
    { "Typeface name": "Webdings", "Dingbat dec": "84", "Dingbat hex": "54", "Unicode dec": "128755", "Unicode hex": "1F6F3" },
    { "Typeface name": "Webdings", "Dingbat dec": "85", "Dingbat hex": "55", "Unicode dec": "128364", "Unicode hex": "1F56C" },
    { "Typeface name": "Webdings", "Dingbat dec": "86", "Dingbat hex": "56", "Unicode dec": "128363", "Unicode hex": "1F56B" },
    { "Typeface name": "Webdings", "Dingbat dec": "87", "Dingbat hex": "57", "Unicode dec": "128360", "Unicode hex": "1F568" },
    { "Typeface name": "Webdings", "Dingbat dec": "88", "Dingbat hex": "58", "Unicode dec": "128264", "Unicode hex": "1F508" },
    { "Typeface name": "Webdings", "Dingbat dec": "89", "Dingbat hex": "59", "Unicode dec": "127892", "Unicode hex": "1F394" },
    { "Typeface name": "Webdings", "Dingbat dec": "90", "Dingbat hex": "5A", "Unicode dec": "127893", "Unicode hex": "1F395" },
    { "Typeface name": "Webdings", "Dingbat dec": "91", "Dingbat hex": "5B", "Unicode dec": "128492", "Unicode hex": "1F5EC" },
    { "Typeface name": "Webdings", "Dingbat dec": "92", "Dingbat hex": "5C", "Unicode dec": "128637", "Unicode hex": "1F67D" },
    { "Typeface name": "Webdings", "Dingbat dec": "93", "Dingbat hex": "5D", "Unicode dec": "128493", "Unicode hex": "1F5ED" },
    { "Typeface name": "Webdings", "Dingbat dec": "94", "Dingbat hex": "5E", "Unicode dec": "128490", "Unicode hex": "1F5EA" },
    { "Typeface name": "Webdings", "Dingbat dec": "95", "Dingbat hex": "5F", "Unicode dec": "128491", "Unicode hex": "1F5EB" },
    { "Typeface name": "Webdings", "Dingbat dec": "96", "Dingbat hex": "60", "Unicode dec": "11156", "Unicode hex": "2B94" },
    { "Typeface name": "Webdings", "Dingbat dec": "97", "Dingbat hex": "61", "Unicode dec": "10004", "Unicode hex": "2714" },
    { "Typeface name": "Webdings", "Dingbat dec": "98", "Dingbat hex": "62", "Unicode dec": "128690", "Unicode hex": "1F6B2" },
    { "Typeface name": "Webdings", "Dingbat dec": "99", "Dingbat hex": "63", "Unicode dec": "11036", "Unicode hex": "2B1C" },
    { "Typeface name": "Webdings", "Dingbat dec": "100", "Dingbat hex": "64", "Unicode dec": "128737", "Unicode hex": "1F6E1" },
    { "Typeface name": "Webdings", "Dingbat dec": "101", "Dingbat hex": "65", "Unicode dec": "128230", "Unicode hex": "1F4E6" },
    { "Typeface name": "Webdings", "Dingbat dec": "102", "Dingbat hex": "66", "Unicode dec": "128753", "Unicode hex": "1F6F1" },
    { "Typeface name": "Webdings", "Dingbat dec": "103", "Dingbat hex": "67", "Unicode dec": "11035", "Unicode hex": "2B1B" },
    { "Typeface name": "Webdings", "Dingbat dec": "104", "Dingbat hex": "68", "Unicode dec": "128657", "Unicode hex": "1F691" },
    { "Typeface name": "Webdings", "Dingbat dec": "105", "Dingbat hex": "69", "Unicode dec": "128712", "Unicode hex": "1F6C8" },
    { "Typeface name": "Webdings", "Dingbat dec": "106", "Dingbat hex": "6A", "Unicode dec": "128745", "Unicode hex": "1F6E9" },
    { "Typeface name": "Webdings", "Dingbat dec": "107", "Dingbat hex": "6B", "Unicode dec": "128752", "Unicode hex": "1F6F0" },
    { "Typeface name": "Webdings", "Dingbat dec": "108", "Dingbat hex": "6C", "Unicode dec": "128968", "Unicode hex": "1F7C8" },
    { "Typeface name": "Webdings", "Dingbat dec": "109", "Dingbat hex": "6D", "Unicode dec": "128372", "Unicode hex": "1F574" },
    { "Typeface name": "Webdings", "Dingbat dec": "110", "Dingbat hex": "6E", "Unicode dec": "11044", "Unicode hex": "2B24" },
    { "Typeface name": "Webdings", "Dingbat dec": "111", "Dingbat hex": "6F", "Unicode dec": "128741", "Unicode hex": "1F6E5" },
    { "Typeface name": "Webdings", "Dingbat dec": "112", "Dingbat hex": "70", "Unicode dec": "128660", "Unicode hex": "1F694" },
    { "Typeface name": "Webdings", "Dingbat dec": "113", "Dingbat hex": "71", "Unicode dec": "128472", "Unicode hex": "1F5D8" },
    { "Typeface name": "Webdings", "Dingbat dec": "114", "Dingbat hex": "72", "Unicode dec": "128473", "Unicode hex": "1F5D9" },
    { "Typeface name": "Webdings", "Dingbat dec": "115", "Dingbat hex": "73", "Unicode dec": "10067", "Unicode hex": "2753" },
    { "Typeface name": "Webdings", "Dingbat dec": "116", "Dingbat hex": "74", "Unicode dec": "128754", "Unicode hex": "1F6F2" },
    { "Typeface name": "Webdings", "Dingbat dec": "117", "Dingbat hex": "75", "Unicode dec": "128647", "Unicode hex": "1F687" },
    { "Typeface name": "Webdings", "Dingbat dec": "118", "Dingbat hex": "76", "Unicode dec": "128653", "Unicode hex": "1F68D" },
    { "Typeface name": "Webdings", "Dingbat dec": "119", "Dingbat hex": "77", "Unicode dec": "9971", "Unicode hex": "26F3" },
    { "Typeface name": "Webdings", "Dingbat dec": "120", "Dingbat hex": "78", "Unicode dec": "10680", "Unicode hex": "29B8" },
    { "Typeface name": "Webdings", "Dingbat dec": "121", "Dingbat hex": "79", "Unicode dec": "8854", "Unicode hex": "2296" },
    { "Typeface name": "Webdings", "Dingbat dec": "122", "Dingbat hex": "7A", "Unicode dec": "128685", "Unicode hex": "1F6AD" },
    { "Typeface name": "Webdings", "Dingbat dec": "123", "Dingbat hex": "7B", "Unicode dec": "128494", "Unicode hex": "1F5EE" },
    { "Typeface name": "Webdings", "Dingbat dec": "124", "Dingbat hex": "7C", "Unicode dec": "9168", "Unicode hex": "23D0" },
    { "Typeface name": "Webdings", "Dingbat dec": "125", "Dingbat hex": "7D", "Unicode dec": "128495", "Unicode hex": "1F5EF" },
    { "Typeface name": "Webdings", "Dingbat dec": "126", "Dingbat hex": "7E", "Unicode dec": "128498", "Unicode hex": "1F5F2" },
    { "Typeface name": "Webdings", "Dingbat dec": "128", "Dingbat hex": "80", "Unicode dec": "128697", "Unicode hex": "1F6B9" },
    { "Typeface name": "Webdings", "Dingbat dec": "129", "Dingbat hex": "81", "Unicode dec": "128698", "Unicode hex": "1F6BA" },
    { "Typeface name": "Webdings", "Dingbat dec": "130", "Dingbat hex": "82", "Unicode dec": "128713", "Unicode hex": "1F6C9" },
    { "Typeface name": "Webdings", "Dingbat dec": "131", "Dingbat hex": "83", "Unicode dec": "128714", "Unicode hex": "1F6CA" },
    { "Typeface name": "Webdings", "Dingbat dec": "132", "Dingbat hex": "84", "Unicode dec": "128700", "Unicode hex": "1F6BC" },
    { "Typeface name": "Webdings", "Dingbat dec": "133", "Dingbat hex": "85", "Unicode dec": "128125", "Unicode hex": "1F47D" },
    { "Typeface name": "Webdings", "Dingbat dec": "134", "Dingbat hex": "86", "Unicode dec": "127947", "Unicode hex": "1F3CB" },
    { "Typeface name": "Webdings", "Dingbat dec": "135", "Dingbat hex": "87", "Unicode dec": "9975", "Unicode hex": "26F7" },
    { "Typeface name": "Webdings", "Dingbat dec": "136", "Dingbat hex": "88", "Unicode dec": "127938", "Unicode hex": "1F3C2" },
    { "Typeface name": "Webdings", "Dingbat dec": "137", "Dingbat hex": "89", "Unicode dec": "127948", "Unicode hex": "1F3CC" },
    { "Typeface name": "Webdings", "Dingbat dec": "138", "Dingbat hex": "8A", "Unicode dec": "127946", "Unicode hex": "1F3CA" },
    { "Typeface name": "Webdings", "Dingbat dec": "139", "Dingbat hex": "8B", "Unicode dec": "127940", "Unicode hex": "1F3C4" },
    { "Typeface name": "Webdings", "Dingbat dec": "140", "Dingbat hex": "8C", "Unicode dec": "127949", "Unicode hex": "1F3CD" },
    { "Typeface name": "Webdings", "Dingbat dec": "141", "Dingbat hex": "8D", "Unicode dec": "127950", "Unicode hex": "1F3CE" },
    { "Typeface name": "Webdings", "Dingbat dec": "142", "Dingbat hex": "8E", "Unicode dec": "128664", "Unicode hex": "1F698" },
    { "Typeface name": "Webdings", "Dingbat dec": "143", "Dingbat hex": "8F", "Unicode dec": "128480", "Unicode hex": "1F5E0" },
    { "Typeface name": "Webdings", "Dingbat dec": "144", "Dingbat hex": "90", "Unicode dec": "128738", "Unicode hex": "1F6E2" },
    { "Typeface name": "Webdings", "Dingbat dec": "145", "Dingbat hex": "91", "Unicode dec": "128176", "Unicode hex": "1F4B0" },
    { "Typeface name": "Webdings", "Dingbat dec": "146", "Dingbat hex": "92", "Unicode dec": "127991", "Unicode hex": "1F3F7" },
    { "Typeface name": "Webdings", "Dingbat dec": "147", "Dingbat hex": "93", "Unicode dec": "128179", "Unicode hex": "1F4B3" },
    { "Typeface name": "Webdings", "Dingbat dec": "148", "Dingbat hex": "94", "Unicode dec": "128106", "Unicode hex": "1F46A" },
    { "Typeface name": "Webdings", "Dingbat dec": "149", "Dingbat hex": "95", "Unicode dec": "128481", "Unicode hex": "1F5E1" },
    { "Typeface name": "Webdings", "Dingbat dec": "150", "Dingbat hex": "96", "Unicode dec": "128482", "Unicode hex": "1F5E2" },
    { "Typeface name": "Webdings", "Dingbat dec": "151", "Dingbat hex": "97", "Unicode dec": "128483", "Unicode hex": "1F5E3" },
    { "Typeface name": "Webdings", "Dingbat dec": "152", "Dingbat hex": "98", "Unicode dec": "10031", "Unicode hex": "272F" },
    { "Typeface name": "Webdings", "Dingbat dec": "153", "Dingbat hex": "99", "Unicode dec": "128388", "Unicode hex": "1F584" },
    { "Typeface name": "Webdings", "Dingbat dec": "154", "Dingbat hex": "9A", "Unicode dec": "128389", "Unicode hex": "1F585" },
    { "Typeface name": "Webdings", "Dingbat dec": "155", "Dingbat hex": "9B", "Unicode dec": "128387", "Unicode hex": "1F583" },
    { "Typeface name": "Webdings", "Dingbat dec": "156", "Dingbat hex": "9C", "Unicode dec": "128390", "Unicode hex": "1F586" },
    { "Typeface name": "Webdings", "Dingbat dec": "157", "Dingbat hex": "9D", "Unicode dec": "128441", "Unicode hex": "1F5B9" },
    { "Typeface name": "Webdings", "Dingbat dec": "158", "Dingbat hex": "9E", "Unicode dec": "128442", "Unicode hex": "1F5BA" },
    { "Typeface name": "Webdings", "Dingbat dec": "159", "Dingbat hex": "9F", "Unicode dec": "128443", "Unicode hex": "1F5BB" },
    { "Typeface name": "Webdings", "Dingbat dec": "160", "Dingbat hex": "A0", "Unicode dec": "128373", "Unicode hex": "1F575" },
    { "Typeface name": "Webdings", "Dingbat dec": "161", "Dingbat hex": "A1", "Unicode dec": "128368", "Unicode hex": "1F570" },
    { "Typeface name": "Webdings", "Dingbat dec": "162", "Dingbat hex": "A2", "Unicode dec": "128445", "Unicode hex": "1F5BD" },
    { "Typeface name": "Webdings", "Dingbat dec": "163", "Dingbat hex": "A3", "Unicode dec": "128446", "Unicode hex": "1F5BE" },
    { "Typeface name": "Webdings", "Dingbat dec": "164", "Dingbat hex": "A4", "Unicode dec": "128203", "Unicode hex": "1F4CB" },
    { "Typeface name": "Webdings", "Dingbat dec": "165", "Dingbat hex": "A5", "Unicode dec": "128466", "Unicode hex": "1F5D2" },
    { "Typeface name": "Webdings", "Dingbat dec": "166", "Dingbat hex": "A6", "Unicode dec": "128467", "Unicode hex": "1F5D3" },
    { "Typeface name": "Webdings", "Dingbat dec": "167", "Dingbat hex": "A7", "Unicode dec": "128366", "Unicode hex": "1F56E" },
    { "Typeface name": "Webdings", "Dingbat dec": "168", "Dingbat hex": "A8", "Unicode dec": "128218", "Unicode hex": "1F4DA" },
    { "Typeface name": "Webdings", "Dingbat dec": "169", "Dingbat hex": "A9", "Unicode dec": "128478", "Unicode hex": "1F5DE" },
    { "Typeface name": "Webdings", "Dingbat dec": "170", "Dingbat hex": "AA", "Unicode dec": "128479", "Unicode hex": "1F5DF" },
    { "Typeface name": "Webdings", "Dingbat dec": "171", "Dingbat hex": "AB", "Unicode dec": "128451", "Unicode hex": "1F5C3" },
    { "Typeface name": "Webdings", "Dingbat dec": "172", "Dingbat hex": "AC", "Unicode dec": "128450", "Unicode hex": "1F5C2" },
    { "Typeface name": "Webdings", "Dingbat dec": "173", "Dingbat hex": "AD", "Unicode dec": "128444", "Unicode hex": "1F5BC" },
    { "Typeface name": "Webdings", "Dingbat dec": "174", "Dingbat hex": "AE", "Unicode dec": "127917", "Unicode hex": "1F3AD" },
    { "Typeface name": "Webdings", "Dingbat dec": "175", "Dingbat hex": "AF", "Unicode dec": "127900", "Unicode hex": "1F39C" },
    { "Typeface name": "Webdings", "Dingbat dec": "176", "Dingbat hex": "B0", "Unicode dec": "127896", "Unicode hex": "1F398" },
    { "Typeface name": "Webdings", "Dingbat dec": "177", "Dingbat hex": "B1", "Unicode dec": "127897", "Unicode hex": "1F399" },
    { "Typeface name": "Webdings", "Dingbat dec": "178", "Dingbat hex": "B2", "Unicode dec": "127911", "Unicode hex": "1F3A7" },
    { "Typeface name": "Webdings", "Dingbat dec": "179", "Dingbat hex": "B3", "Unicode dec": "128191", "Unicode hex": "1F4BF" },
    { "Typeface name": "Webdings", "Dingbat dec": "180", "Dingbat hex": "B4", "Unicode dec": "127902", "Unicode hex": "1F39E" },
    { "Typeface name": "Webdings", "Dingbat dec": "181", "Dingbat hex": "B5", "Unicode dec": "128247", "Unicode hex": "1F4F7" },
    { "Typeface name": "Webdings", "Dingbat dec": "182", "Dingbat hex": "B6", "Unicode dec": "127903", "Unicode hex": "1F39F" },
    { "Typeface name": "Webdings", "Dingbat dec": "183", "Dingbat hex": "B7", "Unicode dec": "127916", "Unicode hex": "1F3AC" },
    { "Typeface name": "Webdings", "Dingbat dec": "184", "Dingbat hex": "B8", "Unicode dec": "128253", "Unicode hex": "1F4FD" },
    { "Typeface name": "Webdings", "Dingbat dec": "185", "Dingbat hex": "B9", "Unicode dec": "128249", "Unicode hex": "1F4F9" },
    { "Typeface name": "Webdings", "Dingbat dec": "186", "Dingbat hex": "BA", "Unicode dec": "128254", "Unicode hex": "1F4FE" },
    { "Typeface name": "Webdings", "Dingbat dec": "187", "Dingbat hex": "BB", "Unicode dec": "128251", "Unicode hex": "1F4FB" },
    { "Typeface name": "Webdings", "Dingbat dec": "188", "Dingbat hex": "BC", "Unicode dec": "127898", "Unicode hex": "1F39A" },
    { "Typeface name": "Webdings", "Dingbat dec": "189", "Dingbat hex": "BD", "Unicode dec": "127899", "Unicode hex": "1F39B" },
    { "Typeface name": "Webdings", "Dingbat dec": "190", "Dingbat hex": "BE", "Unicode dec": "128250", "Unicode hex": "1F4FA" },
    { "Typeface name": "Webdings", "Dingbat dec": "191", "Dingbat hex": "BF", "Unicode dec": "128187", "Unicode hex": "1F4BB" },
    { "Typeface name": "Webdings", "Dingbat dec": "192", "Dingbat hex": "C0", "Unicode dec": "128421", "Unicode hex": "1F5A5" },
    { "Typeface name": "Webdings", "Dingbat dec": "193", "Dingbat hex": "C1", "Unicode dec": "128422", "Unicode hex": "1F5A6" },
    { "Typeface name": "Webdings", "Dingbat dec": "194", "Dingbat hex": "C2", "Unicode dec": "128423", "Unicode hex": "1F5A7" },
    { "Typeface name": "Webdings", "Dingbat dec": "195", "Dingbat hex": "C3", "Unicode dec": "128377", "Unicode hex": "1F579" },
    { "Typeface name": "Webdings", "Dingbat dec": "196", "Dingbat hex": "C4", "Unicode dec": "127918", "Unicode hex": "1F3AE" },
    { "Typeface name": "Webdings", "Dingbat dec": "197", "Dingbat hex": "C5", "Unicode dec": "128379", "Unicode hex": "1F57B" },
    { "Typeface name": "Webdings", "Dingbat dec": "198", "Dingbat hex": "C6", "Unicode dec": "128380", "Unicode hex": "1F57C" },
    { "Typeface name": "Webdings", "Dingbat dec": "199", "Dingbat hex": "C7", "Unicode dec": "128223", "Unicode hex": "1F4DF" },
    { "Typeface name": "Webdings", "Dingbat dec": "200", "Dingbat hex": "C8", "Unicode dec": "128385", "Unicode hex": "1F581" },
    { "Typeface name": "Webdings", "Dingbat dec": "201", "Dingbat hex": "C9", "Unicode dec": "128384", "Unicode hex": "1F580" },
    { "Typeface name": "Webdings", "Dingbat dec": "202", "Dingbat hex": "CA", "Unicode dec": "128424", "Unicode hex": "1F5A8" },
    { "Typeface name": "Webdings", "Dingbat dec": "203", "Dingbat hex": "CB", "Unicode dec": "128425", "Unicode hex": "1F5A9" },
    { "Typeface name": "Webdings", "Dingbat dec": "204", "Dingbat hex": "CC", "Unicode dec": "128447", "Unicode hex": "1F5BF" },
    { "Typeface name": "Webdings", "Dingbat dec": "205", "Dingbat hex": "CD", "Unicode dec": "128426", "Unicode hex": "1F5AA" },
    { "Typeface name": "Webdings", "Dingbat dec": "206", "Dingbat hex": "CE", "Unicode dec": "128476", "Unicode hex": "1F5DC" },
    { "Typeface name": "Webdings", "Dingbat dec": "207", "Dingbat hex": "CF", "Unicode dec": "128274", "Unicode hex": "1F512" },
    { "Typeface name": "Webdings", "Dingbat dec": "208", "Dingbat hex": "D0", "Unicode dec": "128275", "Unicode hex": "1F513" },
    { "Typeface name": "Webdings", "Dingbat dec": "209", "Dingbat hex": "D1", "Unicode dec": "128477", "Unicode hex": "1F5DD" },
    { "Typeface name": "Webdings", "Dingbat dec": "210", "Dingbat hex": "D2", "Unicode dec": "128229", "Unicode hex": "1F4E5" },
    { "Typeface name": "Webdings", "Dingbat dec": "211", "Dingbat hex": "D3", "Unicode dec": "128228", "Unicode hex": "1F4E4" },
    { "Typeface name": "Webdings", "Dingbat dec": "212", "Dingbat hex": "D4", "Unicode dec": "128371", "Unicode hex": "1F573" },
    { "Typeface name": "Webdings", "Dingbat dec": "213", "Dingbat hex": "D5", "Unicode dec": "127779", "Unicode hex": "1F323" },
    { "Typeface name": "Webdings", "Dingbat dec": "214", "Dingbat hex": "D6", "Unicode dec": "127780", "Unicode hex": "1F324" },
    { "Typeface name": "Webdings", "Dingbat dec": "215", "Dingbat hex": "D7", "Unicode dec": "127781", "Unicode hex": "1F325" },
    { "Typeface name": "Webdings", "Dingbat dec": "216", "Dingbat hex": "D8", "Unicode dec": "127782", "Unicode hex": "1F326" },
    { "Typeface name": "Webdings", "Dingbat dec": "217", "Dingbat hex": "D9", "Unicode dec": "9729", "Unicode hex": "2601" },
    { "Typeface name": "Webdings", "Dingbat dec": "218", "Dingbat hex": "DA", "Unicode dec": "127784", "Unicode hex": "1F328" },
    { "Typeface name": "Webdings", "Dingbat dec": "219", "Dingbat hex": "DB", "Unicode dec": "127783", "Unicode hex": "1F327" },
    { "Typeface name": "Webdings", "Dingbat dec": "220", "Dingbat hex": "DC", "Unicode dec": "127785", "Unicode hex": "1F329" },
    { "Typeface name": "Webdings", "Dingbat dec": "221", "Dingbat hex": "DD", "Unicode dec": "127786", "Unicode hex": "1F32A" },
    { "Typeface name": "Webdings", "Dingbat dec": "222", "Dingbat hex": "DE", "Unicode dec": "127788", "Unicode hex": "1F32C" },
    { "Typeface name": "Webdings", "Dingbat dec": "223", "Dingbat hex": "DF", "Unicode dec": "127787", "Unicode hex": "1F32B" },
    { "Typeface name": "Webdings", "Dingbat dec": "224", "Dingbat hex": "E0", "Unicode dec": "127772", "Unicode hex": "1F31C" },
    { "Typeface name": "Webdings", "Dingbat dec": "225", "Dingbat hex": "E1", "Unicode dec": "127777", "Unicode hex": "1F321" },
    { "Typeface name": "Webdings", "Dingbat dec": "226", "Dingbat hex": "E2", "Unicode dec": "128715", "Unicode hex": "1F6CB" },
    { "Typeface name": "Webdings", "Dingbat dec": "227", "Dingbat hex": "E3", "Unicode dec": "128719", "Unicode hex": "1F6CF" },
    { "Typeface name": "Webdings", "Dingbat dec": "228", "Dingbat hex": "E4", "Unicode dec": "127869", "Unicode hex": "1F37D" },
    { "Typeface name": "Webdings", "Dingbat dec": "229", "Dingbat hex": "E5", "Unicode dec": "127864", "Unicode hex": "1F378" },
    { "Typeface name": "Webdings", "Dingbat dec": "230", "Dingbat hex": "E6", "Unicode dec": "128718", "Unicode hex": "1F6CE" },
    { "Typeface name": "Webdings", "Dingbat dec": "231", "Dingbat hex": "E7", "Unicode dec": "128717", "Unicode hex": "1F6CD" },
    { "Typeface name": "Webdings", "Dingbat dec": "232", "Dingbat hex": "E8", "Unicode dec": "9413", "Unicode hex": "24C5" },
    { "Typeface name": "Webdings", "Dingbat dec": "233", "Dingbat hex": "E9", "Unicode dec": "9855", "Unicode hex": "267F" },
    { "Typeface name": "Webdings", "Dingbat dec": "234", "Dingbat hex": "EA", "Unicode dec": "128710", "Unicode hex": "1F6C6" },
    { "Typeface name": "Webdings", "Dingbat dec": "235", "Dingbat hex": "EB", "Unicode dec": "128392", "Unicode hex": "1F588" },
    { "Typeface name": "Webdings", "Dingbat dec": "236", "Dingbat hex": "EC", "Unicode dec": "127891", "Unicode hex": "1F393" },
    { "Typeface name": "Webdings", "Dingbat dec": "237", "Dingbat hex": "ED", "Unicode dec": "128484", "Unicode hex": "1F5E4" },
    { "Typeface name": "Webdings", "Dingbat dec": "238", "Dingbat hex": "EE", "Unicode dec": "128485", "Unicode hex": "1F5E5" },
    { "Typeface name": "Webdings", "Dingbat dec": "239", "Dingbat hex": "EF", "Unicode dec": "128486", "Unicode hex": "1F5E6" },
    { "Typeface name": "Webdings", "Dingbat dec": "240", "Dingbat hex": "F0", "Unicode dec": "128487", "Unicode hex": "1F5E7" },
    { "Typeface name": "Webdings", "Dingbat dec": "241", "Dingbat hex": "F1", "Unicode dec": "128746", "Unicode hex": "1F6EA" },
    { "Typeface name": "Webdings", "Dingbat dec": "242", "Dingbat hex": "F2", "Unicode dec": "128063", "Unicode hex": "1F43F" },
    { "Typeface name": "Webdings", "Dingbat dec": "243", "Dingbat hex": "F3", "Unicode dec": "128038", "Unicode hex": "1F426" },
    { "Typeface name": "Webdings", "Dingbat dec": "244", "Dingbat hex": "F4", "Unicode dec": "128031", "Unicode hex": "1F41F" },
    { "Typeface name": "Webdings", "Dingbat dec": "245", "Dingbat hex": "F5", "Unicode dec": "128021", "Unicode hex": "1F415" },
    { "Typeface name": "Webdings", "Dingbat dec": "246", "Dingbat hex": "F6", "Unicode dec": "128008", "Unicode hex": "1F408" },
    { "Typeface name": "Webdings", "Dingbat dec": "247", "Dingbat hex": "F7", "Unicode dec": "128620", "Unicode hex": "1F66C" },
    { "Typeface name": "Webdings", "Dingbat dec": "248", "Dingbat hex": "F8", "Unicode dec": "128622", "Unicode hex": "1F66E" },
    { "Typeface name": "Webdings", "Dingbat dec": "249", "Dingbat hex": "F9", "Unicode dec": "128621", "Unicode hex": "1F66D" },
    { "Typeface name": "Webdings", "Dingbat dec": "250", "Dingbat hex": "FA", "Unicode dec": "128623", "Unicode hex": "1F66F" },
    { "Typeface name": "Webdings", "Dingbat dec": "251", "Dingbat hex": "FB", "Unicode dec": "128506", "Unicode hex": "1F5FA" },
    { "Typeface name": "Webdings", "Dingbat dec": "252", "Dingbat hex": "FC", "Unicode dec": "127757", "Unicode hex": "1F30D" },
    { "Typeface name": "Webdings", "Dingbat dec": "253", "Dingbat hex": "FD", "Unicode dec": "127759", "Unicode hex": "1F30F" },
    { "Typeface name": "Webdings", "Dingbat dec": "254", "Dingbat hex": "FE", "Unicode dec": "127758", "Unicode hex": "1F30E" },
    { "Typeface name": "Webdings", "Dingbat dec": "255", "Dingbat hex": "FF", "Unicode dec": "128330", "Unicode hex": "1F54A" },
    { "Typeface name": "Wingdings", "Dingbat dec": "32", "Dingbat hex": "20", "Unicode dec": "32", "Unicode hex": "20" },
    { "Typeface name": "Wingdings", "Dingbat dec": "33", "Dingbat hex": "21", "Unicode dec": "128393", "Unicode hex": "1F589" },
    { "Typeface name": "Wingdings", "Dingbat dec": "34", "Dingbat hex": "22", "Unicode dec": "9986", "Unicode hex": "2702" },
    { "Typeface name": "Wingdings", "Dingbat dec": "35", "Dingbat hex": "23", "Unicode dec": "9985", "Unicode hex": "2701" },
    { "Typeface name": "Wingdings", "Dingbat dec": "36", "Dingbat hex": "24", "Unicode dec": "128083", "Unicode hex": "1F453" },
    { "Typeface name": "Wingdings", "Dingbat dec": "37", "Dingbat hex": "25", "Unicode dec": "128365", "Unicode hex": "1F56D" },
    { "Typeface name": "Wingdings", "Dingbat dec": "38", "Dingbat hex": "26", "Unicode dec": "128366", "Unicode hex": "1F56E" },
    { "Typeface name": "Wingdings", "Dingbat dec": "39", "Dingbat hex": "27", "Unicode dec": "128367", "Unicode hex": "1F56F" },
    { "Typeface name": "Wingdings", "Dingbat dec": "40", "Dingbat hex": "28", "Unicode dec": "128383", "Unicode hex": "1F57F" },
    { "Typeface name": "Wingdings", "Dingbat dec": "41", "Dingbat hex": "29", "Unicode dec": "9990", "Unicode hex": "2706" },
    { "Typeface name": "Wingdings", "Dingbat dec": "42", "Dingbat hex": "2A", "Unicode dec": "128386", "Unicode hex": "1F582" },
    { "Typeface name": "Wingdings", "Dingbat dec": "43", "Dingbat hex": "2B", "Unicode dec": "128387", "Unicode hex": "1F583" },
    { "Typeface name": "Wingdings", "Dingbat dec": "44", "Dingbat hex": "2C", "Unicode dec": "128234", "Unicode hex": "1F4EA" },
    { "Typeface name": "Wingdings", "Dingbat dec": "45", "Dingbat hex": "2D", "Unicode dec": "128235", "Unicode hex": "1F4EB" },
    { "Typeface name": "Wingdings", "Dingbat dec": "46", "Dingbat hex": "2E", "Unicode dec": "128236", "Unicode hex": "1F4EC" },
    { "Typeface name": "Wingdings", "Dingbat dec": "47", "Dingbat hex": "2F", "Unicode dec": "128237", "Unicode hex": "1F4ED" },
    { "Typeface name": "Wingdings", "Dingbat dec": "48", "Dingbat hex": "30", "Unicode dec": "128448", "Unicode hex": "1F5C0" },
    { "Typeface name": "Wingdings", "Dingbat dec": "49", "Dingbat hex": "31", "Unicode dec": "128449", "Unicode hex": "1F5C1" },
    { "Typeface name": "Wingdings", "Dingbat dec": "50", "Dingbat hex": "32", "Unicode dec": "128462", "Unicode hex": "1F5CE" },
    { "Typeface name": "Wingdings", "Dingbat dec": "51", "Dingbat hex": "33", "Unicode dec": "128463", "Unicode hex": "1F5CF" },
    { "Typeface name": "Wingdings", "Dingbat dec": "52", "Dingbat hex": "34", "Unicode dec": "128464", "Unicode hex": "1F5D0" },
    { "Typeface name": "Wingdings", "Dingbat dec": "53", "Dingbat hex": "35", "Unicode dec": "128452", "Unicode hex": "1F5C4" },
    { "Typeface name": "Wingdings", "Dingbat dec": "54", "Dingbat hex": "36", "Unicode dec": "8987", "Unicode hex": "231B" },
    { "Typeface name": "Wingdings", "Dingbat dec": "55", "Dingbat hex": "37", "Unicode dec": "128430", "Unicode hex": "1F5AE" },
    { "Typeface name": "Wingdings", "Dingbat dec": "56", "Dingbat hex": "38", "Unicode dec": "128432", "Unicode hex": "1F5B0" },
    { "Typeface name": "Wingdings", "Dingbat dec": "57", "Dingbat hex": "39", "Unicode dec": "128434", "Unicode hex": "1F5B2" },
    { "Typeface name": "Wingdings", "Dingbat dec": "58", "Dingbat hex": "3A", "Unicode dec": "128435", "Unicode hex": "1F5B3" },
    { "Typeface name": "Wingdings", "Dingbat dec": "59", "Dingbat hex": "3B", "Unicode dec": "128436", "Unicode hex": "1F5B4" },
    { "Typeface name": "Wingdings", "Dingbat dec": "60", "Dingbat hex": "3C", "Unicode dec": "128427", "Unicode hex": "1F5AB" },
    { "Typeface name": "Wingdings", "Dingbat dec": "61", "Dingbat hex": "3D", "Unicode dec": "128428", "Unicode hex": "1F5AC" },
    { "Typeface name": "Wingdings", "Dingbat dec": "62", "Dingbat hex": "3E", "Unicode dec": "9991", "Unicode hex": "2707" },
    { "Typeface name": "Wingdings", "Dingbat dec": "63", "Dingbat hex": "3F", "Unicode dec": "9997", "Unicode hex": "270D" },
    { "Typeface name": "Wingdings", "Dingbat dec": "64", "Dingbat hex": "40", "Unicode dec": "128398", "Unicode hex": "1F58E" },
    { "Typeface name": "Wingdings", "Dingbat dec": "65", "Dingbat hex": "41", "Unicode dec": "9996", "Unicode hex": "270C" },
    { "Typeface name": "Wingdings", "Dingbat dec": "66", "Dingbat hex": "42", "Unicode dec": "128399", "Unicode hex": "1F58F" },
    { "Typeface name": "Wingdings", "Dingbat dec": "67", "Dingbat hex": "43", "Unicode dec": "128077", "Unicode hex": "1F44D" },
    { "Typeface name": "Wingdings", "Dingbat dec": "68", "Dingbat hex": "44", "Unicode dec": "128078", "Unicode hex": "1F44E" },
    { "Typeface name": "Wingdings", "Dingbat dec": "69", "Dingbat hex": "45", "Unicode dec": "9756", "Unicode hex": "261C" },
    { "Typeface name": "Wingdings", "Dingbat dec": "70", "Dingbat hex": "46", "Unicode dec": "9758", "Unicode hex": "261E" },
    { "Typeface name": "Wingdings", "Dingbat dec": "71", "Dingbat hex": "47", "Unicode dec": "9757", "Unicode hex": "261D" },
    { "Typeface name": "Wingdings", "Dingbat dec": "72", "Dingbat hex": "48", "Unicode dec": "9759", "Unicode hex": "261F" },
    { "Typeface name": "Wingdings", "Dingbat dec": "73", "Dingbat hex": "49", "Unicode dec": "128400", "Unicode hex": "1F590" },
    { "Typeface name": "Wingdings", "Dingbat dec": "74", "Dingbat hex": "4A", "Unicode dec": "9786", "Unicode hex": "263A" },
    { "Typeface name": "Wingdings", "Dingbat dec": "75", "Dingbat hex": "4B", "Unicode dec": "128528", "Unicode hex": "1F610" },
    { "Typeface name": "Wingdings", "Dingbat dec": "76", "Dingbat hex": "4C", "Unicode dec": "9785", "Unicode hex": "2639" },
    { "Typeface name": "Wingdings", "Dingbat dec": "77", "Dingbat hex": "4D", "Unicode dec": "128163", "Unicode hex": "1F4A3" },
    { "Typeface name": "Wingdings", "Dingbat dec": "78", "Dingbat hex": "4E", "Unicode dec": "128369", "Unicode hex": "1F571" },
    { "Typeface name": "Wingdings", "Dingbat dec": "79", "Dingbat hex": "4F", "Unicode dec": "127987", "Unicode hex": "1F3F3" },
    { "Typeface name": "Wingdings", "Dingbat dec": "80", "Dingbat hex": "50", "Unicode dec": "127985", "Unicode hex": "1F3F1" },
    { "Typeface name": "Wingdings", "Dingbat dec": "81", "Dingbat hex": "51", "Unicode dec": "9992", "Unicode hex": "2708" },
    { "Typeface name": "Wingdings", "Dingbat dec": "82", "Dingbat hex": "52", "Unicode dec": "9788", "Unicode hex": "263C" },
    { "Typeface name": "Wingdings", "Dingbat dec": "83", "Dingbat hex": "53", "Unicode dec": "127778", "Unicode hex": "1F322" },
    { "Typeface name": "Wingdings", "Dingbat dec": "84", "Dingbat hex": "54", "Unicode dec": "10052", "Unicode hex": "2744" },
    { "Typeface name": "Wingdings", "Dingbat dec": "85", "Dingbat hex": "55", "Unicode dec": "128326", "Unicode hex": "1F546" },
    { "Typeface name": "Wingdings", "Dingbat dec": "86", "Dingbat hex": "56", "Unicode dec": "10014", "Unicode hex": "271E" },
    { "Typeface name": "Wingdings", "Dingbat dec": "87", "Dingbat hex": "57", "Unicode dec": "128328", "Unicode hex": "1F548" },
    { "Typeface name": "Wingdings", "Dingbat dec": "88", "Dingbat hex": "58", "Unicode dec": "10016", "Unicode hex": "2720" },
    { "Typeface name": "Wingdings", "Dingbat dec": "89", "Dingbat hex": "59", "Unicode dec": "10017", "Unicode hex": "2721" },
    { "Typeface name": "Wingdings", "Dingbat dec": "90", "Dingbat hex": "5A", "Unicode dec": "9770", "Unicode hex": "262A" },
    { "Typeface name": "Wingdings", "Dingbat dec": "91", "Dingbat hex": "5B", "Unicode dec": "9775", "Unicode hex": "262F" },
    { "Typeface name": "Wingdings", "Dingbat dec": "92", "Dingbat hex": "5C", "Unicode dec": "128329", "Unicode hex": "1F549" },
    { "Typeface name": "Wingdings", "Dingbat dec": "93", "Dingbat hex": "5D", "Unicode dec": "9784", "Unicode hex": "2638" },
    { "Typeface name": "Wingdings", "Dingbat dec": "94", "Dingbat hex": "5E", "Unicode dec": "9800", "Unicode hex": "2648" },
    { "Typeface name": "Wingdings", "Dingbat dec": "95", "Dingbat hex": "5F", "Unicode dec": "9801", "Unicode hex": "2649" },
    { "Typeface name": "Wingdings", "Dingbat dec": "96", "Dingbat hex": "60", "Unicode dec": "9802", "Unicode hex": "264A" },
    { "Typeface name": "Wingdings", "Dingbat dec": "97", "Dingbat hex": "61", "Unicode dec": "9803", "Unicode hex": "264B" },
    { "Typeface name": "Wingdings", "Dingbat dec": "98", "Dingbat hex": "62", "Unicode dec": "9804", "Unicode hex": "264C" },
    { "Typeface name": "Wingdings", "Dingbat dec": "99", "Dingbat hex": "63", "Unicode dec": "9805", "Unicode hex": "264D" },
    { "Typeface name": "Wingdings", "Dingbat dec": "100", "Dingbat hex": "64", "Unicode dec": "9806", "Unicode hex": "264E" },
    { "Typeface name": "Wingdings", "Dingbat dec": "101", "Dingbat hex": "65", "Unicode dec": "9807", "Unicode hex": "264F" },
    { "Typeface name": "Wingdings", "Dingbat dec": "102", "Dingbat hex": "66", "Unicode dec": "9808", "Unicode hex": "2650" },
    { "Typeface name": "Wingdings", "Dingbat dec": "103", "Dingbat hex": "67", "Unicode dec": "9809", "Unicode hex": "2651" },
    { "Typeface name": "Wingdings", "Dingbat dec": "104", "Dingbat hex": "68", "Unicode dec": "9810", "Unicode hex": "2652" },
    { "Typeface name": "Wingdings", "Dingbat dec": "105", "Dingbat hex": "69", "Unicode dec": "9811", "Unicode hex": "2653" },
    { "Typeface name": "Wingdings", "Dingbat dec": "106", "Dingbat hex": "6A", "Unicode dec": "128624", "Unicode hex": "1F670" },
    { "Typeface name": "Wingdings", "Dingbat dec": "107", "Dingbat hex": "6B", "Unicode dec": "128629", "Unicode hex": "1F675" },
    { "Typeface name": "Wingdings", "Dingbat dec": "108", "Dingbat hex": "6C", "Unicode dec": "9899", "Unicode hex": "26AB" },
    { "Typeface name": "Wingdings", "Dingbat dec": "109", "Dingbat hex": "6D", "Unicode dec": "128318", "Unicode hex": "1F53E" },
    { "Typeface name": "Wingdings", "Dingbat dec": "110", "Dingbat hex": "6E", "Unicode dec": "9724", "Unicode hex": "25FC" },
    { "Typeface name": "Wingdings", "Dingbat dec": "111", "Dingbat hex": "6F", "Unicode dec": "128911", "Unicode hex": "1F78F" },
    { "Typeface name": "Wingdings", "Dingbat dec": "112", "Dingbat hex": "70", "Unicode dec": "128912", "Unicode hex": "1F790" },
    { "Typeface name": "Wingdings", "Dingbat dec": "113", "Dingbat hex": "71", "Unicode dec": "10065", "Unicode hex": "2751" },
    { "Typeface name": "Wingdings", "Dingbat dec": "114", "Dingbat hex": "72", "Unicode dec": "10066", "Unicode hex": "2752" },
    { "Typeface name": "Wingdings", "Dingbat dec": "115", "Dingbat hex": "73", "Unicode dec": "128927", "Unicode hex": "1F79F" },
    { "Typeface name": "Wingdings", "Dingbat dec": "116", "Dingbat hex": "74", "Unicode dec": "10731", "Unicode hex": "29EB" },
    { "Typeface name": "Wingdings", "Dingbat dec": "117", "Dingbat hex": "75", "Unicode dec": "9670", "Unicode hex": "25C6" },
    { "Typeface name": "Wingdings", "Dingbat dec": "118", "Dingbat hex": "76", "Unicode dec": "10070", "Unicode hex": "2756" },
    { "Typeface name": "Wingdings", "Dingbat dec": "119", "Dingbat hex": "77", "Unicode dec": "11049", "Unicode hex": "2B29" },
    { "Typeface name": "Wingdings", "Dingbat dec": "120", "Dingbat hex": "78", "Unicode dec": "8999", "Unicode hex": "2327" },
    { "Typeface name": "Wingdings", "Dingbat dec": "121", "Dingbat hex": "79", "Unicode dec": "11193", "Unicode hex": "2BB9" },
    { "Typeface name": "Wingdings", "Dingbat dec": "122", "Dingbat hex": "7A", "Unicode dec": "8984", "Unicode hex": "2318" },
    { "Typeface name": "Wingdings", "Dingbat dec": "123", "Dingbat hex": "7B", "Unicode dec": "127989", "Unicode hex": "1F3F5" },
    { "Typeface name": "Wingdings", "Dingbat dec": "124", "Dingbat hex": "7C", "Unicode dec": "127990", "Unicode hex": "1F3F6" },
    { "Typeface name": "Wingdings", "Dingbat dec": "125", "Dingbat hex": "7D", "Unicode dec": "128630", "Unicode hex": "1F676" },
    { "Typeface name": "Wingdings", "Dingbat dec": "126", "Dingbat hex": "7E", "Unicode dec": "128631", "Unicode hex": "1F677" },
    { "Typeface name": "Wingdings", "Dingbat dec": "127", "Dingbat hex": "7F", "Unicode dec": "9647", "Unicode hex": "25AF" },
    { "Typeface name": "Wingdings", "Dingbat dec": "128", "Dingbat hex": "80", "Unicode dec": "127243", "Unicode hex": "1F10B" },
    { "Typeface name": "Wingdings", "Dingbat dec": "129", "Dingbat hex": "81", "Unicode dec": "10112", "Unicode hex": "2780" },
    { "Typeface name": "Wingdings", "Dingbat dec": "130", "Dingbat hex": "82", "Unicode dec": "10113", "Unicode hex": "2781" },
    { "Typeface name": "Wingdings", "Dingbat dec": "131", "Dingbat hex": "83", "Unicode dec": "10114", "Unicode hex": "2782" },
    { "Typeface name": "Wingdings", "Dingbat dec": "132", "Dingbat hex": "84", "Unicode dec": "10115", "Unicode hex": "2783" },
    { "Typeface name": "Wingdings", "Dingbat dec": "133", "Dingbat hex": "85", "Unicode dec": "10116", "Unicode hex": "2784" },
    { "Typeface name": "Wingdings", "Dingbat dec": "134", "Dingbat hex": "86", "Unicode dec": "10117", "Unicode hex": "2785" },
    { "Typeface name": "Wingdings", "Dingbat dec": "135", "Dingbat hex": "87", "Unicode dec": "10118", "Unicode hex": "2786" },
    { "Typeface name": "Wingdings", "Dingbat dec": "136", "Dingbat hex": "88", "Unicode dec": "10119", "Unicode hex": "2787" },
    { "Typeface name": "Wingdings", "Dingbat dec": "137", "Dingbat hex": "89", "Unicode dec": "10120", "Unicode hex": "2788" },
    { "Typeface name": "Wingdings", "Dingbat dec": "138", "Dingbat hex": "8A", "Unicode dec": "10121", "Unicode hex": "2789" },
    { "Typeface name": "Wingdings", "Dingbat dec": "139", "Dingbat hex": "8B", "Unicode dec": "127244", "Unicode hex": "1F10C" },
    { "Typeface name": "Wingdings", "Dingbat dec": "140", "Dingbat hex": "8C", "Unicode dec": "10122", "Unicode hex": "278A" },
    { "Typeface name": "Wingdings", "Dingbat dec": "141", "Dingbat hex": "8D", "Unicode dec": "10123", "Unicode hex": "278B" },
    { "Typeface name": "Wingdings", "Dingbat dec": "142", "Dingbat hex": "8E", "Unicode dec": "10124", "Unicode hex": "278C" },
    { "Typeface name": "Wingdings", "Dingbat dec": "143", "Dingbat hex": "8F", "Unicode dec": "10125", "Unicode hex": "278D" },
    { "Typeface name": "Wingdings", "Dingbat dec": "144", "Dingbat hex": "90", "Unicode dec": "10126", "Unicode hex": "278E" },
    { "Typeface name": "Wingdings", "Dingbat dec": "145", "Dingbat hex": "91", "Unicode dec": "10127", "Unicode hex": "278F" },
    { "Typeface name": "Wingdings", "Dingbat dec": "146", "Dingbat hex": "92", "Unicode dec": "10128", "Unicode hex": "2790" },
    { "Typeface name": "Wingdings", "Dingbat dec": "147", "Dingbat hex": "93", "Unicode dec": "10129", "Unicode hex": "2791" },
    { "Typeface name": "Wingdings", "Dingbat dec": "148", "Dingbat hex": "94", "Unicode dec": "10130", "Unicode hex": "2792" },
    { "Typeface name": "Wingdings", "Dingbat dec": "149", "Dingbat hex": "95", "Unicode dec": "10131", "Unicode hex": "2793" },
    { "Typeface name": "Wingdings", "Dingbat dec": "150", "Dingbat hex": "96", "Unicode dec": "128610", "Unicode hex": "1F662" },
    { "Typeface name": "Wingdings", "Dingbat dec": "151", "Dingbat hex": "97", "Unicode dec": "128608", "Unicode hex": "1F660" },
    { "Typeface name": "Wingdings", "Dingbat dec": "152", "Dingbat hex": "98", "Unicode dec": "128609", "Unicode hex": "1F661" },
    { "Typeface name": "Wingdings", "Dingbat dec": "153", "Dingbat hex": "99", "Unicode dec": "128611", "Unicode hex": "1F663" },
    { "Typeface name": "Wingdings", "Dingbat dec": "154", "Dingbat hex": "9A", "Unicode dec": "128606", "Unicode hex": "1F65E" },
    { "Typeface name": "Wingdings", "Dingbat dec": "155", "Dingbat hex": "9B", "Unicode dec": "128604", "Unicode hex": "1F65C" },
    { "Typeface name": "Wingdings", "Dingbat dec": "156", "Dingbat hex": "9C", "Unicode dec": "128605", "Unicode hex": "1F65D" },
    { "Typeface name": "Wingdings", "Dingbat dec": "157", "Dingbat hex": "9D", "Unicode dec": "128607", "Unicode hex": "1F65F" },
    { "Typeface name": "Wingdings", "Dingbat dec": "158", "Dingbat hex": "9E", "Unicode dec": "8729", "Unicode hex": "2219" },
    { "Typeface name": "Wingdings", "Dingbat dec": "159", "Dingbat hex": "9F", "Unicode dec": "8226", "Unicode hex": "2022" },
    { "Typeface name": "Wingdings", "Dingbat dec": "160", "Dingbat hex": "A0", "Unicode dec": "11037", "Unicode hex": "2B1D" },
    { "Typeface name": "Wingdings", "Dingbat dec": "161", "Dingbat hex": "A1", "Unicode dec": "11096", "Unicode hex": "2B58" },
    { "Typeface name": "Wingdings", "Dingbat dec": "162", "Dingbat hex": "A2", "Unicode dec": "128902", "Unicode hex": "1F786" },
    { "Typeface name": "Wingdings", "Dingbat dec": "163", "Dingbat hex": "A3", "Unicode dec": "128904", "Unicode hex": "1F788" },
    { "Typeface name": "Wingdings", "Dingbat dec": "164", "Dingbat hex": "A4", "Unicode dec": "128906", "Unicode hex": "1F78A" },
    { "Typeface name": "Wingdings", "Dingbat dec": "165", "Dingbat hex": "A5", "Unicode dec": "128907", "Unicode hex": "1F78B" },
    { "Typeface name": "Wingdings", "Dingbat dec": "166", "Dingbat hex": "A6", "Unicode dec": "128319", "Unicode hex": "1F53F" },
    { "Typeface name": "Wingdings", "Dingbat dec": "167", "Dingbat hex": "A7", "Unicode dec": "9642", "Unicode hex": "25AA" },
    { "Typeface name": "Wingdings", "Dingbat dec": "168", "Dingbat hex": "A8", "Unicode dec": "128910", "Unicode hex": "1F78E" },
    { "Typeface name": "Wingdings", "Dingbat dec": "169", "Dingbat hex": "A9", "Unicode dec": "128961", "Unicode hex": "1F7C1" },
    { "Typeface name": "Wingdings", "Dingbat dec": "170", "Dingbat hex": "AA", "Unicode dec": "128965", "Unicode hex": "1F7C5" },
    { "Typeface name": "Wingdings", "Dingbat dec": "171", "Dingbat hex": "AB", "Unicode dec": "9733", "Unicode hex": "2605" },
    { "Typeface name": "Wingdings", "Dingbat dec": "172", "Dingbat hex": "AC", "Unicode dec": "128971", "Unicode hex": "1F7CB" },
    { "Typeface name": "Wingdings", "Dingbat dec": "173", "Dingbat hex": "AD", "Unicode dec": "128975", "Unicode hex": "1F7CF" },
    { "Typeface name": "Wingdings", "Dingbat dec": "174", "Dingbat hex": "AE", "Unicode dec": "128979", "Unicode hex": "1F7D3" },
    { "Typeface name": "Wingdings", "Dingbat dec": "175", "Dingbat hex": "AF", "Unicode dec": "128977", "Unicode hex": "1F7D1" },
    { "Typeface name": "Wingdings", "Dingbat dec": "176", "Dingbat hex": "B0", "Unicode dec": "11216", "Unicode hex": "2BD0" },
    { "Typeface name": "Wingdings", "Dingbat dec": "177", "Dingbat hex": "B1", "Unicode dec": "8982", "Unicode hex": "2316" },
    { "Typeface name": "Wingdings", "Dingbat dec": "178", "Dingbat hex": "B2", "Unicode dec": "11214", "Unicode hex": "2BCE" },
    { "Typeface name": "Wingdings", "Dingbat dec": "179", "Dingbat hex": "B3", "Unicode dec": "11215", "Unicode hex": "2BCF" },
    { "Typeface name": "Wingdings", "Dingbat dec": "180", "Dingbat hex": "B4", "Unicode dec": "11217", "Unicode hex": "2BD1" },
    { "Typeface name": "Wingdings", "Dingbat dec": "181", "Dingbat hex": "B5", "Unicode dec": "10026", "Unicode hex": "272A" },
    { "Typeface name": "Wingdings", "Dingbat dec": "182", "Dingbat hex": "B6", "Unicode dec": "10032", "Unicode hex": "2730" },
    { "Typeface name": "Wingdings", "Dingbat dec": "183", "Dingbat hex": "B7", "Unicode dec": "128336", "Unicode hex": "1F550" },
    { "Typeface name": "Wingdings", "Dingbat dec": "184", "Dingbat hex": "B8", "Unicode dec": "128337", "Unicode hex": "1F551" },
    { "Typeface name": "Wingdings", "Dingbat dec": "185", "Dingbat hex": "B9", "Unicode dec": "128338", "Unicode hex": "1F552" },
    { "Typeface name": "Wingdings", "Dingbat dec": "186", "Dingbat hex": "BA", "Unicode dec": "128339", "Unicode hex": "1F553" },
    { "Typeface name": "Wingdings", "Dingbat dec": "187", "Dingbat hex": "BB", "Unicode dec": "128340", "Unicode hex": "1F554" },
    { "Typeface name": "Wingdings", "Dingbat dec": "188", "Dingbat hex": "BC", "Unicode dec": "128341", "Unicode hex": "1F555" },
    { "Typeface name": "Wingdings", "Dingbat dec": "189", "Dingbat hex": "BD", "Unicode dec": "128342", "Unicode hex": "1F556" },
    { "Typeface name": "Wingdings", "Dingbat dec": "190", "Dingbat hex": "BE", "Unicode dec": "128343", "Unicode hex": "1F557" },
    { "Typeface name": "Wingdings", "Dingbat dec": "191", "Dingbat hex": "BF", "Unicode dec": "128344", "Unicode hex": "1F558" },
    { "Typeface name": "Wingdings", "Dingbat dec": "192", "Dingbat hex": "C0", "Unicode dec": "128345", "Unicode hex": "1F559" },
    { "Typeface name": "Wingdings", "Dingbat dec": "193", "Dingbat hex": "C1", "Unicode dec": "128346", "Unicode hex": "1F55A" },
    { "Typeface name": "Wingdings", "Dingbat dec": "194", "Dingbat hex": "C2", "Unicode dec": "128347", "Unicode hex": "1F55B" },
    { "Typeface name": "Wingdings", "Dingbat dec": "195", "Dingbat hex": "C3", "Unicode dec": "11184", "Unicode hex": "2BB0" },
    { "Typeface name": "Wingdings", "Dingbat dec": "196", "Dingbat hex": "C4", "Unicode dec": "11185", "Unicode hex": "2BB1" },
    { "Typeface name": "Wingdings", "Dingbat dec": "197", "Dingbat hex": "C5", "Unicode dec": "11186", "Unicode hex": "2BB2" },
    { "Typeface name": "Wingdings", "Dingbat dec": "198", "Dingbat hex": "C6", "Unicode dec": "11187", "Unicode hex": "2BB3" },
    { "Typeface name": "Wingdings", "Dingbat dec": "199", "Dingbat hex": "C7", "Unicode dec": "11188", "Unicode hex": "2BB4" },
    { "Typeface name": "Wingdings", "Dingbat dec": "200", "Dingbat hex": "C8", "Unicode dec": "11189", "Unicode hex": "2BB5" },
    { "Typeface name": "Wingdings", "Dingbat dec": "201", "Dingbat hex": "C9", "Unicode dec": "11190", "Unicode hex": "2BB6" },
    { "Typeface name": "Wingdings", "Dingbat dec": "202", "Dingbat hex": "CA", "Unicode dec": "11191", "Unicode hex": "2BB7" },
    { "Typeface name": "Wingdings", "Dingbat dec": "203", "Dingbat hex": "CB", "Unicode dec": "128618", "Unicode hex": "1F66A" },
    { "Typeface name": "Wingdings", "Dingbat dec": "204", "Dingbat hex": "CC", "Unicode dec": "128619", "Unicode hex": "1F66B" },
    { "Typeface name": "Wingdings", "Dingbat dec": "205", "Dingbat hex": "CD", "Unicode dec": "128597", "Unicode hex": "1F655" },
    { "Typeface name": "Wingdings", "Dingbat dec": "206", "Dingbat hex": "CE", "Unicode dec": "128596", "Unicode hex": "1F654" },
    { "Typeface name": "Wingdings", "Dingbat dec": "207", "Dingbat hex": "CF", "Unicode dec": "128599", "Unicode hex": "1F657" },
    { "Typeface name": "Wingdings", "Dingbat dec": "208", "Dingbat hex": "D0", "Unicode dec": "128598", "Unicode hex": "1F656" },
    { "Typeface name": "Wingdings", "Dingbat dec": "209", "Dingbat hex": "D1", "Unicode dec": "128592", "Unicode hex": "1F650" },
    { "Typeface name": "Wingdings", "Dingbat dec": "210", "Dingbat hex": "D2", "Unicode dec": "128593", "Unicode hex": "1F651" },
    { "Typeface name": "Wingdings", "Dingbat dec": "211", "Dingbat hex": "D3", "Unicode dec": "128594", "Unicode hex": "1F652" },
    { "Typeface name": "Wingdings", "Dingbat dec": "212", "Dingbat hex": "D4", "Unicode dec": "128595", "Unicode hex": "1F653" },
    { "Typeface name": "Wingdings", "Dingbat dec": "213", "Dingbat hex": "D5", "Unicode dec": "9003", "Unicode hex": "232B" },
    { "Typeface name": "Wingdings", "Dingbat dec": "214", "Dingbat hex": "D6", "Unicode dec": "8998", "Unicode hex": "2326" },
    { "Typeface name": "Wingdings", "Dingbat dec": "215", "Dingbat hex": "D7", "Unicode dec": "11160", "Unicode hex": "2B98" },
    { "Typeface name": "Wingdings", "Dingbat dec": "216", "Dingbat hex": "D8", "Unicode dec": "11162", "Unicode hex": "2B9A" },
    { "Typeface name": "Wingdings", "Dingbat dec": "217", "Dingbat hex": "D9", "Unicode dec": "11161", "Unicode hex": "2B99" },
    { "Typeface name": "Wingdings", "Dingbat dec": "218", "Dingbat hex": "DA", "Unicode dec": "11163", "Unicode hex": "2B9B" },
    { "Typeface name": "Wingdings", "Dingbat dec": "219", "Dingbat hex": "DB", "Unicode dec": "11144", "Unicode hex": "2B88" },
    { "Typeface name": "Wingdings", "Dingbat dec": "220", "Dingbat hex": "DC", "Unicode dec": "11146", "Unicode hex": "2B8A" },
    { "Typeface name": "Wingdings", "Dingbat dec": "221", "Dingbat hex": "DD", "Unicode dec": "11145", "Unicode hex": "2B89" },
    { "Typeface name": "Wingdings", "Dingbat dec": "222", "Dingbat hex": "DE", "Unicode dec": "11147", "Unicode hex": "2B8B" },
    { "Typeface name": "Wingdings", "Dingbat dec": "223", "Dingbat hex": "DF", "Unicode dec": "129128", "Unicode hex": "1F868" },
    { "Typeface name": "Wingdings", "Dingbat dec": "224", "Dingbat hex": "E0", "Unicode dec": "129130", "Unicode hex": "1F86A" },
    { "Typeface name": "Wingdings", "Dingbat dec": "225", "Dingbat hex": "E1", "Unicode dec": "129129", "Unicode hex": "1F869" },
    { "Typeface name": "Wingdings", "Dingbat dec": "226", "Dingbat hex": "E2", "Unicode dec": "129131", "Unicode hex": "1F86B" },
    { "Typeface name": "Wingdings", "Dingbat dec": "227", "Dingbat hex": "E3", "Unicode dec": "129132", "Unicode hex": "1F86C" },
    { "Typeface name": "Wingdings", "Dingbat dec": "228", "Dingbat hex": "E4", "Unicode dec": "129133", "Unicode hex": "1F86D" },
    { "Typeface name": "Wingdings", "Dingbat dec": "229", "Dingbat hex": "E5", "Unicode dec": "129135", "Unicode hex": "1F86F" },
    { "Typeface name": "Wingdings", "Dingbat dec": "230", "Dingbat hex": "E6", "Unicode dec": "129134", "Unicode hex": "1F86E" },
    { "Typeface name": "Wingdings", "Dingbat dec": "231", "Dingbat hex": "E7", "Unicode dec": "129144", "Unicode hex": "1F878" },
    { "Typeface name": "Wingdings", "Dingbat dec": "232", "Dingbat hex": "E8", "Unicode dec": "129146", "Unicode hex": "1F87A" },
    { "Typeface name": "Wingdings", "Dingbat dec": "233", "Dingbat hex": "E9", "Unicode dec": "129145", "Unicode hex": "1F879" },
    { "Typeface name": "Wingdings", "Dingbat dec": "234", "Dingbat hex": "EA", "Unicode dec": "129147", "Unicode hex": "1F87B" },
    { "Typeface name": "Wingdings", "Dingbat dec": "235", "Dingbat hex": "EB", "Unicode dec": "129148", "Unicode hex": "1F87C" },
    { "Typeface name": "Wingdings", "Dingbat dec": "236", "Dingbat hex": "EC", "Unicode dec": "129149", "Unicode hex": "1F87D" },
    { "Typeface name": "Wingdings", "Dingbat dec": "237", "Dingbat hex": "ED", "Unicode dec": "129151", "Unicode hex": "1F87F" },
    { "Typeface name": "Wingdings", "Dingbat dec": "238", "Dingbat hex": "EE", "Unicode dec": "129150", "Unicode hex": "1F87E" },
    { "Typeface name": "Wingdings", "Dingbat dec": "239", "Dingbat hex": "EF", "Unicode dec": "8678", "Unicode hex": "21E6" },
    { "Typeface name": "Wingdings", "Dingbat dec": "240", "Dingbat hex": "F0", "Unicode dec": "8680", "Unicode hex": "21E8" },
    { "Typeface name": "Wingdings", "Dingbat dec": "241", "Dingbat hex": "F1", "Unicode dec": "8679", "Unicode hex": "21E7" },
    { "Typeface name": "Wingdings", "Dingbat dec": "242", "Dingbat hex": "F2", "Unicode dec": "8681", "Unicode hex": "21E9" },
    { "Typeface name": "Wingdings", "Dingbat dec": "243", "Dingbat hex": "F3", "Unicode dec": "11012", "Unicode hex": "2B04" },
    { "Typeface name": "Wingdings", "Dingbat dec": "244", "Dingbat hex": "F4", "Unicode dec": "8691", "Unicode hex": "21F3" },
    { "Typeface name": "Wingdings", "Dingbat dec": "245", "Dingbat hex": "F5", "Unicode dec": "11009", "Unicode hex": "2B01" },
    { "Typeface name": "Wingdings", "Dingbat dec": "246", "Dingbat hex": "F6", "Unicode dec": "11008", "Unicode hex": "2B00" },
    { "Typeface name": "Wingdings", "Dingbat dec": "247", "Dingbat hex": "F7", "Unicode dec": "11011", "Unicode hex": "2B03" },
    { "Typeface name": "Wingdings", "Dingbat dec": "248", "Dingbat hex": "F8", "Unicode dec": "11010", "Unicode hex": "2B02" },
    { "Typeface name": "Wingdings", "Dingbat dec": "249", "Dingbat hex": "F9", "Unicode dec": "129196", "Unicode hex": "1F8AC" },
    { "Typeface name": "Wingdings", "Dingbat dec": "250", "Dingbat hex": "FA", "Unicode dec": "129197", "Unicode hex": "1F8AD" },
    { "Typeface name": "Wingdings", "Dingbat dec": "251", "Dingbat hex": "FB", "Unicode dec": "128502", "Unicode hex": "1F5F6" },
    { "Typeface name": "Wingdings", "Dingbat dec": "252", "Dingbat hex": "FC", "Unicode dec": "10003", "Unicode hex": "2713" },
    { "Typeface name": "Wingdings", "Dingbat dec": "253", "Dingbat hex": "FD", "Unicode dec": "128503", "Unicode hex": "1F5F7" },
    { "Typeface name": "Wingdings", "Dingbat dec": "254", "Dingbat hex": "FE", "Unicode dec": "128505", "Unicode hex": "1F5F9" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "32", "Dingbat hex": "20", "Unicode dec": "32", "Unicode hex": "20" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "33", "Dingbat hex": "21", "Unicode dec": "128394", "Unicode hex": "1F58A" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "34", "Dingbat hex": "22", "Unicode dec": "128395", "Unicode hex": "1F58B" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "35", "Dingbat hex": "23", "Unicode dec": "128396", "Unicode hex": "1F58C" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "36", "Dingbat hex": "24", "Unicode dec": "128397", "Unicode hex": "1F58D" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "37", "Dingbat hex": "25", "Unicode dec": "9988", "Unicode hex": "2704" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "38", "Dingbat hex": "26", "Unicode dec": "9984", "Unicode hex": "2700" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "39", "Dingbat hex": "27", "Unicode dec": "128382", "Unicode hex": "1F57E" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "40", "Dingbat hex": "28", "Unicode dec": "128381", "Unicode hex": "1F57D" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "41", "Dingbat hex": "29", "Unicode dec": "128453", "Unicode hex": "1F5C5" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "42", "Dingbat hex": "2A", "Unicode dec": "128454", "Unicode hex": "1F5C6" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "43", "Dingbat hex": "2B", "Unicode dec": "128455", "Unicode hex": "1F5C7" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "44", "Dingbat hex": "2C", "Unicode dec": "128456", "Unicode hex": "1F5C8" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "45", "Dingbat hex": "2D", "Unicode dec": "128457", "Unicode hex": "1F5C9" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "46", "Dingbat hex": "2E", "Unicode dec": "128458", "Unicode hex": "1F5CA" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "47", "Dingbat hex": "2F", "Unicode dec": "128459", "Unicode hex": "1F5CB" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "48", "Dingbat hex": "30", "Unicode dec": "128460", "Unicode hex": "1F5CC" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "49", "Dingbat hex": "31", "Unicode dec": "128461", "Unicode hex": "1F5CD" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "50", "Dingbat hex": "32", "Unicode dec": "128203", "Unicode hex": "1F4CB" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "51", "Dingbat hex": "33", "Unicode dec": "128465", "Unicode hex": "1F5D1" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "52", "Dingbat hex": "34", "Unicode dec": "128468", "Unicode hex": "1F5D4" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "53", "Dingbat hex": "35", "Unicode dec": "128437", "Unicode hex": "1F5B5" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "54", "Dingbat hex": "36", "Unicode dec": "128438", "Unicode hex": "1F5B6" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "55", "Dingbat hex": "37", "Unicode dec": "128439", "Unicode hex": "1F5B7" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "56", "Dingbat hex": "38", "Unicode dec": "128440", "Unicode hex": "1F5B8" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "57", "Dingbat hex": "39", "Unicode dec": "128429", "Unicode hex": "1F5AD" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "58", "Dingbat hex": "3A", "Unicode dec": "128431", "Unicode hex": "1F5AF" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "59", "Dingbat hex": "3B", "Unicode dec": "128433", "Unicode hex": "1F5B1" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "60", "Dingbat hex": "3C", "Unicode dec": "128402", "Unicode hex": "1F592" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "61", "Dingbat hex": "3D", "Unicode dec": "128403", "Unicode hex": "1F593" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "62", "Dingbat hex": "3E", "Unicode dec": "128408", "Unicode hex": "1F598" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "63", "Dingbat hex": "3F", "Unicode dec": "128409", "Unicode hex": "1F599" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "64", "Dingbat hex": "40", "Unicode dec": "128410", "Unicode hex": "1F59A" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "65", "Dingbat hex": "41", "Unicode dec": "128411", "Unicode hex": "1F59B" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "66", "Dingbat hex": "42", "Unicode dec": "128072", "Unicode hex": "1F448" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "67", "Dingbat hex": "43", "Unicode dec": "128073", "Unicode hex": "1F449" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "68", "Dingbat hex": "44", "Unicode dec": "128412", "Unicode hex": "1F59C" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "69", "Dingbat hex": "45", "Unicode dec": "128413", "Unicode hex": "1F59D" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "70", "Dingbat hex": "46", "Unicode dec": "128414", "Unicode hex": "1F59E" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "71", "Dingbat hex": "47", "Unicode dec": "128415", "Unicode hex": "1F59F" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "72", "Dingbat hex": "48", "Unicode dec": "128416", "Unicode hex": "1F5A0" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "73", "Dingbat hex": "49", "Unicode dec": "128417", "Unicode hex": "1F5A1" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "74", "Dingbat hex": "4A", "Unicode dec": "128070", "Unicode hex": "1F446" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "75", "Dingbat hex": "4B", "Unicode dec": "128071", "Unicode hex": "1F447" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "76", "Dingbat hex": "4C", "Unicode dec": "128418", "Unicode hex": "1F5A2" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "77", "Dingbat hex": "4D", "Unicode dec": "128419", "Unicode hex": "1F5A3" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "78", "Dingbat hex": "4E", "Unicode dec": "128401", "Unicode hex": "1F591" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "79", "Dingbat hex": "4F", "Unicode dec": "128500", "Unicode hex": "1F5F4" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "80", "Dingbat hex": "50", "Unicode dec": "128504", "Unicode hex": "1F5F8" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "81", "Dingbat hex": "51", "Unicode dec": "128501", "Unicode hex": "1F5F5" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "82", "Dingbat hex": "52", "Unicode dec": "9745", "Unicode hex": "2611" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "83", "Dingbat hex": "53", "Unicode dec": "11197", "Unicode hex": "2BBD" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "84", "Dingbat hex": "54", "Unicode dec": "9746", "Unicode hex": "2612" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "85", "Dingbat hex": "55", "Unicode dec": "11198", "Unicode hex": "2BBE" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "86", "Dingbat hex": "56", "Unicode dec": "11199", "Unicode hex": "2BBF" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "87", "Dingbat hex": "57", "Unicode dec": "128711", "Unicode hex": "1F6C7" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "88", "Dingbat hex": "58", "Unicode dec": "10680", "Unicode hex": "29B8" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "89", "Dingbat hex": "59", "Unicode dec": "128625", "Unicode hex": "1F671" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "90", "Dingbat hex": "5A", "Unicode dec": "128628", "Unicode hex": "1F674" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "91", "Dingbat hex": "5B", "Unicode dec": "128626", "Unicode hex": "1F672" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "92", "Dingbat hex": "5C", "Unicode dec": "128627", "Unicode hex": "1F673" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "93", "Dingbat hex": "5D", "Unicode dec": "8253", "Unicode hex": "203D" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "94", "Dingbat hex": "5E", "Unicode dec": "128633", "Unicode hex": "1F679" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "95", "Dingbat hex": "5F", "Unicode dec": "128634", "Unicode hex": "1F67A" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "96", "Dingbat hex": "60", "Unicode dec": "128635", "Unicode hex": "1F67B" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "97", "Dingbat hex": "61", "Unicode dec": "128614", "Unicode hex": "1F666" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "98", "Dingbat hex": "62", "Unicode dec": "128612", "Unicode hex": "1F664" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "99", "Dingbat hex": "63", "Unicode dec": "128613", "Unicode hex": "1F665" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "100", "Dingbat hex": "64", "Unicode dec": "128615", "Unicode hex": "1F667" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "101", "Dingbat hex": "65", "Unicode dec": "128602", "Unicode hex": "1F65A" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "102", "Dingbat hex": "66", "Unicode dec": "128600", "Unicode hex": "1F658" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "103", "Dingbat hex": "67", "Unicode dec": "128601", "Unicode hex": "1F659" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "104", "Dingbat hex": "68", "Unicode dec": "128603", "Unicode hex": "1F65B" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "105", "Dingbat hex": "69", "Unicode dec": "9450", "Unicode hex": "24EA" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "106", "Dingbat hex": "6A", "Unicode dec": "9312", "Unicode hex": "2460" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "107", "Dingbat hex": "6B", "Unicode dec": "9313", "Unicode hex": "2461" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "108", "Dingbat hex": "6C", "Unicode dec": "9314", "Unicode hex": "2462" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "109", "Dingbat hex": "6D", "Unicode dec": "9315", "Unicode hex": "2463" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "110", "Dingbat hex": "6E", "Unicode dec": "9316", "Unicode hex": "2464" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "111", "Dingbat hex": "6F", "Unicode dec": "9317", "Unicode hex": "2465" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "112", "Dingbat hex": "70", "Unicode dec": "9318", "Unicode hex": "2466" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "113", "Dingbat hex": "71", "Unicode dec": "9319", "Unicode hex": "2467" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "114", "Dingbat hex": "72", "Unicode dec": "9320", "Unicode hex": "2468" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "115", "Dingbat hex": "73", "Unicode dec": "9321", "Unicode hex": "2469" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "116", "Dingbat hex": "74", "Unicode dec": "9471", "Unicode hex": "24FF" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "117", "Dingbat hex": "75", "Unicode dec": "10102", "Unicode hex": "2776" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "118", "Dingbat hex": "76", "Unicode dec": "10103", "Unicode hex": "2777" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "119", "Dingbat hex": "77", "Unicode dec": "10104", "Unicode hex": "2778" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "120", "Dingbat hex": "78", "Unicode dec": "10105", "Unicode hex": "2779" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "121", "Dingbat hex": "79", "Unicode dec": "10106", "Unicode hex": "277A" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "122", "Dingbat hex": "7A", "Unicode dec": "10107", "Unicode hex": "277B" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "123", "Dingbat hex": "7B", "Unicode dec": "10108", "Unicode hex": "277C" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "124", "Dingbat hex": "7C", "Unicode dec": "10109", "Unicode hex": "277D" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "125", "Dingbat hex": "7D", "Unicode dec": "10110", "Unicode hex": "277E" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "126", "Dingbat hex": "7E", "Unicode dec": "10111", "Unicode hex": "277F" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "128", "Dingbat hex": "80", "Unicode dec": "9737", "Unicode hex": "2609" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "129", "Dingbat hex": "81", "Unicode dec": "127765", "Unicode hex": "1F315" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "130", "Dingbat hex": "82", "Unicode dec": "9789", "Unicode hex": "263D" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "131", "Dingbat hex": "83", "Unicode dec": "9790", "Unicode hex": "263E" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "132", "Dingbat hex": "84", "Unicode dec": "11839", "Unicode hex": "2E3F" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "133", "Dingbat hex": "85", "Unicode dec": "10013", "Unicode hex": "271D" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "134", "Dingbat hex": "86", "Unicode dec": "128327", "Unicode hex": "1F547" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "135", "Dingbat hex": "87", "Unicode dec": "128348", "Unicode hex": "1F55C" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "136", "Dingbat hex": "88", "Unicode dec": "128349", "Unicode hex": "1F55D" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "137", "Dingbat hex": "89", "Unicode dec": "128350", "Unicode hex": "1F55E" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "138", "Dingbat hex": "8A", "Unicode dec": "128351", "Unicode hex": "1F55F" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "139", "Dingbat hex": "8B", "Unicode dec": "128352", "Unicode hex": "1F560" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "140", "Dingbat hex": "8C", "Unicode dec": "128353", "Unicode hex": "1F561" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "141", "Dingbat hex": "8D", "Unicode dec": "128354", "Unicode hex": "1F562" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "142", "Dingbat hex": "8E", "Unicode dec": "128355", "Unicode hex": "1F563" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "143", "Dingbat hex": "8F", "Unicode dec": "128356", "Unicode hex": "1F564" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "144", "Dingbat hex": "90", "Unicode dec": "128357", "Unicode hex": "1F565" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "145", "Dingbat hex": "91", "Unicode dec": "128358", "Unicode hex": "1F566" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "146", "Dingbat hex": "92", "Unicode dec": "128359", "Unicode hex": "1F567" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "147", "Dingbat hex": "93", "Unicode dec": "128616", "Unicode hex": "1F668" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "148", "Dingbat hex": "94", "Unicode dec": "128617", "Unicode hex": "1F669" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "149", "Dingbat hex": "95", "Unicode dec": "8901", "Unicode hex": "22C5" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "150", "Dingbat hex": "96", "Unicode dec": "128900", "Unicode hex": "1F784" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "151", "Dingbat hex": "97", "Unicode dec": "10625", "Unicode hex": "2981" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "152", "Dingbat hex": "98", "Unicode dec": "9679", "Unicode hex": "25CF" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "153", "Dingbat hex": "99", "Unicode dec": "9675", "Unicode hex": "25CB" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "154", "Dingbat hex": "9A", "Unicode dec": "128901", "Unicode hex": "1F785" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "155", "Dingbat hex": "9B", "Unicode dec": "128903", "Unicode hex": "1F787" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "156", "Dingbat hex": "9C", "Unicode dec": "128905", "Unicode hex": "1F789" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "157", "Dingbat hex": "9D", "Unicode dec": "8857", "Unicode hex": "2299" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "158", "Dingbat hex": "9E", "Unicode dec": "10687", "Unicode hex": "29BF" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "159", "Dingbat hex": "9F", "Unicode dec": "128908", "Unicode hex": "1F78C" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "160", "Dingbat hex": "A0", "Unicode dec": "128909", "Unicode hex": "1F78D" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "161", "Dingbat hex": "A1", "Unicode dec": "9726", "Unicode hex": "25FE" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "162", "Dingbat hex": "A2", "Unicode dec": "9632", "Unicode hex": "25A0" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "163", "Dingbat hex": "A3", "Unicode dec": "9633", "Unicode hex": "25A1" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "164", "Dingbat hex": "A4", "Unicode dec": "128913", "Unicode hex": "1F791" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "165", "Dingbat hex": "A5", "Unicode dec": "128914", "Unicode hex": "1F792" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "166", "Dingbat hex": "A6", "Unicode dec": "128915", "Unicode hex": "1F793" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "167", "Dingbat hex": "A7", "Unicode dec": "128916", "Unicode hex": "1F794" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "168", "Dingbat hex": "A8", "Unicode dec": "9635", "Unicode hex": "25A3" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "169", "Dingbat hex": "A9", "Unicode dec": "128917", "Unicode hex": "1F795" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "170", "Dingbat hex": "AA", "Unicode dec": "128918", "Unicode hex": "1F796" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "171", "Dingbat hex": "AB", "Unicode dec": "128919", "Unicode hex": "1F797" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "172", "Dingbat hex": "AC", "Unicode dec": "128920", "Unicode hex": "1F798" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "173", "Dingbat hex": "AD", "Unicode dec": "11049", "Unicode hex": "2B29" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "174", "Dingbat hex": "AE", "Unicode dec": "11045", "Unicode hex": "2B25" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "175", "Dingbat hex": "AF", "Unicode dec": "9671", "Unicode hex": "25C7" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "176", "Dingbat hex": "B0", "Unicode dec": "128922", "Unicode hex": "1F79A" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "177", "Dingbat hex": "B1", "Unicode dec": "9672", "Unicode hex": "25C8" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "178", "Dingbat hex": "B2", "Unicode dec": "128923", "Unicode hex": "1F79B" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "179", "Dingbat hex": "B3", "Unicode dec": "128924", "Unicode hex": "1F79C" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "180", "Dingbat hex": "B4", "Unicode dec": "128925", "Unicode hex": "1F79D" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "181", "Dingbat hex": "B5", "Unicode dec": "128926", "Unicode hex": "1F79E" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "182", "Dingbat hex": "B6", "Unicode dec": "11050", "Unicode hex": "2B2A" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "183", "Dingbat hex": "B7", "Unicode dec": "11047", "Unicode hex": "2B27" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "184", "Dingbat hex": "B8", "Unicode dec": "9674", "Unicode hex": "25CA" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "185", "Dingbat hex": "B9", "Unicode dec": "128928", "Unicode hex": "1F7A0" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "186", "Dingbat hex": "BA", "Unicode dec": "9686", "Unicode hex": "25D6" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "187", "Dingbat hex": "BB", "Unicode dec": "9687", "Unicode hex": "25D7" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "188", "Dingbat hex": "BC", "Unicode dec": "11210", "Unicode hex": "2BCA" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "189", "Dingbat hex": "BD", "Unicode dec": "11211", "Unicode hex": "2BCB" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "190", "Dingbat hex": "BE", "Unicode dec": "11200", "Unicode hex": "2BC0" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "191", "Dingbat hex": "BF", "Unicode dec": "11201", "Unicode hex": "2BC1" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "192", "Dingbat hex": "C0", "Unicode dec": "11039", "Unicode hex": "2B1F" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "193", "Dingbat hex": "C1", "Unicode dec": "11202", "Unicode hex": "2BC2" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "194", "Dingbat hex": "C2", "Unicode dec": "11043", "Unicode hex": "2B23" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "195", "Dingbat hex": "C3", "Unicode dec": "11042", "Unicode hex": "2B22" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "196", "Dingbat hex": "C4", "Unicode dec": "11203", "Unicode hex": "2BC3" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "197", "Dingbat hex": "C5", "Unicode dec": "11204", "Unicode hex": "2BC4" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "198", "Dingbat hex": "C6", "Unicode dec": "128929", "Unicode hex": "1F7A1" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "199", "Dingbat hex": "C7", "Unicode dec": "128930", "Unicode hex": "1F7A2" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "200", "Dingbat hex": "C8", "Unicode dec": "128931", "Unicode hex": "1F7A3" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "201", "Dingbat hex": "C9", "Unicode dec": "128932", "Unicode hex": "1F7A4" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "202", "Dingbat hex": "CA", "Unicode dec": "128933", "Unicode hex": "1F7A5" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "203", "Dingbat hex": "CB", "Unicode dec": "128934", "Unicode hex": "1F7A6" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "204", "Dingbat hex": "CC", "Unicode dec": "128935", "Unicode hex": "1F7A7" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "205", "Dingbat hex": "CD", "Unicode dec": "128936", "Unicode hex": "1F7A8" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "206", "Dingbat hex": "CE", "Unicode dec": "128937", "Unicode hex": "1F7A9" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "207", "Dingbat hex": "CF", "Unicode dec": "128938", "Unicode hex": "1F7AA" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "208", "Dingbat hex": "D0", "Unicode dec": "128939", "Unicode hex": "1F7AB" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "209", "Dingbat hex": "D1", "Unicode dec": "128940", "Unicode hex": "1F7AC" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "210", "Dingbat hex": "D2", "Unicode dec": "128941", "Unicode hex": "1F7AD" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "211", "Dingbat hex": "D3", "Unicode dec": "128942", "Unicode hex": "1F7AE" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "212", "Dingbat hex": "D4", "Unicode dec": "128943", "Unicode hex": "1F7AF" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "213", "Dingbat hex": "D5", "Unicode dec": "128944", "Unicode hex": "1F7B0" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "214", "Dingbat hex": "D6", "Unicode dec": "128945", "Unicode hex": "1F7B1" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "215", "Dingbat hex": "D7", "Unicode dec": "128946", "Unicode hex": "1F7B2" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "216", "Dingbat hex": "D8", "Unicode dec": "128947", "Unicode hex": "1F7B3" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "217", "Dingbat hex": "D9", "Unicode dec": "128948", "Unicode hex": "1F7B4" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "218", "Dingbat hex": "DA", "Unicode dec": "128949", "Unicode hex": "1F7B5" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "219", "Dingbat hex": "DB", "Unicode dec": "128950", "Unicode hex": "1F7B6" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "220", "Dingbat hex": "DC", "Unicode dec": "128951", "Unicode hex": "1F7B7" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "221", "Dingbat hex": "DD", "Unicode dec": "128952", "Unicode hex": "1F7B8" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "222", "Dingbat hex": "DE", "Unicode dec": "128953", "Unicode hex": "1F7B9" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "223", "Dingbat hex": "DF", "Unicode dec": "128954", "Unicode hex": "1F7BA" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "224", "Dingbat hex": "E0", "Unicode dec": "128955", "Unicode hex": "1F7BB" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "225", "Dingbat hex": "E1", "Unicode dec": "128956", "Unicode hex": "1F7BC" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "226", "Dingbat hex": "E2", "Unicode dec": "128957", "Unicode hex": "1F7BD" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "227", "Dingbat hex": "E3", "Unicode dec": "128958", "Unicode hex": "1F7BE" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "228", "Dingbat hex": "E4", "Unicode dec": "128959", "Unicode hex": "1F7BF" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "229", "Dingbat hex": "E5", "Unicode dec": "128960", "Unicode hex": "1F7C0" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "230", "Dingbat hex": "E6", "Unicode dec": "128962", "Unicode hex": "1F7C2" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "231", "Dingbat hex": "E7", "Unicode dec": "128964", "Unicode hex": "1F7C4" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "232", "Dingbat hex": "E8", "Unicode dec": "128966", "Unicode hex": "1F7C6" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "233", "Dingbat hex": "E9", "Unicode dec": "128969", "Unicode hex": "1F7C9" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "234", "Dingbat hex": "EA", "Unicode dec": "128970", "Unicode hex": "1F7CA" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "235", "Dingbat hex": "EB", "Unicode dec": "10038", "Unicode hex": "2736" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "236", "Dingbat hex": "EC", "Unicode dec": "128972", "Unicode hex": "1F7CC" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "237", "Dingbat hex": "ED", "Unicode dec": "128974", "Unicode hex": "1F7CE" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "238", "Dingbat hex": "EE", "Unicode dec": "128976", "Unicode hex": "1F7D0" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "239", "Dingbat hex": "EF", "Unicode dec": "128978", "Unicode hex": "1F7D2" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "240", "Dingbat hex": "F0", "Unicode dec": "10041", "Unicode hex": "2739" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "241", "Dingbat hex": "F1", "Unicode dec": "128963", "Unicode hex": "1F7C3" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "242", "Dingbat hex": "F2", "Unicode dec": "128967", "Unicode hex": "1F7C7" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "243", "Dingbat hex": "F3", "Unicode dec": "10031", "Unicode hex": "272F" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "244", "Dingbat hex": "F4", "Unicode dec": "128973", "Unicode hex": "1F7CD" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "245", "Dingbat hex": "F5", "Unicode dec": "128980", "Unicode hex": "1F7D4" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "246", "Dingbat hex": "F6", "Unicode dec": "11212", "Unicode hex": "2BCC" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "247", "Dingbat hex": "F7", "Unicode dec": "11213", "Unicode hex": "2BCD" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "248", "Dingbat hex": "F8", "Unicode dec": "8251", "Unicode hex": "203B" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "249", "Dingbat hex": "F9", "Unicode dec": "8258", "Unicode hex": "2042" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "32", "Dingbat hex": "20", "Unicode dec": "32", "Unicode hex": "20" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "33", "Dingbat hex": "21", "Unicode dec": "11104", "Unicode hex": "2B60" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "34", "Dingbat hex": "22", "Unicode dec": "11106", "Unicode hex": "2B62" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "35", "Dingbat hex": "23", "Unicode dec": "11105", "Unicode hex": "2B61" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "36", "Dingbat hex": "24", "Unicode dec": "11107", "Unicode hex": "2B63" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "37", "Dingbat hex": "25", "Unicode dec": "11110", "Unicode hex": "2B66" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "38", "Dingbat hex": "26", "Unicode dec": "11111", "Unicode hex": "2B67" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "39", "Dingbat hex": "27", "Unicode dec": "11113", "Unicode hex": "2B69" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "40", "Dingbat hex": "28", "Unicode dec": "11112", "Unicode hex": "2B68" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "41", "Dingbat hex": "29", "Unicode dec": "11120", "Unicode hex": "2B70" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "42", "Dingbat hex": "2A", "Unicode dec": "11122", "Unicode hex": "2B72" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "43", "Dingbat hex": "2B", "Unicode dec": "11121", "Unicode hex": "2B71" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "44", "Dingbat hex": "2C", "Unicode dec": "11123", "Unicode hex": "2B73" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "45", "Dingbat hex": "2D", "Unicode dec": "11126", "Unicode hex": "2B76" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "46", "Dingbat hex": "2E", "Unicode dec": "11128", "Unicode hex": "2B78" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "47", "Dingbat hex": "2F", "Unicode dec": "11131", "Unicode hex": "2B7B" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "48", "Dingbat hex": "30", "Unicode dec": "11133", "Unicode hex": "2B7D" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "49", "Dingbat hex": "31", "Unicode dec": "11108", "Unicode hex": "2B64" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "50", "Dingbat hex": "32", "Unicode dec": "11109", "Unicode hex": "2B65" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "51", "Dingbat hex": "33", "Unicode dec": "11114", "Unicode hex": "2B6A" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "52", "Dingbat hex": "34", "Unicode dec": "11116", "Unicode hex": "2B6C" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "53", "Dingbat hex": "35", "Unicode dec": "11115", "Unicode hex": "2B6B" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "54", "Dingbat hex": "36", "Unicode dec": "11117", "Unicode hex": "2B6D" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "55", "Dingbat hex": "37", "Unicode dec": "11085", "Unicode hex": "2B4D" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "56", "Dingbat hex": "38", "Unicode dec": "11168", "Unicode hex": "2BA0" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "57", "Dingbat hex": "39", "Unicode dec": "11169", "Unicode hex": "2BA1" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "58", "Dingbat hex": "3A", "Unicode dec": "11170", "Unicode hex": "2BA2" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "59", "Dingbat hex": "3B", "Unicode dec": "11171", "Unicode hex": "2BA3" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "60", "Dingbat hex": "3C", "Unicode dec": "11172", "Unicode hex": "2BA4" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "61", "Dingbat hex": "3D", "Unicode dec": "11173", "Unicode hex": "2BA5" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "62", "Dingbat hex": "3E", "Unicode dec": "11174", "Unicode hex": "2BA6" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "63", "Dingbat hex": "3F", "Unicode dec": "11175", "Unicode hex": "2BA7" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "64", "Dingbat hex": "40", "Unicode dec": "11152", "Unicode hex": "2B90" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "65", "Dingbat hex": "41", "Unicode dec": "11153", "Unicode hex": "2B91" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "66", "Dingbat hex": "42", "Unicode dec": "11154", "Unicode hex": "2B92" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "67", "Dingbat hex": "43", "Unicode dec": "11155", "Unicode hex": "2B93" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "68", "Dingbat hex": "44", "Unicode dec": "11136", "Unicode hex": "2B80" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "69", "Dingbat hex": "45", "Unicode dec": "11139", "Unicode hex": "2B83" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "70", "Dingbat hex": "46", "Unicode dec": "11134", "Unicode hex": "2B7E" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "71", "Dingbat hex": "47", "Unicode dec": "11135", "Unicode hex": "2B7F" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "72", "Dingbat hex": "48", "Unicode dec": "11140", "Unicode hex": "2B84" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "73", "Dingbat hex": "49", "Unicode dec": "11142", "Unicode hex": "2B86" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "74", "Dingbat hex": "4A", "Unicode dec": "11141", "Unicode hex": "2B85" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "75", "Dingbat hex": "4B", "Unicode dec": "11143", "Unicode hex": "2B87" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "76", "Dingbat hex": "4C", "Unicode dec": "11151", "Unicode hex": "2B8F" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "77", "Dingbat hex": "4D", "Unicode dec": "11149", "Unicode hex": "2B8D" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "78", "Dingbat hex": "4E", "Unicode dec": "11150", "Unicode hex": "2B8E" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "79", "Dingbat hex": "4F", "Unicode dec": "11148", "Unicode hex": "2B8C" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "80", "Dingbat hex": "50", "Unicode dec": "11118", "Unicode hex": "2B6E" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "81", "Dingbat hex": "51", "Unicode dec": "11119", "Unicode hex": "2B6F" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "82", "Dingbat hex": "52", "Unicode dec": "9099", "Unicode hex": "238B" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "83", "Dingbat hex": "53", "Unicode dec": "8996", "Unicode hex": "2324" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "84", "Dingbat hex": "54", "Unicode dec": "8963", "Unicode hex": "2303" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "85", "Dingbat hex": "55", "Unicode dec": "8997", "Unicode hex": "2325" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "86", "Dingbat hex": "56", "Unicode dec": "9251", "Unicode hex": "2423" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "87", "Dingbat hex": "57", "Unicode dec": "9085", "Unicode hex": "237D" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "88", "Dingbat hex": "58", "Unicode dec": "8682", "Unicode hex": "21EA" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "89", "Dingbat hex": "59", "Unicode dec": "11192", "Unicode hex": "2BB8" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "90", "Dingbat hex": "5A", "Unicode dec": "129184", "Unicode hex": "1F8A0" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "91", "Dingbat hex": "5B", "Unicode dec": "129185", "Unicode hex": "1F8A1" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "92", "Dingbat hex": "5C", "Unicode dec": "129186", "Unicode hex": "1F8A2" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "93", "Dingbat hex": "5D", "Unicode dec": "129187", "Unicode hex": "1F8A3" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "94", "Dingbat hex": "5E", "Unicode dec": "129188", "Unicode hex": "1F8A4" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "95", "Dingbat hex": "5F", "Unicode dec": "129189", "Unicode hex": "1F8A5" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "96", "Dingbat hex": "60", "Unicode dec": "129190", "Unicode hex": "1F8A6" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "97", "Dingbat hex": "61", "Unicode dec": "129191", "Unicode hex": "1F8A7" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "98", "Dingbat hex": "62", "Unicode dec": "129192", "Unicode hex": "1F8A8" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "99", "Dingbat hex": "63", "Unicode dec": "129193", "Unicode hex": "1F8A9" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "100", "Dingbat hex": "64", "Unicode dec": "129194", "Unicode hex": "1F8AA" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "101", "Dingbat hex": "65", "Unicode dec": "129195", "Unicode hex": "1F8AB" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "102", "Dingbat hex": "66", "Unicode dec": "129104", "Unicode hex": "1F850" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "103", "Dingbat hex": "67", "Unicode dec": "129106", "Unicode hex": "1F852" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "104", "Dingbat hex": "68", "Unicode dec": "129105", "Unicode hex": "1F851" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "105", "Dingbat hex": "69", "Unicode dec": "129107", "Unicode hex": "1F853" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "106", "Dingbat hex": "6A", "Unicode dec": "129108", "Unicode hex": "1F854" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "107", "Dingbat hex": "6B", "Unicode dec": "129109", "Unicode hex": "1F855" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "108", "Dingbat hex": "6C", "Unicode dec": "129111", "Unicode hex": "1F857" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "109", "Dingbat hex": "6D", "Unicode dec": "129110", "Unicode hex": "1F856" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "110", "Dingbat hex": "6E", "Unicode dec": "129112", "Unicode hex": "1F858" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "111", "Dingbat hex": "6F", "Unicode dec": "129113", "Unicode hex": "1F859" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "112", "Dingbat hex": "70", "Unicode dec": "9650", "Unicode hex": "25B2" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "113", "Dingbat hex": "71", "Unicode dec": "9660", "Unicode hex": "25BC" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "114", "Dingbat hex": "72", "Unicode dec": "9651", "Unicode hex": "25B3" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "115", "Dingbat hex": "73", "Unicode dec": "9661", "Unicode hex": "25BD" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "116", "Dingbat hex": "74", "Unicode dec": "9664", "Unicode hex": "25C0" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "117", "Dingbat hex": "75", "Unicode dec": "9654", "Unicode hex": "25B6" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "118", "Dingbat hex": "76", "Unicode dec": "9665", "Unicode hex": "25C1" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "119", "Dingbat hex": "77", "Unicode dec": "9655", "Unicode hex": "25B7" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "120", "Dingbat hex": "78", "Unicode dec": "9699", "Unicode hex": "25E3" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "121", "Dingbat hex": "79", "Unicode dec": "9698", "Unicode hex": "25E2" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "122", "Dingbat hex": "7A", "Unicode dec": "9700", "Unicode hex": "25E4" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "123", "Dingbat hex": "7B", "Unicode dec": "9701", "Unicode hex": "25E5" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "124", "Dingbat hex": "7C", "Unicode dec": "128896", "Unicode hex": "1F780" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "125", "Dingbat hex": "7D", "Unicode dec": "128898", "Unicode hex": "1F782" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "126", "Dingbat hex": "7E", "Unicode dec": "128897", "Unicode hex": "1F781" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "128", "Dingbat hex": "80", "Unicode dec": "128899", "Unicode hex": "1F783" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "129", "Dingbat hex": "81", "Unicode dec": "11205", "Unicode hex": "2BC5" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "130", "Dingbat hex": "82", "Unicode dec": "11206", "Unicode hex": "2BC6" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "131", "Dingbat hex": "83", "Unicode dec": "11207", "Unicode hex": "2BC7" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "132", "Dingbat hex": "84", "Unicode dec": "11208", "Unicode hex": "2BC8" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "133", "Dingbat hex": "85", "Unicode dec": "11164", "Unicode hex": "2B9C" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "134", "Dingbat hex": "86", "Unicode dec": "11166", "Unicode hex": "2B9E" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "135", "Dingbat hex": "87", "Unicode dec": "11165", "Unicode hex": "2B9D" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "136", "Dingbat hex": "88", "Unicode dec": "11167", "Unicode hex": "2B9F" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "137", "Dingbat hex": "89", "Unicode dec": "129040", "Unicode hex": "1F810" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "138", "Dingbat hex": "8A", "Unicode dec": "129042", "Unicode hex": "1F812" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "139", "Dingbat hex": "8B", "Unicode dec": "129041", "Unicode hex": "1F811" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "140", "Dingbat hex": "8C", "Unicode dec": "129043", "Unicode hex": "1F813" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "141", "Dingbat hex": "8D", "Unicode dec": "129044", "Unicode hex": "1F814" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "142", "Dingbat hex": "8E", "Unicode dec": "129046", "Unicode hex": "1F816" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "143", "Dingbat hex": "8F", "Unicode dec": "129045", "Unicode hex": "1F815" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "144", "Dingbat hex": "90", "Unicode dec": "129047", "Unicode hex": "1F817" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "145", "Dingbat hex": "91", "Unicode dec": "129048", "Unicode hex": "1F818" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "146", "Dingbat hex": "92", "Unicode dec": "129050", "Unicode hex": "1F81A" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "147", "Dingbat hex": "93", "Unicode dec": "129049", "Unicode hex": "1F819" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "148", "Dingbat hex": "94", "Unicode dec": "129051", "Unicode hex": "1F81B" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "149", "Dingbat hex": "95", "Unicode dec": "129052", "Unicode hex": "1F81C" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "150", "Dingbat hex": "96", "Unicode dec": "129054", "Unicode hex": "1F81E" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "151", "Dingbat hex": "97", "Unicode dec": "129053", "Unicode hex": "1F81D" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "152", "Dingbat hex": "98", "Unicode dec": "129055", "Unicode hex": "1F81F" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "153", "Dingbat hex": "99", "Unicode dec": "129024", "Unicode hex": "1F800" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "154", "Dingbat hex": "9A", "Unicode dec": "129026", "Unicode hex": "1F802" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "155", "Dingbat hex": "9B", "Unicode dec": "129025", "Unicode hex": "1F801" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "156", "Dingbat hex": "9C", "Unicode dec": "129027", "Unicode hex": "1F803" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "157", "Dingbat hex": "9D", "Unicode dec": "129028", "Unicode hex": "1F804" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "158", "Dingbat hex": "9E", "Unicode dec": "129030", "Unicode hex": "1F806" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "159", "Dingbat hex": "9F", "Unicode dec": "129029", "Unicode hex": "1F805" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "160", "Dingbat hex": "A0", "Unicode dec": "129031", "Unicode hex": "1F807" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "161", "Dingbat hex": "A1", "Unicode dec": "129032", "Unicode hex": "1F808" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "162", "Dingbat hex": "A2", "Unicode dec": "129034", "Unicode hex": "1F80A" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "163", "Dingbat hex": "A3", "Unicode dec": "129033", "Unicode hex": "1F809" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "164", "Dingbat hex": "A4", "Unicode dec": "129035", "Unicode hex": "1F80B" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "165", "Dingbat hex": "A5", "Unicode dec": "129056", "Unicode hex": "1F820" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "166", "Dingbat hex": "A6", "Unicode dec": "129058", "Unicode hex": "1F822" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "167", "Dingbat hex": "A7", "Unicode dec": "129060", "Unicode hex": "1F824" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "168", "Dingbat hex": "A8", "Unicode dec": "129062", "Unicode hex": "1F826" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "169", "Dingbat hex": "A9", "Unicode dec": "129064", "Unicode hex": "1F828" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "170", "Dingbat hex": "AA", "Unicode dec": "129066", "Unicode hex": "1F82A" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "171", "Dingbat hex": "AB", "Unicode dec": "129068", "Unicode hex": "1F82C" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "172", "Dingbat hex": "AC", "Unicode dec": "129180", "Unicode hex": "1F89C" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "173", "Dingbat hex": "AD", "Unicode dec": "129181", "Unicode hex": "1F89D" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "174", "Dingbat hex": "AE", "Unicode dec": "129182", "Unicode hex": "1F89E" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "175", "Dingbat hex": "AF", "Unicode dec": "129183", "Unicode hex": "1F89F" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "176", "Dingbat hex": "B0", "Unicode dec": "129070", "Unicode hex": "1F82E" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "177", "Dingbat hex": "B1", "Unicode dec": "129072", "Unicode hex": "1F830" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "178", "Dingbat hex": "B2", "Unicode dec": "129074", "Unicode hex": "1F832" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "179", "Dingbat hex": "B3", "Unicode dec": "129076", "Unicode hex": "1F834" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "180", "Dingbat hex": "B4", "Unicode dec": "129078", "Unicode hex": "1F836" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "181", "Dingbat hex": "B5", "Unicode dec": "129080", "Unicode hex": "1F838" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "182", "Dingbat hex": "B6", "Unicode dec": "129082", "Unicode hex": "1F83A" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "183", "Dingbat hex": "B7", "Unicode dec": "129081", "Unicode hex": "1F839" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "184", "Dingbat hex": "B8", "Unicode dec": "129083", "Unicode hex": "1F83B" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "185", "Dingbat hex": "B9", "Unicode dec": "129176", "Unicode hex": "1F898" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "186", "Dingbat hex": "BA", "Unicode dec": "129178", "Unicode hex": "1F89A" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "187", "Dingbat hex": "BB", "Unicode dec": "129177", "Unicode hex": "1F899" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "188", "Dingbat hex": "BC", "Unicode dec": "129179", "Unicode hex": "1F89B" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "189", "Dingbat hex": "BD", "Unicode dec": "129084", "Unicode hex": "1F83C" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "190", "Dingbat hex": "BE", "Unicode dec": "129086", "Unicode hex": "1F83E" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "191", "Dingbat hex": "BF", "Unicode dec": "129085", "Unicode hex": "1F83D" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "192", "Dingbat hex": "C0", "Unicode dec": "129087", "Unicode hex": "1F83F" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "193", "Dingbat hex": "C1", "Unicode dec": "129088", "Unicode hex": "1F840" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "194", "Dingbat hex": "C2", "Unicode dec": "129090", "Unicode hex": "1F842" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "195", "Dingbat hex": "C3", "Unicode dec": "129089", "Unicode hex": "1F841" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "196", "Dingbat hex": "C4", "Unicode dec": "129091", "Unicode hex": "1F843" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "197", "Dingbat hex": "C5", "Unicode dec": "129092", "Unicode hex": "1F844" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "198", "Dingbat hex": "C6", "Unicode dec": "129094", "Unicode hex": "1F846" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "199", "Dingbat hex": "C7", "Unicode dec": "129093", "Unicode hex": "1F845" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "200", "Dingbat hex": "C8", "Unicode dec": "129095", "Unicode hex": "1F847" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "201", "Dingbat hex": "C9", "Unicode dec": "11176", "Unicode hex": "2BA8" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "202", "Dingbat hex": "CA", "Unicode dec": "11177", "Unicode hex": "2BA9" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "203", "Dingbat hex": "CB", "Unicode dec": "11178", "Unicode hex": "2BAA" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "204", "Dingbat hex": "CC", "Unicode dec": "11179", "Unicode hex": "2BAB" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "205", "Dingbat hex": "CD", "Unicode dec": "11180", "Unicode hex": "2BAC" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "206", "Dingbat hex": "CE", "Unicode dec": "11181", "Unicode hex": "2BAD" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "207", "Dingbat hex": "CF", "Unicode dec": "11182", "Unicode hex": "2BAE" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "208", "Dingbat hex": "D0", "Unicode dec": "11183", "Unicode hex": "2BAF" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "209", "Dingbat hex": "D1", "Unicode dec": "129120", "Unicode hex": "1F860" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "210", "Dingbat hex": "D2", "Unicode dec": "129122", "Unicode hex": "1F862" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "211", "Dingbat hex": "D3", "Unicode dec": "129121", "Unicode hex": "1F861" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "212", "Dingbat hex": "D4", "Unicode dec": "129123", "Unicode hex": "1F863" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "213", "Dingbat hex": "D5", "Unicode dec": "129124", "Unicode hex": "1F864" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "214", "Dingbat hex": "D6", "Unicode dec": "129125", "Unicode hex": "1F865" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "215", "Dingbat hex": "D7", "Unicode dec": "129127", "Unicode hex": "1F867" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "216", "Dingbat hex": "D8", "Unicode dec": "129126", "Unicode hex": "1F866" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "217", "Dingbat hex": "D9", "Unicode dec": "129136", "Unicode hex": "1F870" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "218", "Dingbat hex": "DA", "Unicode dec": "129138", "Unicode hex": "1F872" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "219", "Dingbat hex": "DB", "Unicode dec": "129137", "Unicode hex": "1F871" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "220", "Dingbat hex": "DC", "Unicode dec": "129139", "Unicode hex": "1F873" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "221", "Dingbat hex": "DD", "Unicode dec": "129140", "Unicode hex": "1F874" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "222", "Dingbat hex": "DE", "Unicode dec": "129141", "Unicode hex": "1F875" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "223", "Dingbat hex": "DF", "Unicode dec": "129143", "Unicode hex": "1F877" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "224", "Dingbat hex": "E0", "Unicode dec": "129142", "Unicode hex": "1F876" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "225", "Dingbat hex": "E1", "Unicode dec": "129152", "Unicode hex": "1F880" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "226", "Dingbat hex": "E2", "Unicode dec": "129154", "Unicode hex": "1F882" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "227", "Dingbat hex": "E3", "Unicode dec": "129153", "Unicode hex": "1F881" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "228", "Dingbat hex": "E4", "Unicode dec": "129155", "Unicode hex": "1F883" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "229", "Dingbat hex": "E5", "Unicode dec": "129156", "Unicode hex": "1F884" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "230", "Dingbat hex": "E6", "Unicode dec": "129157", "Unicode hex": "1F885" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "231", "Dingbat hex": "E7", "Unicode dec": "129159", "Unicode hex": "1F887" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "232", "Dingbat hex": "E8", "Unicode dec": "129158", "Unicode hex": "1F886" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "233", "Dingbat hex": "E9", "Unicode dec": "129168", "Unicode hex": "1F890" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "234", "Dingbat hex": "EA", "Unicode dec": "129170", "Unicode hex": "1F892" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "235", "Dingbat hex": "EB", "Unicode dec": "129169", "Unicode hex": "1F891" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "236", "Dingbat hex": "EC", "Unicode dec": "129171", "Unicode hex": "1F893" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "237", "Dingbat hex": "ED", "Unicode dec": "129172", "Unicode hex": "1F894" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "238", "Dingbat hex": "EE", "Unicode dec": "129174", "Unicode hex": "1F896" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "239", "Dingbat hex": "EF", "Unicode dec": "129173", "Unicode hex": "1F895" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "240", "Dingbat hex": "F0", "Unicode dec": "129175", "Unicode hex": "1F897" }
  ];
  return lu.default = n, lu;
}
var Ux;
function l5() {
  if (Ux) return Kn;
  Ux = 1;
  var n = Kn && Kn.__importDefault || function(d) {
    return d && d.__esModule ? d : { default: d };
  };
  Object.defineProperty(Kn, "__esModule", { value: !0 }), Kn.hex = Kn.dec = Kn.codePoint = void 0;
  for (var e = n(c5()), t = {}, i = String.fromCodePoint ? String.fromCodePoint : f, r = 0, a = e.default; r < a.length; r++) {
    var s = a[r], o = parseInt(s["Unicode dec"], 10), u = {
      codePoint: o,
      string: i(o)
    };
    t[s["Typeface name"].toUpperCase() + "_" + s["Dingbat dec"]] = u;
  }
  function c(d, y) {
    return t[d.toUpperCase() + "_" + y];
  }
  Kn.codePoint = c;
  function l(d, y) {
    return c(d, parseInt(y, 10));
  }
  Kn.dec = l;
  function h(d, y) {
    return c(d, parseInt(y, 16));
  }
  Kn.hex = h;
  function f(d) {
    if (d <= 65535)
      return String.fromCharCode(d);
    var y = Math.floor((d - 65536) / 1024) + 55296, m = (d - 65536) % 1024 + 56320;
    return String.fromCharCode(y, m);
  }
  return Kn;
}
var du = {}, Rx;
function d5() {
  if (Rx) return du;
  Rx = 1, du.uriToZipEntryName = n, du.replaceFragment = e;
  function n(t, i) {
    return i.charAt(0) === "/" ? i.substr(1) : t + "/" + i;
  }
  function e(t, i) {
    var r = t.indexOf("#");
    return r !== -1 && (t = t.substring(0, r)), t + "#" + i;
  }
  return du;
}
var Ox;
function f5() {
  if (Ox) return cu;
  Ox = 1, cu.createBodyReader = s, cu._readNumberingProperties = u;
  var n = l5(), e = Pt, t = Vr(), i = Pi().Result, r = Pi().warning, a = d5();
  function s(T) {
    return {
      readXmlElement: function(E) {
        return new o(T).readXmlElement(E);
      },
      readXmlElements: function(E) {
        return new o(T).readXmlElements(E);
      }
    };
  }
  function o(T) {
    var E = [], U = [], D = T.relationships, L = T.contentTypes, j = T.docxFile, C = T.files, k = T.numbering, I = T.styles;
    function $(N) {
      var Z = N.map(W);
      return v(Z);
    }
    function W(N) {
      if (N.type === "element") {
        var Z = S[N.name];
        if (Z)
          return Z(N);
        if (!Object.prototype.hasOwnProperty.call(l, N.name)) {
          var de = r("An unrecognised element was ignored: " + N.name);
          return y([de]);
        }
      }
      return m();
    }
    function B(N) {
      return {
        start: N.attributes["w:start"] || N.attributes["w:left"],
        end: N.attributes["w:end"] || N.attributes["w:right"],
        firstLine: N.attributes["w:firstLine"],
        hanging: N.attributes["w:hanging"]
      };
    }
    function z(N) {
      return K(N).map(function(Z) {
        var de = N.firstOrEmpty("w:sz").attributes["w:val"], Te = /^[0-9]+$/.test(de) ? parseInt(de, 10) / 2 : null;
        return {
          type: "runProperties",
          styleId: Z.styleId,
          styleName: Z.name,
          verticalAlignment: N.firstOrEmpty("w:vertAlign").attributes["w:val"],
          font: N.firstOrEmpty("w:rFonts").attributes["w:ascii"],
          fontSize: Te,
          isBold: Y(N.first("w:b")),
          isUnderline: q(N.first("w:u")),
          isItalic: Y(N.first("w:i")),
          isStrikethrough: Y(N.first("w:strike")),
          isAllCaps: Y(N.first("w:caps")),
          isSmallCaps: Y(N.first("w:smallCaps"))
        };
      });
    }
    function q(N) {
      if (N) {
        var Z = N.attributes["w:val"];
        return Z !== void 0 && Z !== "false" && Z !== "0" && Z !== "none";
      } else
        return !1;
    }
    function Y(N) {
      if (N) {
        var Z = N.attributes["w:val"];
        return Z !== "false" && Z !== "0";
      } else
        return !1;
    }
    function H(N) {
      return ge(N, "w:pStyle", "Paragraph", I.findParagraphStyleById);
    }
    function K(N) {
      return ge(N, "w:rStyle", "Run", I.findCharacterStyleById);
    }
    function ie(N) {
      return ge(N, "w:tblStyle", "Table", I.findTableStyleById);
    }
    function ge(N, Z, de, Te) {
      var Ie = [], je = N.first(Z), Ze = null, Qe = null;
      if (je && (Ze = je.attributes["w:val"], Ze)) {
        var ot = Te(Ze);
        ot ? Qe = ot.name : Ie.push(M(de, Ze));
      }
      return p({ styleId: Ze, name: Qe }, Ie);
    }
    var pe = { type: "unknown" };
    function ce(N) {
      var Z = N.attributes["w:fldCharType"];
      if (Z === "begin")
        E.push(pe), U = [];
      else if (Z === "end")
        E.pop();
      else if (Z === "separate") {
        var de = De(U.join("")), Te = de === null ? pe : { type: "hyperlink", options: de };
        E.pop(), E.push(Te);
      }
      return m();
    }
    function oe() {
      var N = e.last(E.filter(function(Z) {
        return Z.type === "hyperlink";
      }));
      return N ? N.options : null;
    }
    function De(N) {
      var Z = /\s*HYPERLINK "(.*)"/.exec(N);
      if (Z)
        return { href: Z[1] };
      var de = /\s*HYPERLINK\s+\\l\s+"(.*)"/.exec(N);
      return de ? { anchor: de[1] } : null;
    }
    function Re(N) {
      return U.push(N.text()), m();
    }
    function Me(N) {
      var Z = N.attributes["w:font"], de = N.attributes["w:char"], Te = n.hex(Z, de);
      return Te == null && /^F0..$/.test(de) && (Te = n.hex(Z, de.substring(2))), Te == null ? y([r(
        "A w:sym element with an unsupported character was ignored: char " + de + " in font " + Z
      )]) : b(new t.Text(Te.string));
    }
    function F(N) {
      return function(Z) {
        var de = Z.attributes["w:id"];
        return b(new t.NoteReference({
          noteType: N,
          noteId: de
        }));
      };
    }
    function P(N) {
      return b(t.commentReference({
        commentId: N.attributes["w:id"]
      }));
    }
    function ne(N) {
      return $(N.children);
    }
    var S = {
      "w:p": function(N) {
        return $(N.children).map(function(Z) {
          var de = e.find(Z, h);
          return new t.Paragraph(
            Z.filter(d(h)),
            de
          );
        }).insertExtra();
      },
      "w:pPr": function(N) {
        return H(N).map(function(Z) {
          return {
            type: "paragraphProperties",
            styleId: Z.styleId,
            styleName: Z.name,
            alignment: N.firstOrEmpty("w:jc").attributes["w:val"],
            numbering: u(Z.styleId, N.firstOrEmpty("w:numPr"), k),
            indent: B(N.firstOrEmpty("w:ind"))
          };
        });
      },
      "w:r": function(N) {
        return $(N.children).map(function(Z) {
          var de = e.find(Z, f);
          Z = Z.filter(d(f));
          var Te = oe();
          return Te !== null && (Z = [new t.Hyperlink(Z, Te)]), new t.Run(Z, de);
        });
      },
      "w:rPr": z,
      "w:fldChar": ce,
      "w:instrText": Re,
      "w:t": function(N) {
        return b(new t.Text(N.text()));
      },
      "w:tab": function(N) {
        return b(new t.Tab());
      },
      "w:noBreakHyphen": function() {
        return b(new t.Text(""));
      },
      "w:softHyphen": function(N) {
        return b(new t.Text(""));
      },
      "w:sym": Me,
      "w:hyperlink": function(N) {
        var Z = N.attributes["r:id"], de = N.attributes["w:anchor"];
        return $(N.children).map(function(Te) {
          function Ie(Ze) {
            var Qe = N.attributes["w:tgtFrame"] || null;
            return new t.Hyperlink(
              Te,
              e.extend({ targetFrame: Qe }, Ze)
            );
          }
          if (Z) {
            var je = D.findTargetByRelationshipId(Z);
            return de && (je = a.replaceFragment(je, de)), Ie({ href: je });
          } else return de ? Ie({ anchor: de }) : Te;
        });
      },
      "w:tbl": he,
      "w:tr": te,
      "w:tc": ee,
      "w:footnoteReference": F("footnote"),
      "w:endnoteReference": F("endnote"),
      "w:commentReference": P,
      "w:br": function(N) {
        var Z = N.attributes["w:type"];
        return Z == null || Z === "textWrapping" ? b(t.lineBreak) : Z === "page" ? b(t.pageBreak) : Z === "column" ? b(t.columnBreak) : y([r("Unsupported break type: " + Z)]);
      },
      "w:bookmarkStart": function(N) {
        var Z = N.attributes["w:name"];
        return Z === "_GoBack" ? m() : b(new t.BookmarkStart({ name: Z }));
      },
      "mc:AlternateContent": function(N) {
        return ne(N.first("mc:Fallback"));
      },
      "w:sdt": function(N) {
        return $(N.firstOrEmpty("w:sdtContent").children);
      },
      "w:ins": ne,
      "w:object": ne,
      "w:smartTag": ne,
      "w:drawing": ne,
      "w:pict": function(N) {
        return ne(N).toExtra();
      },
      "v:roundrect": ne,
      "v:shape": ne,
      "v:textbox": ne,
      "w:txbxContent": ne,
      "wp:inline": Se,
      "wp:anchor": Se,
      "v:imagedata": we,
      "v:group": ne,
      "v:rect": ne
    };
    return {
      readXmlElement: W,
      readXmlElements: $
    };
    function he(N) {
      var Z = ae(N.firstOrEmpty("w:tblPr"));
      return $(N.children).flatMap(Ee).flatMap(function(de) {
        return Z.map(function(Te) {
          return t.Table(de, Te);
        });
      });
    }
    function ae(N) {
      return ie(N).map(function(Z) {
        return {
          styleId: Z.styleId,
          styleName: Z.name
        };
      });
    }
    function te(N) {
      var Z = N.firstOrEmpty("w:trPr"), de = !!Z.first("w:tblHeader");
      return $(N.children).map(function(Te) {
        return t.TableRow(Te, { isHeader: de });
      });
    }
    function ee(N) {
      return $(N.children).map(function(Z) {
        var de = N.firstOrEmpty("w:tcPr"), Te = de.firstOrEmpty("w:gridSpan").attributes["w:val"], Ie = Te ? parseInt(Te, 10) : 1, je = t.TableCell(Z, { colSpan: Ie });
        return je._vMerge = ve(de), je;
      });
    }
    function ve(N) {
      var Z = N.first("w:vMerge");
      if (Z) {
        var de = Z.attributes["w:val"];
        return de === "continue" || !de;
      } else
        return null;
    }
    function Ee(N) {
      var Z = e.any(N, function(Ie) {
        return Ie.type !== t.types.tableRow;
      });
      if (Z)
        return p(N, [r(
          "unexpected non-row element in table, cell merging may be incorrect"
        )]);
      var de = e.any(N, function(Ie) {
        return e.any(Ie.children, function(je) {
          return je.type !== t.types.tableCell;
        });
      });
      if (de)
        return p(N, [r(
          "unexpected non-cell element in table row, cell merging may be incorrect"
        )]);
      var Te = {};
      return N.forEach(function(Ie) {
        var je = 0;
        Ie.children.forEach(function(Ze) {
          Ze._vMerge && Te[je] ? Te[je].rowSpan++ : (Te[je] = Ze, Ze._vMerge = !1), je += Ze.colSpan;
        });
      }), N.forEach(function(Ie) {
        Ie.children = Ie.children.filter(function(je) {
          return !je._vMerge;
        }), Ie.children.forEach(function(je) {
          delete je._vMerge;
        });
      }), b(N);
    }
    function Se(N) {
      var Z = N.getElementsByTagName("a:graphic").getElementsByTagName("a:graphicData").getElementsByTagName("pic:pic").getElementsByTagName("pic:blipFill").getElementsByTagName("a:blip");
      return v(Z.map(xe.bind(null, N)));
    }
    function xe(N, Z) {
      var de = N.first("wp:docPr").attributes, Te = le(de.descr) ? de.title : de.descr, Ie = ye(Z);
      return Ie === null ? y([r("Could not find image file for a:blip element")]) : Q(Ie, Te);
    }
    function le(N) {
      return N == null || /^\s*$/.test(N);
    }
    function ye(N) {
      var Z = N.attributes["r:embed"], de = N.attributes["r:link"];
      if (Z)
        return Ue(Z);
      if (de) {
        var Te = D.findTargetByRelationshipId(de);
        return {
          path: Te,
          read: C.read.bind(C, Te)
        };
      } else
        return null;
    }
    function we(N) {
      var Z = N.attributes["r:id"];
      return Z ? Q(
        Ue(Z),
        N.attributes["o:title"]
      ) : y([r("A v:imagedata element without a relationship ID was ignored")]);
    }
    function Ue(N) {
      var Z = a.uriToZipEntryName("word", D.findTargetByRelationshipId(N));
      return {
        path: Z,
        read: j.read.bind(j, Z)
      };
    }
    function Q(N, Z) {
      var de = L.findContentType(N.path), Te = t.Image({
        readImage: N.read,
        altText: Z,
        contentType: de
      }), Ie = c[de] ? [] : r("Image of type " + de + " is unlikely to display in web browsers");
      return p(Te, Ie);
    }
    function M(N, Z) {
      return r(
        N + " style with ID " + Z + " was referenced but not defined in the document"
      );
    }
  }
  function u(T, E, U) {
    if (T != null) {
      var D = U.findLevelByParagraphStyleId(T);
      if (D != null)
        return D;
    }
    var L = E.firstOrEmpty("w:ilvl").attributes["w:val"], j = E.firstOrEmpty("w:numId").attributes["w:val"];
    return L === void 0 || j === void 0 ? null : U.findLevel(j, L);
  }
  var c = {
    "image/png": !0,
    "image/gif": !0,
    "image/jpeg": !0,
    "image/svg+xml": !0,
    "image/tiff": !0
  }, l = {
    "office-word:wrap": !0,
    "v:shadow": !0,
    "v:shapetype": !0,
    "w:annotationRef": !0,
    "w:bookmarkEnd": !0,
    "w:sectPr": !0,
    "w:proofErr": !0,
    "w:lastRenderedPageBreak": !0,
    "w:commentRangeStart": !0,
    "w:commentRangeEnd": !0,
    "w:del": !0,
    "w:footnoteRef": !0,
    "w:endnoteRef": !0,
    "w:tblPr": !0,
    "w:tblGrid": !0,
    "w:trPr": !0,
    "w:tcPr": !0
  };
  function h(T) {
    return T.type === "paragraphProperties";
  }
  function f(T) {
    return T.type === "runProperties";
  }
  function d(T) {
    return function(E) {
      return !T(E);
    };
  }
  function y(T) {
    return new g(null, null, T);
  }
  function m() {
    return new g(null);
  }
  function b(T) {
    return new g(T);
  }
  function p(T, E) {
    return new g(T, null, E);
  }
  function g(T, E, U) {
    this.value = T || [], this.extra = E, this._result = new i({
      element: this.value,
      extra: E
    }, U), this.messages = this._result.messages;
  }
  g.prototype.toExtra = function() {
    return new g(null, _(this.extra, this.value), this.messages);
  }, g.prototype.insertExtra = function() {
    var T = this.extra;
    return T && T.length ? new g(_(this.value, T), null, this.messages) : this;
  }, g.prototype.map = function(T) {
    var E = this._result.map(function(U) {
      return T(U.element);
    });
    return new g(E.value, this.extra, E.messages);
  }, g.prototype.flatMap = function(T) {
    var E = this._result.flatMap(function(U) {
      return T(U.element)._result;
    });
    return new g(E.value.element, _(this.extra, E.value.extra), E.messages);
  };
  function v(T) {
    var E = i.combine(e.pluck(T, "_result"));
    return new g(
      e.flatten(e.pluck(E.value, "element")),
      e.filter(e.flatten(e.pluck(E.value, "extra")), x),
      E.messages
    );
  }
  function _(T, E) {
    return e.flatten([T, E]);
  }
  function x(T) {
    return T;
  }
  return cu;
}
var Ah = {}, Lx;
function h5() {
  if (Lx) return Ah;
  Lx = 1, Ah.DocumentXmlReader = t;
  var n = Vr(), e = Pi().Result;
  function t(i) {
    var r = i.bodyReader;
    function a(s) {
      var o = s.first("w:body"), u = r.readXmlElements(o.children).map(function(c) {
        return new n.Document(c, {
          notes: i.notes,
          comments: i.comments
        });
      });
      return new e(u.value, u.messages);
    }
    return {
      convertXmlToDocument: a
    };
  }
  return Ah;
}
var ds = {}, Px;
function p5() {
  if (Px) return ds;
  Px = 1, ds.readRelationships = n, ds.defaultValue = new e([]), ds.Relationships = e;
  function n(t) {
    var i = [];
    return t.children.forEach(function(r) {
      if (r.name === "{http://schemas.openxmlformats.org/package/2006/relationships}Relationship") {
        var a = {
          relationshipId: r.attributes.Id,
          target: r.attributes.Target,
          type: r.attributes.Type
        };
        i.push(a);
      }
    }), new e(i);
  }
  function e(t) {
    var i = {};
    t.forEach(function(a) {
      i[a.relationshipId] = a.target;
    });
    var r = {};
    return t.forEach(function(a) {
      r[a.type] || (r[a.type] = []), r[a.type].push(a.target);
    }), {
      findTargetByRelationshipId: function(a) {
        return i[a];
      },
      findTargetsByType: function(a) {
        return r[a] || [];
      }
    };
  }
  return ds;
}
var fu = {}, Fx;
function m5() {
  if (Fx) return fu;
  Fx = 1, fu.readContentTypesFromXml = e;
  var n = {
    png: "png",
    gif: "gif",
    jpeg: "jpeg",
    jpg: "jpeg",
    tif: "tiff",
    tiff: "tiff",
    bmp: "bmp"
  };
  fu.defaultContentTypes = t({}, {});
  function e(i) {
    var r = {}, a = {};
    return i.children.forEach(function(s) {
      if (s.name === "content-types:Default" && (r[s.attributes.Extension] = s.attributes.ContentType), s.name === "content-types:Override") {
        var o = s.attributes.PartName;
        o.charAt(0) === "/" && (o = o.substring(1)), a[o] = s.attributes.ContentType;
      }
    }), t(a, r);
  }
  function t(i, r) {
    return {
      findContentType: function(a) {
        var s = i[a];
        if (s)
          return s;
        var o = a.split("."), u = o[o.length - 1];
        if (r.hasOwnProperty(u))
          return r[u];
        var c = n[u.toLowerCase()];
        return c ? "image/" + c : null;
      }
    };
  }
  return fu;
}
var fs = {}, Nx;
function g5() {
  if (Nx) return fs;
  Nx = 1;
  var n = Pt;
  fs.readNumberingXml = t, fs.Numbering = e, fs.defaultNumbering = new e({}, {});
  function e(s, o, u) {
    var c = n.flatten(n.values(o).map(function(d) {
      return n.values(d.levels);
    })), l = n.indexBy(
      c.filter(function(d) {
        return d.paragraphStyleId != null;
      }),
      "paragraphStyleId"
    );
    function h(d, y) {
      var m = s[d];
      if (m) {
        var b = o[m.abstractNumId];
        if (b) {
          if (b.numStyleLink == null)
            return o[m.abstractNumId].levels[y];
          var p = u.findNumberingStyleById(b.numStyleLink);
          return h(p.numId, y);
        } else return null;
      } else
        return null;
    }
    function f(d) {
      return l[d] || null;
    }
    return {
      findLevel: h,
      findLevelByParagraphStyleId: f
    };
  }
  function t(s, o) {
    if (!o || !o.styles)
      throw new Error("styles is missing");
    var u = i(s), c = a(s);
    return new e(c, u, o.styles);
  }
  function i(s) {
    var o = {};
    return s.getElementsByTagName("w:abstractNum").forEach(function(u) {
      var c = u.attributes["w:abstractNumId"];
      o[c] = r(u);
    }), o;
  }
  function r(s) {
    var o = {};
    s.getElementsByTagName("w:lvl").forEach(function(c) {
      var l = c.attributes["w:ilvl"], h = c.first("w:numFmt").attributes["w:val"], f = c.firstOrEmpty("w:pStyle").attributes["w:val"];
      o[l] = {
        isOrdered: h !== "bullet",
        level: l,
        paragraphStyleId: f
      };
    });
    var u = s.firstOrEmpty("w:numStyleLink").attributes["w:val"];
    return { levels: o, numStyleLink: u };
  }
  function a(s) {
    var o = {};
    return s.getElementsByTagName("w:num").forEach(function(u) {
      var c = u.attributes["w:numId"], l = u.first("w:abstractNumId").attributes["w:val"];
      o[c] = { abstractNumId: l };
    }), o;
  }
  return fs;
}
var hs = {}, Mx;
function b5() {
  if (Mx) return hs;
  Mx = 1, hs.readStylesXml = e, hs.Styles = n, hs.defaultStyles = new n({}, {});
  function n(a, s, o, u) {
    return {
      findParagraphStyleById: function(c) {
        return a[c];
      },
      findCharacterStyleById: function(c) {
        return s[c];
      },
      findTableStyleById: function(c) {
        return o[c];
      },
      findNumberingStyleById: function(c) {
        return u[c];
      }
    };
  }
  n.EMPTY = new n({}, {}, {}, {});
  function e(a) {
    var s = {}, o = {}, u = {}, c = {}, l = {
      paragraph: s,
      character: o,
      table: u
    };
    return a.getElementsByTagName("w:style").forEach(function(h) {
      var f = t(h);
      if (f.type === "numbering")
        c[f.styleId] = r(h);
      else {
        var d = l[f.type];
        d && (d[f.styleId] = f);
      }
    }), new n(s, o, u, c);
  }
  function t(a) {
    var s = a.attributes["w:type"], o = a.attributes["w:styleId"], u = i(a);
    return { type: s, styleId: o, name: u };
  }
  function i(a) {
    var s = a.first("w:name");
    return s ? s.attributes["w:val"] : null;
  }
  function r(a) {
    var s = a.firstOrEmpty("w:pPr").firstOrEmpty("w:numPr").firstOrEmpty("w:numId").attributes["w:val"];
    return { numId: s };
  }
  return hs;
}
var Zr = {}, Bx;
function y5() {
  if (Bx) return Zr;
  Bx = 1;
  var n = Vr(), e = Pi().Result;
  Zr.createFootnotesReader = t.bind(Zr, "footnote"), Zr.createEndnotesReader = t.bind(Zr, "endnote");
  function t(i, r) {
    function a(u) {
      return e.combine(u.getElementsByTagName("w:" + i).filter(s).map(o));
    }
    function s(u) {
      var c = u.attributes["w:type"];
      return c !== "continuationSeparator" && c !== "separator";
    }
    function o(u) {
      var c = u.attributes["w:id"];
      return r.readXmlElements(u.children).map(function(l) {
        return n.Note({ noteType: i, noteId: c, body: l });
      });
    }
    return a;
  }
  return Zr;
}
var kh = {}, jx;
function v5() {
  if (jx) return kh;
  jx = 1;
  var n = Vr(), e = Pi().Result;
  function t(i) {
    function r(s) {
      return e.combine(s.getElementsByTagName("w:comment").map(a));
    }
    function a(s) {
      var o = s.attributes["w:id"];
      function u(c) {
        return (s.attributes[c] || "").trim() || null;
      }
      return i.readXmlElements(s.children).map(function(c) {
        return n.comment({
          commentId: o,
          body: c,
          authorName: u("w:author"),
          authorInitials: u("w:initials")
        });
      });
    }
    return r;
  }
  return kh.createCommentsReader = t, kh;
}
var Ih = {}, qx;
function x5() {
  if (qx) return Ih;
  qx = 1;
  var n = ur();
  Ih.Files = e;
  function e() {
    function t(i) {
      return n.reject(new Error("could not open external image: '" + i + `'
cannot open linked files from a web browser`));
    }
    return {
      read: t
    };
  }
  return Ih;
}
var Wx;
function _5() {
  if (Wx) return Jo;
  Wx = 1, Jo.read = m, Jo._findPartPaths = b;
  var n = Pc(), e = ur(), t = Vr(), i = Pi().Result, r = kE(), a = u5().readXmlFromZipFile, s = f5().createBodyReader, o = h5().DocumentXmlReader, u = p5(), c = m5(), l = g5(), h = b5(), f = y5(), d = v5(), y = x5().Files;
  function m(L, j) {
    return j = j || {}, e.props({
      contentTypes: T(L),
      partPaths: b(L),
      docxFile: L,
      files: new y(j.path ? n.dirname(j.path) : null)
    }).also(function(C) {
      return {
        styles: U(L, C.partPaths.styles)
      };
    }).also(function(C) {
      return {
        numbering: E(L, C.partPaths.numbering, C.styles)
      };
    }).also(function(C) {
      return {
        footnotes: _(C.partPaths.footnotes, C, function(k, I) {
          return I ? f.createFootnotesReader(k)(I) : new i([]);
        }),
        endnotes: _(C.partPaths.endnotes, C, function(k, I) {
          return I ? f.createEndnotesReader(k)(I) : new i([]);
        }),
        comments: _(C.partPaths.comments, C, function(k, I) {
          return I ? d.createCommentsReader(k)(I) : new i([]);
        })
      };
    }).also(function(C) {
      return {
        notes: C.footnotes.flatMap(function(k) {
          return C.endnotes.map(function(I) {
            return new t.Notes(k.concat(I));
          });
        })
      };
    }).then(function(C) {
      return _(C.partPaths.mainDocument, C, function(k, I) {
        return C.notes.flatMap(function($) {
          return C.comments.flatMap(function(W) {
            var B = new o({
              bodyReader: k,
              notes: $,
              comments: W
            });
            return B.convertXmlToDocument(I);
          });
        });
      });
    });
  }
  function b(L) {
    return D(L).then(function(j) {
      var C = p({
        docxFile: L,
        relationships: j,
        relationshipType: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/officeDocument",
        basePath: "",
        fallbackPath: "word/document.xml"
      });
      if (!L.exists(C))
        throw new Error("Could not find main document part. Are you sure this is a valid .docx file?");
      return v({
        filename: x(C),
        readElement: u.readRelationships,
        defaultValue: u.defaultValue
      })(L).then(function(k) {
        function I($) {
          return p({
            docxFile: L,
            relationships: k,
            relationshipType: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/" + $,
            basePath: r.splitPath(C).dirname,
            fallbackPath: "word/" + $ + ".xml"
          });
        }
        return {
          mainDocument: C,
          comments: I("comments"),
          endnotes: I("endnotes"),
          footnotes: I("footnotes"),
          numbering: I("numbering"),
          styles: I("styles")
        };
      });
    });
  }
  function p(L) {
    var j = L.docxFile, C = L.relationships, k = L.relationshipType, I = L.basePath, $ = L.fallbackPath, W = C.findTargetsByType(k), B = W.map(function(q) {
      return g(r.joinPath(I, q), "/");
    }), z = B.filter(function(q) {
      return j.exists(q);
    });
    return z.length === 0 ? $ : z[0];
  }
  function g(L, j) {
    return L.substring(0, j.length) === j ? L.substring(j.length) : L;
  }
  function v(L) {
    return function(j) {
      return a(j, L.filename).then(function(C) {
        return C ? L.readElement(C) : L.defaultValue;
      });
    };
  }
  function _(L, j, C) {
    var k = v({
      filename: x(L),
      readElement: u.readRelationships,
      defaultValue: u.defaultValue
    });
    return k(j.docxFile).then(function(I) {
      var $ = new s({
        relationships: I,
        contentTypes: j.contentTypes,
        docxFile: j.docxFile,
        numbering: j.numbering,
        styles: j.styles,
        files: j.files
      });
      return a(j.docxFile, L).then(function(W) {
        return C($, W);
      });
    });
  }
  function x(L) {
    var j = r.splitPath(L);
    return r.joinPath(j.dirname, "_rels", j.basename + ".rels");
  }
  var T = v({
    filename: "[Content_Types].xml",
    readElement: c.readContentTypesFromXml,
    defaultValue: c.defaultContentTypes
  });
  function E(L, j, C) {
    return v({
      filename: j,
      readElement: function(k) {
        return l.readNumberingXml(k, { styles: C });
      },
      defaultValue: l.defaultNumbering
    })(L);
  }
  function U(L, j) {
    return v({
      filename: j,
      readElement: h.readStylesXml,
      defaultValue: h.defaultStyles
    })(L);
  }
  var D = v({
    filename: "_rels/.rels",
    readElement: u.readRelationships,
    defaultValue: u.defaultValue
  });
  return Jo;
}
var hu = {}, Vx;
function T5() {
  if (Vx) return hu;
  Vx = 1;
  var n = Pt, e = ur(), t = jE();
  hu.writeStyleMap = s, hu.readStyleMap = l;
  var i = "http://schemas.zwobble.org/mammoth/style-map", r = "mammoth/style-map", a = "/" + r;
  function s(h, f) {
    return h.write(r, f), o(h).then(function() {
      return u(h);
    });
  }
  function o(h) {
    var f = "word/_rels/document.xml.rels", d = "http://schemas.openxmlformats.org/package/2006/relationships", y = "{" + d + "}Relationship";
    return h.read(f, "utf8").then(t.readString).then(function(m) {
      var b = m.children;
      c(b, y, "Id", {
        Id: "rMammothStyleMap",
        Type: i,
        Target: a
      });
      var p = { "": d };
      return h.write(f, t.writeString(m, p));
    });
  }
  function u(h) {
    var f = "[Content_Types].xml", d = "http://schemas.openxmlformats.org/package/2006/content-types", y = "{" + d + "}Override";
    return h.read(f, "utf8").then(t.readString).then(function(m) {
      var b = m.children;
      c(b, y, "PartName", {
        PartName: a,
        ContentType: "text/prs.mammoth.style-map"
      });
      var p = { "": d };
      return h.write(f, t.writeString(m, p));
    });
  }
  function c(h, f, d, y) {
    var m = n.find(h, function(b) {
      return b.name === f && b.attributes[d] === y[d];
    });
    m ? m.attributes = y : h.push(t.element(f, y));
  }
  function l(h) {
    return h.exists(r) ? h.read(r, "utf8") : e.resolve(null);
  }
  return hu;
}
var pu = {}, _r = {}, Si = {}, Hi = {}, Hx;
function qE() {
  if (Hx) return Hi;
  Hx = 1;
  var n = ol();
  function e(u, c, l) {
    return i(
      n.element(u, c, { fresh: !1 }),
      l
    );
  }
  function t(u, c, l) {
    var h = n.element(u, c, { fresh: !0 });
    return i(h, l);
  }
  function i(u, c) {
    return {
      type: "element",
      tag: u,
      children: c || []
    };
  }
  function r(u) {
    return {
      type: "text",
      value: u
    };
  }
  var a = {
    type: "forceWrite"
  };
  Hi.freshElement = t, Hi.nonFreshElement = e, Hi.elementWithTag = i, Hi.text = r, Hi.forceWrite = a;
  var s = {
    br: !0,
    hr: !0,
    img: !0
  };
  function o(u) {
    return u.children.length === 0 && s[u.tag.tagName];
  }
  return Hi.isVoidElement = o, Hi;
}
var Uh, zx;
function w5() {
  if (zx) return Uh;
  zx = 1;
  var n = Pt, e = qE();
  function t(m) {
    return i(c(m));
  }
  function i(m) {
    var b = [];
    return m.map(r).forEach(function(p) {
      u(b, p);
    }), b;
  }
  function r(m) {
    return a[m.type](m);
  }
  var a = {
    element: s,
    text: o,
    forceWrite: o
  };
  function s(m) {
    return e.elementWithTag(m.tag, i(m.children));
  }
  function o(m) {
    return m;
  }
  function u(m, b) {
    var p = m[m.length - 1];
    b.type === "element" && !b.tag.fresh && p && p.type === "element" && b.tag.matchesElement(p.tag) ? (b.tag.separator && u(p.children, e.text(b.tag.separator)), b.children.forEach(function(g) {
      u(p.children, g);
    })) : m.push(b);
  }
  function c(m) {
    return l(m, function(b) {
      return h[b.type](b);
    });
  }
  function l(m, b) {
    return n.flatten(n.map(m, b), !0);
  }
  var h = {
    element: d,
    text: y,
    forceWrite: f
  };
  function f(m) {
    return [m];
  }
  function d(m) {
    var b = c(m.children);
    return b.length === 0 && !e.isVoidElement(m) ? [] : [e.elementWithTag(m.tag, b)];
  }
  function y(m) {
    return m.value.length === 0 ? [] : [m];
  }
  return Uh = t, Uh;
}
var $x;
function sl() {
  if ($x) return Si;
  $x = 1;
  var n = qE();
  Si.freshElement = n.freshElement, Si.nonFreshElement = n.nonFreshElement, Si.elementWithTag = n.elementWithTag, Si.text = n.text, Si.forceWrite = n.forceWrite, Si.simplify = w5();
  function e(s, o) {
    o.forEach(function(u) {
      t(s, u);
    });
  }
  function t(s, o) {
    i[o.type](s, o);
  }
  var i = {
    element: r,
    text: a,
    forceWrite: function() {
    }
  };
  function r(s, o) {
    n.isVoidElement(o) ? s.selfClosing(o.tag.tagName, o.tag.attributes) : (s.open(o.tag.tagName, o.tag.attributes), e(s, o.children), s.close(o.tag.tagName));
  }
  function a(s, o) {
    s.text(o.value);
  }
  return Si.write = e, Si;
}
var Gx;
function ol() {
  if (Gx) return _r;
  Gx = 1;
  var n = Pt, e = sl();
  _r.topLevelElement = t, _r.elements = i, _r.element = a;
  function t(o, u) {
    return i([a(o, u, { fresh: !0 })]);
  }
  function i(o) {
    return new r(o.map(function(u) {
      return n.isString(u) ? a(u) : u;
    }));
  }
  function r(o) {
    this._elements = o;
  }
  r.prototype.wrap = function(u) {
    for (var c = u(), l = this._elements.length - 1; l >= 0; l--)
      c = this._elements[l].wrapNodes(c);
    return c;
  };
  function a(o, u, c) {
    return c = c || {}, new s(o, u, c);
  }
  function s(o, u, c) {
    var l = {};
    n.isArray(o) ? (o.forEach(function(h) {
      l[h] = !0;
    }), o = o[0]) : l[o] = !0, this.tagName = o, this.tagNames = l, this.attributes = u || {}, this.fresh = c.fresh, this.separator = c.separator;
  }
  return s.prototype.matchesElement = function(o) {
    return this.tagNames[o.tagName] && n.isEqual(this.attributes || {}, o.attributes || {});
  }, s.prototype.wrap = function(u) {
    return this.wrapNodes(u());
  }, s.prototype.wrapNodes = function(u) {
    return [e.elementWithTag(this, u)];
  }, _r.empty = i([]), _r.ignore = {
    wrap: function() {
      return [];
    }
  }, _r;
}
var Rh = {}, Xx;
function WE() {
  return Xx || (Xx = 1, (function(n) {
    var e = Pt, t = ur(), i = sl();
    n.imgElement = r;
    function r(a) {
      return function(s, o) {
        return t.when(a(s)).then(function(u) {
          var c = {};
          return s.altText && (c.alt = s.altText), e.extend(c, u), [i.freshElement("img", c)];
        });
      };
    }
    n.inline = n.imgElement, n.dataUri = r(function(a) {
      return a.read("base64").then(function(s) {
        return {
          src: "data:" + a.contentType + ";base64," + s
        };
      });
    });
  })(Rh)), Rh;
}
var Oh = {}, Lh = {}, Ph = {}, Fh, Kx;
function E5() {
  return Kx || (Kx = 1, Fh = function(e) {
    return e && typeof e == "object" && typeof e.copy == "function" && typeof e.fill == "function" && typeof e.readUInt8 == "function";
  }), Fh;
}
var mu = { exports: {} }, Yx;
function D5() {
  return Yx || (Yx = 1, typeof Object.create == "function" ? mu.exports = function(e, t) {
    e.super_ = t, e.prototype = Object.create(t.prototype, {
      constructor: {
        value: e,
        enumerable: !1,
        writable: !0,
        configurable: !0
      }
    });
  } : mu.exports = function(e, t) {
    e.super_ = t;
    var i = function() {
    };
    i.prototype = t.prototype, e.prototype = new i(), e.prototype.constructor = e;
  }), mu.exports;
}
var Qx;
function VE() {
  return Qx || (Qx = 1, (function(n) {
    var e = /%[sdj%]/g;
    n.format = function(B) {
      if (!v(B)) {
        for (var z = [], q = 0; q < arguments.length; q++)
          z.push(r(arguments[q]));
        return z.join(" ");
      }
      for (var q = 1, Y = arguments, H = Y.length, K = String(B).replace(e, function(ge) {
        if (ge === "%%") return "%";
        if (q >= H) return ge;
        switch (ge) {
          case "%s":
            return String(Y[q++]);
          case "%d":
            return Number(Y[q++]);
          case "%j":
            try {
              return JSON.stringify(Y[q++]);
            } catch {
              return "[Circular]";
            }
          default:
            return ge;
        }
      }), ie = Y[q]; q < H; ie = Y[++q])
        b(ie) || !E(ie) ? K += " " + ie : K += " " + r(ie);
      return K;
    }, n.deprecate = function(B, z) {
      if (x(At.process))
        return function() {
          return n.deprecate(B, z).apply(this, arguments);
        };
      if (process.noDeprecation === !0)
        return B;
      var q = !1;
      function Y() {
        if (!q) {
          if (process.throwDeprecation)
            throw new Error(z);
          process.traceDeprecation ? console.trace(z) : console.error(z), q = !0;
        }
        return B.apply(this, arguments);
      }
      return Y;
    };
    var t = {}, i;
    n.debuglog = function(B) {
      if (x(i) && (i = process.env.NODE_DEBUG || ""), B = B.toUpperCase(), !t[B])
        if (new RegExp("\\b" + B + "\\b", "i").test(i)) {
          var z = process.pid;
          t[B] = function() {
            var q = n.format.apply(n, arguments);
            console.error("%s %d: %s", B, z, q);
          };
        } else
          t[B] = function() {
          };
      return t[B];
    };
    function r(B, z) {
      var q = {
        seen: [],
        stylize: s
      };
      return arguments.length >= 3 && (q.depth = arguments[2]), arguments.length >= 4 && (q.colors = arguments[3]), m(z) ? q.showHidden = z : z && n._extend(q, z), x(q.showHidden) && (q.showHidden = !1), x(q.depth) && (q.depth = 2), x(q.colors) && (q.colors = !1), x(q.customInspect) && (q.customInspect = !0), q.colors && (q.stylize = a), u(q, B, q.depth);
    }
    n.inspect = r, r.colors = {
      bold: [1, 22],
      italic: [3, 23],
      underline: [4, 24],
      inverse: [7, 27],
      white: [37, 39],
      grey: [90, 39],
      black: [30, 39],
      blue: [34, 39],
      cyan: [36, 39],
      green: [32, 39],
      magenta: [35, 39],
      red: [31, 39],
      yellow: [33, 39]
    }, r.styles = {
      special: "cyan",
      number: "yellow",
      boolean: "yellow",
      undefined: "grey",
      null: "bold",
      string: "green",
      date: "magenta",
      // "name": intentionally not styling
      regexp: "red"
    };
    function a(B, z) {
      var q = r.styles[z];
      return q ? "\x1B[" + r.colors[q][0] + "m" + B + "\x1B[" + r.colors[q][1] + "m" : B;
    }
    function s(B, z) {
      return B;
    }
    function o(B) {
      var z = {};
      return B.forEach(function(q, Y) {
        z[q] = !0;
      }), z;
    }
    function u(B, z, q) {
      if (B.customInspect && z && L(z.inspect) && // Filter out the util module, it's inspect function is special
      z.inspect !== n.inspect && // Also filter out any prototype objects using the circular check.
      !(z.constructor && z.constructor.prototype === z)) {
        var Y = z.inspect(q, B);
        return v(Y) || (Y = u(B, Y, q)), Y;
      }
      var H = c(B, z);
      if (H)
        return H;
      var K = Object.keys(z), ie = o(K);
      if (B.showHidden && (K = Object.getOwnPropertyNames(z)), D(z) && (K.indexOf("message") >= 0 || K.indexOf("description") >= 0))
        return l(z);
      if (K.length === 0) {
        if (L(z)) {
          var ge = z.name ? ": " + z.name : "";
          return B.stylize("[Function" + ge + "]", "special");
        }
        if (T(z))
          return B.stylize(RegExp.prototype.toString.call(z), "regexp");
        if (U(z))
          return B.stylize(Date.prototype.toString.call(z), "date");
        if (D(z))
          return l(z);
      }
      var pe = "", ce = !1, oe = ["{", "}"];
      if (y(z) && (ce = !0, oe = ["[", "]"]), L(z)) {
        var De = z.name ? ": " + z.name : "";
        pe = " [Function" + De + "]";
      }
      if (T(z) && (pe = " " + RegExp.prototype.toString.call(z)), U(z) && (pe = " " + Date.prototype.toUTCString.call(z)), D(z) && (pe = " " + l(z)), K.length === 0 && (!ce || z.length == 0))
        return oe[0] + pe + oe[1];
      if (q < 0)
        return T(z) ? B.stylize(RegExp.prototype.toString.call(z), "regexp") : B.stylize("[Object]", "special");
      B.seen.push(z);
      var Re;
      return ce ? Re = h(B, z, q, ie, K) : Re = K.map(function(Me) {
        return f(B, z, q, ie, Me, ce);
      }), B.seen.pop(), d(Re, pe, oe);
    }
    function c(B, z) {
      if (x(z))
        return B.stylize("undefined", "undefined");
      if (v(z)) {
        var q = "'" + JSON.stringify(z).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
        return B.stylize(q, "string");
      }
      if (g(z))
        return B.stylize("" + z, "number");
      if (m(z))
        return B.stylize("" + z, "boolean");
      if (b(z))
        return B.stylize("null", "null");
    }
    function l(B) {
      return "[" + Error.prototype.toString.call(B) + "]";
    }
    function h(B, z, q, Y, H) {
      for (var K = [], ie = 0, ge = z.length; ie < ge; ++ie)
        W(z, String(ie)) ? K.push(f(
          B,
          z,
          q,
          Y,
          String(ie),
          !0
        )) : K.push("");
      return H.forEach(function(pe) {
        pe.match(/^\d+$/) || K.push(f(
          B,
          z,
          q,
          Y,
          pe,
          !0
        ));
      }), K;
    }
    function f(B, z, q, Y, H, K) {
      var ie, ge, pe;
      if (pe = Object.getOwnPropertyDescriptor(z, H) || { value: z[H] }, pe.get ? pe.set ? ge = B.stylize("[Getter/Setter]", "special") : ge = B.stylize("[Getter]", "special") : pe.set && (ge = B.stylize("[Setter]", "special")), W(Y, H) || (ie = "[" + H + "]"), ge || (B.seen.indexOf(pe.value) < 0 ? (b(q) ? ge = u(B, pe.value, null) : ge = u(B, pe.value, q - 1), ge.indexOf(`
`) > -1 && (K ? ge = ge.split(`
`).map(function(ce) {
        return "  " + ce;
      }).join(`
`).substr(2) : ge = `
` + ge.split(`
`).map(function(ce) {
        return "   " + ce;
      }).join(`
`))) : ge = B.stylize("[Circular]", "special")), x(ie)) {
        if (K && H.match(/^\d+$/))
          return ge;
        ie = JSON.stringify("" + H), ie.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/) ? (ie = ie.substr(1, ie.length - 2), ie = B.stylize(ie, "name")) : (ie = ie.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'"), ie = B.stylize(ie, "string"));
      }
      return ie + ": " + ge;
    }
    function d(B, z, q) {
      var Y = B.reduce(function(H, K) {
        return K.indexOf(`
`) >= 0, H + K.replace(/\u001b\[\d\d?m/g, "").length + 1;
      }, 0);
      return Y > 60 ? q[0] + (z === "" ? "" : z + `
 `) + " " + B.join(`,
  `) + " " + q[1] : q[0] + z + " " + B.join(", ") + " " + q[1];
    }
    function y(B) {
      return Array.isArray(B);
    }
    n.isArray = y;
    function m(B) {
      return typeof B == "boolean";
    }
    n.isBoolean = m;
    function b(B) {
      return B === null;
    }
    n.isNull = b;
    function p(B) {
      return B == null;
    }
    n.isNullOrUndefined = p;
    function g(B) {
      return typeof B == "number";
    }
    n.isNumber = g;
    function v(B) {
      return typeof B == "string";
    }
    n.isString = v;
    function _(B) {
      return typeof B == "symbol";
    }
    n.isSymbol = _;
    function x(B) {
      return B === void 0;
    }
    n.isUndefined = x;
    function T(B) {
      return E(B) && C(B) === "[object RegExp]";
    }
    n.isRegExp = T;
    function E(B) {
      return typeof B == "object" && B !== null;
    }
    n.isObject = E;
    function U(B) {
      return E(B) && C(B) === "[object Date]";
    }
    n.isDate = U;
    function D(B) {
      return E(B) && (C(B) === "[object Error]" || B instanceof Error);
    }
    n.isError = D;
    function L(B) {
      return typeof B == "function";
    }
    n.isFunction = L;
    function j(B) {
      return B === null || typeof B == "boolean" || typeof B == "number" || typeof B == "string" || typeof B == "symbol" || // ES6 symbol
      typeof B > "u";
    }
    n.isPrimitive = j, n.isBuffer = E5();
    function C(B) {
      return Object.prototype.toString.call(B);
    }
    function k(B) {
      return B < 10 ? "0" + B.toString(10) : B.toString(10);
    }
    var I = [
      "Jan",
      "Feb",
      "Mar",
      "Apr",
      "May",
      "Jun",
      "Jul",
      "Aug",
      "Sep",
      "Oct",
      "Nov",
      "Dec"
    ];
    function $() {
      var B = /* @__PURE__ */ new Date(), z = [
        k(B.getHours()),
        k(B.getMinutes()),
        k(B.getSeconds())
      ].join(":");
      return [B.getDate(), I[B.getMonth()], z].join(" ");
    }
    n.log = function() {
      console.log("%s - %s", $(), n.format.apply(n, arguments));
    }, n.inherits = D5(), n._extend = function(B, z) {
      if (!z || !E(z)) return B;
      for (var q = Object.keys(z), Y = q.length; Y--; )
        B[q[Y]] = z[q[Y]];
      return B;
    };
    function W(B, z) {
      return Object.prototype.hasOwnProperty.call(B, z);
    }
  })(Ph)), Ph;
}
var Zx;
function S5() {
  if (Zx) return Lh;
  Zx = 1;
  var n = VE(), e = Pt;
  Lh.writer = t;
  function t(u) {
    return u = u || {}, u.prettyPrint ? r() : a();
  }
  var i = {
    div: !0,
    p: !0,
    ul: !0,
    li: !0
  };
  function r() {
    var u = 0, c = "  ", l = [], h = !0, f = !1, d = a();
    function y(T, E) {
      i[T] && _(), l.push(T), d.open(T, E), i[T] && u++, h = !1;
    }
    function m(T) {
      i[T] && (u--, _()), l.pop(), d.close(T);
    }
    function b(T) {
      v();
      var E = x() ? T : T.replace(`
`, `
` + c);
      d.text(E);
    }
    function p(T, E) {
      _(), d.selfClosing(T, E);
    }
    function g() {
      return l.length === 0 || i[l[l.length - 1]];
    }
    function v() {
      f || (_(), f = !0);
    }
    function _() {
      if (f = !1, !h && g() && !x()) {
        d._append(`
`);
        for (var T = 0; T < u; T++)
          d._append(c);
      }
    }
    function x() {
      return e.some(l, function(T) {
        return T === "pre";
      });
    }
    return {
      asString: d.asString,
      open: y,
      close: m,
      text: b,
      selfClosing: p
    };
  }
  function a() {
    var u = [];
    function c(b, p) {
      var g = f(p);
      u.push(n.format("<%s%s>", b, g));
    }
    function l(b) {
      u.push(n.format("</%s>", b));
    }
    function h(b, p) {
      var g = f(p);
      u.push(n.format("<%s%s />", b, g));
    }
    function f(b) {
      return e.map(b, function(p, g) {
        return n.format(' %s="%s"', g, o(p));
      }).join("");
    }
    function d(b) {
      u.push(s(b));
    }
    function y(b) {
      u.push(b);
    }
    function m() {
      return u.join("");
    }
    return {
      asString: m,
      open: c,
      close: l,
      text: d,
      selfClosing: h,
      _append: y
    };
  }
  function s(u) {
    return u.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
  }
  function o(u) {
    return u.replace(/&/g, "&amp;").replace(/"/g, "&quot;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
  }
  return Lh;
}
var Nh = {}, Jx;
function C5() {
  if (Jx) return Nh;
  Jx = 1;
  var n = Pt;
  function e(h) {
    return t(h, h);
  }
  function t(h, f) {
    return function() {
      return { start: h, end: f };
    };
  }
  function i(h) {
    var f = h.href || "";
    return f ? {
      start: "[",
      end: "](" + f + ")",
      anchorPosition: "before"
    } : {};
  }
  function r(h) {
    var f = h.src || "", d = h.alt || "";
    return f || d ? { start: "![" + d + "](" + f + ")" } : {};
  }
  function a(h) {
    return function(f, d) {
      return {
        start: d ? `
` : "",
        end: d ? "" : `
`,
        list: {
          isOrdered: h.isOrdered,
          indent: d ? d.indent + 1 : 0,
          count: 0
        }
      };
    };
  }
  function s(h, f, d) {
    f = f || { indent: 0, isOrdered: !1, count: 0 }, f.count++, d.hasClosed = !1;
    var y = f.isOrdered ? f.count + "." : "-", m = u("	", f.indent) + y + " ";
    return {
      start: m,
      end: function() {
        if (!d.hasClosed)
          return d.hasClosed = !0, `
`;
      }
    };
  }
  var o = {
    p: t("", `

`),
    br: t("", `  
`),
    ul: a({ isOrdered: !1 }),
    ol: a({ isOrdered: !0 }),
    li: s,
    strong: e("__"),
    em: e("*"),
    a: i,
    img: r
  };
  (function() {
    for (var h = 1; h <= 6; h++)
      o["h" + h] = t(u("#", h) + " ", `

`);
  })();
  function u(h, f) {
    return new Array(f + 1).join(h);
  }
  function c() {
    var h = [], f = [], d = null, y = {};
    function m(x, T) {
      T = T || {};
      var E = o[x] || function() {
        return {};
      }, U = E(T, d, y);
      f.push({ end: U.end, list: d }), U.list && (d = U.list);
      var D = U.anchorPosition === "before";
      D && b(T), h.push(U.start || ""), D || b(T);
    }
    function b(x) {
      x.id && h.push('<a id="' + x.id + '"></a>');
    }
    function p(x) {
      var T = f.pop();
      d = T.list;
      var E = n.isFunction(T.end) ? T.end() : T.end;
      h.push(E || "");
    }
    function g(x, T) {
      m(x, T), p();
    }
    function v(x) {
      h.push(l(x));
    }
    function _() {
      return h.join("");
    }
    return {
      asString: _,
      open: m,
      close: p,
      text: v,
      selfClosing: g
    };
  }
  Nh.writer = c;
  function l(h) {
    return h.replace(/\\/g, "\\\\").replace(/([\`\*_\{\}\[\]\(\)\#\+\-\.\!])/g, "\\$1");
  }
  return Nh;
}
var e2;
function A5() {
  if (e2) return Oh;
  e2 = 1;
  var n = S5(), e = C5();
  Oh.writer = t;
  function t(i) {
    return i = i || {}, i.outputFormat === "markdown" ? e.writer() : n.writer(i);
  }
  return Oh;
}
var t2;
function k5() {
  if (t2) return pu;
  t2 = 1;
  var n = Pt, e = ur(), t = Vr(), i = ol(), r = Pi(), a = WE(), s = sl(), o = A5();
  pu.DocumentConverter = u;
  function u(b) {
    return {
      convertToHtml: function(p) {
        var g = n.indexBy(
          p.type === t.types.document ? p.comments : [],
          "commentId"
        ), v = new c(b, g);
        return v.convertToHtml(p);
      }
    };
  }
  function c(b, p) {
    var g = 1, v = [], _ = [];
    b = n.extend({ ignoreEmptyParagraphs: !0 }, b);
    var x = b.idPrefix === void 0 ? "" : b.idPrefix, T = b.ignoreEmptyParagraphs, E = i.topLevelElement("p"), U = b.styleMap || [];
    function D(S) {
      var he = [], ae = j(S, he, {}), te = [];
      y(ae, function(ve) {
        ve.type === "deferred" && te.push(ve);
      });
      var ee = {};
      return e.mapSeries(te, function(ve) {
        return ve.value().then(function(Ee) {
          ee[ve.id] = Ee;
        });
      }).then(function() {
        function ve(Se) {
          return d(Se, function(xe) {
            return xe.type === "deferred" ? ee[xe.id] : xe.children ? [
              n.extend({}, xe, {
                children: ve(xe.children)
              })
            ] : [xe];
          });
        }
        var Ee = o.writer({
          prettyPrint: b.prettyPrint,
          outputFormat: b.outputFormat
        });
        return s.write(Ee, s.simplify(ve(ae))), new r.Result(Ee.asString(), he);
      });
    }
    function L(S, he, ae) {
      return d(S, function(te) {
        return j(te, he, ae);
      });
    }
    function j(S, he, ae) {
      if (!ae)
        throw new Error("options not set");
      var te = ne[S.type];
      return te ? te(S, he, ae) : [];
    }
    function C(S, he, ae) {
      return k(S, he).wrap(function() {
        var te = L(S.children, he, ae);
        return T ? te : [s.forceWrite].concat(te);
      });
    }
    function k(S, he) {
      var ae = B(S);
      return ae ? ae.to : (S.styleId && he.push(f("paragraph", S)), E);
    }
    function I(S, he, ae) {
      var te = function() {
        return L(S.children, he, ae);
      }, ee = [];
      S.isSmallCaps && ee.push($("smallCaps")), S.isAllCaps && ee.push($("allCaps")), S.isStrikethrough && ee.push($("strikethrough", "s")), S.isUnderline && ee.push($("underline")), S.verticalAlignment === t.verticalAlignment.subscript && ee.push(i.element("sub", {}, { fresh: !1 })), S.verticalAlignment === t.verticalAlignment.superscript && ee.push(i.element("sup", {}, { fresh: !1 })), S.isItalic && ee.push($("italic", "em")), S.isBold && ee.push($("bold", "strong"));
      var ve = i.empty, Ee = B(S);
      return Ee ? ve = Ee.to : S.styleId && he.push(f("run", S)), ee.push(ve), ee.forEach(function(Se) {
        te = Se.wrap.bind(Se, te);
      }), te();
    }
    function $(S, he) {
      var ae = W({ type: S });
      return ae || (he ? i.element(he, {}, { fresh: !1 }) : i.empty);
    }
    function W(S, he) {
      var ae = B(S);
      return ae ? ae.to : he;
    }
    function B(S) {
      for (var he = 0; he < U.length; he++)
        if (U[he].from.matches(S))
          return U[he];
    }
    function z(S) {
      return function(he, ae) {
        return e.attempt(function() {
          return S(he, ae);
        }).caught(function(te) {
          return ae.push(r.error(te)), [];
        });
      };
    }
    function q(S) {
      return H(S.noteType, S.noteId);
    }
    function Y(S) {
      return K(S.noteType, S.noteId);
    }
    function H(S, he) {
      return ie(S + "-" + he);
    }
    function K(S, he) {
      return ie(S + "-ref-" + he);
    }
    function ie(S) {
      return x + S;
    }
    var ge = i.elements([
      i.element("table", {}, { fresh: !0 })
    ]);
    function pe(S, he, ae) {
      return W(S, ge).wrap(function() {
        return ce(S, he, ae);
      });
    }
    function ce(S, he, ae) {
      var te = n.findIndex(S.children, function(Se) {
        return !Se.type === t.types.tableRow || !Se.isHeader;
      });
      te === -1 && (te = S.children.length);
      var ee;
      if (te === 0)
        ee = L(
          S.children,
          he,
          n.extend({}, ae, { isTableHeader: !1 })
        );
      else {
        var ve = L(
          S.children.slice(0, te),
          he,
          n.extend({}, ae, { isTableHeader: !0 })
        ), Ee = L(
          S.children.slice(te),
          he,
          n.extend({}, ae, { isTableHeader: !1 })
        );
        ee = [
          s.freshElement("thead", {}, ve),
          s.freshElement("tbody", {}, Ee)
        ];
      }
      return [s.forceWrite].concat(ee);
    }
    function oe(S, he, ae) {
      var te = L(S.children, he, ae);
      return [
        s.freshElement("tr", {}, [s.forceWrite].concat(te))
      ];
    }
    function De(S, he, ae) {
      var te = ae.isTableHeader ? "th" : "td", ee = L(S.children, he, ae), ve = {};
      return S.colSpan !== 1 && (ve.colspan = S.colSpan.toString()), S.rowSpan !== 1 && (ve.rowspan = S.rowSpan.toString()), [
        s.freshElement(te, ve, [s.forceWrite].concat(ee))
      ];
    }
    function Re(S, he, ae) {
      return W(S, i.ignore).wrap(function() {
        var te = p[S.commentId], ee = _.length + 1, ve = "[" + m(te) + ee + "]";
        return _.push({ label: ve, comment: te }), [
          s.freshElement("a", {
            href: "#" + H("comment", S.commentId),
            id: K("comment", S.commentId)
          }, [s.text(ve)])
        ];
      });
    }
    function Me(S, he, ae) {
      var te = S.label, ee = S.comment, ve = L(ee.body, he, ae).concat([
        s.nonFreshElement("p", {}, [
          s.text(" "),
          s.freshElement("a", { href: "#" + K("comment", ee.commentId) }, [
            s.text("")
          ])
        ])
      ]);
      return [
        s.freshElement(
          "dt",
          { id: H("comment", ee.commentId) },
          [s.text("Comment " + te)]
        ),
        s.freshElement("dd", {}, ve)
      ];
    }
    function F(S, he, ae) {
      return P(S).wrap(function() {
        return [];
      });
    }
    function P(S) {
      var he = B(S);
      return he ? he.to : S.breakType === "line" ? i.topLevelElement("br") : i.empty;
    }
    var ne = {
      document: function(S, he, ae) {
        var te = L(S.children, he, ae), ee = v.map(function(Ee) {
          return S.notes.resolve(Ee);
        }), ve = L(ee, he, ae);
        return te.concat([
          s.freshElement("ol", {}, ve),
          s.freshElement("dl", {}, d(_, function(Ee) {
            return Me(Ee, he, ae);
          }))
        ]);
      },
      paragraph: C,
      run: I,
      text: function(S, he, ae) {
        return [s.text(S.value)];
      },
      tab: function(S, he, ae) {
        return [s.text("	")];
      },
      hyperlink: function(S, he, ae) {
        var te = S.anchor ? "#" + ie(S.anchor) : S.href, ee = { href: te };
        S.targetFrame != null && (ee.target = S.targetFrame);
        var ve = L(S.children, he, ae);
        return [s.nonFreshElement("a", ee, ve)];
      },
      bookmarkStart: function(S, he, ae) {
        var te = s.freshElement("a", {
          id: ie(S.name)
        }, [s.forceWrite]);
        return [te];
      },
      noteReference: function(S, he, ae) {
        v.push(S);
        var te = s.freshElement("a", {
          href: "#" + q(S),
          id: Y(S)
        }, [s.text("[" + g++ + "]")]);
        return [s.freshElement("sup", {}, [te])];
      },
      note: function(S, he, ae) {
        var te = L(S.body, he, ae), ee = s.elementWithTag(i.element("p", {}, { fresh: !1 }), [
          s.text(" "),
          s.freshElement("a", { href: "#" + Y(S) }, [s.text("")])
        ]), ve = te.concat([ee]);
        return s.freshElement("li", { id: q(S) }, ve);
      },
      commentReference: Re,
      comment: Me,
      image: h(z(b.convertImage || a.dataUri)),
      table: pe,
      tableRow: oe,
      tableCell: De,
      break: F
    };
    return {
      convertToHtml: D
    };
  }
  var l = 1;
  function h(b) {
    return function(p, g, v) {
      return [
        {
          type: "deferred",
          id: l++,
          value: function() {
            return b(p, g, v);
          }
        }
      ];
    };
  }
  function f(b, p) {
    return r.warning(
      "Unrecognised " + b + " style: '" + p.styleName + "' (Style ID: " + p.styleId + ")"
    );
  }
  function d(b, p) {
    return n.flatten(b.map(p), !0);
  }
  function y(b, p) {
    b.forEach(function(g) {
      p(g), g.children && y(g.children, p);
    });
  }
  var m = pu.commentAuthorLabel = function(p) {
    return p.authorInitials || "";
  };
  return pu;
}
var Mh = {}, n2;
function I5() {
  if (n2) return Mh;
  n2 = 1;
  var n = Vr();
  function e(t) {
    if (t.type === "text")
      return t.value;
    if (t.type === n.types.tab)
      return "	";
    var i = t.type === "paragraph" ? `

` : "";
    return (t.children || []).map(e).join("") + i;
  }
  return Mh.convertElementToRawText = e, Mh;
}
var ps = {}, Yn = {}, Bh = {}, jh = { exports: {} }, i2;
function U5() {
  if (i2) return jh.exports;
  i2 = 1;
  var n = jh.exports = function(e, t) {
    this._tokens = e, this._startIndex = t || 0;
  };
  return n.prototype.head = function() {
    return this._tokens[this._startIndex];
  }, n.prototype.tail = function(e) {
    return new n(this._tokens, this._startIndex + 1);
  }, n.prototype.toArray = function() {
    return this._tokens.slice(this._startIndex);
  }, n.prototype.end = function() {
    return this._tokens[this._tokens.length - 1];
  }, n.prototype.to = function(e) {
    var t = this.head().source, i = e.head() || e.end();
    return t.to(i.source);
  }, jh.exports;
}
var r2;
function R5() {
  if (r2) return Bh;
  r2 = 1;
  var n = U5();
  return Bh.Parser = function(e) {
    var t = function(i, r) {
      return i(new n(r));
    };
    return {
      parseTokens: t
    };
  }, Bh;
}
var qh = {}, Wh = {}, a2;
function O5() {
  return a2 || (a2 = 1, (function(n) {
    n.none = /* @__PURE__ */ Object.create({
      value: function() {
        throw new Error("Called value on none");
      },
      isNone: function() {
        return !0;
      },
      isSome: function() {
        return !1;
      },
      map: function() {
        return n.none;
      },
      flatMap: function() {
        return n.none;
      },
      filter: function() {
        return n.none;
      },
      toArray: function() {
        return [];
      },
      orElse: e,
      valueOrElse: e
    });
    function e(i) {
      return typeof i == "function" ? i() : i;
    }
    n.some = function(i) {
      return new t(i);
    };
    var t = function(i) {
      this._value = i;
    };
    t.prototype.value = function() {
      return this._value;
    }, t.prototype.isNone = function() {
      return !1;
    }, t.prototype.isSome = function() {
      return !0;
    }, t.prototype.map = function(i) {
      return new t(i(this._value));
    }, t.prototype.flatMap = function(i) {
      return i(this._value);
    }, t.prototype.filter = function(i) {
      return i(this._value) ? this : n.none;
    }, t.prototype.toArray = function() {
      return [this._value];
    }, t.prototype.orElse = function(i) {
      return this;
    }, t.prototype.valueOrElse = function(i) {
      return this._value;
    }, n.isOption = function(i) {
      return i === n.none || i instanceof t;
    }, n.fromNullable = function(i) {
      return i == null ? n.none : new t(i);
    };
  })(Wh)), Wh;
}
var Vh, s2;
function Bg() {
  if (s2) return Vh;
  s2 = 1, Vh = {
    failure: function(e, t) {
      if (e.length < 1)
        throw new Error("Failure must have errors");
      return new n({
        status: "failure",
        remaining: t,
        errors: e
      });
    },
    error: function(e, t) {
      if (e.length < 1)
        throw new Error("Failure must have errors");
      return new n({
        status: "error",
        remaining: t,
        errors: e
      });
    },
    success: function(e, t, i) {
      return new n({
        status: "success",
        value: e,
        source: i,
        remaining: t,
        errors: []
      });
    },
    cut: function(e) {
      return new n({
        status: "cut",
        remaining: e,
        errors: []
      });
    }
  };
  var n = function(e) {
    this._value = e.value, this._status = e.status, this._hasValue = e.value !== void 0, this._remaining = e.remaining, this._source = e.source, this._errors = e.errors;
  };
  return n.prototype.map = function(e) {
    return this._hasValue ? new n({
      value: e(this._value, this._source),
      status: this._status,
      remaining: this._remaining,
      source: this._source,
      errors: this._errors
    }) : this;
  }, n.prototype.changeRemaining = function(e) {
    return new n({
      value: this._value,
      status: this._status,
      remaining: e,
      source: this._source,
      errors: this._errors
    });
  }, n.prototype.isSuccess = function() {
    return this._status === "success" || this._status === "cut";
  }, n.prototype.isFailure = function() {
    return this._status === "failure";
  }, n.prototype.isError = function() {
    return this._status === "error";
  }, n.prototype.isCut = function() {
    return this._status === "cut";
  }, n.prototype.value = function() {
    return this._value;
  }, n.prototype.remaining = function() {
    return this._remaining;
  }, n.prototype.source = function() {
    return this._source;
  }, n.prototype.errors = function() {
    return this._errors;
  }, Vh;
}
var Hh = {}, o2;
function HE() {
  if (o2) return Hh;
  o2 = 1, Hh.error = function(e) {
    return new n(e);
  };
  var n = function(e) {
    this.expected = e.expected, this.actual = e.actual, this._location = e.location;
  };
  return n.prototype.describe = function() {
    var e = this._location ? this._location.describe() + `:
` : "";
    return e + "Expected " + this.expected + `
but got ` + this.actual;
  }, n.prototype.lineNumber = function() {
    return this._location.lineNumber();
  }, n.prototype.characterNumber = function() {
    return this._location.characterNumber();
  }, Hh;
}
var zh = {}, u2;
function L5() {
  if (u2) return zh;
  u2 = 1, zh.fromArray = function(e) {
    var t = 0, i = function() {
      return t < e.length;
    };
    return new n({
      hasNext: i,
      next: function() {
        if (i())
          return e[t++];
        throw new Error("No more elements");
      }
    });
  };
  var n = function(e) {
    this._iterator = e;
  };
  return n.prototype.map = function(e) {
    var t = this._iterator;
    return new n({
      hasNext: function() {
        return t.hasNext();
      },
      next: function() {
        return e(t.next());
      }
    });
  }, n.prototype.filter = function(e) {
    var t = this._iterator, i = !1, r = !1, a, s = function() {
      if (!i)
        for (i = !0, r = !1; t.hasNext() && !r; )
          a = t.next(), r = e(a);
    };
    return new n({
      hasNext: function() {
        return s(), r;
      },
      next: function() {
        s();
        var o = a;
        return i = !1, o;
      }
    });
  }, n.prototype.first = function() {
    var e = this._iterator;
    return this._iterator.hasNext() ? e.next() : null;
  }, n.prototype.toArray = function() {
    for (var e = []; this._iterator.hasNext(); )
      e.push(this._iterator.next());
    return e;
  }, zh;
}
var c2;
function zE() {
  return c2 || (c2 = 1, (function(n) {
    var e = Pt, t = O5(), i = Bg(), r = HE(), a = L5();
    n.token = function(f, d) {
      var y = d !== void 0;
      return function(m) {
        var b = m.head();
        if (b && b.name === f && (!y || b.value === d))
          return i.success(b.value, m.tail(), b.source);
        var p = l({ name: f, value: d });
        return h(m, p);
      };
    }, n.tokenOfType = function(f) {
      return n.token(f);
    }, n.firstOf = function(f, d) {
      return e.isArray(d) || (d = Array.prototype.slice.call(arguments, 1)), function(y) {
        return a.fromArray(d).map(function(m) {
          return m(y);
        }).filter(function(m) {
          return m.isSuccess() || m.isError();
        }).first() || h(y, f);
      };
    }, n.then = function(f, d) {
      return function(y) {
        var m = f(y);
        return m.map || console.log(m), m.map(d);
      };
    }, n.sequence = function() {
      var f = Array.prototype.slice.call(arguments, 0), d = function(m) {
        var b = e.foldl(f, function(g, v) {
          var _ = g.result, x = g.hasCut;
          if (!_.isSuccess())
            return { result: _, hasCut: x };
          var T = v(_.remaining());
          if (T.isCut())
            return { result: _, hasCut: !0 };
          if (T.isSuccess()) {
            var E;
            v.isCaptured ? E = _.value().withValue(v, T.value()) : E = _.value();
            var U = T.remaining(), D = m.to(U);
            return {
              result: i.success(E, U, D),
              hasCut: x
            };
          } else return x ? { result: i.error(T.errors(), T.remaining()), hasCut: x } : { result: T, hasCut: x };
        }, { result: i.success(new s(), m), hasCut: !1 }).result, p = m.to(b.remaining());
        return b.map(function(g) {
          return g.withValue(n.sequence.source, p);
        });
      };
      d.head = function() {
        var m = e.find(f, y);
        return n.then(
          d,
          n.sequence.extract(m)
        );
      }, d.map = function(m) {
        return n.then(
          d,
          function(b) {
            return m.apply(this, b.toArray());
          }
        );
      };
      function y(m) {
        return m.isCaptured;
      }
      return d;
    };
    var s = function(f, d) {
      this._values = f || {}, this._valuesArray = d || [];
    };
    s.prototype.withValue = function(f, d) {
      if (f.captureName && f.captureName in this._values)
        throw new Error('Cannot add second value for capture "' + f.captureName + '"');
      var y = e.clone(this._values);
      y[f.captureName] = d;
      var m = this._valuesArray.concat([d]);
      return new s(y, m);
    }, s.prototype.get = function(f) {
      if (f.captureName in this._values)
        return this._values[f.captureName];
      throw new Error('No value for capture "' + f.captureName + '"');
    }, s.prototype.toArray = function() {
      return this._valuesArray;
    }, n.sequence.capture = function(f, d) {
      var y = function() {
        return f.apply(this, arguments);
      };
      return y.captureName = d, y.isCaptured = !0, y;
    }, n.sequence.extract = function(f) {
      return function(d) {
        return d.get(f);
      };
    }, n.sequence.applyValues = function(f) {
      var d = Array.prototype.slice.call(arguments, 1);
      return function(y) {
        var m = d.map(function(b) {
          return y.get(b);
        });
        return f.apply(this, m);
      };
    }, n.sequence.source = {
      captureName: "source"
    }, n.sequence.cut = function() {
      return function(f) {
        return i.cut(f);
      };
    }, n.optional = function(f) {
      return function(d) {
        var y = f(d);
        return y.isSuccess() ? y.map(t.some) : y.isFailure() ? i.success(t.none, d) : y;
      };
    }, n.zeroOrMoreWithSeparator = function(f, d) {
      return c(f, d, !1);
    }, n.oneOrMoreWithSeparator = function(f, d) {
      return c(f, d, !0);
    };
    var o = n.zeroOrMore = function(f) {
      return function(d) {
        for (var y = [], m; (m = f(d)) && m.isSuccess(); )
          d = m.remaining(), y.push(m.value());
        return m.isError() ? m : i.success(y, d);
      };
    };
    n.oneOrMore = function(f) {
      return n.oneOrMoreWithSeparator(f, u);
    };
    function u(f) {
      return i.success(null, f);
    }
    var c = function(f, d, y) {
      return function(m) {
        var b = f(m);
        if (b.isSuccess()) {
          var p = n.sequence.capture(f, "main"), g = o(n.then(
            n.sequence(d, p),
            n.sequence.extract(p)
          )), v = g(b.remaining());
          return i.success([b.value()].concat(v.value()), v.remaining());
        } else return y || b.isError() ? b : i.success([], m);
      };
    };
    n.leftAssociative = function(f, d, y) {
      var m;
      y ? m = [{ func: y, rule: d }] : m = d, m = m.map(function(p) {
        return n.then(p.rule, function(g) {
          return function(v, _) {
            return p.func(v, g, _);
          };
        });
      });
      var b = n.firstOf.apply(null, ["rules"].concat(m));
      return function(p) {
        var g = p, v = f(p);
        if (!v.isSuccess())
          return v;
        for (var _ = b(v.remaining()); _.isSuccess(); ) {
          var x = _.remaining(), T = g.to(_.remaining()), E = _.value();
          v = i.success(
            E(v.value(), T),
            x,
            T
          ), _ = b(v.remaining());
        }
        return _.isError() ? _ : v;
      };
    }, n.leftAssociative.firstOf = function() {
      return Array.prototype.slice.call(arguments, 0);
    }, n.nonConsuming = function(f) {
      return function(d) {
        return f(d).changeRemaining(d);
      };
    };
    var l = function(f) {
      return f.value ? f.name + ' "' + f.value + '"' : f.name;
    };
    function h(f, d) {
      var y, m = f.head();
      return m ? y = r.error({
        expected: d,
        actual: l(m),
        location: m.source
      }) : y = r.error({
        expected: d,
        actual: "end of tokens"
      }), i.failure([y], f);
    }
  })(qh)), qh;
}
var $h = { exports: {} }, l2;
function $E() {
  if (l2) return $h.exports;
  l2 = 1;
  var n = VE();
  $h.exports = function(t, i) {
    var r = {
      asString: function() {
        return t;
      },
      range: function(a, s) {
        return new e(t, i, a, s);
      }
    };
    return r;
  };
  var e = function(t, i, r, a) {
    this._string = t, this._description = i, this._startIndex = r, this._endIndex = a;
  };
  return e.prototype.to = function(t) {
    return new e(this._string, this._description, this._startIndex, t._endIndex);
  }, e.prototype.describe = function() {
    var t = this._position(), i = this._description ? this._description + `
` : "";
    return n.format(
      `%sLine number: %s
Character number: %s`,
      i,
      t.lineNumber,
      t.characterNumber
    );
  }, e.prototype.lineNumber = function() {
    return this._position().lineNumber;
  }, e.prototype.characterNumber = function() {
    return this._position().characterNumber;
  }, e.prototype._position = function() {
    for (var t = this, i = 0, r = function() {
      return t._string.indexOf(`
`, i);
    }, a = 1; r() !== -1 && r() < this._startIndex; )
      i = r() + 1, a += 1;
    var s = this._startIndex - i + 1;
    return { lineNumber: a, characterNumber: s };
  }, $h.exports;
}
var Gh, d2;
function GE() {
  return d2 || (d2 = 1, Gh = function(n, e, t) {
    this.name = n, this.value = e, t && (this.source = t);
  }), Gh;
}
var Xh = {}, f2;
function P5() {
  return f2 || (f2 = 1, (function(n) {
    var e = zE(), t = Bg();
    n.parser = function(a, s, o) {
      var u = {
        rule: f,
        leftAssociative: d,
        rightAssociative: y
      }, c = new i(o.map(h)), l = e.firstOf(a, s);
      function h(p) {
        return {
          name: p.name,
          rule: r(p.ruleBuilder.bind(null, u))
        };
      }
      function f() {
        return m(c);
      }
      function d(p) {
        return m(c.untilExclusive(p));
      }
      function y(p) {
        return m(c.untilInclusive(p));
      }
      function m(p) {
        return b.bind(null, p);
      }
      function b(p, g) {
        var v = l(g);
        return v.isSuccess() ? p.apply(v) : v;
      }
      return u;
    };
    function i(a) {
      function s(h) {
        return new i(a.slice(0, u().indexOf(h)));
      }
      function o(h) {
        return new i(a.slice(0, u().indexOf(h) + 1));
      }
      function u() {
        return a.map(function(h) {
          return h.name;
        });
      }
      function c(h) {
        for (var f, d; ; )
          if (f = l(h.remaining()), f.isSuccess())
            d = h.source().to(f.source()), h = t.success(
              f.value()(h.value(), d),
              f.remaining(),
              d
            );
          else return f.isFailure() ? h : f;
      }
      function l(h) {
        return e.firstOf("infix", a.map(function(f) {
          return f.rule;
        }))(h);
      }
      return {
        apply: c,
        untilExclusive: s,
        untilInclusive: o
      };
    }
    n.infix = function(a, s) {
      function o(u) {
        return n.infix(a, function(c) {
          var l = s(c);
          return function(h) {
            var f = l(h);
            return f.map(function(d) {
              return function(y, m) {
                return u(y, d, m);
              };
            });
          };
        });
      }
      return {
        name: a,
        ruleBuilder: s,
        map: o
      };
    };
    var r = function(a) {
      var s;
      return function(o) {
        return s || (s = a()), s(o);
      };
    };
  })(Xh)), Xh;
}
var Kh = {}, h2;
function F5() {
  if (h2) return Kh;
  h2 = 1;
  var n = GE(), e = $E();
  Kh.RegexTokeniser = t;
  function t(i) {
    i = i.map(function(o) {
      return {
        name: o.name,
        regex: new RegExp(o.regex.source, "g")
      };
    });
    function r(o, u) {
      for (var c = new e(o, u), l = 0, h = []; l < o.length; ) {
        var f = a(o, l, c);
        l = f.endIndex, h.push(f.token);
      }
      return h.push(s(o, c)), h;
    }
    function a(o, u, c) {
      for (var l = 0; l < i.length; l++) {
        var h = i[l].regex;
        h.lastIndex = u;
        var f = h.exec(o);
        if (f) {
          var y = u + f[0].length;
          if (f.index === u && y > u) {
            var d = f[1], m = new n(
              i[l].name,
              d,
              c.range(u, y)
            );
            return { token: m, endIndex: y };
          }
        }
      }
      var y = u + 1, m = new n(
        "unrecognisedCharacter",
        o.substring(u, y),
        c.range(u, y)
      );
      return { token: m, endIndex: y };
    }
    function s(o, u) {
      return new n(
        "end",
        null,
        u.range(o.length, o.length)
      );
    }
    return {
      tokenise: r
    };
  }
  return Kh;
}
var p2;
function XE() {
  return p2 || (p2 = 1, Yn.Parser = R5().Parser, Yn.rules = zE(), Yn.errors = HE(), Yn.results = Bg(), Yn.StringSource = $E(), Yn.Token = GE(), Yn.bottomUp = P5(), Yn.RegexTokeniser = F5().RegexTokeniser, Yn.rule = function(n) {
    var e;
    return function(t) {
      return e || (e = n()), e(t);
    };
  }), Yn;
}
var Ht = {}, m2;
function N5() {
  if (m2) return Ht;
  m2 = 1, Ht.paragraph = n, Ht.run = e, Ht.table = t, Ht.bold = new i("bold"), Ht.italic = new i("italic"), Ht.underline = new i("underline"), Ht.strikethrough = new i("strikethrough"), Ht.allCaps = new i("allCaps"), Ht.smallCaps = new i("smallCaps"), Ht.commentReference = new i("commentReference"), Ht.lineBreak = new i("break", { breakType: "line" }), Ht.pageBreak = new i("break", { breakType: "page" }), Ht.columnBreak = new i("break", { breakType: "column" }), Ht.equalTo = a, Ht.startsWith = s;
  function n(c) {
    return new i("paragraph", c);
  }
  function e(c) {
    return new i("run", c);
  }
  function t(c) {
    return new i("table", c);
  }
  function i(c, l) {
    l = l || {}, this._elementType = c, this._styleId = l.styleId, this._styleName = l.styleName, l.list && (this._listIndex = l.list.levelIndex, this._listIsOrdered = l.list.isOrdered);
  }
  i.prototype.matches = function(c) {
    return c.type === this._elementType && (this._styleId === void 0 || c.styleId === this._styleId) && (this._styleName === void 0 || c.styleName && this._styleName.operator(this._styleName.operand, c.styleName)) && (this._listIndex === void 0 || r(c, this._listIndex, this._listIsOrdered)) && (this._breakType === void 0 || this._breakType === c.breakType);
  };
  function r(c, l, h) {
    return c.numbering && c.numbering.level == l && c.numbering.isOrdered == h;
  }
  function a(c) {
    return {
      operator: o,
      operand: c
    };
  }
  function s(c) {
    return {
      operator: u,
      operand: c
    };
  }
  function o(c, l) {
    return c.toUpperCase() === l.toUpperCase();
  }
  function u(c, l) {
    return l.toUpperCase().indexOf(c.toUpperCase()) === 0;
  }
  return Ht;
}
var Yh = {}, g2;
function M5() {
  if (g2) return Yh;
  g2 = 1;
  var n = XE(), e = n.RegexTokeniser;
  Yh.tokenise = i;
  var t = "'((?:\\\\.|[^'])*)";
  function i(r) {
    var a = "(?:[a-zA-Z\\-_]|\\\\.)", s = new e([
      { name: "identifier", regex: new RegExp("(" + a + "(?:" + a + "|[0-9])*)") },
      { name: "dot", regex: /\./ },
      { name: "colon", regex: /:/ },
      { name: "gt", regex: />/ },
      { name: "whitespace", regex: /\s+/ },
      { name: "arrow", regex: /=>/ },
      { name: "equals", regex: /=/ },
      { name: "startsWith", regex: /\^=/ },
      { name: "open-paren", regex: /\(/ },
      { name: "close-paren", regex: /\)/ },
      { name: "open-square-bracket", regex: /\[/ },
      { name: "close-square-bracket", regex: /\]/ },
      { name: "string", regex: new RegExp(t + "'") },
      { name: "unterminated-string", regex: new RegExp(t) },
      { name: "integer", regex: /([0-9]+)/ },
      { name: "choice", regex: /\|/ },
      { name: "bang", regex: /(!)/ }
    ]);
    return s.tokenise(r);
  }
  return Yh;
}
var b2;
function B5() {
  if (b2) return ps;
  b2 = 1;
  var n = Pt, e = XE(), t = N5(), i = ol(), r = M5().tokenise, a = Pi();
  ps.readHtmlPath = l, ps.readDocumentMatcher = u, ps.readStyle = s;
  function s(T) {
    return g(x, T);
  }
  function o() {
    return e.rules.sequence(
      e.rules.sequence.capture(c()),
      e.rules.tokenOfType("whitespace"),
      e.rules.tokenOfType("arrow"),
      e.rules.sequence.capture(e.rules.optional(e.rules.sequence(
        e.rules.tokenOfType("whitespace"),
        e.rules.sequence.capture(h())
      ).head())),
      e.rules.tokenOfType("end")
    ).map(function(T, E) {
      return {
        from: T,
        to: E.valueOrElse(i.empty)
      };
    });
  }
  function u(T) {
    return g(c(), T);
  }
  function c() {
    var T = e.rules.sequence, E = function(oe, De) {
      return e.rules.then(
        e.rules.token("identifier", oe),
        function() {
          return De;
        }
      );
    }, U = E("p", t.paragraph), D = E("r", t.run), L = e.rules.firstOf(
      "p or r or table",
      U,
      D
    ), j = e.rules.then(
      p,
      function(oe) {
        return { styleId: oe };
      }
    ), C = e.rules.firstOf(
      "style name matcher",
      e.rules.then(
        e.rules.sequence(
          e.rules.tokenOfType("equals"),
          e.rules.sequence.cut(),
          e.rules.sequence.capture(y)
        ).head(),
        function(oe) {
          return { styleName: t.equalTo(oe) };
        }
      ),
      e.rules.then(
        e.rules.sequence(
          e.rules.tokenOfType("startsWith"),
          e.rules.sequence.cut(),
          e.rules.sequence.capture(y)
        ).head(),
        function(oe) {
          return { styleName: t.startsWith(oe) };
        }
      )
    ), k = e.rules.sequence(
      e.rules.tokenOfType("open-square-bracket"),
      e.rules.sequence.cut(),
      e.rules.token("identifier", "style-name"),
      e.rules.sequence.capture(C),
      e.rules.tokenOfType("close-square-bracket")
    ).head(), I = e.rules.firstOf(
      "list type",
      E("ordered-list", { isOrdered: !0 }),
      E("unordered-list", { isOrdered: !1 })
    ), $ = T(
      e.rules.tokenOfType("colon"),
      T.capture(I),
      T.cut(),
      e.rules.tokenOfType("open-paren"),
      T.capture(d),
      e.rules.tokenOfType("close-paren")
    ).map(function(oe, De) {
      return {
        list: {
          isOrdered: oe.isOrdered,
          levelIndex: De - 1
        }
      };
    });
    function W(oe) {
      var De = e.rules.firstOf.apply(
        e.rules.firstOf,
        ["matcher suffix"].concat(oe)
      ), Re = e.rules.zeroOrMore(De);
      return e.rules.then(Re, function(Me) {
        var F = {};
        return Me.forEach(function(P) {
          n.extend(F, P);
        }), F;
      });
    }
    var B = T(
      T.capture(L),
      T.capture(W([
        j,
        k,
        $
      ]))
    ).map(function(oe, De) {
      return oe(De);
    }), z = T(
      e.rules.token("identifier", "table"),
      T.capture(W([
        j,
        k
      ]))
    ).map(function(oe) {
      return t.table(oe);
    }), q = E("b", t.bold), Y = E("i", t.italic), H = E("u", t.underline), K = E("strike", t.strikethrough), ie = E("all-caps", t.allCaps), ge = E("small-caps", t.smallCaps), pe = E("comment-reference", t.commentReference), ce = T(
      e.rules.token("identifier", "br"),
      T.cut(),
      e.rules.tokenOfType("open-square-bracket"),
      e.rules.token("identifier", "type"),
      e.rules.tokenOfType("equals"),
      T.capture(y),
      e.rules.tokenOfType("close-square-bracket")
    ).map(function(oe) {
      switch (oe) {
        case "line":
          return t.lineBreak;
        case "page":
          return t.pageBreak;
        case "column":
          return t.columnBreak;
      }
    });
    return e.rules.firstOf(
      "element type",
      B,
      z,
      q,
      Y,
      H,
      K,
      ie,
      ge,
      pe,
      ce
    );
  }
  function l(T) {
    return g(h(), T);
  }
  function h() {
    var T = e.rules.sequence.capture, E = e.rules.tokenOfType("whitespace"), U = e.rules.then(
      e.rules.optional(e.rules.sequence(
        e.rules.tokenOfType("colon"),
        e.rules.token("identifier", "fresh")
      )),
      function(C) {
        return C.map(function() {
          return !0;
        }).valueOrElse(!1);
      }
    ), D = e.rules.then(
      e.rules.optional(e.rules.sequence(
        e.rules.tokenOfType("colon"),
        e.rules.token("identifier", "separator"),
        e.rules.tokenOfType("open-paren"),
        T(y),
        e.rules.tokenOfType("close-paren")
      ).head()),
      function(C) {
        return C.valueOrElse("");
      }
    ), L = e.rules.oneOrMoreWithSeparator(
      f,
      e.rules.tokenOfType("choice")
    ), j = e.rules.sequence(
      T(L),
      T(e.rules.zeroOrMore(p)),
      T(U),
      T(D)
    ).map(function(C, k, I, $) {
      var W = {}, B = {};
      return k.length > 0 && (W.class = k.join(" ")), I && (B.fresh = !0), $ && (B.separator = $), i.element(C, W, B);
    });
    return e.rules.firstOf(
      "html path",
      e.rules.then(e.rules.tokenOfType("bang"), function() {
        return i.ignore;
      }),
      e.rules.then(
        e.rules.zeroOrMoreWithSeparator(
          j,
          e.rules.sequence(
            E,
            e.rules.tokenOfType("gt"),
            E
          )
        ),
        i.elements
      )
    );
  }
  var f = e.rules.then(
    e.rules.tokenOfType("identifier"),
    b
  ), d = e.rules.tokenOfType("integer"), y = e.rules.then(
    e.rules.tokenOfType("string"),
    b
  ), m = {
    n: `
`,
    r: "\r",
    t: "	"
  };
  function b(T) {
    return T.replace(/\\(.)/g, function(E, U) {
      return m[U] || U;
    });
  }
  var p = e.rules.sequence(
    e.rules.tokenOfType("dot"),
    e.rules.sequence.cut(),
    e.rules.sequence.capture(f)
  ).head();
  function g(T, E) {
    var U = r(E), D = e.Parser(), L = D.parseTokens(T, U);
    return L.isSuccess() ? a.success(L.value()) : new a.Result(null, [a.warning(v(E, L))]);
  }
  function v(T, E) {
    return "Did not understand this style mapping, so ignored it: " + T + `
` + E.errors().map(_).join(`
`);
  }
  function _(T) {
    return "Error was at character number " + T.characterNumber() + ": Expected " + T.expected + " but got " + T.actual;
  }
  var x = o();
  return ps;
}
var ms = {}, y2;
function j5() {
  if (y2) return ms;
  y2 = 1, ms.readOptions = i;
  var n = Pt, e = ms._defaultStyleMap = [
    "p.Heading1 => h1:fresh",
    "p.Heading2 => h2:fresh",
    "p.Heading3 => h3:fresh",
    "p.Heading4 => h4:fresh",
    "p.Heading5 => h5:fresh",
    "p.Heading6 => h6:fresh",
    "p[style-name='Heading 1'] => h1:fresh",
    "p[style-name='Heading 2'] => h2:fresh",
    "p[style-name='Heading 3'] => h3:fresh",
    "p[style-name='Heading 4'] => h4:fresh",
    "p[style-name='Heading 5'] => h5:fresh",
    "p[style-name='Heading 6'] => h6:fresh",
    "p[style-name='heading 1'] => h1:fresh",
    "p[style-name='heading 2'] => h2:fresh",
    "p[style-name='heading 3'] => h3:fresh",
    "p[style-name='heading 4'] => h4:fresh",
    "p[style-name='heading 5'] => h5:fresh",
    "p[style-name='heading 6'] => h6:fresh",
    "r[style-name='Strong'] => strong",
    "p[style-name='footnote text'] => p:fresh",
    "r[style-name='footnote reference'] =>",
    "p[style-name='endnote text'] => p:fresh",
    "r[style-name='endnote reference'] =>",
    "p[style-name='annotation text'] => p:fresh",
    "r[style-name='annotation reference'] =>",
    // LibreOffice
    "p[style-name='Footnote'] => p:fresh",
    "r[style-name='Footnote anchor'] =>",
    "p[style-name='Endnote'] => p:fresh",
    "r[style-name='Endnote anchor'] =>",
    "p:unordered-list(1) => ul > li:fresh",
    "p:unordered-list(2) => ul|ol > li > ul > li:fresh",
    "p:unordered-list(3) => ul|ol > li > ul|ol > li > ul > li:fresh",
    "p:unordered-list(4) => ul|ol > li > ul|ol > li > ul|ol > li > ul > li:fresh",
    "p:unordered-list(5) => ul|ol > li > ul|ol > li > ul|ol > li > ul|ol > li > ul > li:fresh",
    "p:ordered-list(1) => ol > li:fresh",
    "p:ordered-list(2) => ul|ol > li > ol > li:fresh",
    "p:ordered-list(3) => ul|ol > li > ul|ol > li > ol > li:fresh",
    "p:ordered-list(4) => ul|ol > li > ul|ol > li > ul|ol > li > ol > li:fresh",
    "p:ordered-list(5) => ul|ol > li > ul|ol > li > ul|ol > li > ul|ol > li > ol > li:fresh",
    "r[style-name='Hyperlink'] =>",
    "p[style-name='Normal'] => p:fresh"
  ], t = ms._standardOptions = {
    transformDocument: a,
    includeDefaultStyleMap: !0,
    includeEmbeddedStyleMap: !0
  };
  function i(s) {
    return s = s || {}, n.extend({}, t, s, {
      customStyleMap: r(s.styleMap),
      readStyleMap: function() {
        var o = this.customStyleMap;
        return this.includeEmbeddedStyleMap && (o = o.concat(r(this.embeddedStyleMap))), this.includeDefaultStyleMap && (o = o.concat(e)), o;
      }
    });
  }
  function r(s) {
    return s ? n.isString(s) ? s.split(`
`).map(function(o) {
      return o.trim();
    }).filter(function(o) {
      return o !== "" && o.charAt(0) !== "#";
    }) : s : [];
  }
  function a(s) {
    return s;
  }
  return ms;
}
var Qh = {}, v2;
function q5() {
  if (v2) return Qh;
  v2 = 1;
  var n = ur(), e = kE();
  Qh.openZip = t;
  function t(i) {
    return i.arrayBuffer ? n.resolve(e.openArrayBuffer(i.arrayBuffer)) : n.reject(new Error("Could not find file in options"));
  }
  return Qh;
}
var Tr = {}, x2;
function W5() {
  if (x2) return Tr;
  x2 = 1;
  var n = Pt;
  Tr.paragraph = e, Tr.run = t, Tr._elements = r, Tr.getDescendantsOfType = a, Tr.getDescendants = s;
  function e(u) {
    return i("paragraph", u);
  }
  function t(u) {
    return i("run", u);
  }
  function i(u, c) {
    return r(function(l) {
      return l.type === u ? c(l) : l;
    });
  }
  function r(u) {
    return function c(l) {
      if (l.children) {
        var h = n.map(l.children, c);
        l = n.extend(l, { children: h });
      }
      return u(l);
    };
  }
  function a(u, c) {
    return s(u).filter(function(l) {
      return l.type === c;
    });
  }
  function s(u) {
    var c = [];
    return o(u, function(l) {
      c.push(l);
    }), c;
  }
  function o(u, c) {
    u.children && u.children.forEach(function(l) {
      o(l, c), c(l);
    });
  }
  return Tr;
}
var Zh = {}, _2;
function V5() {
  if (_2) return Zh;
  _2 = 1;
  var n = ol(), e = sl();
  Zh.element = t;
  function t(i) {
    return function(r) {
      return e.elementWithTag(n.element(i), [r]);
    };
  }
  return Zh;
}
var T2;
function H5() {
  if (T2) return Rn;
  T2 = 1;
  var n = Pt, e = _5(), t = T5(), i = k5().DocumentConverter, r = I5().convertElementToRawText, a = B5().readStyle, s = j5().readOptions, o = q5(), u = Pi().Result;
  Rn.convertToHtml = c, Rn.convertToMarkdown = l, Rn.convert = h, Rn.extractRawText = m, Rn.images = WE(), Rn.transforms = W5(), Rn.underline = V5(), Rn.embedStyleMap = b, Rn.readEmbeddedStyleMap = f;
  function c(p, g) {
    return h(p, g);
  }
  function l(p, g) {
    var v = Object.create(g || {});
    return v.outputFormat = "markdown", h(p, v);
  }
  function h(p, g) {
    return g = s(g), o.openZip(p).tap(function(v) {
      return t.readStyleMap(v).then(function(_) {
        g.embeddedStyleMap = _;
      });
    }).then(function(v) {
      return e.read(v, p).then(function(_) {
        return _.map(g.transformDocument);
      }).then(function(_) {
        return d(_, g);
      });
    });
  }
  function f(p) {
    return o.openZip(p).then(t.readStyleMap);
  }
  function d(p, g) {
    var v = y(g.readStyleMap()), _ = n.extend({}, g, {
      styleMap: v.value
    }), x = new i(_);
    return p.flatMapThen(function(T) {
      return v.flatMapThen(function(E) {
        return x.convertToHtml(T);
      });
    });
  }
  function y(p) {
    return u.combine((p || []).map(a)).map(function(g) {
      return g.filter(function(v) {
        return !!v;
      });
    });
  }
  function m(p) {
    return o.openZip(p).then(e.read).then(function(g) {
      return g.map(r);
    });
  }
  function b(p, g) {
    return o.openZip(p).tap(function(v) {
      return t.writeStyleMap(v, g);
    }).then(function(v) {
      return v.toBuffer();
    }).then(function(v) {
      return {
        toBuffer: function() {
          return v;
        }
      };
    });
  }
  return Rn.styleMapping = function() {
    throw new Error(`Use a raw string instead of mammoth.styleMapping e.g. "p[style-name='Title'] => h1" instead of mammoth.styleMapping("p[style-name='Title'] => h1")`);
  }, Rn;
}
var z5 = H5();
const $5 = /* @__PURE__ */ Qt(z5), Sr = {
  webvtt: ["text/vtt"],
  srt: ["application/x-subrip", "text/srt"],
  text: ["text/plain"],
  json: ["application/json"],
  docx: ["application/vnd.openxmlformats-officedocument.wordprocessingml.document"]
}, G5 = /^(?:\d{2}:)?\d{2}:\d{2}(?:\.\d+)/g, X5 = /^(?:\d{2}:)?\d{2}:\d{2}(?:[.,]\d+)/g, Jh = [{
  type: Sr.json,
  ext: "json"
}, {
  type: Sr.webvtt,
  ext: "vtt"
}, {
  type: Sr.text,
  ext: "txt"
}, {
  type: Sr.docx,
  ext: "docx"
}, {
  type: Sr.srt,
  ext: "srt"
}], ct = {
  invalidTimestamp: -4,
  invalidVTT: -3,
  noSupport: -2,
  invalid: -1,
  noTranscript: 0,
  timedText: 1,
  plainText: 2,
  docx: 3
}, vt = {
  note: "NOTE",
  timedCue: "TIMED_CUE",
  nonTimedLine: "NON_TIMED_LINE",
  metadata: "METADATA"
}, tr = "supplementing";
async function KE(n, e = "", t) {
  return n === void 0 ? [] : await fetch(n, {
    signal: t
  }).then(function(r) {
    return r.headers.get("Content-Type").includes("application/json") ? r.json() : {};
  }).then((r) => {
    const a = tm(r.annotations, tr) ?? [], s = w2(a, 0, n, r, e);
    let o = [];
    return r.items?.length > 0 && r.items.map((u, c) => {
      let l = tm(u.annotations, tr);
      const h = w2(l, c, n, u, e);
      o.push({
        canvasId: c,
        // Merge canvas and manifest transcripts
        items: [...h, ...s]
      });
    }), o;
  }).catch((r) => (r.name === "AbortError" ? console.warn("transcript-parser -> readSupplementingAnnotations() -> fetch aborted") : console.error("transcript-parser -> readSupplementingAnnotations() -> error fetching transcript resource at, ", n), []));
}
function w2(n, e, t, i, r) {
  let a = i.annotations?.length > 0 && i.annotations[0].label ? Mt(i.annotations[0].label) : r, s = [];
  if (n.length > 0) {
    let o = n[0].body?.length > 0 ? n[0].body[0] : n[0].body;
    if (o.type === "TextualBody") {
      let u = r.length > 0 ? r : a || `${i.type}-${e}`, {
        isMachineGen: c,
        labelText: l
      } = Vs(u);
      s.push({
        url: o.id === void 0 ? t : o.id,
        title: l,
        isMachineGen: c,
        id: `${l}-${e}`,
        format: ""
      });
    } else
      n.forEach((u, c) => {
        let l = u.body, h = "", f = "";
        l.label && Object.keys(l.label).length > 0 ? Object.keys(l.label)?.length > 1 ? (h = Mt(l.label), f = l.label.hasOwnProperty("none") ? Mt(l.label.none[0]) : h) : h = Mt(l.label) : h = `${c}`;
        let d = l.id, y = Ym(d), {
          isMachineGen: m,
          labelText: b
        } = Vs(h);
        f === "" && (f = b), (y === 1 || y === 3) && s.push({
          title: b,
          filename: f,
          url: d,
          isMachineGen: m,
          id: `${b}-${e}-${c}`,
          format: l.format || ""
        });
      });
  }
  return s;
}
async function K5(n) {
  if (!n || n == null || n.length == 0)
    return console.error("No transcripts given as input"), [];
  {
    let e = [];
    n.map((r) => e.push({
      canvasId: r.canvasId,
      items: []
    }));
    let t = await Promise.all(n.map(async (r) => {
      const {
        canvasId: a,
        items: s
      } = r;
      let o = await Promise.all(s.map(async (u, c) => {
        const {
          title: l,
          url: h
        } = u, f = await KE(h, l);
        let {
          isMachineGen: d,
          labelText: y
        } = Vs(l), m = [];
        return f?.length > 0 && (m = f.map((p) => p.items).flat(), e = E2(e.concat(f), "canvasId", "items")), f.length === 0 || m.length === 0 ? {
          title: y,
          filename: y,
          url: h,
          isMachineGen: d,
          id: `${y}-${a}-${c}`,
          format: ""
        } : null;
      }));
      return {
        canvasId: a,
        items: o.filter((u) => u != null)
      };
    }));
    return E2(e.concat(t), "canvasId", "items");
  }
}
function E2(n, e, t) {
  return n.reduce((i, r) => {
    const a = i.filter((s) => s[e] == r[e]);
    if (a?.length > 0) {
      let s = a[0];
      s[t] = s[t].concat(r[t]);
    } else
      i.push(r);
    return i;
  }, []);
}
async function jg({
  url: n,
  format: e,
  canvasIndex: t = 0,
  parseMetadata: i = !1,
  parseNotes: r = !1,
  inlineAnnotations: a = []
}) {
  let s = [], o = n;
  if (n === void 0)
    return {
      tData: s,
      tUrl: o,
      tType: ct.invalid
    };
  if (a.length > 0)
    return s = D2(a), s.length === 0 ? {
      tData: s,
      tUrl: n,
      tType: ct.noTranscript,
      tFileExt: "json"
    } : {
      tData: s,
      tUrl: n,
      tType: ct.timedText,
      tFileExt: "json"
    };
  let u = null, c = null;
  if (await fetch(n).then(XT).then(function(m) {
    u = m.headers.get("Content-Type"), c = m;
  }).catch((m) => {
    console.error("transcript-parser -> parseTranscriptData() -> fetching transcript -> ", m);
  }), u == null)
    return {
      tData: [],
      tUrl: o,
      tType: ct.invalid
    };
  let l = Jh.filter((m) => m.type.includes(u.split(";")[0])), h = Jh.filter((m) => m.type.includes(e)), f = "";
  if (h?.length > 0)
    f = h[0].ext;
  else if (l.length > 0)
    f = l[0].ext;
  else {
    let m = n.split(".").reverse()[0];
    f = Jh.filter((p) => p.ext === m).length > 0 ? m : "";
  }
  let d, y;
  switch (f) {
    case "json":
      let m = await c.json();
      if (m?.type === "Manifest") {
        const {
          _: b,
          annotationSets: p
        } = qg(m, t);
        if (p?.length) {
          const {
            url: g,
            format: v,
            items: _
          } = p[0];
          return _ != null ? (s = D2(_), {
            tData: s,
            tUrl: o,
            tType: ct.timedText,
            tFileExt: f
          }) : jg({
            url: g,
            format: v,
            canvasIndex: t,
            parseMetadata: i,
            parseNotes: r
          });
        } else
          return {
            tData: s,
            tUrl: o,
            tType: ct.noTranscript,
            tFileExt: f
          };
      } else {
        let b = Q5(m);
        return {
          tData: b.tData,
          tUrl: o,
          tType: b.tType,
          tFileExt: f
        };
      }
    case "txt":
      return d = await c.text(), y = d?.split(`
`) ?? [], d == null || d == "" || y.length == 0 ? {
        tData: [],
        tUrl: n,
        tType: ct.noTranscript
      } : {
        tData: YE(y),
        tUrl: n,
        tType: ct.plainText,
        tFileExt: f
      };
    // for timed text with WebVTT/SRT files
    case "srt":
    case "vtt":
      if (d = await c.text(), y = d.split(/\r\n|\r|\n/), d == null || d == "" || y.length == 0)
        return {
          tData: [],
          tUrl: n,
          tType: ct.noTranscript
        };
      {
        let {
          tData: b,
          tType: p
        } = Z5(d, i, r, f === "srt");
        return {
          tData: b,
          tUrl: n,
          tType: p,
          tFileExt: f
        };
      }
    // for .docx files
    case "docx":
      return s = await Y5(c), s == null ? {
        tData: [],
        tUrl: n,
        tType: ct.invalid
      } : {
        tData: iI(s),
        tUrl: n,
        tType: ct.docx,
        tFileExt: f
      };
    default:
      return {
        tData: [],
        tUrl: n,
        tType: ct.noSupport
      };
  }
}
function D2(n) {
  if (n?.length === 0) return [];
  let e = [], t = (i) => {
    let r = [];
    return i.forEach((a) => {
      a?.purpose.includes("tagging") || r.push(a.value);
    }), r.join("<br>");
  };
  return n.map((i) => {
    if (i.motivation.includes(tr)) {
      const {
        time: r,
        value: a
      } = i, s = a.filter((c) => c?.purpose.includes(tr)), o = t(s), u = a?.length > 0 ? a[0].format : "text/plain";
      o.length > 0 && e.push({
        text: o,
        format: u,
        begin: parseFloat(r?.start ?? 0),
        end: parseFloat(r?.end ?? 0),
        tag: vt.timedCue
      });
    }
  }), e;
}
async function Y5(n) {
  let e = null;
  const t = await n.blob();
  let i = new File([t], name, {
    type: n.headers.get("content-type")
  });
  return await $5.convertToHtml({
    arrayBuffer: i
  }).then(function(r) {
    e = r.value;
  }).catch((r) => {
    console.error(r);
  }), e;
}
function Q5(n) {
  if (n.length == 0 || !Array.isArray(n))
    return {
      tData: [],
      tType: ct.noTranscript
    };
  let e = [];
  for (let t of n)
    if (t.speaker) {
      const {
        speaker: i,
        spans: r
      } = t;
      for (let a of r)
        a.speaker = i, e.push(a);
    } else
      for (let i of t.spans)
        i.format = "text/plain", i.tag = vt.timedCue, e.push(i);
  return {
    tData: e,
    tType: ct.timedText
  };
}
function Z5(n, e, t, i = !1) {
  let r = [], a = [], s = [];
  const o = n.split(`
`);
  let u = o;
  if (!i) {
    const {
      valid: h,
      cue_lines: f,
      notes: d,
      metadata: y
    } = J5(o, e, t);
    if (!h)
      return console.error("Invalid WebVTT file"), {
        tData: [],
        tType: ct.invalidVTT
      };
    u = f, a = d, s = y;
  }
  const c = tI(u, t);
  c.unshift(...a), c.unshift(...s);
  let l = !1;
  for (let h = 0; h < c.length; ) {
    let f = nI(c[h], i);
    if (f)
      r.push(f), h++;
    else {
      l ||= !0;
      break;
    }
  }
  return {
    tData: l ? null : r,
    tType: l ? ct.invalidTimestamp : ct.timedText
  };
}
function J5(n, e, t) {
  let i = 0;
  const r = n[0].trim();
  if (r.length === 6 && r === "WEBVTT") {
    i++;
    const {
      valid: a,
      cue_lines: s,
      notes: o,
      metadata: u
    } = eI(n, i, e, t);
    return {
      valid: a,
      cue_lines: s,
      notes: o,
      metadata: u
    };
  } else
    return {
      valid: !1,
      cue_lines: [],
      notes: [],
      metadata: []
    };
}
function eI(n, e, t, i) {
  let r = 0, a = 0, s = [], o = [];
  n = n.filter((c) => !Number(c));
  const u = (c) => !c == "\r" || !c == `
` || !c == `\r
`;
  for (let c = e; c < n.length; c++) {
    const l = n[c].trim();
    if (/^REGION$/.test(l.toUpperCase()) || /^STYLE$/.test(l.toUpperCase())) {
      for (c++; c < n.length && u(n[c]); )
        c++;
      r = c;
    } else if (/^NOTE$/.test(l.toUpperCase())) {
      let h = l;
      for (; c < n.length && u(n[c]); )
        c++, h = `${h}<br />${n[c].trim()}`;
      i && s.push({
        times: "",
        line: h,
        tag: vt.note
      }), r = c;
    } else if (l.includes("-->")) {
      a = c;
      break;
    } else if (typeof l == "string" && l.trim().length != 0) {
      let h = l.trim();
      for (; c < n.length && u(n[c]); )
        c++, h = `${h}<br />${n[c].trim()}`;
      t && h.length > 0 && o.push({
        times: "",
        line: h,
        tag: vt.metadata
      }), r = c;
    }
  }
  return a > r ? {
    valid: !0,
    cue_lines: n.slice(a),
    notes: s,
    metadata: o
  } : {
    valid: !1
  };
}
function tI(n, e = !1) {
  let t = [], i;
  for (i = 0; i < n.length; i++) {
    const r = n[i];
    let a = {};
    if (r.includes("-->") || /^NOTE/.test(r)) {
      const s = /^NOTE/.test(r);
      a.times = s ? "" : r, a.tag = s ? vt.note : vt.timedCue, a.line = s ? r.replace(/^NOTE\s*/, "NOTE ") : "", i++;
      let o = 0;
      for (; i < n.length && !(n[i] == "\r" || n[i] == `
` || n[i] == `\r
` || n[i] == ""); )
        o > 0 && (a.line += "<br>"), a.line += n[i].endsWith("-") ? n[i] : n[i].replace(/\s*$/, " "), o++, i++;
      a.line = a.line.trimEnd(), (!s || e) && t.push(a);
    }
  }
  return t;
}
function nI({
  times: n,
  line: e,
  tag: t
}, i) {
  let r;
  switch (i ? r = X5 : r = G5, t) {
    case vt.note:
    case vt.metadata:
      return {
        begin: 0,
        end: 0,
        text: e,
        tag: t
      };
    case vt.timedCue:
      let [a, s] = n.split(" --> ");
      return s = s.split(" ")[0], !a.match(r) || !s.match(r) ? (console.error("Invalid timestamp in line with text; ", e), null) : {
        begin: Ri(a),
        end: Ri(s),
        text: e,
        tag: t
      };
    default:
      return null;
  }
}
const iI = (n) => {
  const e = document.createElement("div");
  return e.innerHTML = n, YE(Array.from(e.childNodes), !0);
}, YE = (n, e = !1) => {
  let t = [];
  return n.map((i) => {
    t.push({
      text: e ? i.innerText : i,
      tag: vt.nonTimedLine,
      textDisplayed: e ? Qp.decode(i.innerHTML) : i
    });
  }), t;
};
let gu = [];
const rI = ["text/vtt", "text/srt", "application/json"], oc = ["commenting", "supplementing", "transcribing"];
function qg(n, e) {
  let t = null, i = [], r = "";
  if (n?.label != null && (r = Mt(n.label)), e === void 0 || e < 0)
    return null;
  const a = n.items;
  if (a?.length != 0 && a[e] != null) {
    t = a[e];
    const s = t.annotations, o = Number(t.duration);
    return i = QE(s, o, r), {
      canvasIndex: e,
      annotationSets: i
    };
  } else
    return null;
}
async function aI(n, e) {
  const t = /^(https?:\/\/)?([\w-]+\.)+[\w-]+(\/[\w\-._~:\/?#[\]@!$&'()*+,;=]*)?\.json$/;
  if (n == null || n.match(t) == null)
    return [];
  {
    let i = null;
    if (await fetch(n).then(XT).then(function(r) {
      i = r;
    }).catch((r) => (console.error("annotations-parser -> parseExternalAnnotationPage() -> fetching transcript -> ", r), [])), i == null)
      return [];
    try {
      const r = await i.json();
      return QE([r], e);
    } catch {
      return console.error("annotations-parser -> parseExternalAnnotationPage() -> Error: parsing AnnotationPage at, ", n), [];
    }
  }
}
function QE(n, e, t = "") {
  let i = [];
  return n?.length > 0 && n[0].type === "AnnotationPage" && n.map((r) => {
    if (r.type === "AnnotationPage") {
      const a = Mt(r.label);
      let s = {
        label: a,
        filename: t != "" ? `${a} - ${t}.json` : `${a}.json`
      };
      if (r.items?.length > 0) {
        let o = [], u = [], c = !1;
        if (r.items.map((l) => {
          if (sI(l.body)) {
            const {
              body: h,
              id: f,
              motivation: d,
              target: y
            } = l, m = Array.isArray(d) ? d : [d], b = rI.includes(h.format), p = ZE(h, m)[0];
            p != null && i.push({
              ...p,
              canvasId: y,
              id: f,
              motivation: m,
              timed: b,
              isSupplementing: m.includes(tr)
            });
          } else {
            const h = oI(l, e);
            l.motivation === "highlighting" ? u.push(hI(h)) : (c ||= h.motivation?.includes(tr), o.push(h));
          }
        }), o.length > 0 || u.length > 0) {
          const l = QT(o), h = fI(l);
          i.push({
            ...s,
            items: h,
            markers: u,
            timed: !0,
            isSupplementing: c
          });
        }
      } else
        i.push({
          ...s,
          url: r.id,
          format: "application/json",
          timed: !0
        });
    }
  }), i;
}
function sI(n) {
  return Array.isArray(n) || (n = [n]), n.map((e) => e.type != "TextualBody").reduce((e, t) => e && t, !0);
}
function oI(n, e) {
  if (n == null || n == null)
    return;
  let t, i;
  if (typeof n?.target == "string")
    t = Nc(n.target), i = rr(n.target, e);
  else {
    const {
      source: s,
      selector: o
    } = n?.target;
    t = s.id, i = uI(o, e);
  }
  const r = Array.isArray(n.motivation) ? n.motivation : [n.motivation];
  return {
    motivation: r,
    id: n.id,
    time: i,
    canvasId: t,
    value: ZE(n.body, r)
  };
}
function uI(n, e) {
  const t = n.type;
  let i = {};
  switch (t) {
    case "FragmentSelector":
      i = em(n.value.split("t=")[1], e);
      break;
    case "PointSelector":
      i = {
        start: Number(n.t),
        end: void 0
      };
      break;
    // FIXME:: Remove this, as this is an invalid format from previous AVAnnotate
    case "RangeSelector":
      i = em(n.t);
      break;
  }
  return i;
}
function cI(n, e) {
  let t = {}, i;
  if (n) {
    const {
      format: r,
      label: a,
      motivation: s,
      purpose: o,
      value: u
    } = n;
    let c = o ?? s;
    c == null && oc.some((h) => e.includes(h)) && (c = e.filter((h) => oc.includes(h)));
    const l = a != null ? `<strong>${Mt(a)}</strong>: ${u}` : u;
    if (t = {
      format: r,
      /**
       * Use purpose instead of motivation, as it is specific to 'TextualBody' type.
       * 'purpose'/'motivation' can have 0 or more values.
       * Reference: https://www.w3.org/TR/annotation-model/#motivation-and-purpose
       */
      purpose: Array.isArray(c) ? c : [c],
      value: l
    }, c == ["tagging"]) {
      const h = gu.filter((f) => f.tag == u);
      h?.length > 0 ? i = h[0].color : (i = dI(gu?.length > 0 ? gu.map((f) => f.color) : []), gu.push({
        tag: u,
        color: i
      })), t.tagColor = i;
    }
  }
  return t;
}
function ZE(n, e) {
  Array.isArray(n) || (n = [n]);
  let t = [];
  return n.map((i) => {
    switch (i.type) {
      case "TextualBody":
        t.push(cI(i, e));
        break;
      case "Text":
        const {
          format: a,
          id: s,
          label: o
        } = i;
        let u = Ym(s);
        const c = Mt(o);
        u !== 2 && t.push({
          format: a,
          label: c,
          url: s,
          // Assume that an unassigned language is meant to be the downloadable filename
          filename: o.hasOwnProperty("none") ? Mt(o.none[0]) : c,
          /**
           * 'linkedResource' property helps to make parsing the choice in 
           * 'fetchAndParseLinkedAnnotations()' in AnnotationSetSelect.
           */
          linkedResource: a != "application/json"
        });
        break;
    }
  }), t;
}
async function lI(n) {
  const {
    canvasId: e,
    format: t,
    id: i,
    motivation: r,
    url: a
  } = n, {
    tData: s,
    tType: o
  } = await jg({
    url: a,
    format: t
  });
  if (s && o != ct.invalidTimestamp && o != ct.invalidVTT)
    return s.map((u, c) => {
      const {
        begin: l,
        end: h,
        text: f
      } = u;
      return {
        canvasId: e,
        id: `${i}-${c}`,
        // Add unique ids for each cue based on annotation id
        motivation: r,
        time: {
          start: l,
          end: h
        },
        value: [{
          format: "text/plain",
          purpose: r,
          value: f
        }]
      };
    });
}
function dI(n) {
  let e;
  const t = () => {
    e = `hsl(${Math.floor(Math.random() * 360)}, 80%, 90%)`;
  };
  if (t(), n.length > 0 && n.includes(e))
    t();
  else
    return e;
}
function fI(n) {
  let e = n.reduce((i, r) => {
    if (r.time != null) {
      const a = r.time.start;
      i[a] ? i[a][0].value.push(r.value[0]) : (i[a] = [], i[a].push(r));
    }
    return i;
  }, {});
  return Object.values(e).flat();
}
function hI(n) {
  const {
    canvasId: e,
    id: t,
    time: i,
    value: r
  } = n;
  return {
    id: t,
    time: i.start || 0,
    timeStr: i.start ? wn(i.start, !0, !0) : "00:00:00",
    canvasId: e,
    value: r?.length > 0 ? r[0].value : ""
  };
}
function pI(n) {
  return n?.length > 0 && n[0]?.type === "AnnotationService0" ? n[0].id : null;
}
function mI(n) {
  return n ? Mt(n).includes("[Playlist]") : (console.warn("playlist-parser -> getIsPlaylist() -> manifest.label not found"), !1);
}
function gI(n) {
  if (!n)
    return null;
  let [e, t] = n.target.split("#t="), i = n.body;
  return Object.keys(i).length === 0 ? null : i?.type === "TextualBody" ? {
    id: n.id,
    time: parseFloat(t),
    timeStr: wn(parseFloat(t), !0, !0),
    canvasId: e,
    value: i?.value ?? ""
  } : null;
}
const Cn = to(), Hr = to(), JE = {
  manifest: null,
  allCanvases: [],
  canvasIndex: 0,
  // index for active canvas
  currentNavItem: null,
  canvasDuration: 0,
  canvasLink: null,
  canvasIsEmpty: !1,
  customStart: {
    startIndex: 0,
    startTime: 0
  },
  targets: [],
  hasMultiItems: !1,
  // multiple resources in a single canvas
  srcIndex: 0,
  // index for multiple resources in a single canvas
  startTime: 0,
  autoAdvance: !1,
  playlist: {
    markers: [],
    // [{ canvasIndex: Number, canvasMarkers: Array, error: String }]
    isEditing: !1,
    isPlaylist: !1,
    hasAnnotationService: !1,
    annotationServiceId: ""
  },
  renderings: {},
  canvasSegments: [],
  structures: {
    hasStructure: !1,
    // current Canvas has structure timespans
    isCollapsed: !1,
    // all sections are expanded by default
    structItems: []
  },
  annotations: [],
  // [{ canvasIndex: Number, annotationSets: Array }]
  clickedAnnotation: null
  // clicked annotation in the Canvas
};
function S2(n, e) {
  return (n?.length > 0 ? n.filter((i) => i.canvasIndex == e + 1 && !i.isCanvas) : []).length > 0;
}
function bI(n, e) {
  return n.filter((i) => i.canvasIndex == e)?.length > 0;
}
function yI(n = JE, e) {
  switch (e.type) {
    case "updateManifest": {
      const t = e.manifest, i = tw(t), r = m6(t.behavior), a = mI(t.label), s = pI(t.service);
      return {
        ...n,
        manifest: t,
        allCanvases: i,
        autoAdvance: r,
        playlist: {
          ...n.playlist,
          isPlaylist: a,
          annotationServiceId: s,
          hasAnnotationService: !!s
        }
      };
    }
    case "switchCanvas": {
      const t = bI(n.annotations, e.canvasIndex);
      return {
        ...n,
        canvasIndex: e.canvasIndex,
        structures: {
          ...n.structures,
          hasStructure: S2(n.canvasSegments, e.canvasIndex)
        },
        annotations: t ? [...n.annotations] : [...n.annotations, qg(n.manifest, e.canvasIndex)]
      };
    }
    case "switchItem":
      return {
        ...n,
        currentNavItem: e.item
      };
    case "canvasDuration":
      return {
        ...n,
        canvasDuration: e.canvasDuration
      };
    case "canvasLink":
      return {
        ...n,
        canvasLink: e.canvasLink
      };
    case "canvasTargets":
      return {
        ...n,
        targets: e.canvasTargets
      };
    case "hasMultipleItems":
      return {
        ...n,
        hasMultiItems: e.isMultiSource
      };
    case "setSrcIndex":
      return {
        ...n,
        srcIndex: e.srcIndex
      };
    case "setItemStartTime":
      return {
        ...n,
        startTime: e.startTime
      };
    case "setAutoAdvance":
      return {
        ...n,
        autoAdvance: e.autoAdvance
      };
    case "setPlaylistMarkers": {
      if (e.markers)
        return {
          ...n,
          playlist: {
            ...n.playlist,
            markers: [...n.playlist.markers, e.markers]
          }
        };
      if (e.updatedMarkers)
        return {
          ...n,
          playlist: {
            ...n.playlist,
            markers: n.playlist.markers.map((t) => (t.canvasIndex === n.canvasIndex && (t.canvasMarkers = e.updatedMarkers), t))
          }
        };
    }
    case "setIsEditing":
      return {
        ...n,
        playlist: {
          ...n.playlist,
          isEditing: e.isEditing
        }
      };
    case "setCanvasIsEmpty":
      return {
        ...n,
        canvasIsEmpty: e.isEmpty
      };
    case "setStructures":
      return {
        ...n,
        structures: {
          ...n.structures,
          structItems: e.structures
        }
      };
    case "setCanvasSegments": {
      const t = e.timespans.filter((i) => i.canvasIndex == n.canvasIndex + 1 && !i.isCanvas);
      return {
        ...n,
        canvasSegments: e.timespans,
        structures: {
          ...n.structures,
          hasStructure: t.length > 0
        }
      };
    }
    case "setCustomStart": {
      const {
        canvas: t,
        time: i
      } = e.customStart;
      return {
        ...n,
        customStart: {
          startIndex: t,
          startTime: i
        },
        canvasIndex: t,
        structures: {
          ...n.structures,
          hasStructure: S2(n.canvasSegments, t)
        }
      };
    }
    case "setRenderingFiles":
      return {
        ...n,
        renderings: {
          ...e.renderings
        }
      };
    case "setIsCollapsed":
      return {
        ...n,
        structures: {
          ...n.structures,
          isCollapsed: e.isCollapsed
        }
      };
    case "setAnnotations":
      return {
        ...n,
        annotations: [...n.annotations, e.annotations]
      };
    case "setClickedAnnotation":
      return {
        ...n,
        clickedAnnotation: e.clickedAnnotation
      };
    default:
      throw new Error(`Unhandled action type: ${e.type}`);
  }
}
function vI(n) {
  const e = Et.c(5), {
    initialState: t,
    children: i
  } = n, r = t === void 0 ? JE : t, [a, s] = TT(yI, r);
  let o;
  e[0] !== i ? (o = /* @__PURE__ */ se.jsx(Hr.Provider, { value: s, children: i }), e[0] = i, e[1] = o) : o = e[1];
  let u;
  return e[2] !== a || e[3] !== o ? (u = /* @__PURE__ */ se.jsx(Cn.Provider, { value: a, children: o }), e[2] = a, e[3] = o, e[4] = u) : u = e[4], u;
}
function zr() {
  const n = pt(Cn);
  if (n === void 0)
    throw new Error("useManifestState must be used within a ManifestProvider");
  return n;
}
function fo() {
  const n = pt(Hr);
  if (n === void 0)
    throw new Error("useManifestDispatch must be used within a ManifestProvider");
  return n;
}
const $r = to(), La = to(), eD = {
  player: null,
  clickedUrl: "",
  isClicked: !1,
  isPlaying: !1,
  startTime: null,
  endTime: null,
  isEnded: !1,
  currentTime: null,
  searchMarkers: []
};
function xI(n = eD, e) {
  switch (e.type) {
    case "updatePlayer":
      return {
        ...n,
        player: e.player
      };
    case "navClick":
      return {
        ...n,
        clickedUrl: e.clickedUrl,
        isClicked: !0
      };
    case "resetClick":
      return {
        ...n,
        isClicked: !1
      };
    case "clearClickedUrl":
      return {
        ...n,
        clickedUrl: ""
      };
    case "setTimeFragment":
      return {
        ...n,
        startTime: e.startTime,
        endTime: e.endTime
      };
    case "setSearchMarkers":
      return {
        ...n,
        searchMarkers: e.payload
      };
    case "setPlayingStatus":
      return {
        ...n,
        isPlaying: e.isPlaying
      };
    case "setCaptionStatus":
      return {
        ...n,
        captionOn: e.captionOn
      };
    case "setIsEnded":
      return {
        ...n,
        isEnded: e.isEnded
      };
    case "setCurrentTime":
      return {
        ...n,
        currentTime: e.currentTime
      };
    default:
      throw new Error(`Unhandled action type: ${e.type}`);
  }
}
function _I(n) {
  const e = Et.c(5), {
    initialState: t,
    children: i
  } = n, r = t === void 0 ? eD : t, [a, s] = TT(xI, r);
  let o;
  e[0] !== i ? (o = /* @__PURE__ */ se.jsx(La.Provider, { value: s, children: i }), e[0] = i, e[1] = o) : o = e[1];
  let u;
  return e[2] !== a || e[3] !== o ? (u = /* @__PURE__ */ se.jsx($r.Provider, { value: a, children: o }), e[2] = a, e[3] = o, e[4] = u) : u = e[4], u;
}
function Wg() {
  const n = pt($r);
  if (n === void 0)
    throw new Error("usePlayerState must be used within the PlayerProvider");
  return n;
}
function Vg() {
  const n = pt(La);
  if (n === void 0)
    throw new Error("usePlayerDispatch must be used within the PlayerProvider");
  return n;
}
var ep = { exports: {} }, tp, C2;
function TI() {
  if (C2) return tp;
  C2 = 1;
  var n = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
  return tp = n, tp;
}
var np, A2;
function wI() {
  if (A2) return np;
  A2 = 1;
  var n = /* @__PURE__ */ TI();
  function e() {
  }
  function t() {
  }
  return t.resetWarningCache = e, np = function() {
    function i(s, o, u, c, l, h) {
      if (h !== n) {
        var f = new Error(
          "Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types"
        );
        throw f.name = "Invariant Violation", f;
      }
    }
    i.isRequired = i;
    function r() {
      return i;
    }
    var a = {
      array: i,
      bigint: i,
      bool: i,
      func: i,
      number: i,
      object: i,
      string: i,
      symbol: i,
      any: i,
      arrayOf: r,
      element: i,
      elementType: i,
      instanceOf: r,
      node: i,
      objectOf: r,
      oneOf: r,
      oneOfType: r,
      shape: r,
      exact: r,
      checkPropTypes: t,
      resetWarningCache: e
    };
    return a.PropTypes = a, a;
  }, np;
}
var k2;
function EI() {
  return k2 || (k2 = 1, ep.exports = /* @__PURE__ */ wI()()), ep.exports;
}
var DI = /* @__PURE__ */ EI();
const Le = /* @__PURE__ */ Qt(DI), tD = to(null), ip = {
  didCatch: !1,
  error: null
};
class SI extends ZA {
  constructor(e) {
    super(e), this.resetErrorBoundary = this.resetErrorBoundary.bind(this), this.state = ip;
  }
  static getDerivedStateFromError(e) {
    return {
      didCatch: !0,
      error: e
    };
  }
  resetErrorBoundary() {
    const {
      error: e
    } = this.state;
    if (e !== null) {
      for (var t, i, r = arguments.length, a = new Array(r), s = 0; s < r; s++)
        a[s] = arguments[s];
      (t = (i = this.props).onReset) === null || t === void 0 || t.call(i, {
        args: a,
        reason: "imperative-api"
      }), this.setState(ip);
    }
  }
  componentDidCatch(e, t) {
    var i, r;
    (i = (r = this.props).onError) === null || i === void 0 || i.call(r, e, t);
  }
  componentDidUpdate(e, t) {
    const {
      didCatch: i
    } = this.state, {
      resetKeys: r
    } = this.props;
    if (i && t.error !== null && CI(e.resetKeys, r)) {
      var a, s;
      (a = (s = this.props).onReset) === null || a === void 0 || a.call(s, {
        next: r,
        prev: e.resetKeys,
        reason: "keys"
      }), this.setState(ip);
    }
  }
  render() {
    const {
      children: e,
      fallbackRender: t,
      FallbackComponent: i,
      fallback: r
    } = this.props, {
      didCatch: a,
      error: s
    } = this.state;
    let o = e;
    if (a) {
      const u = {
        error: s,
        resetErrorBoundary: this.resetErrorBoundary
      };
      if (JA(r))
        o = r;
      else if (typeof t == "function")
        o = t(u);
      else if (i)
        o = Yu(i, u);
      else
        throw s;
    }
    return Yu(tD.Provider, {
      value: {
        didCatch: a,
        error: s,
        resetErrorBoundary: this.resetErrorBoundary
      }
    }, o);
  }
}
function CI() {
  let n = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [], e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
  return n.length !== e.length || n.some((t, i) => !Object.is(t, e[i]));
}
function AI(n) {
  if (n == null || typeof n.didCatch != "boolean" || typeof n.resetErrorBoundary != "function")
    throw new Error("ErrorBoundaryContext not found");
  return !0;
}
function ho() {
  const n = pt(tD);
  AI(n);
  const [e, t] = $e({
    error: null,
    hasError: !1
  }), i = Je(() => ({
    resetBoundary: () => {
      n?.resetErrorBoundary(), t({
        error: null,
        hasError: !1
      });
    },
    showBoundary: (r) => t({
      error: r,
      hasError: !0
    })
  }), [n?.resetErrorBoundary]);
  if (e.hasError)
    throw e.error;
  return i;
}
const ul = () => {
  const n = Et.c(1);
  let e;
  return n[0] === Symbol.for("react.memo_cache_sentinel") ? (e = /* @__PURE__ */ se.jsxs("div", { className: "lds-spinner", children: [
    /* @__PURE__ */ se.jsx("div", {}),
    /* @__PURE__ */ se.jsx("div", {}),
    /* @__PURE__ */ se.jsx("div", {}),
    /* @__PURE__ */ se.jsx("div", {}),
    /* @__PURE__ */ se.jsx("div", {}),
    /* @__PURE__ */ se.jsx("div", {}),
    /* @__PURE__ */ se.jsx("div", {}),
    /* @__PURE__ */ se.jsx("div", {}),
    /* @__PURE__ */ se.jsx("div", {}),
    /* @__PURE__ */ se.jsx("div", {}),
    /* @__PURE__ */ se.jsx("div", {}),
    /* @__PURE__ */ se.jsx("div", {})
  ] }), n[0] = e) : e = n[0], e;
};
function nD({
  manifestUrl: n,
  customErrorMessage: e,
  emptyManifestMessage: t,
  startCanvasId: i,
  startCanvasTime: r,
  children: a,
  manifest: s
}) {
  const [o, u] = $e(s), c = fo(), l = Vg(), {
    showBoundary: h
  } = ho();
  let f;
  const d = async (y) => {
    f = new AbortController();
    let m = {
      // NOTE: try this in Avalon
      //credentials: 'include',
      // headers: { 'Avalon-Api-Key': '' },
    };
    const b = y.replace(/[\?#].*(?=\/)/i, "");
    try {
      await fetch(b, m, {
        signal: f.signal
      }).then((p) => {
        if (p.status != 200 && p.status != 201)
          throw new Error("Failed to fetch Manifest. Please check again.");
        return p.json();
      }).then((p) => {
        if (!p)
          throw new Error(ka);
        u(p);
      }).catch((p) => {
        throw console.log("Error fetching manifest, ", p), new Error("Failed to fetch Manifest. Please check again.");
      });
    } catch (p) {
      h(p);
    }
  };
  return et(() => (e6(e), t6(t), !o && n && d(n), () => {
    f && f.abort();
  }), []), et(() => {
    if (o) {
      const y = h6(o);
      c({
        renderings: y,
        type: "setRenderingFiles"
      });
      const m = f6(o, i, r);
      c({
        customStart: m,
        type: "setCustomStart"
      }), m.type == "SR" && l({
        currentTime: m.time,
        type: "setCurrentTime"
      }), c({
        manifest: o,
        type: "updateManifest"
      });
    }
  }, [o]), o ? /* @__PURE__ */ se.jsx(se.Fragment, { children: a }) : /* @__PURE__ */ se.jsx(ul, {});
}
nD.propTypes = {
  manifest: Le.object,
  customErrorMessage: Le.string,
  emptyManifestMessage: Le.string,
  manifestUrl: Le.string,
  startCanvasId: Le.string,
  startCanvasTime: Le.number,
  children: Le.node
};
function kI(n) {
  const e = Et.c(7), {
    error: t,
    resetErrorBoundary: i
  } = n;
  let r;
  e[0] !== t.message ? (r = /* @__PURE__ */ se.jsx("span", { className: "ramp--error-message__message", dangerouslySetInnerHTML: {
    __html: t.message
  } }), e[0] = t.message, e[1] = r) : r = e[1];
  let a;
  e[2] !== i ? (a = /* @__PURE__ */ se.jsx("button", { className: "ramp--error-message__reset-button", onClick: i, children: "Try again" }), e[2] = i, e[3] = a) : a = e[3];
  let s;
  return e[4] !== r || e[5] !== a ? (s = /* @__PURE__ */ se.jsxs("div", { role: "alert", className: "ramp--error-message__alert", children: [
    r,
    a
  ] }), e[4] = r, e[5] = a, e[6] = s) : s = e[6], s;
}
const iD = (n) => {
  const e = Et.c(2), {
    children: t
  } = n;
  let i;
  return e[0] !== t ? (i = /* @__PURE__ */ se.jsx(SI, { FallbackComponent: kI, onReset: II, children: t }), e[0] = t, e[1] = i) : i = e[1], i;
};
iD.propTypes = {
  message: Le.string,
  children: Le.object
};
function II(n) {
}
function UI(n) {
  const e = Et.c(9), {
    manifestUrl: t,
    manifest: i,
    customErrorMessage: r,
    emptyManifestMessage: a,
    startCanvasId: s,
    startCanvasTime: o,
    children: u
  } = n;
  if (!t && !i) {
    let l;
    return e[0] === Symbol.for("react.memo_cache_sentinel") ? (l = /* @__PURE__ */ se.jsx("p", { children: "Please provide a valid manifest." }), e[0] = l) : l = e[0], l;
  }
  let c;
  return e[1] !== u || e[2] !== r || e[3] !== a || e[4] !== i || e[5] !== t || e[6] !== s || e[7] !== o ? (c = /* @__PURE__ */ se.jsx(iD, { children: /* @__PURE__ */ se.jsx(vI, { children: /* @__PURE__ */ se.jsx(_I, { children: /* @__PURE__ */ se.jsx(nD, { manifestUrl: t, manifest: i, customErrorMessage: r, emptyManifestMessage: a, startCanvasId: s, startCanvasTime: o, children: u }) }) }) }), e[1] = u, e[2] = r, e[3] = a, e[4] = i, e[5] = t, e[6] = s, e[7] = o, e[8] = c) : c = e[8], c;
}
UI.propTypes = {
  /** A valid IIIF manifest uri */
  manifestUrl: Le.string,
  manifest: Le.object,
  customErrorMessage: Le.string,
  emptyManifestMessage: Le.string,
  startCanvasId: Le.string,
  startCanvasTime: Le.number
};
var rp = { exports: {} };
/*!
	Copyright (c) 2018 Jed Watson.
	Licensed under the MIT License (MIT), see
	http://jedwatson.github.io/classnames
*/
var I2;
function RI() {
  return I2 || (I2 = 1, (function(n) {
    (function() {
      var e = {}.hasOwnProperty;
      function t() {
        for (var a = "", s = 0; s < arguments.length; s++) {
          var o = arguments[s];
          o && (a = r(a, i(o)));
        }
        return a;
      }
      function i(a) {
        if (typeof a == "string" || typeof a == "number")
          return a;
        if (typeof a != "object")
          return "";
        if (Array.isArray(a))
          return t.apply(null, a);
        if (a.toString !== Object.prototype.toString && !a.toString.toString().includes("[native code]"))
          return a.toString();
        var s = "";
        for (var o in a)
          e.call(a, o) && a[o] && (s = r(s, o));
        return s;
      }
      function r(a, s) {
        return s ? a ? a + " " + s : a + s : a;
      }
      n.exports ? (t.default = t, n.exports = t) : window.classNames = t;
    })();
  })(rp)), rp.exports;
}
var OI = RI();
const cn = /* @__PURE__ */ Qt(OI);
var ap, U2;
function cl() {
  if (U2) return ap;
  U2 = 1;
  var n;
  return typeof window < "u" ? n = window : typeof At < "u" ? n = At : typeof self < "u" ? n = self : n = {}, ap = n, ap;
}
var LI = cl();
const me = /* @__PURE__ */ Qt(LI);
var sp, R2;
function rD() {
  if (R2) return sp;
  R2 = 1;
  var n = typeof At < "u" ? At : typeof window < "u" ? window : {}, e = ni, t;
  return typeof document < "u" ? t = document : (t = n["__GLOBAL_DOCUMENT_CACHE@4"], t || (t = n["__GLOBAL_DOCUMENT_CACHE@4"] = e)), sp = t, sp;
}
var PI = rD();
const Be = /* @__PURE__ */ Qt(PI);
var bu = { exports: {} }, op = { exports: {} }, O2;
function FI() {
  return O2 || (O2 = 1, (function(n) {
    function e() {
      return n.exports = e = Object.assign ? Object.assign.bind() : function(t) {
        for (var i = 1; i < arguments.length; i++) {
          var r = arguments[i];
          for (var a in r) ({}).hasOwnProperty.call(r, a) && (t[a] = r[a]);
        }
        return t;
      }, n.exports.__esModule = !0, n.exports.default = n.exports, e.apply(null, arguments);
    }
    n.exports = e, n.exports.__esModule = !0, n.exports.default = n.exports;
  })(op)), op.exports;
}
var up, L2;
function NI() {
  if (L2) return up;
  L2 = 1, up = e;
  var n = Object.prototype.toString;
  function e(t) {
    if (!t)
      return !1;
    var i = n.call(t);
    return i === "[object Function]" || typeof t == "function" && i !== "[object RegExp]" || typeof window < "u" && // IE8 and below
    (t === window.setTimeout || t === window.alert || t === window.confirm || t === window.prompt);
  }
  return up;
}
var cp, P2;
function MI() {
  if (P2) return cp;
  P2 = 1;
  function n(r, a) {
    var s = typeof Symbol < "u" && r[Symbol.iterator] || r["@@iterator"];
    if (s) return (s = s.call(r)).next.bind(s);
    if (Array.isArray(r) || (s = e(r)) || a) {
      s && (r = s);
      var o = 0;
      return function() {
        return o >= r.length ? { done: !0 } : { done: !1, value: r[o++] };
      };
    }
    throw new TypeError(`Invalid attempt to iterate non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
  }
  function e(r, a) {
    if (r) {
      if (typeof r == "string") return t(r, a);
      var s = Object.prototype.toString.call(r).slice(8, -1);
      if (s === "Object" && r.constructor && (s = r.constructor.name), s === "Map" || s === "Set") return Array.from(r);
      if (s === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(s)) return t(r, a);
    }
  }
  function t(r, a) {
    (a == null || a > r.length) && (a = r.length);
    for (var s = 0, o = new Array(a); s < a; s++)
      o[s] = r[s];
    return o;
  }
  var i = /* @__PURE__ */ (function() {
    function r() {
      this.typeToInterceptorsMap_ = /* @__PURE__ */ new Map(), this.enabled_ = !1;
    }
    var a = r.prototype;
    return a.getIsEnabled = function() {
      return this.enabled_;
    }, a.enable = function() {
      this.enabled_ = !0;
    }, a.disable = function() {
      this.enabled_ = !1;
    }, a.reset = function() {
      this.typeToInterceptorsMap_ = /* @__PURE__ */ new Map(), this.enabled_ = !1;
    }, a.addInterceptor = function(o, u) {
      this.typeToInterceptorsMap_.has(o) || this.typeToInterceptorsMap_.set(o, /* @__PURE__ */ new Set());
      var c = this.typeToInterceptorsMap_.get(o);
      return c.has(u) ? !1 : (c.add(u), !0);
    }, a.removeInterceptor = function(o, u) {
      var c = this.typeToInterceptorsMap_.get(o);
      return c && c.has(u) ? (c.delete(u), !0) : !1;
    }, a.clearInterceptorsByType = function(o) {
      var u = this.typeToInterceptorsMap_.get(o);
      return u ? (this.typeToInterceptorsMap_.delete(o), this.typeToInterceptorsMap_.set(o, /* @__PURE__ */ new Set()), !0) : !1;
    }, a.clear = function() {
      return this.typeToInterceptorsMap_.size ? (this.typeToInterceptorsMap_ = /* @__PURE__ */ new Map(), !0) : !1;
    }, a.getForType = function(o) {
      return this.typeToInterceptorsMap_.get(o) || /* @__PURE__ */ new Set();
    }, a.execute = function(o, u) {
      for (var c = this.getForType(o), l = n(c), h; !(h = l()).done; ) {
        var f = h.value;
        try {
          u = f(u);
        } catch {
        }
      }
      return u;
    }, r;
  })();
  return cp = i, cp;
}
var lp, F2;
function BI() {
  if (F2) return lp;
  F2 = 1;
  var n = /* @__PURE__ */ (function() {
    function t() {
      this.maxAttempts_ = 1, this.delayFactor_ = 0.1, this.fuzzFactor_ = 0.1, this.initialDelay_ = 1e3, this.enabled_ = !1;
    }
    var i = t.prototype;
    return i.getIsEnabled = function() {
      return this.enabled_;
    }, i.enable = function() {
      this.enabled_ = !0;
    }, i.disable = function() {
      this.enabled_ = !1;
    }, i.reset = function() {
      this.maxAttempts_ = 1, this.delayFactor_ = 0.1, this.fuzzFactor_ = 0.1, this.initialDelay_ = 1e3, this.enabled_ = !1;
    }, i.getMaxAttempts = function() {
      return this.maxAttempts_;
    }, i.setMaxAttempts = function(a) {
      this.maxAttempts_ = a;
    }, i.getDelayFactor = function() {
      return this.delayFactor_;
    }, i.setDelayFactor = function(a) {
      this.delayFactor_ = a;
    }, i.getFuzzFactor = function() {
      return this.fuzzFactor_;
    }, i.setFuzzFactor = function(a) {
      this.fuzzFactor_ = a;
    }, i.getInitialDelay = function() {
      return this.initialDelay_;
    }, i.setInitialDelay = function(a) {
      this.initialDelay_ = a;
    }, i.createRetry = function(a) {
      var s = a === void 0 ? {} : a, o = s.maxAttempts, u = s.delayFactor, c = s.fuzzFactor, l = s.initialDelay;
      return new e({
        maxAttempts: o || this.maxAttempts_,
        delayFactor: u || this.delayFactor_,
        fuzzFactor: c || this.fuzzFactor_,
        initialDelay: l || this.initialDelay_
      });
    }, t;
  })(), e = /* @__PURE__ */ (function() {
    function t(r) {
      this.maxAttempts_ = r.maxAttempts, this.delayFactor_ = r.delayFactor, this.fuzzFactor_ = r.fuzzFactor, this.currentDelay_ = r.initialDelay, this.currentAttempt_ = 1;
    }
    var i = t.prototype;
    return i.moveToNextAttempt = function() {
      this.currentAttempt_++;
      var a = this.currentDelay_ * this.delayFactor_;
      this.currentDelay_ = this.currentDelay_ + a;
    }, i.shouldRetry = function() {
      return this.currentAttempt_ < this.maxAttempts_;
    }, i.getCurrentDelay = function() {
      return this.currentDelay_;
    }, i.getCurrentMinPossibleDelay = function() {
      return (1 - this.fuzzFactor_) * this.currentDelay_;
    }, i.getCurrentMaxPossibleDelay = function() {
      return (1 + this.fuzzFactor_) * this.currentDelay_;
    }, i.getCurrentFuzzedDelay = function() {
      var a = this.getCurrentMinPossibleDelay(), s = this.getCurrentMaxPossibleDelay();
      return a + Math.random() * (s - a);
    }, t;
  })();
  return lp = n, lp;
}
var dp, N2;
function jI() {
  if (N2) return dp;
  N2 = 1;
  var n = cl(), e = function(r, a) {
    return a === void 0 && (a = !1), function(s, o, u) {
      if (s) {
        r(s);
        return;
      }
      if (o.statusCode >= 400 && o.statusCode <= 599) {
        var c = u;
        if (a)
          if (n.TextDecoder) {
            var l = t(o.headers && o.headers["content-type"]);
            try {
              c = new TextDecoder(l).decode(u);
            } catch {
            }
          } else
            c = String.fromCharCode.apply(null, new Uint8Array(u));
        r({
          cause: c
        });
        return;
      }
      r(null, u);
    };
  };
  function t(i) {
    return i === void 0 && (i = ""), i.toLowerCase().split(";").reduce(function(r, a) {
      var s = a.split("="), o = s[0], u = s[1];
      return o.trim() === "charset" ? u.trim() : r;
    }, "utf-8");
  }
  return dp = e, dp;
}
var M2;
function qI() {
  if (M2) return bu.exports;
  M2 = 1;
  var n = cl(), e = FI(), t = NI(), i = MI(), r = BI();
  c.httpHandler = jI(), c.requestInterceptorsStorage = new i(), c.responseInterceptorsStorage = new i(), c.retryManager = new r();
  /**
   * @license
   * slighly modified parse-headers 2.0.2 <https://github.com/kesla/parse-headers/>
   * Copyright (c) 2014 David Bjrklund
   * Available under the MIT license
   * <https://github.com/kesla/parse-headers/blob/master/LICENCE>
   */
  var a = function(y) {
    var m = {};
    return y && y.trim().split(`
`).forEach(function(b) {
      var p = b.indexOf(":"), g = b.slice(0, p).trim().toLowerCase(), v = b.slice(p + 1).trim();
      typeof m[g] > "u" ? m[g] = v : Array.isArray(m[g]) ? m[g].push(v) : m[g] = [m[g], v];
    }), m;
  };
  bu.exports = c, bu.exports.default = c, c.XMLHttpRequest = n.XMLHttpRequest || f, c.XDomainRequest = "withCredentials" in new c.XMLHttpRequest() ? c.XMLHttpRequest : n.XDomainRequest, s(["get", "put", "post", "patch", "head", "delete"], function(d) {
    c[d === "delete" ? "del" : d] = function(y, m, b) {
      return m = u(y, m, b), m.method = d.toUpperCase(), l(m);
    };
  });
  function s(d, y) {
    for (var m = 0; m < d.length; m++)
      y(d[m]);
  }
  function o(d) {
    for (var y in d)
      if (d.hasOwnProperty(y)) return !1;
    return !0;
  }
  function u(d, y, m) {
    var b = d;
    return t(y) ? (m = y, typeof d == "string" && (b = {
      uri: d
    })) : b = e({}, y, {
      uri: d
    }), b.callback = m, b;
  }
  function c(d, y, m) {
    return y = u(d, y, m), l(y);
  }
  function l(d) {
    if (typeof d.callback > "u")
      throw new Error("callback argument missing");
    if (d.requestType && c.requestInterceptorsStorage.getIsEnabled()) {
      var y = {
        uri: d.uri || d.url,
        headers: d.headers || {},
        body: d.body,
        metadata: d.metadata || {},
        retry: d.retry,
        timeout: d.timeout
      }, m = c.requestInterceptorsStorage.execute(d.requestType, y);
      d.uri = m.uri, d.headers = m.headers, d.body = m.body, d.metadata = m.metadata, d.retry = m.retry, d.timeout = m.timeout;
    }
    var b = !1, p = function(z, q, Y) {
      b || (b = !0, d.callback(z, q, Y));
    };
    function g() {
      T.readyState === 4 && !c.responseInterceptorsStorage.getIsEnabled() && setTimeout(x, 0);
    }
    function v() {
      var B = void 0;
      if (T.response ? B = T.response : B = T.responseText || h(T), I)
        try {
          B = JSON.parse(B);
        } catch {
        }
      return B;
    }
    function _(B) {
      if (clearTimeout($), clearTimeout(d.retryTimeout), B instanceof Error || (B = new Error("" + (B || "Unknown XMLHttpRequest Error"))), B.statusCode = 0, !U && c.retryManager.getIsEnabled() && d.retry && d.retry.shouldRetry()) {
        d.retryTimeout = setTimeout(function() {
          d.retry.moveToNextAttempt(), d.xhr = T, l(d);
        }, d.retry.getCurrentFuzzedDelay());
        return;
      }
      if (d.requestType && c.responseInterceptorsStorage.getIsEnabled()) {
        var z = {
          headers: W.headers || {},
          body: W.body,
          responseUrl: T.responseURL,
          responseType: T.responseType
        }, q = c.responseInterceptorsStorage.execute(d.requestType, z);
        W.body = q.body, W.headers = q.headers;
      }
      return p(B, W);
    }
    function x() {
      if (!U) {
        var B;
        clearTimeout($), clearTimeout(d.retryTimeout), d.useXDR && T.status === void 0 ? B = 200 : B = T.status === 1223 ? 204 : T.status;
        var z = W, q = null;
        if (B !== 0 ? (z = {
          body: v(),
          statusCode: B,
          method: L,
          headers: {},
          url: D,
          rawRequest: T
        }, T.getAllResponseHeaders && (z.headers = a(T.getAllResponseHeaders()))) : q = new Error("Internal XMLHttpRequest Error"), d.requestType && c.responseInterceptorsStorage.getIsEnabled()) {
          var Y = {
            headers: z.headers || {},
            body: z.body,
            responseUrl: T.responseURL,
            responseType: T.responseType
          }, H = c.responseInterceptorsStorage.execute(d.requestType, Y);
          z.body = H.body, z.headers = H.headers;
        }
        return p(q, z, z.body);
      }
    }
    var T = d.xhr || null;
    T || (d.cors || d.useXDR ? T = new c.XDomainRequest() : T = new c.XMLHttpRequest());
    var E, U, D = T.url = d.uri || d.url, L = T.method = d.method || "GET", j = d.body || d.data, C = T.headers = d.headers || {}, k = !!d.sync, I = !1, $, W = {
      body: void 0,
      headers: {},
      statusCode: 0,
      method: L,
      url: D,
      rawRequest: T
    };
    if ("json" in d && d.json !== !1 && (I = !0, C.accept || C.Accept || (C.Accept = "application/json"), L !== "GET" && L !== "HEAD" && (C["content-type"] || C["Content-Type"] || (C["Content-Type"] = "application/json"), j = JSON.stringify(d.json === !0 ? j : d.json))), T.onreadystatechange = g, T.onload = x, T.onerror = _, T.onprogress = function() {
    }, T.onabort = function() {
      U = !0, clearTimeout(d.retryTimeout);
    }, T.ontimeout = _, T.open(L, D, !k, d.username, d.password), k || (T.withCredentials = !!d.withCredentials), !k && d.timeout > 0 && ($ = setTimeout(function() {
      if (!U) {
        U = !0, T.abort("timeout");
        var B = new Error("XMLHttpRequest timeout");
        B.code = "ETIMEDOUT", _(B);
      }
    }, d.timeout)), T.setRequestHeader)
      for (E in C)
        C.hasOwnProperty(E) && T.setRequestHeader(E, C[E]);
    else if (d.headers && !o(d.headers))
      throw new Error("Headers cannot be set on an XDomainRequest object");
    return "responseType" in d && (T.responseType = d.responseType), "beforeSend" in d && typeof d.beforeSend == "function" && d.beforeSend(T), T.send(j || null), T;
  }
  function h(d) {
    try {
      if (d.responseType === "document")
        return d.responseXML;
      var y = d.responseXML && d.responseXML.documentElement.nodeName === "parsererror";
      if (d.responseType === "" && !y)
        return d.responseXML;
    } catch {
    }
    return null;
  }
  function f() {
  }
  return bu.exports;
}
var WI = qI();
const aD = /* @__PURE__ */ Qt(WI);
var fp = { exports: {} }, hp, B2;
function VI() {
  if (B2) return hp;
  B2 = 1;
  var n = rD(), e = Object.create || /* @__PURE__ */ (function() {
    function D() {
    }
    return function(L) {
      if (arguments.length !== 1)
        throw new Error("Object.create shim only accepts one parameter.");
      return D.prototype = L, new D();
    };
  })();
  function t(D, L) {
    this.name = "ParsingError", this.code = D.code, this.message = L || D.message;
  }
  t.prototype = e(Error.prototype), t.prototype.constructor = t, t.Errors = {
    BadSignature: {
      code: 0,
      message: "Malformed WebVTT signature."
    },
    BadTimeStamp: {
      code: 1,
      message: "Malformed time stamp."
    }
  };
  function i(D) {
    function L(C, k, I, $) {
      return (C | 0) * 3600 + (k | 0) * 60 + (I | 0) + ($ | 0) / 1e3;
    }
    var j = D.match(/^(\d+):(\d{1,2})(:\d{1,2})?\.(\d{3})/);
    return j ? j[3] ? L(j[1], j[2], j[3].replace(":", ""), j[4]) : j[1] > 59 ? L(j[1], j[2], 0, j[4]) : L(0, j[1], j[2], j[4]) : null;
  }
  function r() {
    this.values = e(null);
  }
  r.prototype = {
    // Only accept the first assignment to any key.
    set: function(D, L) {
      !this.get(D) && L !== "" && (this.values[D] = L);
    },
    // Return the value for a key, or a default value.
    // If 'defaultKey' is passed then 'dflt' is assumed to be an object with
    // a number of possible default values as properties where 'defaultKey' is
    // the key of the property that will be chosen; otherwise it's assumed to be
    // a single value.
    get: function(D, L, j) {
      return j ? this.has(D) ? this.values[D] : L[j] : this.has(D) ? this.values[D] : L;
    },
    // Check whether we have a value for a key.
    has: function(D) {
      return D in this.values;
    },
    // Accept a setting if its one of the given alternatives.
    alt: function(D, L, j) {
      for (var C = 0; C < j.length; ++C)
        if (L === j[C]) {
          this.set(D, L);
          break;
        }
    },
    // Accept a setting if its a valid (signed) integer.
    integer: function(D, L) {
      /^-?\d+$/.test(L) && this.set(D, parseInt(L, 10));
    },
    // Accept a setting if its a valid percentage.
    percent: function(D, L) {
      return L.match(/^([\d]{1,3})(\.[\d]*)?%$/) && (L = parseFloat(L), L >= 0 && L <= 100) ? (this.set(D, L), !0) : !1;
    }
  };
  function a(D, L, j, C) {
    var k = C ? D.split(C) : [D];
    for (var I in k)
      if (typeof k[I] == "string") {
        var $ = k[I].split(j);
        if ($.length === 2) {
          var W = $[0].trim(), B = $[1].trim();
          L(W, B);
        }
      }
  }
  function s(D, L, j) {
    var C = D;
    function k() {
      var W = i(D);
      if (W === null)
        throw new t(
          t.Errors.BadTimeStamp,
          "Malformed timestamp: " + C
        );
      return D = D.replace(/^[^\sa-zA-Z-]+/, ""), W;
    }
    function I(W, B) {
      var z = new r();
      a(W, function(q, Y) {
        switch (q) {
          case "region":
            for (var H = j.length - 1; H >= 0; H--)
              if (j[H].id === Y) {
                z.set(q, j[H].region);
                break;
              }
            break;
          case "vertical":
            z.alt(q, Y, ["rl", "lr"]);
            break;
          case "line":
            var K = Y.split(","), ie = K[0];
            z.integer(q, ie), z.percent(q, ie) && z.set("snapToLines", !1), z.alt(q, ie, ["auto"]), K.length === 2 && z.alt("lineAlign", K[1], ["start", "center", "end"]);
            break;
          case "position":
            K = Y.split(","), z.percent(q, K[0]), K.length === 2 && z.alt("positionAlign", K[1], ["start", "center", "end"]);
            break;
          case "size":
            z.percent(q, Y);
            break;
          case "align":
            z.alt(q, Y, ["start", "center", "end", "left", "right"]);
            break;
        }
      }, /:/, /\s/), B.region = z.get("region", null), B.vertical = z.get("vertical", "");
      try {
        B.line = z.get("line", "auto");
      } catch {
      }
      B.lineAlign = z.get("lineAlign", "start"), B.snapToLines = z.get("snapToLines", !0), B.size = z.get("size", 100);
      try {
        B.align = z.get("align", "center");
      } catch {
        B.align = z.get("align", "middle");
      }
      try {
        B.position = z.get("position", "auto");
      } catch {
        B.position = z.get("position", {
          start: 0,
          left: 0,
          center: 50,
          middle: 50,
          end: 100,
          right: 100
        }, B.align);
      }
      B.positionAlign = z.get("positionAlign", {
        start: "start",
        left: "start",
        center: "center",
        middle: "center",
        end: "end",
        right: "end"
      }, B.align);
    }
    function $() {
      D = D.replace(/^\s+/, "");
    }
    if ($(), L.startTime = k(), $(), D.substr(0, 3) !== "-->")
      throw new t(
        t.Errors.BadTimeStamp,
        "Malformed time stamp (time stamps must be separated by '-->'): " + C
      );
    D = D.substr(3), $(), L.endTime = k(), $(), I(D, L);
  }
  var o = n.createElement && n.createElement("textarea"), u = {
    c: "span",
    i: "i",
    b: "b",
    u: "u",
    ruby: "ruby",
    rt: "rt",
    v: "span",
    lang: "span"
  }, c = {
    white: "rgba(255,255,255,1)",
    lime: "rgba(0,255,0,1)",
    cyan: "rgba(0,255,255,1)",
    red: "rgba(255,0,0,1)",
    yellow: "rgba(255,255,0,1)",
    magenta: "rgba(255,0,255,1)",
    blue: "rgba(0,0,255,1)",
    black: "rgba(0,0,0,1)"
  }, l = {
    v: "title",
    lang: "lang"
  }, h = {
    rt: "ruby"
  };
  function f(D, L) {
    function j() {
      if (!L)
        return null;
      function ie(pe) {
        return L = L.substr(pe.length), pe;
      }
      var ge = L.match(/^([^<]*)(<[^>]*>?)?/);
      return ie(ge[1] ? ge[1] : ge[2]);
    }
    function C(ie) {
      return o.innerHTML = ie, ie = o.textContent, o.textContent = "", ie;
    }
    function k(ie, ge) {
      return !h[ge.localName] || h[ge.localName] === ie.localName;
    }
    function I(ie, ge) {
      var pe = u[ie];
      if (!pe)
        return null;
      var ce = D.document.createElement(pe), oe = l[ie];
      return oe && ge && (ce[oe] = ge.trim()), ce;
    }
    for (var $ = D.document.createElement("div"), W = $, B, z = []; (B = j()) !== null; ) {
      if (B[0] === "<") {
        if (B[1] === "/") {
          z.length && z[z.length - 1] === B.substr(2).replace(">", "") && (z.pop(), W = W.parentNode);
          continue;
        }
        var q = i(B.substr(1, B.length - 2)), Y;
        if (q) {
          Y = D.document.createProcessingInstruction("timestamp", q), W.appendChild(Y);
          continue;
        }
        var H = B.match(/^<([^.\s/0-9>]+)(\.[^\s\\>]+)?([^>\\]+)?(\\?)>?$/);
        if (!H || (Y = I(H[1], H[3]), !Y) || !k(W, Y))
          continue;
        if (H[2]) {
          var K = H[2].split(".");
          K.forEach(function(ie) {
            var ge = /^bg_/.test(ie), pe = ge ? ie.slice(3) : ie;
            if (c.hasOwnProperty(pe)) {
              var ce = ge ? "background-color" : "color", oe = c[pe];
              Y.style[ce] = oe;
            }
          }), Y.className = K.join(" ");
        }
        z.push(H[1]), W.appendChild(Y), W = Y;
        continue;
      }
      W.appendChild(D.document.createTextNode(C(B)));
    }
    return $;
  }
  var d = [
    [1470, 1470],
    [1472, 1472],
    [1475, 1475],
    [1478, 1478],
    [1488, 1514],
    [1520, 1524],
    [1544, 1544],
    [1547, 1547],
    [1549, 1549],
    [1563, 1563],
    [1566, 1610],
    [1645, 1647],
    [1649, 1749],
    [1765, 1766],
    [1774, 1775],
    [1786, 1805],
    [1807, 1808],
    [1810, 1839],
    [1869, 1957],
    [1969, 1969],
    [1984, 2026],
    [2036, 2037],
    [2042, 2042],
    [2048, 2069],
    [2074, 2074],
    [2084, 2084],
    [2088, 2088],
    [2096, 2110],
    [2112, 2136],
    [2142, 2142],
    [2208, 2208],
    [2210, 2220],
    [8207, 8207],
    [64285, 64285],
    [64287, 64296],
    [64298, 64310],
    [64312, 64316],
    [64318, 64318],
    [64320, 64321],
    [64323, 64324],
    [64326, 64449],
    [64467, 64829],
    [64848, 64911],
    [64914, 64967],
    [65008, 65020],
    [65136, 65140],
    [65142, 65276],
    [67584, 67589],
    [67592, 67592],
    [67594, 67637],
    [67639, 67640],
    [67644, 67644],
    [67647, 67669],
    [67671, 67679],
    [67840, 67867],
    [67872, 67897],
    [67903, 67903],
    [67968, 68023],
    [68030, 68031],
    [68096, 68096],
    [68112, 68115],
    [68117, 68119],
    [68121, 68147],
    [68160, 68167],
    [68176, 68184],
    [68192, 68223],
    [68352, 68405],
    [68416, 68437],
    [68440, 68466],
    [68472, 68479],
    [68608, 68680],
    [126464, 126467],
    [126469, 126495],
    [126497, 126498],
    [126500, 126500],
    [126503, 126503],
    [126505, 126514],
    [126516, 126519],
    [126521, 126521],
    [126523, 126523],
    [126530, 126530],
    [126535, 126535],
    [126537, 126537],
    [126539, 126539],
    [126541, 126543],
    [126545, 126546],
    [126548, 126548],
    [126551, 126551],
    [126553, 126553],
    [126555, 126555],
    [126557, 126557],
    [126559, 126559],
    [126561, 126562],
    [126564, 126564],
    [126567, 126570],
    [126572, 126578],
    [126580, 126583],
    [126585, 126588],
    [126590, 126590],
    [126592, 126601],
    [126603, 126619],
    [126625, 126627],
    [126629, 126633],
    [126635, 126651],
    [1114109, 1114109]
  ];
  function y(D) {
    for (var L = 0; L < d.length; L++) {
      var j = d[L];
      if (D >= j[0] && D <= j[1])
        return !0;
    }
    return !1;
  }
  function m(D) {
    var L = [], j = "", C;
    if (!D || !D.childNodes)
      return "ltr";
    function k(W, B) {
      for (var z = B.childNodes.length - 1; z >= 0; z--)
        W.push(B.childNodes[z]);
    }
    function I(W) {
      if (!W || !W.length)
        return null;
      var B = W.pop(), z = B.textContent || B.innerText;
      if (z) {
        var q = z.match(/^.*(\n|\r)/);
        return q ? (W.length = 0, q[0]) : z;
      }
      if (B.tagName === "ruby")
        return I(W);
      if (B.childNodes)
        return k(W, B), I(W);
    }
    for (k(L, D); j = I(L); )
      for (var $ = 0; $ < j.length; $++)
        if (C = j.charCodeAt($), y(C))
          return "rtl";
    return "ltr";
  }
  function b(D) {
    if (typeof D.line == "number" && (D.snapToLines || D.line >= 0 && D.line <= 100))
      return D.line;
    if (!D.track || !D.track.textTrackList || !D.track.textTrackList.mediaElement)
      return -1;
    for (var L = D.track, j = L.textTrackList, C = 0, k = 0; k < j.length && j[k] !== L; k++)
      j[k].mode === "showing" && C++;
    return ++C * -1;
  }
  function p() {
  }
  p.prototype.applyStyles = function(D, L) {
    L = L || this.div;
    for (var j in D)
      D.hasOwnProperty(j) && (L.style[j] = D[j]);
  }, p.prototype.formatStyle = function(D, L) {
    return D === 0 ? 0 : D + L;
  };
  function g(D, L, j) {
    p.call(this), this.cue = L, this.cueDiv = f(D, L.text);
    var C = {
      color: "rgba(255, 255, 255, 1)",
      backgroundColor: "rgba(0, 0, 0, 0.8)",
      position: "relative",
      left: 0,
      right: 0,
      top: 0,
      bottom: 0,
      display: "inline",
      writingMode: L.vertical === "" ? "horizontal-tb" : L.vertical === "lr" ? "vertical-lr" : "vertical-rl",
      unicodeBidi: "plaintext"
    };
    this.applyStyles(C, this.cueDiv), this.div = D.document.createElement("div"), C = {
      direction: m(this.cueDiv),
      writingMode: L.vertical === "" ? "horizontal-tb" : L.vertical === "lr" ? "vertical-lr" : "vertical-rl",
      unicodeBidi: "plaintext",
      textAlign: L.align === "middle" ? "center" : L.align,
      font: j.font,
      whiteSpace: "pre-line",
      position: "absolute"
    }, this.applyStyles(C), this.div.appendChild(this.cueDiv);
    var k = 0;
    switch (L.positionAlign) {
      case "start":
      case "line-left":
        k = L.position;
        break;
      case "center":
        k = L.position - L.size / 2;
        break;
      case "end":
      case "line-right":
        k = L.position - L.size;
        break;
    }
    L.vertical === "" ? this.applyStyles({
      left: this.formatStyle(k, "%"),
      width: this.formatStyle(L.size, "%")
    }) : this.applyStyles({
      top: this.formatStyle(k, "%"),
      height: this.formatStyle(L.size, "%")
    }), this.move = function(I) {
      this.applyStyles({
        top: this.formatStyle(I.top, "px"),
        bottom: this.formatStyle(I.bottom, "px"),
        left: this.formatStyle(I.left, "px"),
        right: this.formatStyle(I.right, "px"),
        height: this.formatStyle(I.height, "px"),
        width: this.formatStyle(I.width, "px")
      });
    };
  }
  g.prototype = e(p.prototype), g.prototype.constructor = g;
  function v(D) {
    var L, j, C, k;
    if (D.div) {
      j = D.div.offsetHeight, C = D.div.offsetWidth, k = D.div.offsetTop;
      var I = (I = D.div.childNodes) && (I = I[0]) && I.getClientRects && I.getClientRects();
      D = D.div.getBoundingClientRect(), L = I ? Math.max(I[0] && I[0].height || 0, D.height / I.length) : 0;
    }
    this.left = D.left, this.right = D.right, this.top = D.top || k, this.height = D.height || j, this.bottom = D.bottom || k + (D.height || j), this.width = D.width || C, this.lineHeight = L !== void 0 ? L : D.lineHeight;
  }
  v.prototype.move = function(D, L) {
    switch (L = L !== void 0 ? L : this.lineHeight, D) {
      case "+x":
        this.left += L, this.right += L;
        break;
      case "-x":
        this.left -= L, this.right -= L;
        break;
      case "+y":
        this.top += L, this.bottom += L;
        break;
      case "-y":
        this.top -= L, this.bottom -= L;
        break;
    }
  }, v.prototype.overlaps = function(D) {
    return this.left < D.right && this.right > D.left && this.top < D.bottom && this.bottom > D.top;
  }, v.prototype.overlapsAny = function(D) {
    for (var L = 0; L < D.length; L++)
      if (this.overlaps(D[L]))
        return !0;
    return !1;
  }, v.prototype.within = function(D) {
    return this.top >= D.top && this.bottom <= D.bottom && this.left >= D.left && this.right <= D.right;
  }, v.prototype.overlapsOppositeAxis = function(D, L) {
    switch (L) {
      case "+x":
        return this.left < D.left;
      case "-x":
        return this.right > D.right;
      case "+y":
        return this.top < D.top;
      case "-y":
        return this.bottom > D.bottom;
    }
  }, v.prototype.intersectPercentage = function(D) {
    var L = Math.max(0, Math.min(this.right, D.right) - Math.max(this.left, D.left)), j = Math.max(0, Math.min(this.bottom, D.bottom) - Math.max(this.top, D.top)), C = L * j;
    return C / (this.height * this.width);
  }, v.prototype.toCSSCompatValues = function(D) {
    return {
      top: this.top - D.top,
      bottom: D.bottom - this.bottom,
      left: this.left - D.left,
      right: D.right - this.right,
      height: this.height,
      width: this.width
    };
  }, v.getSimpleBoxPosition = function(D) {
    var L = D.div ? D.div.offsetHeight : D.tagName ? D.offsetHeight : 0, j = D.div ? D.div.offsetWidth : D.tagName ? D.offsetWidth : 0, C = D.div ? D.div.offsetTop : D.tagName ? D.offsetTop : 0;
    D = D.div ? D.div.getBoundingClientRect() : D.tagName ? D.getBoundingClientRect() : D;
    var k = {
      left: D.left,
      right: D.right,
      top: D.top || C,
      height: D.height || L,
      bottom: D.bottom || C + (D.height || L),
      width: D.width || j
    };
    return k;
  };
  function _(D, L, j, C) {
    function k(pe, ce) {
      for (var oe, De = new v(pe), Re = 1, Me = 0; Me < ce.length; Me++) {
        for (; pe.overlapsOppositeAxis(j, ce[Me]) || pe.within(j) && pe.overlapsAny(C); )
          pe.move(ce[Me]);
        if (pe.within(j))
          return pe;
        var F = pe.intersectPercentage(j);
        Re > F && (oe = new v(pe), Re = F), pe = new v(De);
      }
      return oe || De;
    }
    var I = new v(L), $ = L.cue, W = b($), B = [];
    if ($.snapToLines) {
      var z;
      switch ($.vertical) {
        case "":
          B = ["+y", "-y"], z = "height";
          break;
        case "rl":
          B = ["+x", "-x"], z = "width";
          break;
        case "lr":
          B = ["-x", "+x"], z = "width";
          break;
      }
      var q = I.lineHeight, Y = q * Math.round(W), H = j[z] + q, K = B[0];
      Math.abs(Y) > H && (Y = Y < 0 ? -1 : 1, Y *= Math.ceil(H / q) * q), W < 0 && (Y += $.vertical === "" ? j.height : j.width, B = B.reverse()), I.move(K, Y);
    } else {
      var ie = I.lineHeight / j.height * 100;
      switch ($.lineAlign) {
        case "center":
          W -= ie / 2;
          break;
        case "end":
          W -= ie;
          break;
      }
      switch ($.vertical) {
        case "":
          L.applyStyles({
            top: L.formatStyle(W, "%")
          });
          break;
        case "rl":
          L.applyStyles({
            left: L.formatStyle(W, "%")
          });
          break;
        case "lr":
          L.applyStyles({
            right: L.formatStyle(W, "%")
          });
          break;
      }
      B = ["+y", "-x", "+x", "-y"], I = new v(L);
    }
    var ge = k(I, B);
    L.move(ge.toCSSCompatValues(j));
  }
  function x() {
  }
  x.StringDecoder = function() {
    return {
      decode: function(D) {
        if (!D)
          return "";
        if (typeof D != "string")
          throw new Error("Error - expected string data.");
        return decodeURIComponent(encodeURIComponent(D));
      }
    };
  }, x.convertCueToDOMTree = function(D, L) {
    return !D || !L ? null : f(D, L);
  };
  var T = 0.05, E = "sans-serif", U = "1.5%";
  return x.processCues = function(D, L, j) {
    if (!D || !L || !j)
      return null;
    for (; j.firstChild; )
      j.removeChild(j.firstChild);
    var C = D.document.createElement("div");
    C.style.position = "absolute", C.style.left = "0", C.style.right = "0", C.style.top = "0", C.style.bottom = "0", C.style.margin = U, j.appendChild(C);
    function k(q) {
      for (var Y = 0; Y < q.length; Y++)
        if (q[Y].hasBeenReset || !q[Y].displayState)
          return !0;
      return !1;
    }
    if (!k(L)) {
      for (var I = 0; I < L.length; I++)
        C.appendChild(L[I].displayState);
      return;
    }
    var $ = [], W = v.getSimpleBoxPosition(C), B = Math.round(W.height * T * 100) / 100, z = {
      font: B + "px " + E
    };
    (function() {
      for (var q, Y, H = 0; H < L.length; H++)
        Y = L[H], q = new g(D, Y, z), C.appendChild(q.div), _(D, q, W, $), Y.displayState = q.div, $.push(v.getSimpleBoxPosition(q));
    })();
  }, x.Parser = function(D, L, j) {
    j || (j = L, L = {}), L || (L = {}), this.window = D, this.vttjs = L, this.state = "INITIAL", this.buffer = "", this.decoder = j || new TextDecoder("utf8"), this.regionList = [];
  }, x.Parser.prototype = {
    // If the error is a ParsingError then report it to the consumer if
    // possible. If it's not a ParsingError then throw it like normal.
    reportOrThrowError: function(D) {
      if (D instanceof t)
        this.onparsingerror && this.onparsingerror(D);
      else
        throw D;
    },
    parse: function(D) {
      var L = this;
      D && (L.buffer += L.decoder.decode(D, { stream: !0 }));
      function j() {
        for (var q = L.buffer, Y = 0; Y < q.length && q[Y] !== "\r" && q[Y] !== `
`; )
          ++Y;
        var H = q.substr(0, Y);
        return q[Y] === "\r" && ++Y, q[Y] === `
` && ++Y, L.buffer = q.substr(Y), H;
      }
      function C(q) {
        var Y = new r();
        if (a(q, function(K, ie) {
          switch (K) {
            case "id":
              Y.set(K, ie);
              break;
            case "width":
              Y.percent(K, ie);
              break;
            case "lines":
              Y.integer(K, ie);
              break;
            case "regionanchor":
            case "viewportanchor":
              var ge = ie.split(",");
              if (ge.length !== 2)
                break;
              var pe = new r();
              if (pe.percent("x", ge[0]), pe.percent("y", ge[1]), !pe.has("x") || !pe.has("y"))
                break;
              Y.set(K + "X", pe.get("x")), Y.set(K + "Y", pe.get("y"));
              break;
            case "scroll":
              Y.alt(K, ie, ["up"]);
              break;
          }
        }, /=/, /\s/), Y.has("id")) {
          var H = new (L.vttjs.VTTRegion || L.window.VTTRegion)();
          H.width = Y.get("width", 100), H.lines = Y.get("lines", 3), H.regionAnchorX = Y.get("regionanchorX", 0), H.regionAnchorY = Y.get("regionanchorY", 100), H.viewportAnchorX = Y.get("viewportanchorX", 0), H.viewportAnchorY = Y.get("viewportanchorY", 100), H.scroll = Y.get("scroll", ""), L.onregion && L.onregion(H), L.regionList.push({
            id: Y.get("id"),
            region: H
          });
        }
      }
      function k(q) {
        var Y = new r();
        a(q, function(H, K) {
          switch (H) {
            case "MPEGT":
              Y.integer(H + "S", K);
              break;
            case "LOCA":
              Y.set(H + "L", i(K));
              break;
          }
        }, /[^\d]:/, /,/), L.ontimestampmap && L.ontimestampmap({
          MPEGTS: Y.get("MPEGTS"),
          LOCAL: Y.get("LOCAL")
        });
      }
      function I(q) {
        q.match(/X-TIMESTAMP-MAP/) ? a(q, function(Y, H) {
          switch (Y) {
            case "X-TIMESTAMP-MAP":
              k(H);
              break;
          }
        }, /=/) : a(q, function(Y, H) {
          switch (Y) {
            case "Region":
              C(H);
              break;
          }
        }, /:/);
      }
      try {
        var $;
        if (L.state === "INITIAL") {
          if (!/\r\n|\n/.test(L.buffer))
            return this;
          $ = j();
          var W = $.match(/^WEBVTT([ \t].*)?$/);
          if (!W || !W[0])
            throw new t(t.Errors.BadSignature);
          L.state = "HEADER";
        }
        for (var B = !1; L.buffer; ) {
          if (!/\r\n|\n/.test(L.buffer))
            return this;
          switch (B ? B = !1 : $ = j(), L.state) {
            case "HEADER":
              /:/.test($) ? I($) : $ || (L.state = "ID");
              continue;
            case "NOTE":
              $ || (L.state = "ID");
              continue;
            case "ID":
              if (/^NOTE($|[ \t])/.test($)) {
                L.state = "NOTE";
                break;
              }
              if (!$)
                continue;
              L.cue = new (L.vttjs.VTTCue || L.window.VTTCue)(0, 0, "");
              try {
                L.cue.align = "center";
              } catch {
                L.cue.align = "middle";
              }
              if (L.state = "CUE", $.indexOf("-->") === -1) {
                L.cue.id = $;
                continue;
              }
            // Process line as start of a cue.
            /*falls through*/
            case "CUE":
              try {
                s($, L.cue, L.regionList);
              } catch (q) {
                L.reportOrThrowError(q), L.cue = null, L.state = "BADCUE";
                continue;
              }
              L.state = "CUETEXT";
              continue;
            case "CUETEXT":
              var z = $.indexOf("-->") !== -1;
              if (!$ || z && (B = !0)) {
                L.oncue && L.oncue(L.cue), L.cue = null, L.state = "ID";
                continue;
              }
              L.cue.text && (L.cue.text += `
`), L.cue.text += $.replace(/\u2028/g, `
`).replace(/u2029/g, `
`);
              continue;
            case "BADCUE":
              $ || (L.state = "ID");
              continue;
          }
        }
      } catch (q) {
        L.reportOrThrowError(q), L.state === "CUETEXT" && L.cue && L.oncue && L.oncue(L.cue), L.cue = null, L.state = L.state === "INITIAL" ? "BADWEBVTT" : "BADCUE";
      }
      return this;
    },
    flush: function() {
      var D = this;
      try {
        if (D.buffer += D.decoder.decode(), (D.cue || D.state === "HEADER") && (D.buffer += `

`, D.parse()), D.state === "INITIAL")
          throw new t(t.Errors.BadSignature);
      } catch (L) {
        D.reportOrThrowError(L);
      }
      return D.onflush && D.onflush(), this;
    }
  }, hp = x, hp;
}
var pp, j2;
function HI() {
  if (j2) return pp;
  j2 = 1;
  var n = "auto", e = {
    "": 1,
    lr: 1,
    rl: 1
  }, t = {
    start: 1,
    center: 1,
    end: 1,
    left: 1,
    right: 1,
    auto: 1,
    "line-left": 1,
    "line-right": 1
  };
  function i(s) {
    if (typeof s != "string")
      return !1;
    var o = e[s.toLowerCase()];
    return o ? s.toLowerCase() : !1;
  }
  function r(s) {
    if (typeof s != "string")
      return !1;
    var o = t[s.toLowerCase()];
    return o ? s.toLowerCase() : !1;
  }
  function a(s, o, u) {
    this.hasBeenReset = !1;
    var c = "", l = !1, h = s, f = o, d = u, y = null, m = "", b = !0, p = "auto", g = "start", v = "auto", _ = "auto", x = 100, T = "center";
    Object.defineProperties(this, {
      id: {
        enumerable: !0,
        get: function() {
          return c;
        },
        set: function(E) {
          c = "" + E;
        }
      },
      pauseOnExit: {
        enumerable: !0,
        get: function() {
          return l;
        },
        set: function(E) {
          l = !!E;
        }
      },
      startTime: {
        enumerable: !0,
        get: function() {
          return h;
        },
        set: function(E) {
          if (typeof E != "number")
            throw new TypeError("Start time must be set to a number.");
          h = E, this.hasBeenReset = !0;
        }
      },
      endTime: {
        enumerable: !0,
        get: function() {
          return f;
        },
        set: function(E) {
          if (typeof E != "number")
            throw new TypeError("End time must be set to a number.");
          f = E, this.hasBeenReset = !0;
        }
      },
      text: {
        enumerable: !0,
        get: function() {
          return d;
        },
        set: function(E) {
          d = "" + E, this.hasBeenReset = !0;
        }
      },
      region: {
        enumerable: !0,
        get: function() {
          return y;
        },
        set: function(E) {
          y = E, this.hasBeenReset = !0;
        }
      },
      vertical: {
        enumerable: !0,
        get: function() {
          return m;
        },
        set: function(E) {
          var U = i(E);
          if (U === !1)
            throw new SyntaxError("Vertical: an invalid or illegal direction string was specified.");
          m = U, this.hasBeenReset = !0;
        }
      },
      snapToLines: {
        enumerable: !0,
        get: function() {
          return b;
        },
        set: function(E) {
          b = !!E, this.hasBeenReset = !0;
        }
      },
      line: {
        enumerable: !0,
        get: function() {
          return p;
        },
        set: function(E) {
          if (typeof E != "number" && E !== n)
            throw new SyntaxError("Line: an invalid number or illegal string was specified.");
          p = E, this.hasBeenReset = !0;
        }
      },
      lineAlign: {
        enumerable: !0,
        get: function() {
          return g;
        },
        set: function(E) {
          var U = r(E);
          U ? (g = U, this.hasBeenReset = !0) : console.warn("lineAlign: an invalid or illegal string was specified.");
        }
      },
      position: {
        enumerable: !0,
        get: function() {
          return v;
        },
        set: function(E) {
          if (E < 0 || E > 100)
            throw new Error("Position must be between 0 and 100.");
          v = E, this.hasBeenReset = !0;
        }
      },
      positionAlign: {
        enumerable: !0,
        get: function() {
          return _;
        },
        set: function(E) {
          var U = r(E);
          U ? (_ = U, this.hasBeenReset = !0) : console.warn("positionAlign: an invalid or illegal string was specified.");
        }
      },
      size: {
        enumerable: !0,
        get: function() {
          return x;
        },
        set: function(E) {
          if (E < 0 || E > 100)
            throw new Error("Size must be between 0 and 100.");
          x = E, this.hasBeenReset = !0;
        }
      },
      align: {
        enumerable: !0,
        get: function() {
          return T;
        },
        set: function(E) {
          var U = r(E);
          if (!U)
            throw new SyntaxError("align: an invalid or illegal alignment string was specified.");
          T = U, this.hasBeenReset = !0;
        }
      }
    }), this.displayState = void 0;
  }
  return a.prototype.getCueAsHTML = function() {
    return WebVTT.convertCueToDOMTree(window, this.text);
  }, pp = a, pp;
}
var mp, q2;
function zI() {
  if (q2) return mp;
  q2 = 1;
  var n = {
    "": !0,
    up: !0
  };
  function e(r) {
    if (typeof r != "string")
      return !1;
    var a = n[r.toLowerCase()];
    return a ? r.toLowerCase() : !1;
  }
  function t(r) {
    return typeof r == "number" && r >= 0 && r <= 100;
  }
  function i() {
    var r = 100, a = 3, s = 0, o = 100, u = 0, c = 100, l = "";
    Object.defineProperties(this, {
      width: {
        enumerable: !0,
        get: function() {
          return r;
        },
        set: function(h) {
          if (!t(h))
            throw new Error("Width must be between 0 and 100.");
          r = h;
        }
      },
      lines: {
        enumerable: !0,
        get: function() {
          return a;
        },
        set: function(h) {
          if (typeof h != "number")
            throw new TypeError("Lines must be set to a number.");
          a = h;
        }
      },
      regionAnchorY: {
        enumerable: !0,
        get: function() {
          return o;
        },
        set: function(h) {
          if (!t(h))
            throw new Error("RegionAnchorX must be between 0 and 100.");
          o = h;
        }
      },
      regionAnchorX: {
        enumerable: !0,
        get: function() {
          return s;
        },
        set: function(h) {
          if (!t(h))
            throw new Error("RegionAnchorY must be between 0 and 100.");
          s = h;
        }
      },
      viewportAnchorY: {
        enumerable: !0,
        get: function() {
          return c;
        },
        set: function(h) {
          if (!t(h))
            throw new Error("ViewportAnchorY must be between 0 and 100.");
          c = h;
        }
      },
      viewportAnchorX: {
        enumerable: !0,
        get: function() {
          return u;
        },
        set: function(h) {
          if (!t(h))
            throw new Error("ViewportAnchorX must be between 0 and 100.");
          u = h;
        }
      },
      scroll: {
        enumerable: !0,
        get: function() {
          return l;
        },
        set: function(h) {
          var f = e(h);
          f === !1 ? console.warn("Scroll: an invalid or illegal string was specified.") : l = f;
        }
      }
    });
  }
  return mp = i, mp;
}
var W2;
function $I() {
  if (W2) return fp.exports;
  W2 = 1;
  var n = cl(), e = fp.exports = {
    WebVTT: VI(),
    VTTCue: HI(),
    VTTRegion: zI()
  };
  n.vttjs = e, n.WebVTT = e.WebVTT;
  var t = e.VTTCue, i = e.VTTRegion, r = n.VTTCue, a = n.VTTRegion;
  return e.shim = function() {
    n.VTTCue = t, n.VTTRegion = i;
  }, e.restore = function() {
    n.VTTCue = r, n.VTTRegion = a;
  }, n.VTTCue || e.shim(), fp.exports;
}
var GI = $I();
const V2 = /* @__PURE__ */ Qt(GI);
function Lt() {
  return Lt = Object.assign ? Object.assign.bind() : function(n) {
    for (var e = 1; e < arguments.length; e++) {
      var t = arguments[e];
      for (var i in t) ({}).hasOwnProperty.call(t, i) && (n[i] = t[i]);
    }
    return n;
  }, Lt.apply(null, arguments);
}
var H2 = "https://example.com", XI = function(e, t) {
  if (/^[a-z]+:/i.test(t))
    return t;
  /^data:/.test(e) && (e = me.location && me.location.href || "");
  var i = /^\/\//.test(e), r = !me.location && !/\/\//i.test(e);
  e = new me.URL(e, me.location || H2);
  var a = new URL(t, e);
  return r ? a.href.slice(H2.length) : i ? a.href.slice(a.protocol.length) : a.href;
}, Hg = /* @__PURE__ */ (function() {
  function n() {
    this.listeners = {};
  }
  var e = n.prototype;
  return e.on = function(i, r) {
    this.listeners[i] || (this.listeners[i] = []), this.listeners[i].push(r);
  }, e.off = function(i, r) {
    if (!this.listeners[i])
      return !1;
    var a = this.listeners[i].indexOf(r);
    return this.listeners[i] = this.listeners[i].slice(0), this.listeners[i].splice(a, 1), a > -1;
  }, e.trigger = function(i) {
    var r = this.listeners[i];
    if (r)
      if (arguments.length === 2)
        for (var a = r.length, s = 0; s < a; ++s)
          r[s].call(this, arguments[1]);
      else
        for (var o = Array.prototype.slice.call(arguments, 1), u = r.length, c = 0; c < u; ++c)
          r[c].apply(this, o);
  }, e.dispose = function() {
    this.listeners = {};
  }, e.pipe = function(i) {
    this.on("data", function(r) {
      i.push(r);
    });
  }, n;
})(), KI = function(e) {
  return me.atob ? me.atob(e) : Buffer.from(e, "base64").toString("binary");
};
function YI(n) {
  for (var e = KI(n), t = new Uint8Array(e.length), i = 0; i < e.length; i++)
    t[i] = e.charCodeAt(i);
  return t;
}
/*! @name m3u8-parser @version 7.2.0 @license Apache-2.0 */
class QI extends Hg {
  constructor() {
    super(), this.buffer = "";
  }
  /**
   * Add new data to be parsed.
   *
   * @param {string} data the text to process
   */
  push(e) {
    let t;
    for (this.buffer += e, t = this.buffer.indexOf(`
`); t > -1; t = this.buffer.indexOf(`
`))
      this.trigger("data", this.buffer.substring(0, t)), this.buffer = this.buffer.substring(t + 1);
  }
}
const ZI = "	", gp = function(n) {
  const e = /([0-9.]*)?@?([0-9.]*)?/.exec(n || ""), t = {};
  return e[1] && (t.length = parseInt(e[1], 10)), e[2] && (t.offset = parseInt(e[2], 10)), t;
}, JI = function() {
  const t = "(?:" + "[^=]*" + ")=(?:" + '"[^"]*"|[^,]*' + ")";
  return new RegExp("(?:^|,)(" + t + ")");
}, an = function(n) {
  const e = {};
  if (!n)
    return e;
  const t = n.split(JI());
  let i = t.length, r;
  for (; i--; )
    t[i] !== "" && (r = /([^=]*)=(.*)/.exec(t[i]).slice(1), r[0] = r[0].replace(/^\s+|\s+$/g, ""), r[1] = r[1].replace(/^\s+|\s+$/g, ""), r[1] = r[1].replace(/^['"](.*)['"]$/g, "$1"), e[r[0]] = r[1]);
  return e;
}, z2 = (n) => {
  const e = n.split("x"), t = {};
  return e[0] && (t.width = parseInt(e[0], 10)), e[1] && (t.height = parseInt(e[1], 10)), t;
};
class eU extends Hg {
  constructor() {
    super(), this.customParsers = [], this.tagMappers = [];
  }
  /**
   * Parses an additional line of input.
   *
   * @param {string} line a single line of an M3U8 file to parse
   */
  push(e) {
    let t, i;
    if (e = e.trim(), e.length === 0)
      return;
    if (e[0] !== "#") {
      this.trigger("data", {
        type: "uri",
        uri: e
      });
      return;
    }
    this.tagMappers.reduce((a, s) => {
      const o = s(e);
      return o === e ? a : a.concat([o]);
    }, [e]).forEach((a) => {
      for (let s = 0; s < this.customParsers.length; s++)
        if (this.customParsers[s].call(this, a))
          return;
      if (a.indexOf("#EXT") !== 0) {
        this.trigger("data", {
          type: "comment",
          text: a.slice(1)
        });
        return;
      }
      if (a = a.replace("\r", ""), t = /^#EXTM3U/.exec(a), t) {
        this.trigger("data", {
          type: "tag",
          tagType: "m3u"
        });
        return;
      }
      if (t = /^#EXTINF:([0-9\.]*)?,?(.*)?$/.exec(a), t) {
        i = {
          type: "tag",
          tagType: "inf"
        }, t[1] && (i.duration = parseFloat(t[1])), t[2] && (i.title = t[2]), this.trigger("data", i);
        return;
      }
      if (t = /^#EXT-X-TARGETDURATION:([0-9.]*)?/.exec(a), t) {
        i = {
          type: "tag",
          tagType: "targetduration"
        }, t[1] && (i.duration = parseInt(t[1], 10)), this.trigger("data", i);
        return;
      }
      if (t = /^#EXT-X-VERSION:([0-9.]*)?/.exec(a), t) {
        i = {
          type: "tag",
          tagType: "version"
        }, t[1] && (i.version = parseInt(t[1], 10)), this.trigger("data", i);
        return;
      }
      if (t = /^#EXT-X-MEDIA-SEQUENCE:(\-?[0-9.]*)?/.exec(a), t) {
        i = {
          type: "tag",
          tagType: "media-sequence"
        }, t[1] && (i.number = parseInt(t[1], 10)), this.trigger("data", i);
        return;
      }
      if (t = /^#EXT-X-DISCONTINUITY-SEQUENCE:(\-?[0-9.]*)?/.exec(a), t) {
        i = {
          type: "tag",
          tagType: "discontinuity-sequence"
        }, t[1] && (i.number = parseInt(t[1], 10)), this.trigger("data", i);
        return;
      }
      if (t = /^#EXT-X-PLAYLIST-TYPE:(.*)?$/.exec(a), t) {
        i = {
          type: "tag",
          tagType: "playlist-type"
        }, t[1] && (i.playlistType = t[1]), this.trigger("data", i);
        return;
      }
      if (t = /^#EXT-X-BYTERANGE:(.*)?$/.exec(a), t) {
        i = Lt(gp(t[1]), {
          type: "tag",
          tagType: "byterange"
        }), this.trigger("data", i);
        return;
      }
      if (t = /^#EXT-X-ALLOW-CACHE:(YES|NO)?/.exec(a), t) {
        i = {
          type: "tag",
          tagType: "allow-cache"
        }, t[1] && (i.allowed = !/NO/.test(t[1])), this.trigger("data", i);
        return;
      }
      if (t = /^#EXT-X-MAP:(.*)$/.exec(a), t) {
        if (i = {
          type: "tag",
          tagType: "map"
        }, t[1]) {
          const s = an(t[1]);
          s.URI && (i.uri = s.URI), s.BYTERANGE && (i.byterange = gp(s.BYTERANGE));
        }
        this.trigger("data", i);
        return;
      }
      if (t = /^#EXT-X-STREAM-INF:(.*)$/.exec(a), t) {
        i = {
          type: "tag",
          tagType: "stream-inf"
        }, t[1] && (i.attributes = an(t[1]), i.attributes.RESOLUTION && (i.attributes.RESOLUTION = z2(i.attributes.RESOLUTION)), i.attributes.BANDWIDTH && (i.attributes.BANDWIDTH = parseInt(i.attributes.BANDWIDTH, 10)), i.attributes["FRAME-RATE"] && (i.attributes["FRAME-RATE"] = parseFloat(i.attributes["FRAME-RATE"])), i.attributes["PROGRAM-ID"] && (i.attributes["PROGRAM-ID"] = parseInt(i.attributes["PROGRAM-ID"], 10))), this.trigger("data", i);
        return;
      }
      if (t = /^#EXT-X-MEDIA:(.*)$/.exec(a), t) {
        i = {
          type: "tag",
          tagType: "media"
        }, t[1] && (i.attributes = an(t[1])), this.trigger("data", i);
        return;
      }
      if (t = /^#EXT-X-ENDLIST/.exec(a), t) {
        this.trigger("data", {
          type: "tag",
          tagType: "endlist"
        });
        return;
      }
      if (t = /^#EXT-X-DISCONTINUITY/.exec(a), t) {
        this.trigger("data", {
          type: "tag",
          tagType: "discontinuity"
        });
        return;
      }
      if (t = /^#EXT-X-PROGRAM-DATE-TIME:(.*)$/.exec(a), t) {
        i = {
          type: "tag",
          tagType: "program-date-time"
        }, t[1] && (i.dateTimeString = t[1], i.dateTimeObject = new Date(t[1])), this.trigger("data", i);
        return;
      }
      if (t = /^#EXT-X-KEY:(.*)$/.exec(a), t) {
        i = {
          type: "tag",
          tagType: "key"
        }, t[1] && (i.attributes = an(t[1]), i.attributes.IV && (i.attributes.IV.substring(0, 2).toLowerCase() === "0x" && (i.attributes.IV = i.attributes.IV.substring(2)), i.attributes.IV = i.attributes.IV.match(/.{8}/g), i.attributes.IV[0] = parseInt(i.attributes.IV[0], 16), i.attributes.IV[1] = parseInt(i.attributes.IV[1], 16), i.attributes.IV[2] = parseInt(i.attributes.IV[2], 16), i.attributes.IV[3] = parseInt(i.attributes.IV[3], 16), i.attributes.IV = new Uint32Array(i.attributes.IV))), this.trigger("data", i);
        return;
      }
      if (t = /^#EXT-X-START:(.*)$/.exec(a), t) {
        i = {
          type: "tag",
          tagType: "start"
        }, t[1] && (i.attributes = an(t[1]), i.attributes["TIME-OFFSET"] = parseFloat(i.attributes["TIME-OFFSET"]), i.attributes.PRECISE = /YES/.test(i.attributes.PRECISE)), this.trigger("data", i);
        return;
      }
      if (t = /^#EXT-X-CUE-OUT-CONT:(.*)?$/.exec(a), t) {
        i = {
          type: "tag",
          tagType: "cue-out-cont"
        }, t[1] ? i.data = t[1] : i.data = "", this.trigger("data", i);
        return;
      }
      if (t = /^#EXT-X-CUE-OUT:(.*)?$/.exec(a), t) {
        i = {
          type: "tag",
          tagType: "cue-out"
        }, t[1] ? i.data = t[1] : i.data = "", this.trigger("data", i);
        return;
      }
      if (t = /^#EXT-X-CUE-IN:?(.*)?$/.exec(a), t) {
        i = {
          type: "tag",
          tagType: "cue-in"
        }, t[1] ? i.data = t[1] : i.data = "", this.trigger("data", i);
        return;
      }
      if (t = /^#EXT-X-SKIP:(.*)$/.exec(a), t && t[1]) {
        i = {
          type: "tag",
          tagType: "skip"
        }, i.attributes = an(t[1]), i.attributes.hasOwnProperty("SKIPPED-SEGMENTS") && (i.attributes["SKIPPED-SEGMENTS"] = parseInt(i.attributes["SKIPPED-SEGMENTS"], 10)), i.attributes.hasOwnProperty("RECENTLY-REMOVED-DATERANGES") && (i.attributes["RECENTLY-REMOVED-DATERANGES"] = i.attributes["RECENTLY-REMOVED-DATERANGES"].split(ZI)), this.trigger("data", i);
        return;
      }
      if (t = /^#EXT-X-PART:(.*)$/.exec(a), t && t[1]) {
        i = {
          type: "tag",
          tagType: "part"
        }, i.attributes = an(t[1]), ["DURATION"].forEach(function(s) {
          i.attributes.hasOwnProperty(s) && (i.attributes[s] = parseFloat(i.attributes[s]));
        }), ["INDEPENDENT", "GAP"].forEach(function(s) {
          i.attributes.hasOwnProperty(s) && (i.attributes[s] = /YES/.test(i.attributes[s]));
        }), i.attributes.hasOwnProperty("BYTERANGE") && (i.attributes.byterange = gp(i.attributes.BYTERANGE)), this.trigger("data", i);
        return;
      }
      if (t = /^#EXT-X-SERVER-CONTROL:(.*)$/.exec(a), t && t[1]) {
        i = {
          type: "tag",
          tagType: "server-control"
        }, i.attributes = an(t[1]), ["CAN-SKIP-UNTIL", "PART-HOLD-BACK", "HOLD-BACK"].forEach(function(s) {
          i.attributes.hasOwnProperty(s) && (i.attributes[s] = parseFloat(i.attributes[s]));
        }), ["CAN-SKIP-DATERANGES", "CAN-BLOCK-RELOAD"].forEach(function(s) {
          i.attributes.hasOwnProperty(s) && (i.attributes[s] = /YES/.test(i.attributes[s]));
        }), this.trigger("data", i);
        return;
      }
      if (t = /^#EXT-X-PART-INF:(.*)$/.exec(a), t && t[1]) {
        i = {
          type: "tag",
          tagType: "part-inf"
        }, i.attributes = an(t[1]), ["PART-TARGET"].forEach(function(s) {
          i.attributes.hasOwnProperty(s) && (i.attributes[s] = parseFloat(i.attributes[s]));
        }), this.trigger("data", i);
        return;
      }
      if (t = /^#EXT-X-PRELOAD-HINT:(.*)$/.exec(a), t && t[1]) {
        i = {
          type: "tag",
          tagType: "preload-hint"
        }, i.attributes = an(t[1]), ["BYTERANGE-START", "BYTERANGE-LENGTH"].forEach(function(s) {
          if (i.attributes.hasOwnProperty(s)) {
            i.attributes[s] = parseInt(i.attributes[s], 10);
            const o = s === "BYTERANGE-LENGTH" ? "length" : "offset";
            i.attributes.byterange = i.attributes.byterange || {}, i.attributes.byterange[o] = i.attributes[s], delete i.attributes[s];
          }
        }), this.trigger("data", i);
        return;
      }
      if (t = /^#EXT-X-RENDITION-REPORT:(.*)$/.exec(a), t && t[1]) {
        i = {
          type: "tag",
          tagType: "rendition-report"
        }, i.attributes = an(t[1]), ["LAST-MSN", "LAST-PART"].forEach(function(s) {
          i.attributes.hasOwnProperty(s) && (i.attributes[s] = parseInt(i.attributes[s], 10));
        }), this.trigger("data", i);
        return;
      }
      if (t = /^#EXT-X-DATERANGE:(.*)$/.exec(a), t && t[1]) {
        i = {
          type: "tag",
          tagType: "daterange"
        }, i.attributes = an(t[1]), ["ID", "CLASS"].forEach(function(o) {
          i.attributes.hasOwnProperty(o) && (i.attributes[o] = String(i.attributes[o]));
        }), ["START-DATE", "END-DATE"].forEach(function(o) {
          i.attributes.hasOwnProperty(o) && (i.attributes[o] = new Date(i.attributes[o]));
        }), ["DURATION", "PLANNED-DURATION"].forEach(function(o) {
          i.attributes.hasOwnProperty(o) && (i.attributes[o] = parseFloat(i.attributes[o]));
        }), ["END-ON-NEXT"].forEach(function(o) {
          i.attributes.hasOwnProperty(o) && (i.attributes[o] = /YES/i.test(i.attributes[o]));
        }), ["SCTE35-CMD", " SCTE35-OUT", "SCTE35-IN"].forEach(function(o) {
          i.attributes.hasOwnProperty(o) && (i.attributes[o] = i.attributes[o].toString(16));
        });
        const s = /^X-([A-Z]+-)+[A-Z]+$/;
        for (const o in i.attributes) {
          if (!s.test(o))
            continue;
          const u = /[0-9A-Fa-f]{6}/g.test(i.attributes[o]), c = /^\d+(\.\d+)?$/.test(i.attributes[o]);
          i.attributes[o] = u ? i.attributes[o].toString(16) : c ? parseFloat(i.attributes[o]) : String(i.attributes[o]);
        }
        this.trigger("data", i);
        return;
      }
      if (t = /^#EXT-X-INDEPENDENT-SEGMENTS/.exec(a), t) {
        this.trigger("data", {
          type: "tag",
          tagType: "independent-segments"
        });
        return;
      }
      if (t = /^#EXT-X-I-FRAMES-ONLY/.exec(a), t) {
        this.trigger("data", {
          type: "tag",
          tagType: "i-frames-only"
        });
        return;
      }
      if (t = /^#EXT-X-CONTENT-STEERING:(.*)$/.exec(a), t) {
        i = {
          type: "tag",
          tagType: "content-steering"
        }, i.attributes = an(t[1]), this.trigger("data", i);
        return;
      }
      if (t = /^#EXT-X-I-FRAME-STREAM-INF:(.*)$/.exec(a), t) {
        i = {
          type: "tag",
          tagType: "i-frame-playlist"
        }, i.attributes = an(t[1]), i.attributes.URI && (i.uri = i.attributes.URI), i.attributes.BANDWIDTH && (i.attributes.BANDWIDTH = parseInt(i.attributes.BANDWIDTH, 10)), i.attributes.RESOLUTION && (i.attributes.RESOLUTION = z2(i.attributes.RESOLUTION)), i.attributes["AVERAGE-BANDWIDTH"] && (i.attributes["AVERAGE-BANDWIDTH"] = parseInt(i.attributes["AVERAGE-BANDWIDTH"], 10)), i.attributes["FRAME-RATE"] && (i.attributes["FRAME-RATE"] = parseFloat(i.attributes["FRAME-RATE"])), this.trigger("data", i);
        return;
      }
      if (t = /^#EXT-X-DEFINE:(.*)$/.exec(a), t) {
        i = {
          type: "tag",
          tagType: "define"
        }, i.attributes = an(t[1]), this.trigger("data", i);
        return;
      }
      this.trigger("data", {
        type: "tag",
        data: a.slice(4)
      });
    });
  }
  /**
   * Add a parser for custom headers
   *
   * @param {Object}   options              a map of options for the added parser
   * @param {RegExp}   options.expression   a regular expression to match the custom header
   * @param {string}   options.customType   the custom type to register to the output
   * @param {Function} [options.dataParser] function to parse the line into an object
   * @param {boolean}  [options.segment]    should tag data be attached to the segment object
   */
  addParser({
    expression: e,
    customType: t,
    dataParser: i,
    segment: r
  }) {
    typeof i != "function" && (i = (a) => a), this.customParsers.push((a) => {
      if (e.exec(a))
        return this.trigger("data", {
          type: "custom",
          data: i(a),
          customType: t,
          segment: r
        }), !0;
    });
  }
  /**
   * Add a custom header mapper
   *
   * @param {Object}   options
   * @param {RegExp}   options.expression   a regular expression to match the custom header
   * @param {Function} options.map          function to translate tag into a different tag
   */
  addTagMapper({
    expression: e,
    map: t
  }) {
    const i = (r) => e.test(r) ? t(r) : r;
    this.tagMappers.push(i);
  }
}
const tU = (n) => n.toLowerCase().replace(/-(\w)/g, (e) => e[1].toUpperCase()), zi = function(n) {
  const e = {};
  return Object.keys(n).forEach(function(t) {
    e[tU(t)] = n[t];
  }), e;
}, bp = function(n) {
  const {
    serverControl: e,
    targetDuration: t,
    partTargetDuration: i
  } = n;
  if (!e)
    return;
  const r = "#EXT-X-SERVER-CONTROL", a = "holdBack", s = "partHoldBack", o = t && t * 3, u = i && i * 2;
  t && !e.hasOwnProperty(a) && (e[a] = o, this.trigger("info", {
    message: `${r} defaulting HOLD-BACK to targetDuration * 3 (${o}).`
  })), o && e[a] < o && (this.trigger("warn", {
    message: `${r} clamping HOLD-BACK (${e[a]}) to targetDuration * 3 (${o})`
  }), e[a] = o), i && !e.hasOwnProperty(s) && (e[s] = i * 3, this.trigger("info", {
    message: `${r} defaulting PART-HOLD-BACK to partTargetDuration * 3 (${e[s]}).`
  })), i && e[s] < u && (this.trigger("warn", {
    message: `${r} clamping PART-HOLD-BACK (${e[s]}) to partTargetDuration * 2 (${u}).`
  }), e[s] = u);
};
class nU extends Hg {
  constructor(e = {}) {
    super(), this.lineStream = new QI(), this.parseStream = new eU(), this.lineStream.pipe(this.parseStream), this.mainDefinitions = e.mainDefinitions || {}, this.params = new URL(e.uri, "https://a.com").searchParams, this.lastProgramDateTime = null;
    const t = this, i = [];
    let r = {}, a, s, o = !1;
    const u = function() {
    }, c = {
      AUDIO: {},
      VIDEO: {},
      "CLOSED-CAPTIONS": {},
      SUBTITLES: {}
    }, l = "urn:uuid:edef8ba9-79d6-4ace-a3c8-27dcd51d21ed";
    let h = 0;
    this.manifest = {
      allowCache: !0,
      discontinuityStarts: [],
      dateRanges: [],
      iFramePlaylists: [],
      segments: []
    };
    let f = 0, d = 0;
    const y = {};
    this.on("end", () => {
      r.uri || !r.parts && !r.preloadHints || (!r.map && a && (r.map = a), !r.key && s && (r.key = s), !r.timeline && typeof h == "number" && (r.timeline = h), this.manifest.preloadSegment = r);
    }), this.parseStream.on("data", function(m) {
      let b, p;
      if (t.manifest.definitions) {
        for (const g in t.manifest.definitions)
          if (m.uri && (m.uri = m.uri.replace(`{$${g}}`, t.manifest.definitions[g])), m.attributes)
            for (const v in m.attributes)
              typeof m.attributes[v] == "string" && (m.attributes[v] = m.attributes[v].replace(`{$${g}}`, t.manifest.definitions[g]));
      }
      ({
        tag() {
          ({
            version() {
              m.version && (this.manifest.version = m.version);
            },
            "allow-cache"() {
              this.manifest.allowCache = m.allowed, "allowed" in m || (this.trigger("info", {
                message: "defaulting allowCache to YES"
              }), this.manifest.allowCache = !0);
            },
            byterange() {
              const g = {};
              "length" in m && (r.byterange = g, g.length = m.length, "offset" in m || (m.offset = f)), "offset" in m && (r.byterange = g, g.offset = m.offset), f = g.offset + g.length;
            },
            endlist() {
              this.manifest.endList = !0;
            },
            inf() {
              "mediaSequence" in this.manifest || (this.manifest.mediaSequence = 0, this.trigger("info", {
                message: "defaulting media sequence to zero"
              })), "discontinuitySequence" in this.manifest || (this.manifest.discontinuitySequence = 0, this.trigger("info", {
                message: "defaulting discontinuity sequence to zero"
              })), m.title && (r.title = m.title), m.duration > 0 && (r.duration = m.duration), m.duration === 0 && (r.duration = 0.01, this.trigger("info", {
                message: "updating zero segment duration to a small value"
              })), this.manifest.segments = i;
            },
            key() {
              if (!m.attributes) {
                this.trigger("warn", {
                  message: "ignoring key declaration without attribute list"
                });
                return;
              }
              if (m.attributes.METHOD === "NONE") {
                s = null;
                return;
              }
              if (!m.attributes.URI) {
                this.trigger("warn", {
                  message: "ignoring key declaration without URI"
                });
                return;
              }
              if (m.attributes.KEYFORMAT === "com.apple.streamingkeydelivery") {
                this.manifest.contentProtection = this.manifest.contentProtection || {}, this.manifest.contentProtection["com.apple.fps.1_0"] = {
                  attributes: m.attributes
                };
                return;
              }
              if (m.attributes.KEYFORMAT === "com.microsoft.playready") {
                this.manifest.contentProtection = this.manifest.contentProtection || {}, this.manifest.contentProtection["com.microsoft.playready"] = {
                  uri: m.attributes.URI
                };
                return;
              }
              if (m.attributes.KEYFORMAT === l) {
                if (["SAMPLE-AES", "SAMPLE-AES-CTR", "SAMPLE-AES-CENC"].indexOf(m.attributes.METHOD) === -1) {
                  this.trigger("warn", {
                    message: "invalid key method provided for Widevine"
                  });
                  return;
                }
                if (m.attributes.METHOD === "SAMPLE-AES-CENC" && this.trigger("warn", {
                  message: "SAMPLE-AES-CENC is deprecated, please use SAMPLE-AES-CTR instead"
                }), m.attributes.URI.substring(0, 23) !== "data:text/plain;base64,") {
                  this.trigger("warn", {
                    message: "invalid key URI provided for Widevine"
                  });
                  return;
                }
                if (!(m.attributes.KEYID && m.attributes.KEYID.substring(0, 2) === "0x")) {
                  this.trigger("warn", {
                    message: "invalid key ID provided for Widevine"
                  });
                  return;
                }
                this.manifest.contentProtection = this.manifest.contentProtection || {}, this.manifest.contentProtection["com.widevine.alpha"] = {
                  attributes: {
                    schemeIdUri: m.attributes.KEYFORMAT,
                    // remove '0x' from the key id string
                    keyId: m.attributes.KEYID.substring(2)
                  },
                  // decode the base64-encoded PSSH box
                  pssh: YI(m.attributes.URI.split(",")[1])
                };
                return;
              }
              m.attributes.METHOD || this.trigger("warn", {
                message: "defaulting key method to AES-128"
              }), s = {
                method: m.attributes.METHOD || "AES-128",
                uri: m.attributes.URI
              }, typeof m.attributes.IV < "u" && (s.iv = m.attributes.IV);
            },
            "media-sequence"() {
              if (!isFinite(m.number)) {
                this.trigger("warn", {
                  message: "ignoring invalid media sequence: " + m.number
                });
                return;
              }
              this.manifest.mediaSequence = m.number;
            },
            "discontinuity-sequence"() {
              if (!isFinite(m.number)) {
                this.trigger("warn", {
                  message: "ignoring invalid discontinuity sequence: " + m.number
                });
                return;
              }
              this.manifest.discontinuitySequence = m.number, h = m.number;
            },
            "playlist-type"() {
              if (!/VOD|EVENT/.test(m.playlistType)) {
                this.trigger("warn", {
                  message: "ignoring unknown playlist type: " + m.playlist
                });
                return;
              }
              this.manifest.playlistType = m.playlistType;
            },
            map() {
              a = {}, m.uri && (a.uri = m.uri), m.byterange && (a.byterange = m.byterange), s && (a.key = s);
            },
            "stream-inf"() {
              if (this.manifest.playlists = i, this.manifest.mediaGroups = this.manifest.mediaGroups || c, !m.attributes) {
                this.trigger("warn", {
                  message: "ignoring empty stream-inf attributes"
                });
                return;
              }
              r.attributes || (r.attributes = {}), Lt(r.attributes, m.attributes);
            },
            media() {
              if (this.manifest.mediaGroups = this.manifest.mediaGroups || c, !(m.attributes && m.attributes.TYPE && m.attributes["GROUP-ID"] && m.attributes.NAME)) {
                this.trigger("warn", {
                  message: "ignoring incomplete or missing media group"
                });
                return;
              }
              const g = this.manifest.mediaGroups[m.attributes.TYPE];
              g[m.attributes["GROUP-ID"]] = g[m.attributes["GROUP-ID"]] || {}, b = g[m.attributes["GROUP-ID"]], p = {
                default: /yes/i.test(m.attributes.DEFAULT)
              }, p.default ? p.autoselect = !0 : p.autoselect = /yes/i.test(m.attributes.AUTOSELECT), m.attributes.LANGUAGE && (p.language = m.attributes.LANGUAGE), m.attributes.URI && (p.uri = m.attributes.URI), m.attributes["INSTREAM-ID"] && (p.instreamId = m.attributes["INSTREAM-ID"]), m.attributes.CHARACTERISTICS && (p.characteristics = m.attributes.CHARACTERISTICS), m.attributes.FORCED && (p.forced = /yes/i.test(m.attributes.FORCED)), b[m.attributes.NAME] = p;
            },
            discontinuity() {
              h += 1, r.discontinuity = !0, this.manifest.discontinuityStarts.push(i.length);
            },
            "program-date-time"() {
              typeof this.manifest.dateTimeString > "u" && (this.manifest.dateTimeString = m.dateTimeString, this.manifest.dateTimeObject = m.dateTimeObject), r.dateTimeString = m.dateTimeString, r.dateTimeObject = m.dateTimeObject;
              const {
                lastProgramDateTime: g
              } = this;
              this.lastProgramDateTime = new Date(m.dateTimeString).getTime(), g === null && this.manifest.segments.reduceRight((v, _) => (_.programDateTime = v - _.duration * 1e3, _.programDateTime), this.lastProgramDateTime);
            },
            targetduration() {
              if (!isFinite(m.duration) || m.duration < 0) {
                this.trigger("warn", {
                  message: "ignoring invalid target duration: " + m.duration
                });
                return;
              }
              this.manifest.targetDuration = m.duration, bp.call(this, this.manifest);
            },
            start() {
              if (!m.attributes || isNaN(m.attributes["TIME-OFFSET"])) {
                this.trigger("warn", {
                  message: "ignoring start declaration without appropriate attribute list"
                });
                return;
              }
              this.manifest.start = {
                timeOffset: m.attributes["TIME-OFFSET"],
                precise: m.attributes.PRECISE
              };
            },
            "cue-out"() {
              r.cueOut = m.data;
            },
            "cue-out-cont"() {
              r.cueOutCont = m.data;
            },
            "cue-in"() {
              r.cueIn = m.data;
            },
            skip() {
              this.manifest.skip = zi(m.attributes), this.warnOnMissingAttributes_("#EXT-X-SKIP", m.attributes, ["SKIPPED-SEGMENTS"]);
            },
            part() {
              o = !0;
              const g = this.manifest.segments.length, v = zi(m.attributes);
              r.parts = r.parts || [], r.parts.push(v), v.byterange && (v.byterange.hasOwnProperty("offset") || (v.byterange.offset = d), d = v.byterange.offset + v.byterange.length);
              const _ = r.parts.length - 1;
              this.warnOnMissingAttributes_(`#EXT-X-PART #${_} for segment #${g}`, m.attributes, ["URI", "DURATION"]), this.manifest.renditionReports && this.manifest.renditionReports.forEach((x, T) => {
                x.hasOwnProperty("lastPart") || this.trigger("warn", {
                  message: `#EXT-X-RENDITION-REPORT #${T} lacks required attribute(s): LAST-PART`
                });
              });
            },
            "server-control"() {
              const g = this.manifest.serverControl = zi(m.attributes);
              g.hasOwnProperty("canBlockReload") || (g.canBlockReload = !1, this.trigger("info", {
                message: "#EXT-X-SERVER-CONTROL defaulting CAN-BLOCK-RELOAD to false"
              })), bp.call(this, this.manifest), g.canSkipDateranges && !g.hasOwnProperty("canSkipUntil") && this.trigger("warn", {
                message: "#EXT-X-SERVER-CONTROL lacks required attribute CAN-SKIP-UNTIL which is required when CAN-SKIP-DATERANGES is set"
              });
            },
            "preload-hint"() {
              const g = this.manifest.segments.length, v = zi(m.attributes), _ = v.type && v.type === "PART";
              r.preloadHints = r.preloadHints || [], r.preloadHints.push(v), v.byterange && (v.byterange.hasOwnProperty("offset") || (v.byterange.offset = _ ? d : 0, _ && (d = v.byterange.offset + v.byterange.length)));
              const x = r.preloadHints.length - 1;
              if (this.warnOnMissingAttributes_(`#EXT-X-PRELOAD-HINT #${x} for segment #${g}`, m.attributes, ["TYPE", "URI"]), !!v.type)
                for (let T = 0; T < r.preloadHints.length - 1; T++) {
                  const E = r.preloadHints[T];
                  E.type && E.type === v.type && this.trigger("warn", {
                    message: `#EXT-X-PRELOAD-HINT #${x} for segment #${g} has the same TYPE ${v.type} as preload hint #${T}`
                  });
                }
            },
            "rendition-report"() {
              const g = zi(m.attributes);
              this.manifest.renditionReports = this.manifest.renditionReports || [], this.manifest.renditionReports.push(g);
              const v = this.manifest.renditionReports.length - 1, _ = ["LAST-MSN", "URI"];
              o && _.push("LAST-PART"), this.warnOnMissingAttributes_(`#EXT-X-RENDITION-REPORT #${v}`, m.attributes, _);
            },
            "part-inf"() {
              this.manifest.partInf = zi(m.attributes), this.warnOnMissingAttributes_("#EXT-X-PART-INF", m.attributes, ["PART-TARGET"]), this.manifest.partInf.partTarget && (this.manifest.partTargetDuration = this.manifest.partInf.partTarget), bp.call(this, this.manifest);
            },
            daterange() {
              this.manifest.dateRanges.push(zi(m.attributes));
              const g = this.manifest.dateRanges.length - 1;
              this.warnOnMissingAttributes_(`#EXT-X-DATERANGE #${g}`, m.attributes, ["ID", "START-DATE"]);
              const v = this.manifest.dateRanges[g];
              v.endDate && v.startDate && new Date(v.endDate) < new Date(v.startDate) && this.trigger("warn", {
                message: "EXT-X-DATERANGE END-DATE must be equal to or later than the value of the START-DATE"
              }), v.duration && v.duration < 0 && this.trigger("warn", {
                message: "EXT-X-DATERANGE DURATION must not be negative"
              }), v.plannedDuration && v.plannedDuration < 0 && this.trigger("warn", {
                message: "EXT-X-DATERANGE PLANNED-DURATION must not be negative"
              });
              const _ = !!v.endOnNext;
              if (_ && !v.class && this.trigger("warn", {
                message: "EXT-X-DATERANGE with an END-ON-NEXT=YES attribute must have a CLASS attribute"
              }), _ && (v.duration || v.endDate) && this.trigger("warn", {
                message: "EXT-X-DATERANGE with an END-ON-NEXT=YES attribute must not contain DURATION or END-DATE attributes"
              }), v.duration && v.endDate) {
                const T = v.startDate.getTime() + v.duration * 1e3;
                this.manifest.dateRanges[g].endDate = new Date(T);
              }
              if (!y[v.id])
                y[v.id] = v;
              else {
                for (const T in y[v.id])
                  if (v[T] && JSON.stringify(y[v.id][T]) !== JSON.stringify(v[T])) {
                    this.trigger("warn", {
                      message: "EXT-X-DATERANGE tags with the same ID in a playlist must have the same attributes values"
                    });
                    break;
                  }
                const x = this.manifest.dateRanges.findIndex((T) => T.id === v.id);
                this.manifest.dateRanges[x] = Lt(this.manifest.dateRanges[x], v), y[v.id] = Lt(y[v.id], v), this.manifest.dateRanges.pop();
              }
            },
            "independent-segments"() {
              this.manifest.independentSegments = !0;
            },
            "i-frames-only"() {
              this.manifest.iFramesOnly = !0, this.requiredCompatibilityversion(this.manifest.version, 4);
            },
            "content-steering"() {
              this.manifest.contentSteering = zi(m.attributes), this.warnOnMissingAttributes_("#EXT-X-CONTENT-STEERING", m.attributes, ["SERVER-URI"]);
            },
            /** @this {Parser} */
            define() {
              this.manifest.definitions = this.manifest.definitions || {};
              const g = (v, _) => {
                if (v in this.manifest.definitions) {
                  this.trigger("error", {
                    message: `EXT-X-DEFINE: Duplicate name ${v}`
                  });
                  return;
                }
                this.manifest.definitions[v] = _;
              };
              if ("QUERYPARAM" in m.attributes) {
                if ("NAME" in m.attributes || "IMPORT" in m.attributes) {
                  this.trigger("error", {
                    message: "EXT-X-DEFINE: Invalid attributes"
                  });
                  return;
                }
                const v = this.params.get(m.attributes.QUERYPARAM);
                if (!v) {
                  this.trigger("error", {
                    message: `EXT-X-DEFINE: No query param ${m.attributes.QUERYPARAM}`
                  });
                  return;
                }
                g(m.attributes.QUERYPARAM, decodeURIComponent(v));
                return;
              }
              if ("NAME" in m.attributes) {
                if ("IMPORT" in m.attributes) {
                  this.trigger("error", {
                    message: "EXT-X-DEFINE: Invalid attributes"
                  });
                  return;
                }
                if (!("VALUE" in m.attributes) || typeof m.attributes.VALUE != "string") {
                  this.trigger("error", {
                    message: `EXT-X-DEFINE: No value for ${m.attributes.NAME}`
                  });
                  return;
                }
                g(m.attributes.NAME, m.attributes.VALUE);
                return;
              }
              if ("IMPORT" in m.attributes) {
                if (!this.mainDefinitions[m.attributes.IMPORT]) {
                  this.trigger("error", {
                    message: `EXT-X-DEFINE: No value ${m.attributes.IMPORT} to import, or IMPORT used on main playlist`
                  });
                  return;
                }
                g(m.attributes.IMPORT, this.mainDefinitions[m.attributes.IMPORT]);
                return;
              }
              this.trigger("error", {
                message: "EXT-X-DEFINE: No attribute"
              });
            },
            "i-frame-playlist"() {
              this.manifest.iFramePlaylists.push({
                attributes: m.attributes,
                uri: m.uri,
                timeline: h
              }), this.warnOnMissingAttributes_("#EXT-X-I-FRAME-STREAM-INF", m.attributes, ["BANDWIDTH", "URI"]);
            }
          }[m.tagType] || u).call(t);
        },
        uri() {
          r.uri = m.uri, i.push(r), this.manifest.targetDuration && !("duration" in r) && (this.trigger("warn", {
            message: "defaulting segment duration to the target duration"
          }), r.duration = this.manifest.targetDuration), s && (r.key = s), r.timeline = h, a && (r.map = a), d = 0, this.lastProgramDateTime !== null && (r.programDateTime = this.lastProgramDateTime, this.lastProgramDateTime += r.duration * 1e3), r = {};
        },
        comment() {
        },
        custom() {
          m.segment ? (r.custom = r.custom || {}, r.custom[m.customType] = m.data) : (this.manifest.custom = this.manifest.custom || {}, this.manifest.custom[m.customType] = m.data);
        }
      })[m.type].call(t);
    });
  }
  requiredCompatibilityversion(e, t) {
    (e < t || !e) && this.trigger("warn", {
      message: `manifest must be at least version ${t}`
    });
  }
  warnOnMissingAttributes_(e, t, i) {
    const r = [];
    i.forEach(function(a) {
      t.hasOwnProperty(a) || r.push(a);
    }), r.length && this.trigger("warn", {
      message: `${e} lacks required attribute(s): ${r.join(", ")}`
    });
  }
  /**
   * Parse the input string and update the manifest object.
   *
   * @param {string} chunk a potentially incomplete portion of the manifest
   */
  push(e) {
    this.lineStream.push(e);
  }
  /**
   * Flush any remaining input. This can be handy if the last line of an M3U8
   * manifest did not contain a trailing newline but the file has been
   * completely received.
   */
  end() {
    this.lineStream.push(`
`), this.manifest.dateRanges.length && this.lastProgramDateTime === null && this.trigger("warn", {
      message: "A playlist with EXT-X-DATERANGE tag must contain atleast one EXT-X-PROGRAM-DATE-TIME tag"
    }), this.lastProgramDateTime = null, this.trigger("end");
  }
  /**
   * Add an additional parser for non-standard tags
   *
   * @param {Object}   options              a map of options for the added parser
   * @param {RegExp}   options.expression   a regular expression to match the custom header
   * @param {string}   options.customType   the custom type to register to the output
   * @param {Function} [options.dataParser] function to parse the line into an object
   * @param {boolean}  [options.segment]    should tag data be attached to the segment object
   */
  addParser(e) {
    this.parseStream.addParser(e);
  }
  /**
   * Add a custom header mapper
   *
   * @param {Object}   options
   * @param {RegExp}   options.expression   a regular expression to match the custom header
   * @param {Function} options.map          function to translate tag into a different tag
   */
  addTagMapper(e) {
    this.parseStream.addTagMapper(e);
  }
}
var Ur = {
  // to determine mime types
  mp4: /^(av0?1|avc0?[1234]|vp0?9|flac|opus|mp3|mp4a|mp4v|stpp.ttml.im1t)/,
  webm: /^(vp0?[89]|av0?1|opus|vorbis)/,
  ogg: /^(vp0?[89]|theora|flac|opus|vorbis)/,
  // to determine if a codec is audio or video
  video: /^(av0?1|avc0?[1234]|vp0?[89]|hvc1|hev1|theora|mp4v)/,
  audio: /^(mp4a|flac|vorbis|opus|ac-[34]|ec-3|alac|mp3|speex|aac)/,
  text: /^(stpp.ttml.im1t)/,
  // mux.js support regex
  muxerVideo: /^(avc0?1)/,
  muxerAudio: /^(mp4a)/,
  // match nothing as muxer does not support text right now.
  // there cannot never be a character before the start of a string
  // so this matches nothing.
  muxerText: /a^/
}, iU = ["video", "audio", "text"], $2 = ["Video", "Audio", "Text"], sD = function(e) {
  return e && e.replace(/avc1\.(\d+)\.(\d+)/i, function(t, i, r) {
    var a = ("00" + Number(i).toString(16)).slice(-2), s = ("00" + Number(r).toString(16)).slice(-2);
    return "avc1." + a + "00" + s;
  });
}, hi = function(e) {
  e === void 0 && (e = "");
  var t = e.split(","), i = [];
  return t.forEach(function(r) {
    r = r.trim();
    var a;
    iU.forEach(function(s) {
      var o = Ur[s].exec(r.toLowerCase());
      if (!(!o || o.length <= 1)) {
        a = s;
        var u = r.substring(0, o[1].length), c = r.replace(u, "");
        i.push({
          type: u,
          details: c,
          mediaType: s
        });
      }
    }), a || i.push({
      type: r,
      details: "",
      mediaType: "unknown"
    });
  }), i;
}, rU = function(e, t) {
  if (!e.mediaGroups.AUDIO || !t)
    return null;
  var i = e.mediaGroups.AUDIO[t];
  if (!i)
    return null;
  for (var r in i) {
    var a = i[r];
    if (a.default && a.playlists)
      return hi(a.playlists[0].attributes.CODECS);
  }
  return null;
}, oD = function(e) {
  return e === void 0 && (e = ""), Ur.audio.test(e.trim().toLowerCase());
}, aU = function(e) {
  return e === void 0 && (e = ""), Ur.text.test(e.trim().toLowerCase());
}, xa = function(e) {
  if (!(!e || typeof e != "string")) {
    var t = e.toLowerCase().split(",").map(function(a) {
      return sD(a.trim());
    }), i = "video";
    t.length === 1 && oD(t[0]) ? i = "audio" : t.length === 1 && aU(t[0]) && (i = "application");
    var r = "mp4";
    return t.every(function(a) {
      return Ur.mp4.test(a);
    }) ? r = "mp4" : t.every(function(a) {
      return Ur.webm.test(a);
    }) ? r = "webm" : t.every(function(a) {
      return Ur.ogg.test(a);
    }) && (r = "ogg"), i + "/" + r + ';codecs="' + e + '"';
  }
}, Rs = function(e, t) {
  return e === void 0 && (e = ""), t === void 0 && (t = !1), me.MediaSource && me.MediaSource.isTypeSupported && me.MediaSource.isTypeSupported(xa(e)) || t && me.ManagedMediaSource && me.ManagedMediaSource.isTypeSupported && me.ManagedMediaSource.isTypeSupported(xa(e)) || !1;
}, yp = function(e) {
  return e === void 0 && (e = ""), e.toLowerCase().split(",").every(function(t) {
    t = t.trim();
    for (var i = 0; i < $2.length; i++) {
      var r = $2[i];
      if (Ur["muxer" + r].test(t))
        return !0;
    }
    return !1;
  });
}, G2 = "mp4a.40.2", sU = "avc1.4d400d", oU = /^(audio|video|application)\/(x-|vnd\.apple\.)?mpegurl/i, uU = /^application\/dash\+xml/i, uD = function(e) {
  return oU.test(e) ? "hls" : uU.test(e) ? "dash" : e === "application/vnd.videojs.vhs+json" ? "vhs-json" : null;
}, cU = function(e) {
  return e.toString(2).length;
}, lU = function(e) {
  return Math.ceil(cU(e) / 8);
}, cD = function(e) {
  return ArrayBuffer.isView === "function" ? ArrayBuffer.isView(e) : e && e.buffer instanceof ArrayBuffer;
}, dU = function(e) {
  return cD(e);
}, Ke = function(e) {
  return e instanceof Uint8Array ? e : (!Array.isArray(e) && !dU(e) && !(e instanceof ArrayBuffer) && (typeof e != "number" || typeof e == "number" && e !== e ? e = 0 : e = [e]), new Uint8Array(e && e.buffer || e, e && e.byteOffset || 0, e && e.byteLength || 0));
}, zt = me.BigInt || Number, um = [zt("0x1"), zt("0x100"), zt("0x10000"), zt("0x1000000"), zt("0x100000000"), zt("0x10000000000"), zt("0x1000000000000"), zt("0x100000000000000"), zt("0x10000000000000000")];
(function() {
  var n = new Uint16Array([65484]), e = new Uint8Array(n.buffer, n.byteOffset, n.byteLength);
  return e[0] === 255 ? "big" : e[0] === 204 ? "little" : "unknown";
})();
var fU = function(e, t) {
  var i = t === void 0 ? {} : t, r = i.signed, a = r === void 0 ? !1 : r, s = i.le, o = s === void 0 ? !1 : s;
  e = Ke(e);
  var u = o ? "reduce" : "reduceRight", c = e[u] ? e[u] : Array.prototype[u], l = c.call(e, function(f, d, y) {
    var m = o ? y : Math.abs(y + 1 - e.length);
    return f + zt(d) * um[m];
  }, zt(0));
  if (a) {
    var h = um[e.length] / zt(2) - zt(1);
    l = zt(l), l > h && (l -= h, l -= h, l -= zt(2));
  }
  return Number(l);
}, hU = function(e, t) {
  var i = {}, r = i.le, a = r === void 0 ? !1 : r;
  (typeof e != "bigint" && typeof e != "number" || typeof e == "number" && e !== e) && (e = 0), e = zt(e);
  for (var s = lU(e), o = new Uint8Array(new ArrayBuffer(s)), u = 0; u < s; u++) {
    var c = a ? u : Math.abs(u + 1 - o.length);
    o[c] = Number(e / um[u] & zt(255)), e < 0 && (o[c] = Math.abs(~o[c]), o[c] -= u === 0 ? 1 : 2);
  }
  return o;
}, lD = function(e, t) {
  if (typeof e != "string" && e && typeof e.toString == "function" && (e = e.toString()), typeof e != "string")
    return new Uint8Array();
  t || (e = unescape(encodeURIComponent(e)));
  for (var i = new Uint8Array(e.length), r = 0; r < e.length; r++)
    i[r] = e.charCodeAt(r);
  return i;
}, pU = function() {
  for (var e = arguments.length, t = new Array(e), i = 0; i < e; i++)
    t[i] = arguments[i];
  if (t = t.filter(function(o) {
    return o && (o.byteLength || o.length) && typeof o != "string";
  }), t.length <= 1)
    return Ke(t[0]);
  var r = t.reduce(function(o, u, c) {
    return o + (u.byteLength || u.length);
  }, 0), a = new Uint8Array(r), s = 0;
  return t.forEach(function(o) {
    o = Ke(o), a.set(o, s), s += o.byteLength;
  }), a;
}, St = function(e, t, i) {
  var r = i === void 0 ? {} : i, a = r.offset, s = a === void 0 ? 0 : a, o = r.mask, u = o === void 0 ? [] : o;
  e = Ke(e), t = Ke(t);
  var c = t.every ? t.every : Array.prototype.every;
  return t.length && e.length - s >= t.length && // ie 11 doesn't support every on uin8
  c.call(t, function(l, h) {
    var f = u[h] ? u[h] & e[s + h] : e[s + h];
    return l === f;
  });
}, vp = { exports: {} }, X2;
function mU() {
  return X2 || (X2 = 1, (function(n, e) {
    (function(t) {
      var i = /^(?=((?:[a-zA-Z0-9+\-.]+:)?))\1(?=((?:\/\/[^\/?#]*)?))\2(?=((?:(?:[^?#\/]*\/)*[^;?#\/]*)?))\3((?:;[^?#]*)?)(\?[^#]*)?(#[^]*)?$/, r = /^(?=([^\/?#]*))\1([^]*)$/, a = /(?:\/|^)\.(?=\/)/g, s = /(?:\/|^)\.\.\/(?!\.\.\/)[^\/]*(?=\/)/g, o = {
        // If opts.alwaysNormalize is true then the path will always be normalized even when it starts with / or //
        // E.g
        // With opts.alwaysNormalize = false (default, spec compliant)
        // http://a.com/b/cd + /e/f/../g => http://a.com/e/f/../g
        // With opts.alwaysNormalize = true (not spec compliant)
        // http://a.com/b/cd + /e/f/../g => http://a.com/e/g
        buildAbsoluteURL: function(u, c, l) {
          if (l = l || {}, u = u.trim(), c = c.trim(), !c) {
            if (!l.alwaysNormalize)
              return u;
            var h = o.parseURL(u);
            if (!h)
              throw new Error("Error trying to parse base URL.");
            return h.path = o.normalizePath(
              h.path
            ), o.buildURLFromParts(h);
          }
          var f = o.parseURL(c);
          if (!f)
            throw new Error("Error trying to parse relative URL.");
          if (f.scheme)
            return l.alwaysNormalize ? (f.path = o.normalizePath(f.path), o.buildURLFromParts(f)) : c;
          var d = o.parseURL(u);
          if (!d)
            throw new Error("Error trying to parse base URL.");
          if (!d.netLoc && d.path && d.path[0] !== "/") {
            var y = r.exec(d.path);
            d.netLoc = y[1], d.path = y[2];
          }
          d.netLoc && !d.path && (d.path = "/");
          var m = {
            // 2c) Otherwise, the embedded URL inherits the scheme of
            // the base URL.
            scheme: d.scheme,
            netLoc: f.netLoc,
            path: null,
            params: f.params,
            query: f.query,
            fragment: f.fragment
          };
          if (!f.netLoc && (m.netLoc = d.netLoc, f.path[0] !== "/"))
            if (!f.path)
              m.path = d.path, f.params || (m.params = d.params, f.query || (m.query = d.query));
            else {
              var b = d.path, p = b.substring(0, b.lastIndexOf("/") + 1) + f.path;
              m.path = o.normalizePath(p);
            }
          return m.path === null && (m.path = l.alwaysNormalize ? o.normalizePath(f.path) : f.path), o.buildURLFromParts(m);
        },
        parseURL: function(u) {
          var c = i.exec(u);
          return c ? {
            scheme: c[1] || "",
            netLoc: c[2] || "",
            path: c[3] || "",
            params: c[4] || "",
            query: c[5] || "",
            fragment: c[6] || ""
          } : null;
        },
        normalizePath: function(u) {
          for (u = u.split("").reverse().join("").replace(a, ""); u.length !== (u = u.replace(s, "")).length; )
            ;
          return u.split("").reverse().join("");
        },
        buildURLFromParts: function(u) {
          return u.scheme + u.netLoc + u.path + u.params + u.query + u.fragment;
        }
      };
      n.exports = o;
    })();
  })(vp)), vp.exports;
}
var gU = mU();
const K2 = /* @__PURE__ */ Qt(gU);
var Y2 = "http://example.com", zg = function(e, t) {
  if (/^[a-z]+:/i.test(t))
    return t;
  /^data:/.test(e) && (e = me.location && me.location.href || "");
  var i = typeof me.URL == "function", r = /^\/\//.test(e), a = !me.location && !/\/\//i.test(e);
  if (i ? e = new me.URL(e, me.location || Y2) : /\/\//i.test(e) || (e = K2.buildAbsoluteURL(me.location && me.location.href || "", e)), i) {
    var s = new URL(t, e);
    return a ? s.href.slice(Y2.length) : r ? s.href.slice(s.protocol.length) : s.href;
  }
  return K2.buildAbsoluteURL(e, t);
}, bU = function(e, t, i) {
  t.forEach(function(r) {
    for (var a in e.mediaGroups[r])
      for (var s in e.mediaGroups[r][a]) {
        var o = e.mediaGroups[r][a][s];
        i(o, r, a, s);
      }
  });
}, yU = function(e) {
  return me.atob ? me.atob(e) : Buffer.from(e, "base64").toString("binary");
};
function vU(n) {
  for (var e = yU(n), t = new Uint8Array(e.length), i = 0; i < e.length; i++)
    t[i] = e.charCodeAt(i);
  return t;
}
var gs = {}, Ci = {}, wr = {}, Q2;
function ll() {
  if (Q2) return wr;
  Q2 = 1;
  function n(a, s, o) {
    if (o === void 0 && (o = Array.prototype), a && typeof o.find == "function")
      return o.find.call(a, s);
    for (var u = 0; u < a.length; u++)
      if (Object.prototype.hasOwnProperty.call(a, u)) {
        var c = a[u];
        if (s.call(void 0, c, u, a))
          return c;
      }
  }
  function e(a, s) {
    return s === void 0 && (s = Object), s && typeof s.freeze == "function" ? s.freeze(a) : a;
  }
  function t(a, s) {
    if (a === null || typeof a != "object")
      throw new TypeError("target is not an object");
    for (var o in s)
      Object.prototype.hasOwnProperty.call(s, o) && (a[o] = s[o]);
    return a;
  }
  var i = e({
    /**
     * `text/html`, the only mime type that triggers treating an XML document as HTML.
     *
     * @see DOMParser.SupportedType.isHTML
     * @see https://www.iana.org/assignments/media-types/text/html IANA MimeType registration
     * @see https://en.wikipedia.org/wiki/HTML Wikipedia
     * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMParser/parseFromString MDN
     * @see https://html.spec.whatwg.org/multipage/dynamic-markup-insertion.html#dom-domparser-parsefromstring WHATWG HTML Spec
     */
    HTML: "text/html",
    /**
     * Helper method to check a mime type if it indicates an HTML document
     *
     * @param {string} [value]
     * @returns {boolean}
     *
     * @see https://www.iana.org/assignments/media-types/text/html IANA MimeType registration
     * @see https://en.wikipedia.org/wiki/HTML Wikipedia
     * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMParser/parseFromString MDN
     * @see https://html.spec.whatwg.org/multipage/dynamic-markup-insertion.html#dom-domparser-parsefromstring 	 */
    isHTML: function(a) {
      return a === i.HTML;
    },
    /**
     * `application/xml`, the standard mime type for XML documents.
     *
     * @see https://www.iana.org/assignments/media-types/application/xml IANA MimeType registration
     * @see https://tools.ietf.org/html/rfc7303#section-9.1 RFC 7303
     * @see https://en.wikipedia.org/wiki/XML_and_MIME Wikipedia
     */
    XML_APPLICATION: "application/xml",
    /**
     * `text/html`, an alias for `application/xml`.
     *
     * @see https://tools.ietf.org/html/rfc7303#section-9.2 RFC 7303
     * @see https://www.iana.org/assignments/media-types/text/xml IANA MimeType registration
     * @see https://en.wikipedia.org/wiki/XML_and_MIME Wikipedia
     */
    XML_TEXT: "text/xml",
    /**
     * `application/xhtml+xml`, indicates an XML document that has the default HTML namespace,
     * but is parsed as an XML document.
     *
     * @see https://www.iana.org/assignments/media-types/application/xhtml+xml IANA MimeType registration
     * @see https://dom.spec.whatwg.org/#dom-domimplementation-createdocument WHATWG DOM Spec
     * @see https://en.wikipedia.org/wiki/XHTML Wikipedia
     */
    XML_XHTML_APPLICATION: "application/xhtml+xml",
    /**
     * `image/svg+xml`,
     *
     * @see https://www.iana.org/assignments/media-types/image/svg+xml IANA MimeType registration
     * @see https://www.w3.org/TR/SVG11/ W3C SVG 1.1
     * @see https://en.wikipedia.org/wiki/Scalable_Vector_Graphics Wikipedia
     */
    XML_SVG_IMAGE: "image/svg+xml"
  }), r = e({
    /**
     * The XHTML namespace.
     *
     * @see http://www.w3.org/1999/xhtml
     */
    HTML: "http://www.w3.org/1999/xhtml",
    /**
     * Checks if `uri` equals `NAMESPACE.HTML`.
     *
     * @param {string} [uri]
     *
     * @see NAMESPACE.HTML
     */
    isHTML: function(a) {
      return a === r.HTML;
    },
    /**
     * The SVG namespace.
     *
     * @see http://www.w3.org/2000/svg
     */
    SVG: "http://www.w3.org/2000/svg",
    /**
     * The `xml:` namespace.
     *
     * @see http://www.w3.org/XML/1998/namespace
     */
    XML: "http://www.w3.org/XML/1998/namespace",
    /**
     * The `xmlns:` namespace
     *
     * @see https://www.w3.org/2000/xmlns/
     */
    XMLNS: "http://www.w3.org/2000/xmlns/"
  });
  return wr.assign = t, wr.find = n, wr.freeze = e, wr.MIME_TYPE = i, wr.NAMESPACE = r, wr;
}
var Z2;
function dD() {
  if (Z2) return Ci;
  Z2 = 1;
  var n = ll(), e = n.find, t = n.NAMESPACE;
  function i(G) {
    return G !== "";
  }
  function r(G) {
    return G ? G.split(/[\t\n\f\r ]+/).filter(i) : [];
  }
  function a(G, J) {
    return G.hasOwnProperty(J) || (G[J] = !0), G;
  }
  function s(G) {
    if (!G) return [];
    var J = r(G);
    return Object.keys(J.reduce(a, {}));
  }
  function o(G) {
    return function(J) {
      return G && G.indexOf(J) !== -1;
    };
  }
  function u(G, J) {
    for (var fe in G)
      Object.prototype.hasOwnProperty.call(G, fe) && (J[fe] = G[fe]);
  }
  function c(G, J) {
    var fe = G.prototype;
    if (!(fe instanceof J)) {
      let Ce = function() {
      };
      Ce.prototype = J.prototype, Ce = new Ce(), u(fe, Ce), G.prototype = fe = Ce;
    }
    fe.constructor != G && (typeof G != "function" && console.error("unknown Class:" + G), fe.constructor = G);
  }
  var l = {}, h = l.ELEMENT_NODE = 1, f = l.ATTRIBUTE_NODE = 2, d = l.TEXT_NODE = 3, y = l.CDATA_SECTION_NODE = 4, m = l.ENTITY_REFERENCE_NODE = 5, b = l.ENTITY_NODE = 6, p = l.PROCESSING_INSTRUCTION_NODE = 7, g = l.COMMENT_NODE = 8, v = l.DOCUMENT_NODE = 9, _ = l.DOCUMENT_TYPE_NODE = 10, x = l.DOCUMENT_FRAGMENT_NODE = 11, T = l.NOTATION_NODE = 12, E = {}, U = {};
  E.INDEX_SIZE_ERR = (U[1] = "Index size error", 1), E.DOMSTRING_SIZE_ERR = (U[2] = "DOMString size error", 2);
  var D = E.HIERARCHY_REQUEST_ERR = (U[3] = "Hierarchy request error", 3);
  E.WRONG_DOCUMENT_ERR = (U[4] = "Wrong document", 4), E.INVALID_CHARACTER_ERR = (U[5] = "Invalid character", 5), E.NO_DATA_ALLOWED_ERR = (U[6] = "No data allowed", 6), E.NO_MODIFICATION_ALLOWED_ERR = (U[7] = "No modification allowed", 7);
  var L = E.NOT_FOUND_ERR = (U[8] = "Not found", 8);
  E.NOT_SUPPORTED_ERR = (U[9] = "Not supported", 9);
  var j = E.INUSE_ATTRIBUTE_ERR = (U[10] = "Attribute in use", 10);
  E.INVALID_STATE_ERR = (U[11] = "Invalid state", 11), E.SYNTAX_ERR = (U[12] = "Syntax error", 12), E.INVALID_MODIFICATION_ERR = (U[13] = "Invalid modification", 13), E.NAMESPACE_ERR = (U[14] = "Invalid namespace", 14), E.INVALID_ACCESS_ERR = (U[15] = "Invalid access", 15);
  function C(G, J) {
    if (J instanceof Error)
      var fe = J;
    else
      fe = this, Error.call(this, U[G]), this.message = U[G], Error.captureStackTrace && Error.captureStackTrace(this, C);
    return fe.code = G, J && (this.message = this.message + ": " + J), fe;
  }
  C.prototype = Error.prototype, u(E, C);
  function k() {
  }
  k.prototype = {
    /**
     * The number of nodes in the list. The range of valid child node indices is 0 to length-1 inclusive.
     * @standard level1
     */
    length: 0,
    /**
     * Returns the indexth item in the collection. If index is greater than or equal to the number of nodes in the list, this returns null.
     * @standard level1
     * @param index  unsigned long
     *   Index into the collection.
     * @return Node
     * 	The node at the indexth position in the NodeList, or null if that is not a valid index.
     */
    item: function(G) {
      return G >= 0 && G < this.length ? this[G] : null;
    },
    toString: function(G, J) {
      for (var fe = [], Ce = 0; Ce < this.length; Ce++)
        rt(this[Ce], fe, G, J);
      return fe.join("");
    },
    /**
     * @private
     * @param {function (Node):boolean} predicate
     * @returns {Node[]}
     */
    filter: function(G) {
      return Array.prototype.filter.call(this, G);
    },
    /**
     * @private
     * @param {Node} item
     * @returns {number}
     */
    indexOf: function(G) {
      return Array.prototype.indexOf.call(this, G);
    }
  };
  function I(G, J) {
    this._node = G, this._refresh = J, $(this);
  }
  function $(G) {
    var J = G._node._inc || G._node.ownerDocument._inc;
    if (G._inc !== J) {
      var fe = G._refresh(G._node);
      if (ui(G, "length", fe.length), !G.$$length || fe.length < G.$$length)
        for (var Ce = fe.length; Ce in G; Ce++)
          Object.prototype.hasOwnProperty.call(G, Ce) && delete G[Ce];
      u(fe, G), G._inc = J;
    }
  }
  I.prototype.item = function(G) {
    return $(this), this[G] || null;
  }, c(I, k);
  function W() {
  }
  function B(G, J) {
    for (var fe = G.length; fe--; )
      if (G[fe] === J)
        return fe;
  }
  function z(G, J, fe, Ce) {
    if (Ce ? J[B(J, Ce)] = fe : J[J.length++] = fe, G) {
      fe.ownerElement = G;
      var Ne = G.ownerDocument;
      Ne && (Ce && ce(Ne, G, Ce), pe(Ne, G, fe));
    }
  }
  function q(G, J, fe) {
    var Ce = B(J, fe);
    if (Ce >= 0) {
      for (var Ne = J.length - 1; Ce < Ne; )
        J[Ce] = J[++Ce];
      if (J.length = Ne, G) {
        var Ve = G.ownerDocument;
        Ve && (ce(Ve, G, fe), fe.ownerElement = null);
      }
    } else
      throw new C(L, new Error(G.tagName + "@" + fe));
  }
  W.prototype = {
    length: 0,
    item: k.prototype.item,
    getNamedItem: function(G) {
      for (var J = this.length; J--; ) {
        var fe = this[J];
        if (fe.nodeName == G)
          return fe;
      }
    },
    setNamedItem: function(G) {
      var J = G.ownerElement;
      if (J && J != this._ownerElement)
        throw new C(j);
      var fe = this.getNamedItem(G.nodeName);
      return z(this._ownerElement, this, G, fe), fe;
    },
    /* returns Node */
    setNamedItemNS: function(G) {
      var J = G.ownerElement, fe;
      if (J && J != this._ownerElement)
        throw new C(j);
      return fe = this.getNamedItemNS(G.namespaceURI, G.localName), z(this._ownerElement, this, G, fe), fe;
    },
    /* returns Node */
    removeNamedItem: function(G) {
      var J = this.getNamedItem(G);
      return q(this._ownerElement, this, J), J;
    },
    // raises: NOT_FOUND_ERR,NO_MODIFICATION_ALLOWED_ERR
    //for level2
    removeNamedItemNS: function(G, J) {
      var fe = this.getNamedItemNS(G, J);
      return q(this._ownerElement, this, fe), fe;
    },
    getNamedItemNS: function(G, J) {
      for (var fe = this.length; fe--; ) {
        var Ce = this[fe];
        if (Ce.localName == J && Ce.namespaceURI == G)
          return Ce;
      }
      return null;
    }
  };
  function Y() {
  }
  Y.prototype = {
    /**
     * The DOMImplementation.hasFeature() method returns a Boolean flag indicating if a given feature is supported.
     * The different implementations fairly diverged in what kind of features were reported.
     * The latest version of the spec settled to force this method to always return true, where the functionality was accurate and in use.
     *
     * @deprecated It is deprecated and modern browsers return true in all cases.
     *
     * @param {string} feature
     * @param {string} [version]
     * @returns {boolean} always true
     *
     * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMImplementation/hasFeature MDN
     * @see https://www.w3.org/TR/REC-DOM-Level-1/level-one-core.html#ID-5CED94D7 DOM Level 1 Core
     * @see https://dom.spec.whatwg.org/#dom-domimplementation-hasfeature DOM Living Standard
     */
    hasFeature: function(G, J) {
      return !0;
    },
    /**
     * Creates an XML Document object of the specified type with its document element.
     *
     * __It behaves slightly different from the description in the living standard__:
     * - There is no interface/class `XMLDocument`, it returns a `Document` instance.
     * - `contentType`, `encoding`, `mode`, `origin`, `url` fields are currently not declared.
     * - this implementation is not validating names or qualified names
     *   (when parsing XML strings, the SAX parser takes care of that)
     *
     * @param {string|null} namespaceURI
     * @param {string} qualifiedName
     * @param {DocumentType=null} doctype
     * @returns {Document}
     *
     * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMImplementation/createDocument MDN
     * @see https://www.w3.org/TR/DOM-Level-2-Core/core.html#Level-2-Core-DOM-createDocument DOM Level 2 Core (initial)
     * @see https://dom.spec.whatwg.org/#dom-domimplementation-createdocument  DOM Level 2 Core
     *
     * @see https://dom.spec.whatwg.org/#validate-and-extract DOM: Validate and extract
     * @see https://www.w3.org/TR/xml/#NT-NameStartChar XML Spec: Names
     * @see https://www.w3.org/TR/xml-names/#ns-qualnames XML Namespaces: Qualified names
     */
    createDocument: function(G, J, fe) {
      var Ce = new ge();
      if (Ce.implementation = this, Ce.childNodes = new k(), Ce.doctype = fe || null, fe && Ce.appendChild(fe), J) {
        var Ne = Ce.createElementNS(G, J);
        Ce.appendChild(Ne);
      }
      return Ce;
    },
    /**
     * Returns a doctype, with the given `qualifiedName`, `publicId`, and `systemId`.
     *
     * __This behavior is slightly different from the in the specs__:
     * - this implementation is not validating names or qualified names
     *   (when parsing XML strings, the SAX parser takes care of that)
     *
     * @param {string} qualifiedName
     * @param {string} [publicId]
     * @param {string} [systemId]
     * @returns {DocumentType} which can either be used with `DOMImplementation.createDocument` upon document creation
     * 				  or can be put into the document via methods like `Node.insertBefore()` or `Node.replaceChild()`
     *
     * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMImplementation/createDocumentType MDN
     * @see https://www.w3.org/TR/DOM-Level-2-Core/core.html#Level-2-Core-DOM-createDocType DOM Level 2 Core
     * @see https://dom.spec.whatwg.org/#dom-domimplementation-createdocumenttype DOM Living Standard
     *
     * @see https://dom.spec.whatwg.org/#validate-and-extract DOM: Validate and extract
     * @see https://www.w3.org/TR/xml/#NT-NameStartChar XML Spec: Names
     * @see https://www.w3.org/TR/xml-names/#ns-qualnames XML Namespaces: Qualified names
     */
    createDocumentType: function(G, J, fe) {
      var Ce = new M();
      return Ce.name = G, Ce.nodeName = G, Ce.publicId = J || "", Ce.systemId = fe || "", Ce;
    }
  };
  function H() {
  }
  H.prototype = {
    firstChild: null,
    lastChild: null,
    previousSibling: null,
    nextSibling: null,
    attributes: null,
    parentNode: null,
    childNodes: null,
    ownerDocument: null,
    nodeValue: null,
    namespaceURI: null,
    prefix: null,
    localName: null,
    // Modified in DOM Level 2:
    insertBefore: function(G, J) {
      return ve(this, G, J);
    },
    replaceChild: function(G, J) {
      ve(this, G, J, ee), J && this.removeChild(J);
    },
    removeChild: function(G) {
      return De(this, G);
    },
    appendChild: function(G) {
      return this.insertBefore(G, null);
    },
    hasChildNodes: function() {
      return this.firstChild != null;
    },
    cloneNode: function(G) {
      return oi(this.ownerDocument || this, this, G);
    },
    // Modified in DOM Level 2:
    normalize: function() {
      for (var G = this.firstChild; G; ) {
        var J = G.nextSibling;
        J && J.nodeType == d && G.nodeType == d ? (this.removeChild(J), G.appendData(J.data)) : (G.normalize(), G = J);
      }
    },
    // Introduced in DOM Level 2:
    isSupported: function(G, J) {
      return this.ownerDocument.implementation.hasFeature(G, J);
    },
    // Introduced in DOM Level 2:
    hasAttributes: function() {
      return this.attributes.length > 0;
    },
    /**
     * Look up the prefix associated to the given namespace URI, starting from this node.
     * **The default namespace declarations are ignored by this method.**
     * See Namespace Prefix Lookup for details on the algorithm used by this method.
     *
     * _Note: The implementation seems to be incomplete when compared to the algorithm described in the specs._
     *
     * @param {string | null} namespaceURI
     * @returns {string | null}
     * @see https://www.w3.org/TR/DOM-Level-3-Core/core.html#Node3-lookupNamespacePrefix
     * @see https://www.w3.org/TR/DOM-Level-3-Core/namespaces-algorithms.html#lookupNamespacePrefixAlgo
     * @see https://dom.spec.whatwg.org/#dom-node-lookupprefix
     * @see https://github.com/xmldom/xmldom/issues/322
     */
    lookupPrefix: function(G) {
      for (var J = this; J; ) {
        var fe = J._nsMap;
        if (fe) {
          for (var Ce in fe)
            if (Object.prototype.hasOwnProperty.call(fe, Ce) && fe[Ce] === G)
              return Ce;
        }
        J = J.nodeType == f ? J.ownerDocument : J.parentNode;
      }
      return null;
    },
    // Introduced in DOM Level 3:
    lookupNamespaceURI: function(G) {
      for (var J = this; J; ) {
        var fe = J._nsMap;
        if (fe && Object.prototype.hasOwnProperty.call(fe, G))
          return fe[G];
        J = J.nodeType == f ? J.ownerDocument : J.parentNode;
      }
      return null;
    },
    // Introduced in DOM Level 3:
    isDefaultNamespace: function(G) {
      var J = this.lookupPrefix(G);
      return J == null;
    }
  };
  function K(G) {
    return G == "<" && "&lt;" || G == ">" && "&gt;" || G == "&" && "&amp;" || G == '"' && "&quot;" || "&#" + G.charCodeAt() + ";";
  }
  u(l, H), u(l, H.prototype);
  function ie(G, J) {
    if (J(G))
      return !0;
    if (G = G.firstChild)
      do
        if (ie(G, J))
          return !0;
      while (G = G.nextSibling);
  }
  function ge() {
    this.ownerDocument = this;
  }
  function pe(G, J, fe) {
    G && G._inc++;
    var Ce = fe.namespaceURI;
    Ce === t.XMLNS && (J._nsMap[fe.prefix ? fe.localName : ""] = fe.value);
  }
  function ce(G, J, fe, Ce) {
    G && G._inc++;
    var Ne = fe.namespaceURI;
    Ne === t.XMLNS && delete J._nsMap[fe.prefix ? fe.localName : ""];
  }
  function oe(G, J, fe) {
    if (G && G._inc) {
      G._inc++;
      var Ce = J.childNodes;
      if (fe)
        Ce[Ce.length++] = fe;
      else {
        for (var Ne = J.firstChild, Ve = 0; Ne; )
          Ce[Ve++] = Ne, Ne = Ne.nextSibling;
        Ce.length = Ve, delete Ce[Ce.length];
      }
    }
  }
  function De(G, J) {
    var fe = J.previousSibling, Ce = J.nextSibling;
    return fe ? fe.nextSibling = Ce : G.firstChild = Ce, Ce ? Ce.previousSibling = fe : G.lastChild = fe, J.parentNode = null, J.previousSibling = null, J.nextSibling = null, oe(G.ownerDocument, G), J;
  }
  function Re(G) {
    return G && (G.nodeType === H.DOCUMENT_NODE || G.nodeType === H.DOCUMENT_FRAGMENT_NODE || G.nodeType === H.ELEMENT_NODE);
  }
  function Me(G) {
    return G && (P(G) || ne(G) || F(G) || G.nodeType === H.DOCUMENT_FRAGMENT_NODE || G.nodeType === H.COMMENT_NODE || G.nodeType === H.PROCESSING_INSTRUCTION_NODE);
  }
  function F(G) {
    return G && G.nodeType === H.DOCUMENT_TYPE_NODE;
  }
  function P(G) {
    return G && G.nodeType === H.ELEMENT_NODE;
  }
  function ne(G) {
    return G && G.nodeType === H.TEXT_NODE;
  }
  function S(G, J) {
    var fe = G.childNodes || [];
    if (e(fe, P) || F(J))
      return !1;
    var Ce = e(fe, F);
    return !(J && Ce && fe.indexOf(Ce) > fe.indexOf(J));
  }
  function he(G, J) {
    var fe = G.childNodes || [];
    function Ce(Ve) {
      return P(Ve) && Ve !== J;
    }
    if (e(fe, Ce))
      return !1;
    var Ne = e(fe, F);
    return !(J && Ne && fe.indexOf(Ne) > fe.indexOf(J));
  }
  function ae(G, J, fe) {
    if (!Re(G))
      throw new C(D, "Unexpected parent node type " + G.nodeType);
    if (fe && fe.parentNode !== G)
      throw new C(L, "child not in parent");
    if (
      // 4. If `node` is not a DocumentFragment, DocumentType, Element, or CharacterData node, then throw a "HierarchyRequestError" DOMException.
      !Me(J) || // 5. If either `node` is a Text node and `parent` is a document,
      // the sax parser currently adds top level text nodes, this will be fixed in 0.9.0
      // || (node.nodeType === Node.TEXT_NODE && parent.nodeType === Node.DOCUMENT_NODE)
      // or `node` is a doctype and `parent` is not a document, then throw a "HierarchyRequestError" DOMException.
      F(J) && G.nodeType !== H.DOCUMENT_NODE
    )
      throw new C(
        D,
        "Unexpected node type " + J.nodeType + " for parent node type " + G.nodeType
      );
  }
  function te(G, J, fe) {
    var Ce = G.childNodes || [], Ne = J.childNodes || [];
    if (J.nodeType === H.DOCUMENT_FRAGMENT_NODE) {
      var Ve = Ne.filter(P);
      if (Ve.length > 1 || e(Ne, ne))
        throw new C(D, "More than one element or text in fragment");
      if (Ve.length === 1 && !S(G, fe))
        throw new C(D, "Element in fragment can not be inserted before doctype");
    }
    if (P(J) && !S(G, fe))
      throw new C(D, "Only one element can be added and only after doctype");
    if (F(J)) {
      if (e(Ce, F))
        throw new C(D, "Only one doctype is allowed");
      var ut = e(Ce, P);
      if (fe && Ce.indexOf(ut) < Ce.indexOf(fe))
        throw new C(D, "Doctype can only be inserted before an element");
      if (!fe && ut)
        throw new C(D, "Doctype can not be appended since element is present");
    }
  }
  function ee(G, J, fe) {
    var Ce = G.childNodes || [], Ne = J.childNodes || [];
    if (J.nodeType === H.DOCUMENT_FRAGMENT_NODE) {
      var Ve = Ne.filter(P);
      if (Ve.length > 1 || e(Ne, ne))
        throw new C(D, "More than one element or text in fragment");
      if (Ve.length === 1 && !he(G, fe))
        throw new C(D, "Element in fragment can not be inserted before doctype");
    }
    if (P(J) && !he(G, fe))
      throw new C(D, "Only one element can be added and only after doctype");
    if (F(J)) {
      if (e(Ce, function(Jt) {
        return F(Jt) && Jt !== fe;
      }))
        throw new C(D, "Only one doctype is allowed");
      var ut = e(Ce, P);
      if (fe && Ce.indexOf(ut) < Ce.indexOf(fe))
        throw new C(D, "Doctype can only be inserted before an element");
    }
  }
  function ve(G, J, fe, Ce) {
    ae(G, J, fe), G.nodeType === H.DOCUMENT_NODE && (Ce || te)(G, J, fe);
    var Ne = J.parentNode;
    if (Ne && Ne.removeChild(J), J.nodeType === x) {
      var Ve = J.firstChild;
      if (Ve == null)
        return J;
      var ut = J.lastChild;
    } else
      Ve = ut = J;
    var mt = fe ? fe.previousSibling : G.lastChild;
    Ve.previousSibling = mt, ut.nextSibling = fe, mt ? mt.nextSibling = Ve : G.firstChild = Ve, fe == null ? G.lastChild = ut : fe.previousSibling = ut;
    do {
      Ve.parentNode = G;
      var Jt = G.ownerDocument || G;
      Ee(Ve, Jt);
    } while (Ve !== ut && (Ve = Ve.nextSibling));
    return oe(G.ownerDocument || G, G), J.nodeType == x && (J.firstChild = J.lastChild = null), J;
  }
  function Ee(G, J) {
    if (G.ownerDocument !== J) {
      if (G.ownerDocument = J, G.nodeType === h && G.attributes)
        for (var fe = 0; fe < G.attributes.length; fe++) {
          var Ce = G.attributes.item(fe);
          Ce && (Ce.ownerDocument = J);
        }
      for (var Ne = G.firstChild; Ne; )
        Ee(Ne, J), Ne = Ne.nextSibling;
    }
  }
  function Se(G, J) {
    J.parentNode && J.parentNode.removeChild(J), J.parentNode = G, J.previousSibling = G.lastChild, J.nextSibling = null, J.previousSibling ? J.previousSibling.nextSibling = J : G.firstChild = J, G.lastChild = J, oe(G.ownerDocument, G, J);
    var fe = G.ownerDocument || G;
    return Ee(J, fe), J;
  }
  ge.prototype = {
    //implementation : null,
    nodeName: "#document",
    nodeType: v,
    /**
     * The DocumentType node of the document.
     *
     * @readonly
     * @type DocumentType
     */
    doctype: null,
    documentElement: null,
    _inc: 1,
    insertBefore: function(G, J) {
      if (G.nodeType == x) {
        for (var fe = G.firstChild; fe; ) {
          var Ce = fe.nextSibling;
          this.insertBefore(fe, J), fe = Ce;
        }
        return G;
      }
      return ve(this, G, J), Ee(G, this), this.documentElement === null && G.nodeType === h && (this.documentElement = G), G;
    },
    removeChild: function(G) {
      return this.documentElement == G && (this.documentElement = null), De(this, G);
    },
    replaceChild: function(G, J) {
      ve(this, G, J, ee), Ee(G, this), J && this.removeChild(J), P(G) && (this.documentElement = G);
    },
    // Introduced in DOM Level 2:
    importNode: function(G, J) {
      return Bi(this, G, J);
    },
    // Introduced in DOM Level 2:
    getElementById: function(G) {
      var J = null;
      return ie(this.documentElement, function(fe) {
        if (fe.nodeType == h && fe.getAttribute("id") == G)
          return J = fe, !0;
      }), J;
    },
    /**
     * The `getElementsByClassName` method of `Document` interface returns an array-like object
     * of all child elements which have **all** of the given class name(s).
     *
     * Returns an empty list if `classeNames` is an empty string or only contains HTML white space characters.
     *
     *
     * Warning: This is a live LiveNodeList.
     * Changes in the DOM will reflect in the array as the changes occur.
     * If an element selected by this array no longer qualifies for the selector,
     * it will automatically be removed. Be aware of this for iteration purposes.
     *
     * @param {string} classNames is a string representing the class name(s) to match; multiple class names are separated by (ASCII-)whitespace
     *
     * @see https://developer.mozilla.org/en-US/docs/Web/API/Document/getElementsByClassName
     * @see https://dom.spec.whatwg.org/#concept-getelementsbyclassname
     */
    getElementsByClassName: function(G) {
      var J = s(G);
      return new I(this, function(fe) {
        var Ce = [];
        return J.length > 0 && ie(fe.documentElement, function(Ne) {
          if (Ne !== fe && Ne.nodeType === h) {
            var Ve = Ne.getAttribute("class");
            if (Ve) {
              var ut = G === Ve;
              if (!ut) {
                var mt = s(Ve);
                ut = J.every(o(mt));
              }
              ut && Ce.push(Ne);
            }
          }
        }), Ce;
      });
    },
    //document factory method:
    createElement: function(G) {
      var J = new xe();
      J.ownerDocument = this, J.nodeName = G, J.tagName = G, J.localName = G, J.childNodes = new k();
      var fe = J.attributes = new W();
      return fe._ownerElement = J, J;
    },
    createDocumentFragment: function() {
      var G = new Te();
      return G.ownerDocument = this, G.childNodes = new k(), G;
    },
    createTextNode: function(G) {
      var J = new we();
      return J.ownerDocument = this, J.appendData(G), J;
    },
    createComment: function(G) {
      var J = new Ue();
      return J.ownerDocument = this, J.appendData(G), J;
    },
    createCDATASection: function(G) {
      var J = new Q();
      return J.ownerDocument = this, J.appendData(G), J;
    },
    createProcessingInstruction: function(G, J) {
      var fe = new Ie();
      return fe.ownerDocument = this, fe.tagName = fe.nodeName = fe.target = G, fe.nodeValue = fe.data = J, fe;
    },
    createAttribute: function(G) {
      var J = new le();
      return J.ownerDocument = this, J.name = G, J.nodeName = G, J.localName = G, J.specified = !0, J;
    },
    createEntityReference: function(G) {
      var J = new de();
      return J.ownerDocument = this, J.nodeName = G, J;
    },
    // Introduced in DOM Level 2:
    createElementNS: function(G, J) {
      var fe = new xe(), Ce = J.split(":"), Ne = fe.attributes = new W();
      return fe.childNodes = new k(), fe.ownerDocument = this, fe.nodeName = J, fe.tagName = J, fe.namespaceURI = G, Ce.length == 2 ? (fe.prefix = Ce[0], fe.localName = Ce[1]) : fe.localName = J, Ne._ownerElement = fe, fe;
    },
    // Introduced in DOM Level 2:
    createAttributeNS: function(G, J) {
      var fe = new le(), Ce = J.split(":");
      return fe.ownerDocument = this, fe.nodeName = J, fe.name = J, fe.namespaceURI = G, fe.specified = !0, Ce.length == 2 ? (fe.prefix = Ce[0], fe.localName = Ce[1]) : fe.localName = J, fe;
    }
  }, c(ge, H);
  function xe() {
    this._nsMap = {};
  }
  xe.prototype = {
    nodeType: h,
    hasAttribute: function(G) {
      return this.getAttributeNode(G) != null;
    },
    getAttribute: function(G) {
      var J = this.getAttributeNode(G);
      return J && J.value || "";
    },
    getAttributeNode: function(G) {
      return this.attributes.getNamedItem(G);
    },
    setAttribute: function(G, J) {
      var fe = this.ownerDocument.createAttribute(G);
      fe.value = fe.nodeValue = "" + J, this.setAttributeNode(fe);
    },
    removeAttribute: function(G) {
      var J = this.getAttributeNode(G);
      J && this.removeAttributeNode(J);
    },
    //four real opeartion method
    appendChild: function(G) {
      return G.nodeType === x ? this.insertBefore(G, null) : Se(this, G);
    },
    setAttributeNode: function(G) {
      return this.attributes.setNamedItem(G);
    },
    setAttributeNodeNS: function(G) {
      return this.attributes.setNamedItemNS(G);
    },
    removeAttributeNode: function(G) {
      return this.attributes.removeNamedItem(G.nodeName);
    },
    //get real attribute name,and remove it by removeAttributeNode
    removeAttributeNS: function(G, J) {
      var fe = this.getAttributeNodeNS(G, J);
      fe && this.removeAttributeNode(fe);
    },
    hasAttributeNS: function(G, J) {
      return this.getAttributeNodeNS(G, J) != null;
    },
    getAttributeNS: function(G, J) {
      var fe = this.getAttributeNodeNS(G, J);
      return fe && fe.value || "";
    },
    setAttributeNS: function(G, J, fe) {
      var Ce = this.ownerDocument.createAttributeNS(G, J);
      Ce.value = Ce.nodeValue = "" + fe, this.setAttributeNode(Ce);
    },
    getAttributeNodeNS: function(G, J) {
      return this.attributes.getNamedItemNS(G, J);
    },
    getElementsByTagName: function(G) {
      return new I(this, function(J) {
        var fe = [];
        return ie(J, function(Ce) {
          Ce !== J && Ce.nodeType == h && (G === "*" || Ce.tagName == G) && fe.push(Ce);
        }), fe;
      });
    },
    getElementsByTagNameNS: function(G, J) {
      return new I(this, function(fe) {
        var Ce = [];
        return ie(fe, function(Ne) {
          Ne !== fe && Ne.nodeType === h && (G === "*" || Ne.namespaceURI === G) && (J === "*" || Ne.localName == J) && Ce.push(Ne);
        }), Ce;
      });
    }
  }, ge.prototype.getElementsByTagName = xe.prototype.getElementsByTagName, ge.prototype.getElementsByTagNameNS = xe.prototype.getElementsByTagNameNS, c(xe, H);
  function le() {
  }
  le.prototype.nodeType = f, c(le, H);
  function ye() {
  }
  ye.prototype = {
    data: "",
    substringData: function(G, J) {
      return this.data.substring(G, G + J);
    },
    appendData: function(G) {
      G = this.data + G, this.nodeValue = this.data = G, this.length = G.length;
    },
    insertData: function(G, J) {
      this.replaceData(G, 0, J);
    },
    appendChild: function(G) {
      throw new Error(U[D]);
    },
    deleteData: function(G, J) {
      this.replaceData(G, J, "");
    },
    replaceData: function(G, J, fe) {
      var Ce = this.data.substring(0, G), Ne = this.data.substring(G + J);
      fe = Ce + fe + Ne, this.nodeValue = this.data = fe, this.length = fe.length;
    }
  }, c(ye, H);
  function we() {
  }
  we.prototype = {
    nodeName: "#text",
    nodeType: d,
    splitText: function(G) {
      var J = this.data, fe = J.substring(G);
      J = J.substring(0, G), this.data = this.nodeValue = J, this.length = J.length;
      var Ce = this.ownerDocument.createTextNode(fe);
      return this.parentNode && this.parentNode.insertBefore(Ce, this.nextSibling), Ce;
    }
  }, c(we, ye);
  function Ue() {
  }
  Ue.prototype = {
    nodeName: "#comment",
    nodeType: g
  }, c(Ue, ye);
  function Q() {
  }
  Q.prototype = {
    nodeName: "#cdata-section",
    nodeType: y
  }, c(Q, ye);
  function M() {
  }
  M.prototype.nodeType = _, c(M, H);
  function N() {
  }
  N.prototype.nodeType = T, c(N, H);
  function Z() {
  }
  Z.prototype.nodeType = b, c(Z, H);
  function de() {
  }
  de.prototype.nodeType = m, c(de, H);
  function Te() {
  }
  Te.prototype.nodeName = "#document-fragment", Te.prototype.nodeType = x, c(Te, H);
  function Ie() {
  }
  Ie.prototype.nodeType = p, c(Ie, H);
  function je() {
  }
  je.prototype.serializeToString = function(G, J, fe) {
    return Ze.call(G, J, fe);
  }, H.prototype.toString = Ze;
  function Ze(G, J) {
    var fe = [], Ce = this.nodeType == 9 && this.documentElement || this, Ne = Ce.prefix, Ve = Ce.namespaceURI;
    if (Ve && Ne == null) {
      var Ne = Ce.lookupPrefix(Ve);
      if (Ne == null)
        var ut = [
          { namespace: Ve, prefix: null }
          //{namespace:uri,prefix:''}
        ];
    }
    return rt(this, fe, G, J, ut), fe.join("");
  }
  function Qe(G, J, fe) {
    var Ce = G.prefix || "", Ne = G.namespaceURI;
    if (!Ne || Ce === "xml" && Ne === t.XML || Ne === t.XMLNS)
      return !1;
    for (var Ve = fe.length; Ve--; ) {
      var ut = fe[Ve];
      if (ut.prefix === Ce)
        return ut.namespace !== Ne;
    }
    return !0;
  }
  function ot(G, J, fe) {
    G.push(" ", J, '="', fe.replace(/[<>&"\t\n\r]/g, K), '"');
  }
  function rt(G, J, fe, Ce, Ne) {
    if (Ne || (Ne = []), Ce)
      if (G = Ce(G), G) {
        if (typeof G == "string") {
          J.push(G);
          return;
        }
      } else
        return;
    switch (G.nodeType) {
      case h:
        var Ve = G.attributes, ut = Ve.length, xt = G.firstChild, mt = G.tagName;
        fe = t.isHTML(G.namespaceURI) || fe;
        var Jt = mt;
        if (!fe && !G.prefix && G.namespaceURI) {
          for (var qn, An = 0; An < Ve.length; An++)
            if (Ve.item(An).name === "xmlns") {
              qn = Ve.item(An).value;
              break;
            }
          if (!qn)
            for (var Wn = Ne.length - 1; Wn >= 0; Wn--) {
              var kn = Ne[Wn];
              if (kn.prefix === "" && kn.namespace === G.namespaceURI) {
                qn = kn.namespace;
                break;
              }
            }
          if (qn !== G.namespaceURI)
            for (var Wn = Ne.length - 1; Wn >= 0; Wn--) {
              var kn = Ne[Wn];
              if (kn.namespace === G.namespaceURI) {
                kn.prefix && (Jt = kn.prefix + ":" + mt);
                break;
              }
            }
        }
        J.push("<", Jt);
        for (var Ut = 0; Ut < ut; Ut++) {
          var In = Ve.item(Ut);
          In.prefix == "xmlns" ? Ne.push({ prefix: In.localName, namespace: In.value }) : In.nodeName == "xmlns" && Ne.push({ prefix: "", namespace: In.value });
        }
        for (var Ut = 0; Ut < ut; Ut++) {
          var In = Ve.item(Ut);
          if (Qe(In, fe, Ne)) {
            var wi = In.prefix || "", ci = In.namespaceURI;
            ot(J, wi ? "xmlns:" + wi : "xmlns", ci), Ne.push({ prefix: wi, namespace: ci });
          }
          rt(In, J, fe, Ce, Ne);
        }
        if (mt === Jt && Qe(G, fe, Ne)) {
          var wi = G.prefix || "", ci = G.namespaceURI;
          ot(J, wi ? "xmlns:" + wi : "xmlns", ci), Ne.push({ prefix: wi, namespace: ci });
        }
        if (xt || fe && !/^(?:meta|link|img|br|hr|input)$/i.test(mt)) {
          if (J.push(">"), fe && /^script$/i.test(mt))
            for (; xt; )
              xt.data ? J.push(xt.data) : rt(xt, J, fe, Ce, Ne.slice()), xt = xt.nextSibling;
          else
            for (; xt; )
              rt(xt, J, fe, Ce, Ne.slice()), xt = xt.nextSibling;
          J.push("</", Jt, ">");
        } else
          J.push("/>");
        return;
      case v:
      case x:
        for (var xt = G.firstChild; xt; )
          rt(xt, J, fe, Ce, Ne.slice()), xt = xt.nextSibling;
        return;
      case f:
        return ot(J, G.name, G.value);
      case d:
        return J.push(
          G.data.replace(/[<&>]/g, K)
        );
      case y:
        return J.push("<![CDATA[", G.data, "]]>");
      case g:
        return J.push("<!--", G.data, "-->");
      case _:
        var dr = G.publicId, lt = G.systemId;
        if (J.push("<!DOCTYPE ", G.name), dr)
          J.push(" PUBLIC ", dr), lt && lt != "." && J.push(" ", lt), J.push(">");
        else if (lt && lt != ".")
          J.push(" SYSTEM ", lt, ">");
        else {
          var _o = G.internalSubset;
          _o && J.push(" [", _o, "]"), J.push(">");
        }
        return;
      case p:
        return J.push("<?", G.target, " ", G.data, "?>");
      case m:
        return J.push("&", G.nodeName, ";");
      //case ENTITY_NODE:
      //case NOTATION_NODE:
      default:
        J.push("??", G.nodeName);
    }
  }
  function Bi(G, J, fe) {
    var Ce;
    switch (J.nodeType) {
      case h:
        Ce = J.cloneNode(!1), Ce.ownerDocument = G;
      //var attrs = node2.attributes;
      //var len = attrs.length;
      //for(var i=0;i<len;i++){
      //node2.setAttributeNodeNS(importNode(doc,attrs.item(i),deep));
      //}
      case x:
        break;
      case f:
        fe = !0;
        break;
    }
    if (Ce || (Ce = J.cloneNode(!1)), Ce.ownerDocument = G, Ce.parentNode = null, fe)
      for (var Ne = J.firstChild; Ne; )
        Ce.appendChild(Bi(G, Ne, fe)), Ne = Ne.nextSibling;
    return Ce;
  }
  function oi(G, J, fe) {
    var Ce = new J.constructor();
    for (var Ne in J)
      if (Object.prototype.hasOwnProperty.call(J, Ne)) {
        var Ve = J[Ne];
        typeof Ve != "object" && Ve != Ce[Ne] && (Ce[Ne] = Ve);
      }
    switch (J.childNodes && (Ce.childNodes = new k()), Ce.ownerDocument = G, Ce.nodeType) {
      case h:
        var ut = J.attributes, mt = Ce.attributes = new W(), Jt = ut.length;
        mt._ownerElement = Ce;
        for (var qn = 0; qn < Jt; qn++)
          Ce.setAttributeNode(oi(G, ut.item(qn), !0));
        break;
      case f:
        fe = !0;
    }
    if (fe)
      for (var An = J.firstChild; An; )
        Ce.appendChild(oi(G, An, fe)), An = An.nextSibling;
    return Ce;
  }
  function ui(G, J, fe) {
    G[J] = fe;
  }
  try {
    if (Object.defineProperty) {
      let G = function(J) {
        switch (J.nodeType) {
          case h:
          case x:
            var fe = [];
            for (J = J.firstChild; J; )
              J.nodeType !== 7 && J.nodeType !== 8 && fe.push(G(J)), J = J.nextSibling;
            return fe.join("");
          default:
            return J.nodeValue;
        }
      };
      Object.defineProperty(I.prototype, "length", {
        get: function() {
          return $(this), this.$$length;
        }
      }), Object.defineProperty(H.prototype, "textContent", {
        get: function() {
          return G(this);
        },
        set: function(J) {
          switch (this.nodeType) {
            case h:
            case x:
              for (; this.firstChild; )
                this.removeChild(this.firstChild);
              (J || String(J)) && this.appendChild(this.ownerDocument.createTextNode(J));
              break;
            default:
              this.data = J, this.value = J, this.nodeValue = J;
          }
        }
      }), ui = function(J, fe, Ce) {
        J["$$" + fe] = Ce;
      };
    }
  } catch {
  }
  return Ci.DocumentType = M, Ci.DOMException = C, Ci.DOMImplementation = Y, Ci.Element = xe, Ci.Node = H, Ci.NodeList = k, Ci.XMLSerializer = je, Ci;
}
var bs = {}, xp = {}, J2;
function xU() {
  return J2 || (J2 = 1, (function(n) {
    var e = ll().freeze;
    n.XML_ENTITIES = e({
      amp: "&",
      apos: "'",
      gt: ">",
      lt: "<",
      quot: '"'
    }), n.HTML_ENTITIES = e({
      Aacute: "",
      aacute: "",
      Abreve: "",
      abreve: "",
      ac: "",
      acd: "",
      acE: "",
      Acirc: "",
      acirc: "",
      acute: "",
      Acy: "",
      acy: "",
      AElig: "",
      aelig: "",
      af: "",
      Afr: "",
      afr: "",
      Agrave: "",
      agrave: "",
      alefsym: "",
      aleph: "",
      Alpha: "",
      alpha: "",
      Amacr: "",
      amacr: "",
      amalg: "",
      AMP: "&",
      amp: "&",
      And: "",
      and: "",
      andand: "",
      andd: "",
      andslope: "",
      andv: "",
      ang: "",
      ange: "",
      angle: "",
      angmsd: "",
      angmsdaa: "",
      angmsdab: "",
      angmsdac: "",
      angmsdad: "",
      angmsdae: "",
      angmsdaf: "",
      angmsdag: "",
      angmsdah: "",
      angrt: "",
      angrtvb: "",
      angrtvbd: "",
      angsph: "",
      angst: "",
      angzarr: "",
      Aogon: "",
      aogon: "",
      Aopf: "",
      aopf: "",
      ap: "",
      apacir: "",
      apE: "",
      ape: "",
      apid: "",
      apos: "'",
      ApplyFunction: "",
      approx: "",
      approxeq: "",
      Aring: "",
      aring: "",
      Ascr: "",
      ascr: "",
      Assign: "",
      ast: "*",
      asymp: "",
      asympeq: "",
      Atilde: "",
      atilde: "",
      Auml: "",
      auml: "",
      awconint: "",
      awint: "",
      backcong: "",
      backepsilon: "",
      backprime: "",
      backsim: "",
      backsimeq: "",
      Backslash: "",
      Barv: "",
      barvee: "",
      Barwed: "",
      barwed: "",
      barwedge: "",
      bbrk: "",
      bbrktbrk: "",
      bcong: "",
      Bcy: "",
      bcy: "",
      bdquo: "",
      becaus: "",
      Because: "",
      because: "",
      bemptyv: "",
      bepsi: "",
      bernou: "",
      Bernoullis: "",
      Beta: "",
      beta: "",
      beth: "",
      between: "",
      Bfr: "",
      bfr: "",
      bigcap: "",
      bigcirc: "",
      bigcup: "",
      bigodot: "",
      bigoplus: "",
      bigotimes: "",
      bigsqcup: "",
      bigstar: "",
      bigtriangledown: "",
      bigtriangleup: "",
      biguplus: "",
      bigvee: "",
      bigwedge: "",
      bkarow: "",
      blacklozenge: "",
      blacksquare: "",
      blacktriangle: "",
      blacktriangledown: "",
      blacktriangleleft: "",
      blacktriangleright: "",
      blank: "",
      blk12: "",
      blk14: "",
      blk34: "",
      block: "",
      bne: "=",
      bnequiv: "",
      bNot: "",
      bnot: "",
      Bopf: "",
      bopf: "",
      bot: "",
      bottom: "",
      bowtie: "",
      boxbox: "",
      boxDL: "",
      boxDl: "",
      boxdL: "",
      boxdl: "",
      boxDR: "",
      boxDr: "",
      boxdR: "",
      boxdr: "",
      boxH: "",
      boxh: "",
      boxHD: "",
      boxHd: "",
      boxhD: "",
      boxhd: "",
      boxHU: "",
      boxHu: "",
      boxhU: "",
      boxhu: "",
      boxminus: "",
      boxplus: "",
      boxtimes: "",
      boxUL: "",
      boxUl: "",
      boxuL: "",
      boxul: "",
      boxUR: "",
      boxUr: "",
      boxuR: "",
      boxur: "",
      boxV: "",
      boxv: "",
      boxVH: "",
      boxVh: "",
      boxvH: "",
      boxvh: "",
      boxVL: "",
      boxVl: "",
      boxvL: "",
      boxvl: "",
      boxVR: "",
      boxVr: "",
      boxvR: "",
      boxvr: "",
      bprime: "",
      Breve: "",
      breve: "",
      brvbar: "",
      Bscr: "",
      bscr: "",
      bsemi: "",
      bsim: "",
      bsime: "",
      bsol: "\\",
      bsolb: "",
      bsolhsub: "",
      bull: "",
      bullet: "",
      bump: "",
      bumpE: "",
      bumpe: "",
      Bumpeq: "",
      bumpeq: "",
      Cacute: "",
      cacute: "",
      Cap: "",
      cap: "",
      capand: "",
      capbrcup: "",
      capcap: "",
      capcup: "",
      capdot: "",
      CapitalDifferentialD: "",
      caps: "",
      caret: "",
      caron: "",
      Cayleys: "",
      ccaps: "",
      Ccaron: "",
      ccaron: "",
      Ccedil: "",
      ccedil: "",
      Ccirc: "",
      ccirc: "",
      Cconint: "",
      ccups: "",
      ccupssm: "",
      Cdot: "",
      cdot: "",
      cedil: "",
      Cedilla: "",
      cemptyv: "",
      cent: "",
      CenterDot: "",
      centerdot: "",
      Cfr: "",
      cfr: "",
      CHcy: "",
      chcy: "",
      check: "",
      checkmark: "",
      Chi: "",
      chi: "",
      cir: "",
      circ: "",
      circeq: "",
      circlearrowleft: "",
      circlearrowright: "",
      circledast: "",
      circledcirc: "",
      circleddash: "",
      CircleDot: "",
      circledR: "",
      circledS: "",
      CircleMinus: "",
      CirclePlus: "",
      CircleTimes: "",
      cirE: "",
      cire: "",
      cirfnint: "",
      cirmid: "",
      cirscir: "",
      ClockwiseContourIntegral: "",
      CloseCurlyDoubleQuote: "",
      CloseCurlyQuote: "",
      clubs: "",
      clubsuit: "",
      Colon: "",
      colon: ":",
      Colone: "",
      colone: "",
      coloneq: "",
      comma: ",",
      commat: "@",
      comp: "",
      compfn: "",
      complement: "",
      complexes: "",
      cong: "",
      congdot: "",
      Congruent: "",
      Conint: "",
      conint: "",
      ContourIntegral: "",
      Copf: "",
      copf: "",
      coprod: "",
      Coproduct: "",
      COPY: "",
      copy: "",
      copysr: "",
      CounterClockwiseContourIntegral: "",
      crarr: "",
      Cross: "",
      cross: "",
      Cscr: "",
      cscr: "",
      csub: "",
      csube: "",
      csup: "",
      csupe: "",
      ctdot: "",
      cudarrl: "",
      cudarrr: "",
      cuepr: "",
      cuesc: "",
      cularr: "",
      cularrp: "",
      Cup: "",
      cup: "",
      cupbrcap: "",
      CupCap: "",
      cupcap: "",
      cupcup: "",
      cupdot: "",
      cupor: "",
      cups: "",
      curarr: "",
      curarrm: "",
      curlyeqprec: "",
      curlyeqsucc: "",
      curlyvee: "",
      curlywedge: "",
      curren: "",
      curvearrowleft: "",
      curvearrowright: "",
      cuvee: "",
      cuwed: "",
      cwconint: "",
      cwint: "",
      cylcty: "",
      Dagger: "",
      dagger: "",
      daleth: "",
      Darr: "",
      dArr: "",
      darr: "",
      dash: "",
      Dashv: "",
      dashv: "",
      dbkarow: "",
      dblac: "",
      Dcaron: "",
      dcaron: "",
      Dcy: "",
      dcy: "",
      DD: "",
      dd: "",
      ddagger: "",
      ddarr: "",
      DDotrahd: "",
      ddotseq: "",
      deg: "",
      Del: "",
      Delta: "",
      delta: "",
      demptyv: "",
      dfisht: "",
      Dfr: "",
      dfr: "",
      dHar: "",
      dharl: "",
      dharr: "",
      DiacriticalAcute: "",
      DiacriticalDot: "",
      DiacriticalDoubleAcute: "",
      DiacriticalGrave: "`",
      DiacriticalTilde: "",
      diam: "",
      Diamond: "",
      diamond: "",
      diamondsuit: "",
      diams: "",
      die: "",
      DifferentialD: "",
      digamma: "",
      disin: "",
      div: "",
      divide: "",
      divideontimes: "",
      divonx: "",
      DJcy: "",
      djcy: "",
      dlcorn: "",
      dlcrop: "",
      dollar: "$",
      Dopf: "",
      dopf: "",
      Dot: "",
      dot: "",
      DotDot: "",
      doteq: "",
      doteqdot: "",
      DotEqual: "",
      dotminus: "",
      dotplus: "",
      dotsquare: "",
      doublebarwedge: "",
      DoubleContourIntegral: "",
      DoubleDot: "",
      DoubleDownArrow: "",
      DoubleLeftArrow: "",
      DoubleLeftRightArrow: "",
      DoubleLeftTee: "",
      DoubleLongLeftArrow: "",
      DoubleLongLeftRightArrow: "",
      DoubleLongRightArrow: "",
      DoubleRightArrow: "",
      DoubleRightTee: "",
      DoubleUpArrow: "",
      DoubleUpDownArrow: "",
      DoubleVerticalBar: "",
      DownArrow: "",
      Downarrow: "",
      downarrow: "",
      DownArrowBar: "",
      DownArrowUpArrow: "",
      DownBreve: "",
      downdownarrows: "",
      downharpoonleft: "",
      downharpoonright: "",
      DownLeftRightVector: "",
      DownLeftTeeVector: "",
      DownLeftVector: "",
      DownLeftVectorBar: "",
      DownRightTeeVector: "",
      DownRightVector: "",
      DownRightVectorBar: "",
      DownTee: "",
      DownTeeArrow: "",
      drbkarow: "",
      drcorn: "",
      drcrop: "",
      Dscr: "",
      dscr: "",
      DScy: "",
      dscy: "",
      dsol: "",
      Dstrok: "",
      dstrok: "",
      dtdot: "",
      dtri: "",
      dtrif: "",
      duarr: "",
      duhar: "",
      dwangle: "",
      DZcy: "",
      dzcy: "",
      dzigrarr: "",
      Eacute: "",
      eacute: "",
      easter: "",
      Ecaron: "",
      ecaron: "",
      ecir: "",
      Ecirc: "",
      ecirc: "",
      ecolon: "",
      Ecy: "",
      ecy: "",
      eDDot: "",
      Edot: "",
      eDot: "",
      edot: "",
      ee: "",
      efDot: "",
      Efr: "",
      efr: "",
      eg: "",
      Egrave: "",
      egrave: "",
      egs: "",
      egsdot: "",
      el: "",
      Element: "",
      elinters: "",
      ell: "",
      els: "",
      elsdot: "",
      Emacr: "",
      emacr: "",
      empty: "",
      emptyset: "",
      EmptySmallSquare: "",
      emptyv: "",
      EmptyVerySmallSquare: "",
      emsp: "",
      emsp13: "",
      emsp14: "",
      ENG: "",
      eng: "",
      ensp: "",
      Eogon: "",
      eogon: "",
      Eopf: "",
      eopf: "",
      epar: "",
      eparsl: "",
      eplus: "",
      epsi: "",
      Epsilon: "",
      epsilon: "",
      epsiv: "",
      eqcirc: "",
      eqcolon: "",
      eqsim: "",
      eqslantgtr: "",
      eqslantless: "",
      Equal: "",
      equals: "=",
      EqualTilde: "",
      equest: "",
      Equilibrium: "",
      equiv: "",
      equivDD: "",
      eqvparsl: "",
      erarr: "",
      erDot: "",
      Escr: "",
      escr: "",
      esdot: "",
      Esim: "",
      esim: "",
      Eta: "",
      eta: "",
      ETH: "",
      eth: "",
      Euml: "",
      euml: "",
      euro: "",
      excl: "!",
      exist: "",
      Exists: "",
      expectation: "",
      ExponentialE: "",
      exponentiale: "",
      fallingdotseq: "",
      Fcy: "",
      fcy: "",
      female: "",
      ffilig: "",
      fflig: "",
      ffllig: "",
      Ffr: "",
      ffr: "",
      filig: "",
      FilledSmallSquare: "",
      FilledVerySmallSquare: "",
      fjlig: "fj",
      flat: "",
      fllig: "",
      fltns: "",
      fnof: "",
      Fopf: "",
      fopf: "",
      ForAll: "",
      forall: "",
      fork: "",
      forkv: "",
      Fouriertrf: "",
      fpartint: "",
      frac12: "",
      frac13: "",
      frac14: "",
      frac15: "",
      frac16: "",
      frac18: "",
      frac23: "",
      frac25: "",
      frac34: "",
      frac35: "",
      frac38: "",
      frac45: "",
      frac56: "",
      frac58: "",
      frac78: "",
      frasl: "",
      frown: "",
      Fscr: "",
      fscr: "",
      gacute: "",
      Gamma: "",
      gamma: "",
      Gammad: "",
      gammad: "",
      gap: "",
      Gbreve: "",
      gbreve: "",
      Gcedil: "",
      Gcirc: "",
      gcirc: "",
      Gcy: "",
      gcy: "",
      Gdot: "",
      gdot: "",
      gE: "",
      ge: "",
      gEl: "",
      gel: "",
      geq: "",
      geqq: "",
      geqslant: "",
      ges: "",
      gescc: "",
      gesdot: "",
      gesdoto: "",
      gesdotol: "",
      gesl: "",
      gesles: "",
      Gfr: "",
      gfr: "",
      Gg: "",
      gg: "",
      ggg: "",
      gimel: "",
      GJcy: "",
      gjcy: "",
      gl: "",
      gla: "",
      glE: "",
      glj: "",
      gnap: "",
      gnapprox: "",
      gnE: "",
      gne: "",
      gneq: "",
      gneqq: "",
      gnsim: "",
      Gopf: "",
      gopf: "",
      grave: "`",
      GreaterEqual: "",
      GreaterEqualLess: "",
      GreaterFullEqual: "",
      GreaterGreater: "",
      GreaterLess: "",
      GreaterSlantEqual: "",
      GreaterTilde: "",
      Gscr: "",
      gscr: "",
      gsim: "",
      gsime: "",
      gsiml: "",
      Gt: "",
      GT: ">",
      gt: ">",
      gtcc: "",
      gtcir: "",
      gtdot: "",
      gtlPar: "",
      gtquest: "",
      gtrapprox: "",
      gtrarr: "",
      gtrdot: "",
      gtreqless: "",
      gtreqqless: "",
      gtrless: "",
      gtrsim: "",
      gvertneqq: "",
      gvnE: "",
      Hacek: "",
      hairsp: "",
      half: "",
      hamilt: "",
      HARDcy: "",
      hardcy: "",
      hArr: "",
      harr: "",
      harrcir: "",
      harrw: "",
      Hat: "^",
      hbar: "",
      Hcirc: "",
      hcirc: "",
      hearts: "",
      heartsuit: "",
      hellip: "",
      hercon: "",
      Hfr: "",
      hfr: "",
      HilbertSpace: "",
      hksearow: "",
      hkswarow: "",
      hoarr: "",
      homtht: "",
      hookleftarrow: "",
      hookrightarrow: "",
      Hopf: "",
      hopf: "",
      horbar: "",
      HorizontalLine: "",
      Hscr: "",
      hscr: "",
      hslash: "",
      Hstrok: "",
      hstrok: "",
      HumpDownHump: "",
      HumpEqual: "",
      hybull: "",
      hyphen: "",
      Iacute: "",
      iacute: "",
      ic: "",
      Icirc: "",
      icirc: "",
      Icy: "",
      icy: "",
      Idot: "",
      IEcy: "",
      iecy: "",
      iexcl: "",
      iff: "",
      Ifr: "",
      ifr: "",
      Igrave: "",
      igrave: "",
      ii: "",
      iiiint: "",
      iiint: "",
      iinfin: "",
      iiota: "",
      IJlig: "",
      ijlig: "",
      Im: "",
      Imacr: "",
      imacr: "",
      image: "",
      ImaginaryI: "",
      imagline: "",
      imagpart: "",
      imath: "",
      imof: "",
      imped: "",
      Implies: "",
      in: "",
      incare: "",
      infin: "",
      infintie: "",
      inodot: "",
      Int: "",
      int: "",
      intcal: "",
      integers: "",
      Integral: "",
      intercal: "",
      Intersection: "",
      intlarhk: "",
      intprod: "",
      InvisibleComma: "",
      InvisibleTimes: "",
      IOcy: "",
      iocy: "",
      Iogon: "",
      iogon: "",
      Iopf: "",
      iopf: "",
      Iota: "",
      iota: "",
      iprod: "",
      iquest: "",
      Iscr: "",
      iscr: "",
      isin: "",
      isindot: "",
      isinE: "",
      isins: "",
      isinsv: "",
      isinv: "",
      it: "",
      Itilde: "",
      itilde: "",
      Iukcy: "",
      iukcy: "",
      Iuml: "",
      iuml: "",
      Jcirc: "",
      jcirc: "",
      Jcy: "",
      jcy: "",
      Jfr: "",
      jfr: "",
      jmath: "",
      Jopf: "",
      jopf: "",
      Jscr: "",
      jscr: "",
      Jsercy: "",
      jsercy: "",
      Jukcy: "",
      jukcy: "",
      Kappa: "",
      kappa: "",
      kappav: "",
      Kcedil: "",
      kcedil: "",
      Kcy: "",
      kcy: "",
      Kfr: "",
      kfr: "",
      kgreen: "",
      KHcy: "",
      khcy: "",
      KJcy: "",
      kjcy: "",
      Kopf: "",
      kopf: "",
      Kscr: "",
      kscr: "",
      lAarr: "",
      Lacute: "",
      lacute: "",
      laemptyv: "",
      lagran: "",
      Lambda: "",
      lambda: "",
      Lang: "",
      lang: "",
      langd: "",
      langle: "",
      lap: "",
      Laplacetrf: "",
      laquo: "",
      Larr: "",
      lArr: "",
      larr: "",
      larrb: "",
      larrbfs: "",
      larrfs: "",
      larrhk: "",
      larrlp: "",
      larrpl: "",
      larrsim: "",
      larrtl: "",
      lat: "",
      lAtail: "",
      latail: "",
      late: "",
      lates: "",
      lBarr: "",
      lbarr: "",
      lbbrk: "",
      lbrace: "{",
      lbrack: "[",
      lbrke: "",
      lbrksld: "",
      lbrkslu: "",
      Lcaron: "",
      lcaron: "",
      Lcedil: "",
      lcedil: "",
      lceil: "",
      lcub: "{",
      Lcy: "",
      lcy: "",
      ldca: "",
      ldquo: "",
      ldquor: "",
      ldrdhar: "",
      ldrushar: "",
      ldsh: "",
      lE: "",
      le: "",
      LeftAngleBracket: "",
      LeftArrow: "",
      Leftarrow: "",
      leftarrow: "",
      LeftArrowBar: "",
      LeftArrowRightArrow: "",
      leftarrowtail: "",
      LeftCeiling: "",
      LeftDoubleBracket: "",
      LeftDownTeeVector: "",
      LeftDownVector: "",
      LeftDownVectorBar: "",
      LeftFloor: "",
      leftharpoondown: "",
      leftharpoonup: "",
      leftleftarrows: "",
      LeftRightArrow: "",
      Leftrightarrow: "",
      leftrightarrow: "",
      leftrightarrows: "",
      leftrightharpoons: "",
      leftrightsquigarrow: "",
      LeftRightVector: "",
      LeftTee: "",
      LeftTeeArrow: "",
      LeftTeeVector: "",
      leftthreetimes: "",
      LeftTriangle: "",
      LeftTriangleBar: "",
      LeftTriangleEqual: "",
      LeftUpDownVector: "",
      LeftUpTeeVector: "",
      LeftUpVector: "",
      LeftUpVectorBar: "",
      LeftVector: "",
      LeftVectorBar: "",
      lEg: "",
      leg: "",
      leq: "",
      leqq: "",
      leqslant: "",
      les: "",
      lescc: "",
      lesdot: "",
      lesdoto: "",
      lesdotor: "",
      lesg: "",
      lesges: "",
      lessapprox: "",
      lessdot: "",
      lesseqgtr: "",
      lesseqqgtr: "",
      LessEqualGreater: "",
      LessFullEqual: "",
      LessGreater: "",
      lessgtr: "",
      LessLess: "",
      lesssim: "",
      LessSlantEqual: "",
      LessTilde: "",
      lfisht: "",
      lfloor: "",
      Lfr: "",
      lfr: "",
      lg: "",
      lgE: "",
      lHar: "",
      lhard: "",
      lharu: "",
      lharul: "",
      lhblk: "",
      LJcy: "",
      ljcy: "",
      Ll: "",
      ll: "",
      llarr: "",
      llcorner: "",
      Lleftarrow: "",
      llhard: "",
      lltri: "",
      Lmidot: "",
      lmidot: "",
      lmoust: "",
      lmoustache: "",
      lnap: "",
      lnapprox: "",
      lnE: "",
      lne: "",
      lneq: "",
      lneqq: "",
      lnsim: "",
      loang: "",
      loarr: "",
      lobrk: "",
      LongLeftArrow: "",
      Longleftarrow: "",
      longleftarrow: "",
      LongLeftRightArrow: "",
      Longleftrightarrow: "",
      longleftrightarrow: "",
      longmapsto: "",
      LongRightArrow: "",
      Longrightarrow: "",
      longrightarrow: "",
      looparrowleft: "",
      looparrowright: "",
      lopar: "",
      Lopf: "",
      lopf: "",
      loplus: "",
      lotimes: "",
      lowast: "",
      lowbar: "_",
      LowerLeftArrow: "",
      LowerRightArrow: "",
      loz: "",
      lozenge: "",
      lozf: "",
      lpar: "(",
      lparlt: "",
      lrarr: "",
      lrcorner: "",
      lrhar: "",
      lrhard: "",
      lrm: "",
      lrtri: "",
      lsaquo: "",
      Lscr: "",
      lscr: "",
      Lsh: "",
      lsh: "",
      lsim: "",
      lsime: "",
      lsimg: "",
      lsqb: "[",
      lsquo: "",
      lsquor: "",
      Lstrok: "",
      lstrok: "",
      Lt: "",
      LT: "<",
      lt: "<",
      ltcc: "",
      ltcir: "",
      ltdot: "",
      lthree: "",
      ltimes: "",
      ltlarr: "",
      ltquest: "",
      ltri: "",
      ltrie: "",
      ltrif: "",
      ltrPar: "",
      lurdshar: "",
      luruhar: "",
      lvertneqq: "",
      lvnE: "",
      macr: "",
      male: "",
      malt: "",
      maltese: "",
      Map: "",
      map: "",
      mapsto: "",
      mapstodown: "",
      mapstoleft: "",
      mapstoup: "",
      marker: "",
      mcomma: "",
      Mcy: "",
      mcy: "",
      mdash: "",
      mDDot: "",
      measuredangle: "",
      MediumSpace: "",
      Mellintrf: "",
      Mfr: "",
      mfr: "",
      mho: "",
      micro: "",
      mid: "",
      midast: "*",
      midcir: "",
      middot: "",
      minus: "",
      minusb: "",
      minusd: "",
      minusdu: "",
      MinusPlus: "",
      mlcp: "",
      mldr: "",
      mnplus: "",
      models: "",
      Mopf: "",
      mopf: "",
      mp: "",
      Mscr: "",
      mscr: "",
      mstpos: "",
      Mu: "",
      mu: "",
      multimap: "",
      mumap: "",
      nabla: "",
      Nacute: "",
      nacute: "",
      nang: "",
      nap: "",
      napE: "",
      napid: "",
      napos: "",
      napprox: "",
      natur: "",
      natural: "",
      naturals: "",
      nbsp: "",
      nbump: "",
      nbumpe: "",
      ncap: "",
      Ncaron: "",
      ncaron: "",
      Ncedil: "",
      ncedil: "",
      ncong: "",
      ncongdot: "",
      ncup: "",
      Ncy: "",
      ncy: "",
      ndash: "",
      ne: "",
      nearhk: "",
      neArr: "",
      nearr: "",
      nearrow: "",
      nedot: "",
      NegativeMediumSpace: "",
      NegativeThickSpace: "",
      NegativeThinSpace: "",
      NegativeVeryThinSpace: "",
      nequiv: "",
      nesear: "",
      nesim: "",
      NestedGreaterGreater: "",
      NestedLessLess: "",
      NewLine: `
`,
      nexist: "",
      nexists: "",
      Nfr: "",
      nfr: "",
      ngE: "",
      nge: "",
      ngeq: "",
      ngeqq: "",
      ngeqslant: "",
      nges: "",
      nGg: "",
      ngsim: "",
      nGt: "",
      ngt: "",
      ngtr: "",
      nGtv: "",
      nhArr: "",
      nharr: "",
      nhpar: "",
      ni: "",
      nis: "",
      nisd: "",
      niv: "",
      NJcy: "",
      njcy: "",
      nlArr: "",
      nlarr: "",
      nldr: "",
      nlE: "",
      nle: "",
      nLeftarrow: "",
      nleftarrow: "",
      nLeftrightarrow: "",
      nleftrightarrow: "",
      nleq: "",
      nleqq: "",
      nleqslant: "",
      nles: "",
      nless: "",
      nLl: "",
      nlsim: "",
      nLt: "",
      nlt: "",
      nltri: "",
      nltrie: "",
      nLtv: "",
      nmid: "",
      NoBreak: "",
      NonBreakingSpace: "",
      Nopf: "",
      nopf: "",
      Not: "",
      not: "",
      NotCongruent: "",
      NotCupCap: "",
      NotDoubleVerticalBar: "",
      NotElement: "",
      NotEqual: "",
      NotEqualTilde: "",
      NotExists: "",
      NotGreater: "",
      NotGreaterEqual: "",
      NotGreaterFullEqual: "",
      NotGreaterGreater: "",
      NotGreaterLess: "",
      NotGreaterSlantEqual: "",
      NotGreaterTilde: "",
      NotHumpDownHump: "",
      NotHumpEqual: "",
      notin: "",
      notindot: "",
      notinE: "",
      notinva: "",
      notinvb: "",
      notinvc: "",
      NotLeftTriangle: "",
      NotLeftTriangleBar: "",
      NotLeftTriangleEqual: "",
      NotLess: "",
      NotLessEqual: "",
      NotLessGreater: "",
      NotLessLess: "",
      NotLessSlantEqual: "",
      NotLessTilde: "",
      NotNestedGreaterGreater: "",
      NotNestedLessLess: "",
      notni: "",
      notniva: "",
      notnivb: "",
      notnivc: "",
      NotPrecedes: "",
      NotPrecedesEqual: "",
      NotPrecedesSlantEqual: "",
      NotReverseElement: "",
      NotRightTriangle: "",
      NotRightTriangleBar: "",
      NotRightTriangleEqual: "",
      NotSquareSubset: "",
      NotSquareSubsetEqual: "",
      NotSquareSuperset: "",
      NotSquareSupersetEqual: "",
      NotSubset: "",
      NotSubsetEqual: "",
      NotSucceeds: "",
      NotSucceedsEqual: "",
      NotSucceedsSlantEqual: "",
      NotSucceedsTilde: "",
      NotSuperset: "",
      NotSupersetEqual: "",
      NotTilde: "",
      NotTildeEqual: "",
      NotTildeFullEqual: "",
      NotTildeTilde: "",
      NotVerticalBar: "",
      npar: "",
      nparallel: "",
      nparsl: "",
      npart: "",
      npolint: "",
      npr: "",
      nprcue: "",
      npre: "",
      nprec: "",
      npreceq: "",
      nrArr: "",
      nrarr: "",
      nrarrc: "",
      nrarrw: "",
      nRightarrow: "",
      nrightarrow: "",
      nrtri: "",
      nrtrie: "",
      nsc: "",
      nsccue: "",
      nsce: "",
      Nscr: "",
      nscr: "",
      nshortmid: "",
      nshortparallel: "",
      nsim: "",
      nsime: "",
      nsimeq: "",
      nsmid: "",
      nspar: "",
      nsqsube: "",
      nsqsupe: "",
      nsub: "",
      nsubE: "",
      nsube: "",
      nsubset: "",
      nsubseteq: "",
      nsubseteqq: "",
      nsucc: "",
      nsucceq: "",
      nsup: "",
      nsupE: "",
      nsupe: "",
      nsupset: "",
      nsupseteq: "",
      nsupseteqq: "",
      ntgl: "",
      Ntilde: "",
      ntilde: "",
      ntlg: "",
      ntriangleleft: "",
      ntrianglelefteq: "",
      ntriangleright: "",
      ntrianglerighteq: "",
      Nu: "",
      nu: "",
      num: "#",
      numero: "",
      numsp: "",
      nvap: "",
      nVDash: "",
      nVdash: "",
      nvDash: "",
      nvdash: "",
      nvge: "",
      nvgt: ">",
      nvHarr: "",
      nvinfin: "",
      nvlArr: "",
      nvle: "",
      nvlt: "<",
      nvltrie: "",
      nvrArr: "",
      nvrtrie: "",
      nvsim: "",
      nwarhk: "",
      nwArr: "",
      nwarr: "",
      nwarrow: "",
      nwnear: "",
      Oacute: "",
      oacute: "",
      oast: "",
      ocir: "",
      Ocirc: "",
      ocirc: "",
      Ocy: "",
      ocy: "",
      odash: "",
      Odblac: "",
      odblac: "",
      odiv: "",
      odot: "",
      odsold: "",
      OElig: "",
      oelig: "",
      ofcir: "",
      Ofr: "",
      ofr: "",
      ogon: "",
      Ograve: "",
      ograve: "",
      ogt: "",
      ohbar: "",
      ohm: "",
      oint: "",
      olarr: "",
      olcir: "",
      olcross: "",
      oline: "",
      olt: "",
      Omacr: "",
      omacr: "",
      Omega: "",
      omega: "",
      Omicron: "",
      omicron: "",
      omid: "",
      ominus: "",
      Oopf: "",
      oopf: "",
      opar: "",
      OpenCurlyDoubleQuote: "",
      OpenCurlyQuote: "",
      operp: "",
      oplus: "",
      Or: "",
      or: "",
      orarr: "",
      ord: "",
      order: "",
      orderof: "",
      ordf: "",
      ordm: "",
      origof: "",
      oror: "",
      orslope: "",
      orv: "",
      oS: "",
      Oscr: "",
      oscr: "",
      Oslash: "",
      oslash: "",
      osol: "",
      Otilde: "",
      otilde: "",
      Otimes: "",
      otimes: "",
      otimesas: "",
      Ouml: "",
      ouml: "",
      ovbar: "",
      OverBar: "",
      OverBrace: "",
      OverBracket: "",
      OverParenthesis: "",
      par: "",
      para: "",
      parallel: "",
      parsim: "",
      parsl: "",
      part: "",
      PartialD: "",
      Pcy: "",
      pcy: "",
      percnt: "%",
      period: ".",
      permil: "",
      perp: "",
      pertenk: "",
      Pfr: "",
      pfr: "",
      Phi: "",
      phi: "",
      phiv: "",
      phmmat: "",
      phone: "",
      Pi: "",
      pi: "",
      pitchfork: "",
      piv: "",
      planck: "",
      planckh: "",
      plankv: "",
      plus: "+",
      plusacir: "",
      plusb: "",
      pluscir: "",
      plusdo: "",
      plusdu: "",
      pluse: "",
      PlusMinus: "",
      plusmn: "",
      plussim: "",
      plustwo: "",
      pm: "",
      Poincareplane: "",
      pointint: "",
      Popf: "",
      popf: "",
      pound: "",
      Pr: "",
      pr: "",
      prap: "",
      prcue: "",
      prE: "",
      pre: "",
      prec: "",
      precapprox: "",
      preccurlyeq: "",
      Precedes: "",
      PrecedesEqual: "",
      PrecedesSlantEqual: "",
      PrecedesTilde: "",
      preceq: "",
      precnapprox: "",
      precneqq: "",
      precnsim: "",
      precsim: "",
      Prime: "",
      prime: "",
      primes: "",
      prnap: "",
      prnE: "",
      prnsim: "",
      prod: "",
      Product: "",
      profalar: "",
      profline: "",
      profsurf: "",
      prop: "",
      Proportion: "",
      Proportional: "",
      propto: "",
      prsim: "",
      prurel: "",
      Pscr: "",
      pscr: "",
      Psi: "",
      psi: "",
      puncsp: "",
      Qfr: "",
      qfr: "",
      qint: "",
      Qopf: "",
      qopf: "",
      qprime: "",
      Qscr: "",
      qscr: "",
      quaternions: "",
      quatint: "",
      quest: "?",
      questeq: "",
      QUOT: '"',
      quot: '"',
      rAarr: "",
      race: "",
      Racute: "",
      racute: "",
      radic: "",
      raemptyv: "",
      Rang: "",
      rang: "",
      rangd: "",
      range: "",
      rangle: "",
      raquo: "",
      Rarr: "",
      rArr: "",
      rarr: "",
      rarrap: "",
      rarrb: "",
      rarrbfs: "",
      rarrc: "",
      rarrfs: "",
      rarrhk: "",
      rarrlp: "",
      rarrpl: "",
      rarrsim: "",
      Rarrtl: "",
      rarrtl: "",
      rarrw: "",
      rAtail: "",
      ratail: "",
      ratio: "",
      rationals: "",
      RBarr: "",
      rBarr: "",
      rbarr: "",
      rbbrk: "",
      rbrace: "}",
      rbrack: "]",
      rbrke: "",
      rbrksld: "",
      rbrkslu: "",
      Rcaron: "",
      rcaron: "",
      Rcedil: "",
      rcedil: "",
      rceil: "",
      rcub: "}",
      Rcy: "",
      rcy: "",
      rdca: "",
      rdldhar: "",
      rdquo: "",
      rdquor: "",
      rdsh: "",
      Re: "",
      real: "",
      realine: "",
      realpart: "",
      reals: "",
      rect: "",
      REG: "",
      reg: "",
      ReverseElement: "",
      ReverseEquilibrium: "",
      ReverseUpEquilibrium: "",
      rfisht: "",
      rfloor: "",
      Rfr: "",
      rfr: "",
      rHar: "",
      rhard: "",
      rharu: "",
      rharul: "",
      Rho: "",
      rho: "",
      rhov: "",
      RightAngleBracket: "",
      RightArrow: "",
      Rightarrow: "",
      rightarrow: "",
      RightArrowBar: "",
      RightArrowLeftArrow: "",
      rightarrowtail: "",
      RightCeiling: "",
      RightDoubleBracket: "",
      RightDownTeeVector: "",
      RightDownVector: "",
      RightDownVectorBar: "",
      RightFloor: "",
      rightharpoondown: "",
      rightharpoonup: "",
      rightleftarrows: "",
      rightleftharpoons: "",
      rightrightarrows: "",
      rightsquigarrow: "",
      RightTee: "",
      RightTeeArrow: "",
      RightTeeVector: "",
      rightthreetimes: "",
      RightTriangle: "",
      RightTriangleBar: "",
      RightTriangleEqual: "",
      RightUpDownVector: "",
      RightUpTeeVector: "",
      RightUpVector: "",
      RightUpVectorBar: "",
      RightVector: "",
      RightVectorBar: "",
      ring: "",
      risingdotseq: "",
      rlarr: "",
      rlhar: "",
      rlm: "",
      rmoust: "",
      rmoustache: "",
      rnmid: "",
      roang: "",
      roarr: "",
      robrk: "",
      ropar: "",
      Ropf: "",
      ropf: "",
      roplus: "",
      rotimes: "",
      RoundImplies: "",
      rpar: ")",
      rpargt: "",
      rppolint: "",
      rrarr: "",
      Rrightarrow: "",
      rsaquo: "",
      Rscr: "",
      rscr: "",
      Rsh: "",
      rsh: "",
      rsqb: "]",
      rsquo: "",
      rsquor: "",
      rthree: "",
      rtimes: "",
      rtri: "",
      rtrie: "",
      rtrif: "",
      rtriltri: "",
      RuleDelayed: "",
      ruluhar: "",
      rx: "",
      Sacute: "",
      sacute: "",
      sbquo: "",
      Sc: "",
      sc: "",
      scap: "",
      Scaron: "",
      scaron: "",
      sccue: "",
      scE: "",
      sce: "",
      Scedil: "",
      scedil: "",
      Scirc: "",
      scirc: "",
      scnap: "",
      scnE: "",
      scnsim: "",
      scpolint: "",
      scsim: "",
      Scy: "",
      scy: "",
      sdot: "",
      sdotb: "",
      sdote: "",
      searhk: "",
      seArr: "",
      searr: "",
      searrow: "",
      sect: "",
      semi: ";",
      seswar: "",
      setminus: "",
      setmn: "",
      sext: "",
      Sfr: "",
      sfr: "",
      sfrown: "",
      sharp: "",
      SHCHcy: "",
      shchcy: "",
      SHcy: "",
      shcy: "",
      ShortDownArrow: "",
      ShortLeftArrow: "",
      shortmid: "",
      shortparallel: "",
      ShortRightArrow: "",
      ShortUpArrow: "",
      shy: "",
      Sigma: "",
      sigma: "",
      sigmaf: "",
      sigmav: "",
      sim: "",
      simdot: "",
      sime: "",
      simeq: "",
      simg: "",
      simgE: "",
      siml: "",
      simlE: "",
      simne: "",
      simplus: "",
      simrarr: "",
      slarr: "",
      SmallCircle: "",
      smallsetminus: "",
      smashp: "",
      smeparsl: "",
      smid: "",
      smile: "",
      smt: "",
      smte: "",
      smtes: "",
      SOFTcy: "",
      softcy: "",
      sol: "/",
      solb: "",
      solbar: "",
      Sopf: "",
      sopf: "",
      spades: "",
      spadesuit: "",
      spar: "",
      sqcap: "",
      sqcaps: "",
      sqcup: "",
      sqcups: "",
      Sqrt: "",
      sqsub: "",
      sqsube: "",
      sqsubset: "",
      sqsubseteq: "",
      sqsup: "",
      sqsupe: "",
      sqsupset: "",
      sqsupseteq: "",
      squ: "",
      Square: "",
      square: "",
      SquareIntersection: "",
      SquareSubset: "",
      SquareSubsetEqual: "",
      SquareSuperset: "",
      SquareSupersetEqual: "",
      SquareUnion: "",
      squarf: "",
      squf: "",
      srarr: "",
      Sscr: "",
      sscr: "",
      ssetmn: "",
      ssmile: "",
      sstarf: "",
      Star: "",
      star: "",
      starf: "",
      straightepsilon: "",
      straightphi: "",
      strns: "",
      Sub: "",
      sub: "",
      subdot: "",
      subE: "",
      sube: "",
      subedot: "",
      submult: "",
      subnE: "",
      subne: "",
      subplus: "",
      subrarr: "",
      Subset: "",
      subset: "",
      subseteq: "",
      subseteqq: "",
      SubsetEqual: "",
      subsetneq: "",
      subsetneqq: "",
      subsim: "",
      subsub: "",
      subsup: "",
      succ: "",
      succapprox: "",
      succcurlyeq: "",
      Succeeds: "",
      SucceedsEqual: "",
      SucceedsSlantEqual: "",
      SucceedsTilde: "",
      succeq: "",
      succnapprox: "",
      succneqq: "",
      succnsim: "",
      succsim: "",
      SuchThat: "",
      Sum: "",
      sum: "",
      sung: "",
      Sup: "",
      sup: "",
      sup1: "",
      sup2: "",
      sup3: "",
      supdot: "",
      supdsub: "",
      supE: "",
      supe: "",
      supedot: "",
      Superset: "",
      SupersetEqual: "",
      suphsol: "",
      suphsub: "",
      suplarr: "",
      supmult: "",
      supnE: "",
      supne: "",
      supplus: "",
      Supset: "",
      supset: "",
      supseteq: "",
      supseteqq: "",
      supsetneq: "",
      supsetneqq: "",
      supsim: "",
      supsub: "",
      supsup: "",
      swarhk: "",
      swArr: "",
      swarr: "",
      swarrow: "",
      swnwar: "",
      szlig: "",
      Tab: "	",
      target: "",
      Tau: "",
      tau: "",
      tbrk: "",
      Tcaron: "",
      tcaron: "",
      Tcedil: "",
      tcedil: "",
      Tcy: "",
      tcy: "",
      tdot: "",
      telrec: "",
      Tfr: "",
      tfr: "",
      there4: "",
      Therefore: "",
      therefore: "",
      Theta: "",
      theta: "",
      thetasym: "",
      thetav: "",
      thickapprox: "",
      thicksim: "",
      ThickSpace: "",
      thinsp: "",
      ThinSpace: "",
      thkap: "",
      thksim: "",
      THORN: "",
      thorn: "",
      Tilde: "",
      tilde: "",
      TildeEqual: "",
      TildeFullEqual: "",
      TildeTilde: "",
      times: "",
      timesb: "",
      timesbar: "",
      timesd: "",
      tint: "",
      toea: "",
      top: "",
      topbot: "",
      topcir: "",
      Topf: "",
      topf: "",
      topfork: "",
      tosa: "",
      tprime: "",
      TRADE: "",
      trade: "",
      triangle: "",
      triangledown: "",
      triangleleft: "",
      trianglelefteq: "",
      triangleq: "",
      triangleright: "",
      trianglerighteq: "",
      tridot: "",
      trie: "",
      triminus: "",
      TripleDot: "",
      triplus: "",
      trisb: "",
      tritime: "",
      trpezium: "",
      Tscr: "",
      tscr: "",
      TScy: "",
      tscy: "",
      TSHcy: "",
      tshcy: "",
      Tstrok: "",
      tstrok: "",
      twixt: "",
      twoheadleftarrow: "",
      twoheadrightarrow: "",
      Uacute: "",
      uacute: "",
      Uarr: "",
      uArr: "",
      uarr: "",
      Uarrocir: "",
      Ubrcy: "",
      ubrcy: "",
      Ubreve: "",
      ubreve: "",
      Ucirc: "",
      ucirc: "",
      Ucy: "",
      ucy: "",
      udarr: "",
      Udblac: "",
      udblac: "",
      udhar: "",
      ufisht: "",
      Ufr: "",
      ufr: "",
      Ugrave: "",
      ugrave: "",
      uHar: "",
      uharl: "",
      uharr: "",
      uhblk: "",
      ulcorn: "",
      ulcorner: "",
      ulcrop: "",
      ultri: "",
      Umacr: "",
      umacr: "",
      uml: "",
      UnderBar: "_",
      UnderBrace: "",
      UnderBracket: "",
      UnderParenthesis: "",
      Union: "",
      UnionPlus: "",
      Uogon: "",
      uogon: "",
      Uopf: "",
      uopf: "",
      UpArrow: "",
      Uparrow: "",
      uparrow: "",
      UpArrowBar: "",
      UpArrowDownArrow: "",
      UpDownArrow: "",
      Updownarrow: "",
      updownarrow: "",
      UpEquilibrium: "",
      upharpoonleft: "",
      upharpoonright: "",
      uplus: "",
      UpperLeftArrow: "",
      UpperRightArrow: "",
      Upsi: "",
      upsi: "",
      upsih: "",
      Upsilon: "",
      upsilon: "",
      UpTee: "",
      UpTeeArrow: "",
      upuparrows: "",
      urcorn: "",
      urcorner: "",
      urcrop: "",
      Uring: "",
      uring: "",
      urtri: "",
      Uscr: "",
      uscr: "",
      utdot: "",
      Utilde: "",
      utilde: "",
      utri: "",
      utrif: "",
      uuarr: "",
      Uuml: "",
      uuml: "",
      uwangle: "",
      vangrt: "",
      varepsilon: "",
      varkappa: "",
      varnothing: "",
      varphi: "",
      varpi: "",
      varpropto: "",
      vArr: "",
      varr: "",
      varrho: "",
      varsigma: "",
      varsubsetneq: "",
      varsubsetneqq: "",
      varsupsetneq: "",
      varsupsetneqq: "",
      vartheta: "",
      vartriangleleft: "",
      vartriangleright: "",
      Vbar: "",
      vBar: "",
      vBarv: "",
      Vcy: "",
      vcy: "",
      VDash: "",
      Vdash: "",
      vDash: "",
      vdash: "",
      Vdashl: "",
      Vee: "",
      vee: "",
      veebar: "",
      veeeq: "",
      vellip: "",
      Verbar: "",
      verbar: "|",
      Vert: "",
      vert: "|",
      VerticalBar: "",
      VerticalLine: "|",
      VerticalSeparator: "",
      VerticalTilde: "",
      VeryThinSpace: "",
      Vfr: "",
      vfr: "",
      vltri: "",
      vnsub: "",
      vnsup: "",
      Vopf: "",
      vopf: "",
      vprop: "",
      vrtri: "",
      Vscr: "",
      vscr: "",
      vsubnE: "",
      vsubne: "",
      vsupnE: "",
      vsupne: "",
      Vvdash: "",
      vzigzag: "",
      Wcirc: "",
      wcirc: "",
      wedbar: "",
      Wedge: "",
      wedge: "",
      wedgeq: "",
      weierp: "",
      Wfr: "",
      wfr: "",
      Wopf: "",
      wopf: "",
      wp: "",
      wr: "",
      wreath: "",
      Wscr: "",
      wscr: "",
      xcap: "",
      xcirc: "",
      xcup: "",
      xdtri: "",
      Xfr: "",
      xfr: "",
      xhArr: "",
      xharr: "",
      Xi: "",
      xi: "",
      xlArr: "",
      xlarr: "",
      xmap: "",
      xnis: "",
      xodot: "",
      Xopf: "",
      xopf: "",
      xoplus: "",
      xotime: "",
      xrArr: "",
      xrarr: "",
      Xscr: "",
      xscr: "",
      xsqcup: "",
      xuplus: "",
      xutri: "",
      xvee: "",
      xwedge: "",
      Yacute: "",
      yacute: "",
      YAcy: "",
      yacy: "",
      Ycirc: "",
      ycirc: "",
      Ycy: "",
      ycy: "",
      yen: "",
      Yfr: "",
      yfr: "",
      YIcy: "",
      yicy: "",
      Yopf: "",
      yopf: "",
      Yscr: "",
      yscr: "",
      YUcy: "",
      yucy: "",
      Yuml: "",
      yuml: "",
      Zacute: "",
      zacute: "",
      Zcaron: "",
      zcaron: "",
      Zcy: "",
      zcy: "",
      Zdot: "",
      zdot: "",
      zeetrf: "",
      ZeroWidthSpace: "",
      Zeta: "",
      zeta: "",
      Zfr: "",
      zfr: "",
      ZHcy: "",
      zhcy: "",
      zigrarr: "",
      Zopf: "",
      zopf: "",
      Zscr: "",
      zscr: "",
      zwj: "",
      zwnj: ""
    }), n.entityMap = n.HTML_ENTITIES;
  })(xp)), xp;
}
var yu = {}, e_;
function _U() {
  if (e_) return yu;
  e_ = 1;
  var n = ll().NAMESPACE, e = /[A-Z_a-z\xC0-\xD6\xD8-\xF6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/, t = new RegExp("[\\-\\.0-9" + e.source.slice(1, -1) + "\\u00B7\\u0300-\\u036F\\u203F-\\u2040]"), i = new RegExp("^" + e.source + t.source + "*(?::" + e.source + t.source + "*)?$"), r = 0, a = 1, s = 2, o = 3, u = 4, c = 5, l = 6, h = 7;
  function f(D, L) {
    this.message = D, this.locator = L, Error.captureStackTrace && Error.captureStackTrace(this, f);
  }
  f.prototype = new Error(), f.prototype.name = f.name;
  function d() {
  }
  d.prototype = {
    parse: function(D, L, j) {
      var C = this.domBuilder;
      C.startDocument(), _(L, L = {}), y(
        D,
        L,
        j,
        C,
        this.errorHandler
      ), C.endDocument();
    }
  };
  function y(D, L, j, C, k) {
    function I(Se) {
      if (Se > 65535) {
        Se -= 65536;
        var xe = 55296 + (Se >> 10), le = 56320 + (Se & 1023);
        return String.fromCharCode(xe, le);
      } else
        return String.fromCharCode(Se);
    }
    function $(Se) {
      var xe = Se.slice(1, -1);
      return Object.hasOwnProperty.call(j, xe) ? j[xe] : xe.charAt(0) === "#" ? I(parseInt(xe.substr(1).replace("x", "0x"))) : (k.error("entity not found:" + Se), Se);
    }
    function W(Se) {
      if (Se > ge) {
        var xe = D.substring(ge, Se).replace(/&#?\w+;/g, $);
        H && B(ge), C.characters(xe, 0, Se - ge), ge = Se;
      }
    }
    function B(Se, xe) {
      for (; Se >= q && (xe = Y.exec(D)); )
        z = xe.index, q = z + xe[0].length, H.lineNumber++;
      H.columnNumber = Se - z + 1;
    }
    for (var z = 0, q = 0, Y = /.*(?:\r\n?|\n)|.*$/g, H = C.locator, K = [{ currentNSMap: L }], ie = {}, ge = 0; ; ) {
      try {
        var pe = D.indexOf("<", ge);
        if (pe < 0) {
          if (!D.substr(ge).match(/^\s*$/)) {
            var ce = C.doc, oe = ce.createTextNode(D.substr(ge));
            ce.appendChild(oe), C.currentElement = oe;
          }
          return;
        }
        switch (pe > ge && W(pe), D.charAt(pe + 1)) {
          case "/":
            var ae = D.indexOf(">", pe + 3), De = D.substring(pe + 2, ae).replace(/[ \t\n\r]+$/g, ""), Re = K.pop();
            ae < 0 ? (De = D.substring(pe + 2).replace(/[\s<].*/, ""), k.error("end tag name: " + De + " is not complete:" + Re.tagName), ae = pe + 1 + De.length) : De.match(/\s</) && (De = De.replace(/[\s<].*/, ""), k.error("end tag name: " + De + " maybe not complete"), ae = pe + 1 + De.length);
            var Me = Re.localNSMap, F = Re.tagName == De, P = F || Re.tagName && Re.tagName.toLowerCase() == De.toLowerCase();
            if (P) {
              if (C.endElement(Re.uri, Re.localName, De), Me)
                for (var ne in Me)
                  Object.prototype.hasOwnProperty.call(Me, ne) && C.endPrefixMapping(ne);
              F || k.fatalError("end tag name: " + De + " is not match the current start tagName:" + Re.tagName);
            } else
              K.push(Re);
            ae++;
            break;
          // end elment
          case "?":
            H && B(pe), ae = T(D, pe, C);
            break;
          case "!":
            H && B(pe), ae = x(D, pe, C, k);
            break;
          default:
            H && B(pe);
            var S = new E(), he = K[K.length - 1].currentNSMap, ae = b(D, pe, S, he, $, k), te = S.length;
            if (!S.closed && v(D, ae, S.tagName, ie) && (S.closed = !0, j.nbsp || k.warning("unclosed xml attribute")), H && te) {
              for (var ee = m(H, {}), ve = 0; ve < te; ve++) {
                var Ee = S[ve];
                B(Ee.offset), Ee.locator = m(H, {});
              }
              C.locator = ee, p(S, C, he) && K.push(S), C.locator = H;
            } else
              p(S, C, he) && K.push(S);
            n.isHTML(S.uri) && !S.closed ? ae = g(D, ae, S.tagName, $, C) : ae++;
        }
      } catch (Se) {
        if (Se instanceof f)
          throw Se;
        k.error("element parse error: " + Se), ae = -1;
      }
      ae > ge ? ge = ae : W(Math.max(pe, ge) + 1);
    }
  }
  function m(D, L) {
    return L.lineNumber = D.lineNumber, L.columnNumber = D.columnNumber, L;
  }
  function b(D, L, j, C, k, I) {
    function $(H, K, ie) {
      j.attributeNames.hasOwnProperty(H) && I.fatalError("Attribute " + H + " redefined"), j.addValue(
        H,
        // @see https://www.w3.org/TR/xml/#AVNormalize
        // since the xmldom sax parser does not "interpret" DTD the following is not implemented:
        // - recursive replacement of (DTD) entity references
        // - trimming and collapsing multiple spaces into a single one for attributes that are not of type CDATA
        K.replace(/[\t\n\r]/g, " ").replace(/&#?\w+;/g, k),
        ie
      );
    }
    for (var W, B, z = ++L, q = r; ; ) {
      var Y = D.charAt(z);
      switch (Y) {
        case "=":
          if (q === a)
            W = D.slice(L, z), q = o;
          else if (q === s)
            q = o;
          else
            throw new Error("attribute equal must after attrName");
          break;
        case "'":
        case '"':
          if (q === o || q === a)
            if (q === a && (I.warning('attribute value must after "="'), W = D.slice(L, z)), L = z + 1, z = D.indexOf(Y, L), z > 0)
              B = D.slice(L, z), $(W, B, L - 1), q = c;
            else
              throw new Error("attribute value no end '" + Y + "' match");
          else if (q == u)
            B = D.slice(L, z), $(W, B, L), I.warning('attribute "' + W + '" missed start quot(' + Y + ")!!"), L = z + 1, q = c;
          else
            throw new Error('attribute value must after "="');
          break;
        case "/":
          switch (q) {
            case r:
              j.setTagName(D.slice(L, z));
            case c:
            case l:
            case h:
              q = h, j.closed = !0;
            case u:
            case a:
              break;
            case s:
              j.closed = !0;
              break;
            //case S_EQ:
            default:
              throw new Error("attribute invalid close char('/')");
          }
          break;
        case "":
          return I.error("unexpected end of input"), q == r && j.setTagName(D.slice(L, z)), z;
        case ">":
          switch (q) {
            case r:
              j.setTagName(D.slice(L, z));
            case c:
            case l:
            case h:
              break;
            //normal
            case u:
            //Compatible state
            case a:
              B = D.slice(L, z), B.slice(-1) === "/" && (j.closed = !0, B = B.slice(0, -1));
            case s:
              q === s && (B = W), q == u ? (I.warning('attribute "' + B + '" missed quot(")!'), $(W, B, L)) : ((!n.isHTML(C[""]) || !B.match(/^(?:disabled|checked|selected)$/i)) && I.warning('attribute "' + B + '" missed value!! "' + B + '" instead!!'), $(B, B, L));
              break;
            case o:
              throw new Error("attribute value missed!!");
          }
          return z;
        /*xml space '\x20' | #x9 | #xD | #xA; */
        case "":
          Y = " ";
        default:
          if (Y <= " ")
            switch (q) {
              case r:
                j.setTagName(D.slice(L, z)), q = l;
                break;
              case a:
                W = D.slice(L, z), q = s;
                break;
              case u:
                var B = D.slice(L, z);
                I.warning('attribute "' + B + '" missed quot(")!!'), $(W, B, L);
              case c:
                q = l;
                break;
            }
          else
            switch (q) {
              //case S_TAG:void();break;
              //case S_ATTR:void();break;
              //case S_ATTR_NOQUOT_VALUE:void();break;
              case s:
                j.tagName, (!n.isHTML(C[""]) || !W.match(/^(?:disabled|checked|selected)$/i)) && I.warning('attribute "' + W + '" missed value!! "' + W + '" instead2!!'), $(W, W, L), L = z, q = a;
                break;
              case c:
                I.warning('attribute space is required"' + W + '"!!');
              case l:
                q = a, L = z;
                break;
              case o:
                q = u, L = z;
                break;
              case h:
                throw new Error("elements closed character '/' and '>' must be connected to");
            }
      }
      z++;
    }
  }
  function p(D, L, j) {
    for (var C = D.tagName, k = null, Y = D.length; Y--; ) {
      var I = D[Y], $ = I.qName, W = I.value, H = $.indexOf(":");
      if (H > 0)
        var B = I.prefix = $.slice(0, H), z = $.slice(H + 1), q = B === "xmlns" && z;
      else
        z = $, B = null, q = $ === "xmlns" && "";
      I.localName = z, q !== !1 && (k == null && (k = {}, _(j, j = {})), j[q] = k[q] = W, I.uri = n.XMLNS, L.startPrefixMapping(q, W));
    }
    for (var Y = D.length; Y--; ) {
      I = D[Y];
      var B = I.prefix;
      B && (B === "xml" && (I.uri = n.XML), B !== "xmlns" && (I.uri = j[B || ""]));
    }
    var H = C.indexOf(":");
    H > 0 ? (B = D.prefix = C.slice(0, H), z = D.localName = C.slice(H + 1)) : (B = null, z = D.localName = C);
    var K = D.uri = j[B || ""];
    if (L.startElement(K, z, C, D), D.closed) {
      if (L.endElement(K, z, C), k)
        for (B in k)
          Object.prototype.hasOwnProperty.call(k, B) && L.endPrefixMapping(B);
    } else
      return D.currentNSMap = j, D.localNSMap = k, !0;
  }
  function g(D, L, j, C, k) {
    if (/^(?:script|textarea)$/i.test(j)) {
      var I = D.indexOf("</" + j + ">", L), $ = D.substring(L + 1, I);
      if (/[&<]/.test($))
        return /^script$/i.test(j) ? (k.characters($, 0, $.length), I) : ($ = $.replace(/&#?\w+;/g, C), k.characters($, 0, $.length), I);
    }
    return L + 1;
  }
  function v(D, L, j, C) {
    var k = C[j];
    return k == null && (k = D.lastIndexOf("</" + j + ">"), k < L && (k = D.lastIndexOf("</" + j)), C[j] = k), k < L;
  }
  function _(D, L) {
    for (var j in D)
      Object.prototype.hasOwnProperty.call(D, j) && (L[j] = D[j]);
  }
  function x(D, L, j, C) {
    var k = D.charAt(L + 2);
    switch (k) {
      case "-":
        if (D.charAt(L + 3) === "-") {
          var I = D.indexOf("-->", L + 4);
          return I > L ? (j.comment(D, L + 4, I - L - 4), I + 3) : (C.error("Unclosed comment"), -1);
        } else
          return -1;
      default:
        if (D.substr(L + 3, 6) == "CDATA[") {
          var I = D.indexOf("]]>", L + 9);
          return j.startCDATA(), j.characters(D, L + 9, I - L - 9), j.endCDATA(), I + 3;
        }
        var $ = U(D, L), W = $.length;
        if (W > 1 && /!doctype/i.test($[0][0])) {
          var B = $[1][0], z = !1, q = !1;
          W > 3 && (/^public$/i.test($[2][0]) ? (z = $[3][0], q = W > 4 && $[4][0]) : /^system$/i.test($[2][0]) && (q = $[3][0]));
          var Y = $[W - 1];
          return j.startDTD(B, z, q), j.endDTD(), Y.index + Y[0].length;
        }
    }
    return -1;
  }
  function T(D, L, j) {
    var C = D.indexOf("?>", L);
    if (C) {
      var k = D.substring(L, C).match(/^<\?(\S*)\s*([\s\S]*?)\s*$/);
      return k ? (k[0].length, j.processingInstruction(k[1], k[2]), C + 2) : -1;
    }
    return -1;
  }
  function E() {
    this.attributeNames = {};
  }
  E.prototype = {
    setTagName: function(D) {
      if (!i.test(D))
        throw new Error("invalid tagName:" + D);
      this.tagName = D;
    },
    addValue: function(D, L, j) {
      if (!i.test(D))
        throw new Error("invalid attribute:" + D);
      this.attributeNames[D] = this.length, this[this.length++] = { qName: D, value: L, offset: j };
    },
    length: 0,
    getLocalName: function(D) {
      return this[D].localName;
    },
    getLocator: function(D) {
      return this[D].locator;
    },
    getQName: function(D) {
      return this[D].qName;
    },
    getURI: function(D) {
      return this[D].uri;
    },
    getValue: function(D) {
      return this[D].value;
    }
    //	,getIndex:function(uri, localName)){
    //		if(localName){
    //
    //		}else{
    //			var qName = uri
    //		}
    //	},
    //	getValue:function(){return this.getValue(this.getIndex.apply(this,arguments))},
    //	getType:function(uri,localName){}
    //	getType:function(i){},
  };
  function U(D, L) {
    var j, C = [], k = /'[^']+'|"[^"]+"|[^\s<>\/=]+=?|(\/?\s*>|<)/g;
    for (k.lastIndex = L, k.exec(D); j = k.exec(D); )
      if (C.push(j), j[1]) return C;
  }
  return yu.XMLReader = d, yu.ParseError = f, yu;
}
var t_;
function TU() {
  if (t_) return bs;
  t_ = 1;
  var n = ll(), e = dD(), t = xU(), i = _U(), r = e.DOMImplementation, a = n.NAMESPACE, s = i.ParseError, o = i.XMLReader;
  function u(b) {
    return b.replace(/\r[\n\u0085]/g, `
`).replace(/[\r\u0085\u2028]/g, `
`);
  }
  function c(b) {
    this.options = b || { locator: {} };
  }
  c.prototype.parseFromString = function(b, p) {
    var g = this.options, v = new o(), _ = g.domBuilder || new h(), x = g.errorHandler, T = g.locator, E = g.xmlns || {}, U = /\/x?html?$/.test(p), D = U ? t.HTML_ENTITIES : t.XML_ENTITIES;
    T && _.setDocumentLocator(T), v.errorHandler = l(x, _, T), v.domBuilder = g.domBuilder || _, U && (E[""] = a.HTML), E.xml = E.xml || a.XML;
    var L = g.normalizeLineEndings || u;
    return b && typeof b == "string" ? v.parse(
      L(b),
      E,
      D
    ) : v.errorHandler.error("invalid doc source"), _.doc;
  };
  function l(b, p, g) {
    if (!b) {
      if (p instanceof h)
        return p;
      b = p;
    }
    var v = {}, _ = b instanceof Function;
    g = g || {};
    function x(T) {
      var E = b[T];
      !E && _ && (E = b.length == 2 ? function(U) {
        b(T, U);
      } : b), v[T] = E && function(U) {
        E("[xmldom " + T + "]	" + U + d(g));
      } || function() {
      };
    }
    return x("warning"), x("error"), x("fatalError"), v;
  }
  function h() {
    this.cdata = !1;
  }
  function f(b, p) {
    p.lineNumber = b.lineNumber, p.columnNumber = b.columnNumber;
  }
  h.prototype = {
    startDocument: function() {
      this.doc = new r().createDocument(null, null, null), this.locator && (this.doc.documentURI = this.locator.systemId);
    },
    startElement: function(b, p, g, v) {
      var _ = this.doc, x = _.createElementNS(b, g || p), T = v.length;
      m(this, x), this.currentElement = x, this.locator && f(this.locator, x);
      for (var E = 0; E < T; E++) {
        var b = v.getURI(E), U = v.getValue(E), g = v.getQName(E), D = _.createAttributeNS(b, g);
        this.locator && f(v.getLocator(E), D), D.value = D.nodeValue = U, x.setAttributeNode(D);
      }
    },
    endElement: function(b, p, g) {
      var v = this.currentElement;
      v.tagName, this.currentElement = v.parentNode;
    },
    startPrefixMapping: function(b, p) {
    },
    endPrefixMapping: function(b) {
    },
    processingInstruction: function(b, p) {
      var g = this.doc.createProcessingInstruction(b, p);
      this.locator && f(this.locator, g), m(this, g);
    },
    ignorableWhitespace: function(b, p, g) {
    },
    characters: function(b, p, g) {
      if (b = y.apply(this, arguments), b) {
        if (this.cdata)
          var v = this.doc.createCDATASection(b);
        else
          var v = this.doc.createTextNode(b);
        this.currentElement ? this.currentElement.appendChild(v) : /^\s*$/.test(b) && this.doc.appendChild(v), this.locator && f(this.locator, v);
      }
    },
    skippedEntity: function(b) {
    },
    endDocument: function() {
      this.doc.normalize();
    },
    setDocumentLocator: function(b) {
      (this.locator = b) && (b.lineNumber = 0);
    },
    //LexicalHandler
    comment: function(b, p, g) {
      b = y.apply(this, arguments);
      var v = this.doc.createComment(b);
      this.locator && f(this.locator, v), m(this, v);
    },
    startCDATA: function() {
      this.cdata = !0;
    },
    endCDATA: function() {
      this.cdata = !1;
    },
    startDTD: function(b, p, g) {
      var v = this.doc.implementation;
      if (v && v.createDocumentType) {
        var _ = v.createDocumentType(b, p, g);
        this.locator && f(this.locator, _), m(this, _), this.doc.doctype = _;
      }
    },
    /**
     * @see org.xml.sax.ErrorHandler
     * @link http://www.saxproject.org/apidoc/org/xml/sax/ErrorHandler.html
     */
    warning: function(b) {
      console.warn("[xmldom warning]	" + b, d(this.locator));
    },
    error: function(b) {
      console.error("[xmldom error]	" + b, d(this.locator));
    },
    fatalError: function(b) {
      throw new s(b, this.locator);
    }
  };
  function d(b) {
    if (b)
      return `
@` + (b.systemId || "") + "#[line:" + b.lineNumber + ",col:" + b.columnNumber + "]";
  }
  function y(b, p, g) {
    return typeof b == "string" ? b.substr(p, g) : b.length >= p + g || p ? new java.lang.String(b, p, g) + "" : b;
  }
  "endDTD,startEntity,endEntity,attributeDecl,elementDecl,externalEntityDecl,internalEntityDecl,resolveEntity,getExternalSubset,notationDecl,unparsedEntityDecl".replace(/\w+/g, function(b) {
    h.prototype[b] = function() {
      return null;
    };
  });
  function m(b, p) {
    b.currentElement ? b.currentElement.appendChild(p) : b.doc.appendChild(p);
  }
  return bs.__DOMHandler = h, bs.normalizeLineEndings = u, bs.DOMParser = c, bs;
}
var n_;
function wU() {
  if (n_) return gs;
  n_ = 1;
  var n = dD();
  return gs.DOMImplementation = n.DOMImplementation, gs.XMLSerializer = n.XMLSerializer, gs.DOMParser = TU().DOMParser, gs;
}
var EU = wU();
/*! @name mpd-parser @version 1.3.1 @license Apache-2.0 */
const i_ = (n) => !!n && typeof n == "object", Wt = (...n) => n.reduce((e, t) => (typeof t != "object" || Object.keys(t).forEach((i) => {
  Array.isArray(e[i]) && Array.isArray(t[i]) ? e[i] = e[i].concat(t[i]) : i_(e[i]) && i_(t[i]) ? e[i] = Wt(e[i], t[i]) : e[i] = t[i];
}), e), {}), fD = (n) => Object.keys(n).map((e) => n[e]), DU = (n, e) => {
  const t = [];
  for (let i = n; i < e; i++)
    t.push(i);
  return t;
}, _a = (n) => n.reduce((e, t) => e.concat(t), []), hD = (n) => {
  if (!n.length)
    return [];
  const e = [];
  for (let t = 0; t < n.length; t++)
    e.push(n[t]);
  return e;
}, SU = (n, e) => n.reduce((t, i, r) => (i[e] && t.push(r), t), []), CU = (n, e) => fD(n.reduce((t, i) => (i.forEach((r) => {
  t[e(r)] = r;
}), t), {}));
var Ta = {
  INVALID_NUMBER_OF_PERIOD: "INVALID_NUMBER_OF_PERIOD",
  DASH_EMPTY_MANIFEST: "DASH_EMPTY_MANIFEST",
  DASH_INVALID_XML: "DASH_INVALID_XML",
  NO_BASE_URL: "NO_BASE_URL",
  SEGMENT_TIME_UNSPECIFIED: "SEGMENT_TIME_UNSPECIFIED",
  UNSUPPORTED_UTC_TIMING_SCHEME: "UNSUPPORTED_UTC_TIMING_SCHEME"
};
const Ys = ({
  baseUrl: n = "",
  source: e = "",
  range: t = "",
  indexRange: i = ""
}) => {
  const r = {
    uri: e,
    resolvedUri: zg(n || "", e)
  };
  if (t || i) {
    const s = (t || i).split("-");
    let o = me.BigInt ? me.BigInt(s[0]) : parseInt(s[0], 10), u = me.BigInt ? me.BigInt(s[1]) : parseInt(s[1], 10);
    o < Number.MAX_SAFE_INTEGER && typeof o == "bigint" && (o = Number(o)), u < Number.MAX_SAFE_INTEGER && typeof u == "bigint" && (u = Number(u));
    let c;
    typeof u == "bigint" || typeof o == "bigint" ? c = me.BigInt(u) - me.BigInt(o) + me.BigInt(1) : c = u - o + 1, typeof c == "bigint" && c < Number.MAX_SAFE_INTEGER && (c = Number(c)), r.byterange = {
      length: c,
      offset: o
    };
  }
  return r;
}, AU = (n) => {
  let e;
  return typeof n.offset == "bigint" || typeof n.length == "bigint" ? e = me.BigInt(n.offset) + me.BigInt(n.length) - me.BigInt(1) : e = n.offset + n.length - 1, `${n.offset}-${e}`;
}, r_ = (n) => (n && typeof n != "number" && (n = parseInt(n, 10)), isNaN(n) ? null : n), kU = {
  /**
   * Returns the entire range of available segments for a static MPD
   *
   * @param {Object} attributes
   *        Inheritied MPD attributes
   * @return {{ start: number, end: number }}
   *         The start and end numbers for available segments
   */
  static(n) {
    const {
      duration: e,
      timescale: t = 1,
      sourceDuration: i,
      periodDuration: r
    } = n, a = r_(n.endNumber), s = e / t;
    return typeof a == "number" ? {
      start: 0,
      end: a
    } : typeof r == "number" ? {
      start: 0,
      end: r / s
    } : {
      start: 0,
      end: i / s
    };
  },
  /**
   * Returns the current live window range of available segments for a dynamic MPD
   *
   * @param {Object} attributes
   *        Inheritied MPD attributes
   * @return {{ start: number, end: number }}
   *         The start and end numbers for available segments
   */
  dynamic(n) {
    const {
      NOW: e,
      clientOffset: t,
      availabilityStartTime: i,
      timescale: r = 1,
      duration: a,
      periodStart: s = 0,
      minimumUpdatePeriod: o = 0,
      timeShiftBufferDepth: u = 1 / 0
    } = n, c = r_(n.endNumber), l = (e + t) / 1e3, h = i + s, d = l + o - h, y = Math.ceil(d * r / a), m = Math.floor((l - h - u) * r / a), b = Math.floor((l - h) * r / a);
    return {
      start: Math.max(0, m),
      end: typeof c == "number" ? c : Math.min(y, b)
    };
  }
}, IU = (n) => (e) => {
  const {
    duration: t,
    timescale: i = 1,
    periodStart: r,
    startNumber: a = 1
  } = n;
  return {
    number: a + e,
    duration: t / i,
    timeline: r,
    time: e * t
  };
}, $g = (n) => {
  const {
    type: e,
    duration: t,
    timescale: i = 1,
    periodDuration: r,
    sourceDuration: a
  } = n, {
    start: s,
    end: o
  } = kU[e](n), u = DU(s, o).map(IU(n));
  if (e === "static") {
    const c = u.length - 1, l = typeof r == "number" ? r : a;
    u[c].duration = l - t / i * c;
  }
  return u;
}, pD = (n) => {
  const {
    baseUrl: e,
    initialization: t = {},
    sourceDuration: i,
    indexRange: r = "",
    periodStart: a,
    presentationTime: s,
    number: o = 0,
    duration: u
  } = n;
  if (!e)
    throw new Error(Ta.NO_BASE_URL);
  const c = Ys({
    baseUrl: e,
    source: t.sourceURL,
    range: t.range
  }), l = Ys({
    baseUrl: e,
    source: e,
    indexRange: r
  });
  if (l.map = c, u) {
    const h = $g(n);
    h.length && (l.duration = h[0].duration, l.timeline = h[0].timeline);
  } else i && (l.duration = i, l.timeline = a);
  return l.presentationTime = s || a, l.number = o, [l];
}, Gg = (n, e, t) => {
  const i = n.sidx.map ? n.sidx.map : null, r = n.sidx.duration, a = n.timeline || 0, s = n.sidx.byterange, o = s.offset + s.length, u = e.timescale, c = e.references.filter((b) => b.referenceType !== 1), l = [], h = n.endList ? "static" : "dynamic", f = n.sidx.timeline;
  let d = f, y = n.mediaSequence || 0, m;
  typeof e.firstOffset == "bigint" ? m = me.BigInt(o) + e.firstOffset : m = o + e.firstOffset;
  for (let b = 0; b < c.length; b++) {
    const p = e.references[b], g = p.referencedSize, v = p.subsegmentDuration;
    let _;
    typeof m == "bigint" ? _ = m + me.BigInt(g) - me.BigInt(1) : _ = m + g - 1;
    const x = `${m}-${_}`, E = pD({
      baseUrl: t,
      timescale: u,
      timeline: a,
      periodStart: f,
      presentationTime: d,
      number: y,
      duration: v,
      sourceDuration: r,
      indexRange: x,
      type: h
    })[0];
    i && (E.map = i), l.push(E), typeof m == "bigint" ? m += me.BigInt(g) : m += g, d += v / u, y++;
  }
  return n.segments = l, n;
}, UU = ["AUDIO", "SUBTITLES"], RU = 1 / 60, mD = (n) => CU(n, ({
  timeline: e
}) => e).sort((e, t) => e.timeline > t.timeline ? 1 : -1), OU = (n, e) => {
  for (let t = 0; t < n.length; t++)
    if (n[t].attributes.NAME === e)
      return n[t];
  return null;
}, a_ = (n) => {
  let e = [];
  return bU(n, UU, (t, i, r, a) => {
    e = e.concat(t.playlists || []);
  }), e;
}, s_ = ({
  playlist: n,
  mediaSequence: e
}) => {
  n.mediaSequence = e, n.segments.forEach((t, i) => {
    t.number = n.mediaSequence + i;
  });
}, LU = ({
  oldPlaylists: n,
  newPlaylists: e,
  timelineStarts: t
}) => {
  e.forEach((i) => {
    i.discontinuitySequence = t.findIndex(function({
      timeline: u
    }) {
      return u === i.timeline;
    });
    const r = OU(n, i.attributes.NAME);
    if (!r || i.sidx)
      return;
    const a = i.segments[0], s = r.segments.findIndex(function(u) {
      return Math.abs(u.presentationTime - a.presentationTime) < RU;
    });
    if (s === -1) {
      s_({
        playlist: i,
        mediaSequence: r.mediaSequence + r.segments.length
      }), i.segments[0].discontinuity = !0, i.discontinuityStarts.unshift(0), (!r.segments.length && i.timeline > r.timeline || r.segments.length && i.timeline > r.segments[r.segments.length - 1].timeline) && i.discontinuitySequence--;
      return;
    }
    r.segments[s].discontinuity && !a.discontinuity && (a.discontinuity = !0, i.discontinuityStarts.unshift(0), i.discontinuitySequence--), s_({
      playlist: i,
      mediaSequence: r.segments[s].number
    });
  });
}, PU = ({
  oldManifest: n,
  newManifest: e
}) => {
  const t = n.playlists.concat(a_(n)), i = e.playlists.concat(a_(e));
  return e.timelineStarts = mD([n.timelineStarts, e.timelineStarts]), LU({
    oldPlaylists: t,
    newPlaylists: i,
    timelineStarts: e.timelineStarts
  }), e;
}, dl = (n) => n && n.uri + "-" + AU(n.byterange), _p = (n) => {
  const e = n.reduce(function(i, r) {
    return i[r.attributes.baseUrl] || (i[r.attributes.baseUrl] = []), i[r.attributes.baseUrl].push(r), i;
  }, {});
  let t = [];
  return Object.values(e).forEach((i) => {
    const r = fD(i.reduce((a, s) => {
      const o = s.attributes.id + (s.attributes.lang || "");
      return a[o] ? (s.segments && (s.segments[0] && (s.segments[0].discontinuity = !0), a[o].segments.push(...s.segments)), s.attributes.contentProtection && (a[o].attributes.contentProtection = s.attributes.contentProtection)) : (a[o] = s, a[o].attributes.timelineStarts = []), a[o].attributes.timelineStarts.push({
        // Although they represent the same number, it's important to have both to make it
        // compatible with HLS potentially having a similar attribute.
        start: s.attributes.periodStart,
        timeline: s.attributes.periodStart
      }), a;
    }, {}));
    t = t.concat(r);
  }), t.map((i) => (i.discontinuityStarts = SU(i.segments || [], "discontinuity"), i));
}, Xg = (n, e) => {
  const t = dl(n.sidx), i = t && e[t] && e[t].sidx;
  return i && Gg(n, i, n.sidx.resolvedUri), n;
}, FU = (n, e = {}) => {
  if (!Object.keys(e).length)
    return n;
  for (const t in n)
    n[t] = Xg(n[t], e);
  return n;
}, NU = ({
  attributes: n,
  segments: e,
  sidx: t,
  mediaSequence: i,
  discontinuitySequence: r,
  discontinuityStarts: a
}, s) => {
  const o = {
    attributes: {
      NAME: n.id,
      BANDWIDTH: n.bandwidth,
      CODECS: n.codecs,
      "PROGRAM-ID": 1
    },
    uri: "",
    endList: n.type === "static",
    timeline: n.periodStart,
    resolvedUri: n.baseUrl || "",
    targetDuration: n.duration,
    discontinuitySequence: r,
    discontinuityStarts: a,
    timelineStarts: n.timelineStarts,
    mediaSequence: i,
    segments: e
  };
  return n.contentProtection && (o.contentProtection = n.contentProtection), n.serviceLocation && (o.attributes.serviceLocation = n.serviceLocation), t && (o.sidx = t), s && (o.attributes.AUDIO = "audio", o.attributes.SUBTITLES = "subs"), o;
}, MU = ({
  attributes: n,
  segments: e,
  mediaSequence: t,
  discontinuityStarts: i,
  discontinuitySequence: r
}) => {
  typeof e > "u" && (e = [{
    uri: n.baseUrl,
    timeline: n.periodStart,
    resolvedUri: n.baseUrl || "",
    duration: n.sourceDuration,
    number: 0
  }], n.duration = n.sourceDuration);
  const a = {
    NAME: n.id,
    BANDWIDTH: n.bandwidth,
    "PROGRAM-ID": 1
  };
  n.codecs && (a.CODECS = n.codecs);
  const s = {
    attributes: a,
    uri: "",
    endList: n.type === "static",
    timeline: n.periodStart,
    resolvedUri: n.baseUrl || "",
    targetDuration: n.duration,
    timelineStarts: n.timelineStarts,
    discontinuityStarts: i,
    discontinuitySequence: r,
    mediaSequence: t,
    segments: e
  };
  return n.serviceLocation && (s.attributes.serviceLocation = n.serviceLocation), s;
}, BU = (n, e = {}, t = !1) => {
  let i;
  const r = n.reduce((a, s) => {
    const o = s.attributes.role && s.attributes.role.value || "", u = s.attributes.lang || "";
    let c = s.attributes.label || "main";
    if (u && !s.attributes.label) {
      const h = o ? ` (${o})` : "";
      c = `${s.attributes.lang}${h}`;
    }
    a[c] || (a[c] = {
      language: u,
      autoselect: !0,
      default: o === "main",
      playlists: [],
      uri: ""
    });
    const l = Xg(NU(s, t), e);
    return a[c].playlists.push(l), typeof i > "u" && o === "main" && (i = s, i.default = !0), a;
  }, {});
  if (!i) {
    const a = Object.keys(r)[0];
    r[a].default = !0;
  }
  return r;
}, jU = (n, e = {}) => n.reduce((t, i) => {
  const r = i.attributes.label || i.attributes.lang || "text", a = i.attributes.lang || "und";
  return t[r] || (t[r] = {
    language: a,
    default: !1,
    autoselect: !1,
    playlists: [],
    uri: ""
  }), t[r].playlists.push(Xg(MU(i), e)), t;
}, {}), qU = (n) => n.reduce((e, t) => (t && t.forEach((i) => {
  const {
    channel: r,
    language: a
  } = i;
  e[a] = {
    autoselect: !1,
    default: !1,
    instreamId: r,
    language: a
  }, i.hasOwnProperty("aspectRatio") && (e[a].aspectRatio = i.aspectRatio), i.hasOwnProperty("easyReader") && (e[a].easyReader = i.easyReader), i.hasOwnProperty("3D") && (e[a]["3D"] = i["3D"]);
}), e), {}), WU = ({
  attributes: n,
  segments: e,
  sidx: t,
  discontinuityStarts: i
}) => {
  const r = {
    attributes: {
      NAME: n.id,
      AUDIO: "audio",
      SUBTITLES: "subs",
      RESOLUTION: {
        width: n.width,
        height: n.height
      },
      CODECS: n.codecs,
      BANDWIDTH: n.bandwidth,
      "PROGRAM-ID": 1
    },
    uri: "",
    endList: n.type === "static",
    timeline: n.periodStart,
    resolvedUri: n.baseUrl || "",
    targetDuration: n.duration,
    discontinuityStarts: i,
    timelineStarts: n.timelineStarts,
    segments: e
  };
  return n.frameRate && (r.attributes["FRAME-RATE"] = n.frameRate), n.contentProtection && (r.contentProtection = n.contentProtection), n.serviceLocation && (r.attributes.serviceLocation = n.serviceLocation), t && (r.sidx = t), r;
}, VU = ({
  attributes: n
}) => n.mimeType === "video/mp4" || n.mimeType === "video/webm" || n.contentType === "video", HU = ({
  attributes: n
}) => n.mimeType === "audio/mp4" || n.mimeType === "audio/webm" || n.contentType === "audio", zU = ({
  attributes: n
}) => n.mimeType === "text/vtt" || n.contentType === "text", $U = (n, e) => {
  n.forEach((t) => {
    t.mediaSequence = 0, t.discontinuitySequence = e.findIndex(function({
      timeline: i
    }) {
      return i === t.timeline;
    }), t.segments && t.segments.forEach((i, r) => {
      i.number = r;
    });
  });
}, o_ = (n) => n ? Object.keys(n).reduce((e, t) => {
  const i = n[t];
  return e.concat(i.playlists);
}, []) : [], GU = ({
  dashPlaylists: n,
  locations: e,
  contentSteering: t,
  sidxMapping: i = {},
  previousManifest: r,
  eventStream: a
}) => {
  if (!n.length)
    return {};
  const {
    sourceDuration: s,
    type: o,
    suggestedPresentationDelay: u,
    minimumUpdatePeriod: c
  } = n[0].attributes, l = _p(n.filter(VU)).map(WU), h = _p(n.filter(HU)), f = _p(n.filter(zU)), d = n.map((_) => _.attributes.captionServices).filter(Boolean), y = {
    allowCache: !0,
    discontinuityStarts: [],
    segments: [],
    endList: !0,
    mediaGroups: {
      AUDIO: {},
      VIDEO: {},
      "CLOSED-CAPTIONS": {},
      SUBTITLES: {}
    },
    uri: "",
    duration: s,
    playlists: FU(l, i)
  };
  c >= 0 && (y.minimumUpdatePeriod = c * 1e3), e && (y.locations = e), t && (y.contentSteering = t), o === "dynamic" && (y.suggestedPresentationDelay = u), a && a.length > 0 && (y.eventStream = a);
  const m = y.playlists.length === 0, b = h.length ? BU(h, i, m) : null, p = f.length ? jU(f, i) : null, g = l.concat(o_(b), o_(p)), v = g.map(({
    timelineStarts: _
  }) => _);
  return y.timelineStarts = mD(v), $U(g, y.timelineStarts), b && (y.mediaGroups.AUDIO.audio = b), p && (y.mediaGroups.SUBTITLES.subs = p), d.length && (y.mediaGroups["CLOSED-CAPTIONS"].cc = qU(d)), r ? PU({
    oldManifest: r,
    newManifest: y
  }) : y;
}, XU = (n, e, t) => {
  const {
    NOW: i,
    clientOffset: r,
    availabilityStartTime: a,
    timescale: s = 1,
    periodStart: o = 0,
    minimumUpdatePeriod: u = 0
  } = n, c = (i + r) / 1e3, l = a + o, f = c + u - l;
  return Math.ceil((f * s - e) / t);
}, gD = (n, e) => {
  const {
    type: t,
    minimumUpdatePeriod: i = 0,
    media: r = "",
    sourceDuration: a,
    timescale: s = 1,
    startNumber: o = 1,
    periodStart: u
  } = n, c = [];
  let l = -1;
  for (let h = 0; h < e.length; h++) {
    const f = e[h], d = f.d, y = f.r || 0, m = f.t || 0;
    l < 0 && (l = m), m && m > l && (l = m);
    let b;
    if (y < 0) {
      const v = h + 1;
      v === e.length ? t === "dynamic" && i > 0 && r.indexOf("$Number$") > 0 ? b = XU(n, l, d) : b = (a * s - l) / d : b = (e[v].t - l) / d;
    } else
      b = y + 1;
    const p = o + c.length + b;
    let g = o + c.length;
    for (; g < p; )
      c.push({
        number: g,
        duration: d / s,
        time: l,
        timeline: u
      }), l += d, g++;
  }
  return c;
}, KU = /\$([A-z]*)(?:(%0)([0-9]+)d)?\$/g, YU = (n) => (e, t, i, r) => {
  if (e === "$$")
    return "$";
  if (typeof n[t] > "u")
    return e;
  const a = "" + n[t];
  return t === "RepresentationID" || (i ? r = parseInt(r, 10) : r = 1, a.length >= r) ? a : `${new Array(r - a.length + 1).join("0")}${a}`;
}, u_ = (n, e) => n.replace(KU, YU(e)), QU = (n, e) => !n.duration && !e ? [{
  number: n.startNumber || 1,
  duration: n.sourceDuration,
  time: 0,
  timeline: n.periodStart
}] : n.duration ? $g(n) : gD(n, e), ZU = (n, e) => {
  const t = {
    RepresentationID: n.id,
    Bandwidth: n.bandwidth || 0
  }, {
    initialization: i = {
      sourceURL: "",
      range: ""
    }
  } = n, r = Ys({
    baseUrl: n.baseUrl,
    source: u_(i.sourceURL, t),
    range: i.range
  });
  return QU(n, e).map((s) => {
    t.Number = s.number, t.Time = s.time;
    const o = u_(n.media || "", t), u = n.timescale || 1, c = n.presentationTimeOffset || 0, l = (
      // Even if the @t attribute is not specified for the segment, segment.time is
      // calculated in mpd-parser prior to this, so it's assumed to be available.
      n.periodStart + (s.time - c) / u
    );
    return {
      uri: o,
      timeline: s.timeline,
      duration: s.duration,
      resolvedUri: zg(n.baseUrl || "", o),
      map: r,
      number: s.number,
      presentationTime: l
    };
  });
}, JU = (n, e) => {
  const {
    baseUrl: t,
    initialization: i = {}
  } = n, r = Ys({
    baseUrl: t,
    source: i.sourceURL,
    range: i.range
  }), a = Ys({
    baseUrl: t,
    source: e.media,
    range: e.mediaRange
  });
  return a.map = r, a;
}, eR = (n, e) => {
  const {
    duration: t,
    segmentUrls: i = [],
    periodStart: r
  } = n;
  if (!t && !e || t && e)
    throw new Error(Ta.SEGMENT_TIME_UNSPECIFIED);
  const a = i.map((u) => JU(n, u));
  let s;
  return t && (s = $g(n)), e && (s = gD(n, e)), s.map((u, c) => {
    if (a[c]) {
      const l = a[c], h = n.timescale || 1, f = n.presentationTimeOffset || 0;
      return l.timeline = u.timeline, l.duration = u.duration, l.number = u.number, l.presentationTime = r + (u.time - f) / h, l;
    }
  }).filter((u) => u);
}, tR = ({
  attributes: n,
  segmentInfo: e
}) => {
  let t, i;
  e.template ? (i = ZU, t = Wt(n, e.template)) : e.base ? (i = pD, t = Wt(n, e.base)) : e.list && (i = eR, t = Wt(n, e.list));
  const r = {
    attributes: n
  };
  if (!i)
    return r;
  const a = i(t, e.segmentTimeline);
  if (t.duration) {
    const {
      duration: s,
      timescale: o = 1
    } = t;
    t.duration = s / o;
  } else a.length ? t.duration = a.reduce((s, o) => Math.max(s, Math.ceil(o.duration)), 0) : t.duration = 0;
  return r.attributes = t, r.segments = a, e.base && t.indexRange && (r.sidx = a[0], r.segments = []), r;
}, nR = (n) => n.map(tR), Ct = (n, e) => hD(n.childNodes).filter(({
  tagName: t
}) => t === e), po = (n) => n.textContent.trim(), iR = (n) => parseFloat(n.split("/").reduce((e, t) => e / t)), Jr = (n) => {
  const o = /P(?:(\d*)Y)?(?:(\d*)M)?(?:(\d*)D)?(?:T(?:(\d*)H)?(?:(\d*)M)?(?:([\d.]*)S)?)?/.exec(n);
  if (!o)
    return 0;
  const [u, c, l, h, f, d] = o.slice(1);
  return parseFloat(u || 0) * 31536e3 + parseFloat(c || 0) * 2592e3 + parseFloat(l || 0) * 86400 + parseFloat(h || 0) * 3600 + parseFloat(f || 0) * 60 + parseFloat(d || 0);
}, rR = (n) => (/^\d+-\d+-\d+T\d+:\d+:\d+(\.\d+)?$/.test(n) && (n += "Z"), Date.parse(n)), c_ = {
  /**
   * Specifies the duration of the entire Media Presentation. Format is a duration string
   * as specified in ISO 8601
   *
   * @param {string} value
   *        value of attribute as a string
   * @return {number}
   *         The duration in seconds
   */
  mediaPresentationDuration(n) {
    return Jr(n);
  },
  /**
   * Specifies the Segment availability start time for all Segments referred to in this
   * MPD. For a dynamic manifest, it specifies the anchor for the earliest availability
   * time. Format is a date string as specified in ISO 8601
   *
   * @param {string} value
   *        value of attribute as a string
   * @return {number}
   *         The date as seconds from unix epoch
   */
  availabilityStartTime(n) {
    return rR(n) / 1e3;
  },
  /**
   * Specifies the smallest period between potential changes to the MPD. Format is a
   * duration string as specified in ISO 8601
   *
   * @param {string} value
   *        value of attribute as a string
   * @return {number}
   *         The duration in seconds
   */
  minimumUpdatePeriod(n) {
    return Jr(n);
  },
  /**
   * Specifies the suggested presentation delay. Format is a
   * duration string as specified in ISO 8601
   *
   * @param {string} value
   *        value of attribute as a string
   * @return {number}
   *         The duration in seconds
   */
  suggestedPresentationDelay(n) {
    return Jr(n);
  },
  /**
   * specifices the type of mpd. Can be either "static" or "dynamic"
   *
   * @param {string} value
   *        value of attribute as a string
   *
   * @return {string}
   *         The type as a string
   */
  type(n) {
    return n;
  },
  /**
   * Specifies the duration of the smallest time shifting buffer for any Representation
   * in the MPD. Format is a duration string as specified in ISO 8601
   *
   * @param {string} value
   *        value of attribute as a string
   * @return {number}
   *         The duration in seconds
   */
  timeShiftBufferDepth(n) {
    return Jr(n);
  },
  /**
   * Specifies the PeriodStart time of the Period relative to the availabilityStarttime.
   * Format is a duration string as specified in ISO 8601
   *
   * @param {string} value
   *        value of attribute as a string
   * @return {number}
   *         The duration in seconds
   */
  start(n) {
    return Jr(n);
  },
  /**
   * Specifies the width of the visual presentation
   *
   * @param {string} value
   *        value of attribute as a string
   * @return {number}
   *         The parsed width
   */
  width(n) {
    return parseInt(n, 10);
  },
  /**
   * Specifies the height of the visual presentation
   *
   * @param {string} value
   *        value of attribute as a string
   * @return {number}
   *         The parsed height
   */
  height(n) {
    return parseInt(n, 10);
  },
  /**
   * Specifies the bitrate of the representation
   *
   * @param {string} value
   *        value of attribute as a string
   * @return {number}
   *         The parsed bandwidth
   */
  bandwidth(n) {
    return parseInt(n, 10);
  },
  /**
   * Specifies the frame rate of the representation
   *
   * @param {string} value
   *        value of attribute as a string
   * @return {number}
   *         The parsed frame rate
   */
  frameRate(n) {
    return iR(n);
  },
  /**
   * Specifies the number of the first Media Segment in this Representation in the Period
   *
   * @param {string} value
   *        value of attribute as a string
   * @return {number}
   *         The parsed number
   */
  startNumber(n) {
    return parseInt(n, 10);
  },
  /**
   * Specifies the timescale in units per seconds
   *
   * @param {string} value
   *        value of attribute as a string
   * @return {number}
   *         The parsed timescale
   */
  timescale(n) {
    return parseInt(n, 10);
  },
  /**
   * Specifies the presentationTimeOffset.
   *
   * @param {string} value
   *        value of the attribute as a string
   *
   * @return {number}
   *         The parsed presentationTimeOffset
   */
  presentationTimeOffset(n) {
    return parseInt(n, 10);
  },
  /**
   * Specifies the constant approximate Segment duration
   * NOTE: The <Period> element also contains an @duration attribute. This duration
   *       specifies the duration of the Period. This attribute is currently not
   *       supported by the rest of the parser, however we still check for it to prevent
   *       errors.
   *
   * @param {string} value
   *        value of attribute as a string
   * @return {number}
   *         The parsed duration
   */
  duration(n) {
    const e = parseInt(n, 10);
    return isNaN(e) ? Jr(n) : e;
  },
  /**
   * Specifies the Segment duration, in units of the value of the @timescale.
   *
   * @param {string} value
   *        value of attribute as a string
   * @return {number}
   *         The parsed duration
   */
  d(n) {
    return parseInt(n, 10);
  },
  /**
   * Specifies the MPD start time, in @timescale units, the first Segment in the series
   * starts relative to the beginning of the Period
   *
   * @param {string} value
   *        value of attribute as a string
   * @return {number}
   *         The parsed time
   */
  t(n) {
    return parseInt(n, 10);
  },
  /**
   * Specifies the repeat count of the number of following contiguous Segments with the
   * same duration expressed by the value of @d
   *
   * @param {string} value
   *        value of attribute as a string
   * @return {number}
   *         The parsed number
   */
  r(n) {
    return parseInt(n, 10);
  },
  /**
   * Specifies the presentationTime.
   *
   * @param {string} value
   *        value of the attribute as a string
   *
   * @return {number}
   *         The parsed presentationTime
   */
  presentationTime(n) {
    return parseInt(n, 10);
  },
  /**
   * Default parser for all other attributes. Acts as a no-op and just returns the value
   * as a string
   *
   * @param {string} value
   *        value of attribute as a string
   * @return {string}
   *         Unparsed value
   */
  DEFAULT(n) {
    return n;
  }
}, Ft = (n) => n && n.attributes ? hD(n.attributes).reduce((e, t) => {
  const i = c_[t.name] || c_.DEFAULT;
  return e[t.name] = i(t.value), e;
}, {}) : {}, aR = {
  "urn:uuid:1077efec-c0b2-4d02-ace3-3c1e52e2fb4b": "org.w3.clearkey",
  "urn:uuid:edef8ba9-79d6-4ace-a3c8-27dcd51d21ed": "com.widevine.alpha",
  "urn:uuid:9a04f079-9840-4286-ab92-e65be0885f95": "com.microsoft.playready",
  "urn:uuid:f239e769-efa3-4850-9c16-a903c6932efb": "com.adobe.primetime",
  // ISO_IEC 23009-1_2022 5.8.5.2.2 The mp4 Protection Scheme
  "urn:mpeg:dash:mp4protection:2011": "mp4protection"
}, fl = (n, e) => e.length ? _a(n.map(function(t) {
  return e.map(function(i) {
    const r = po(i), a = zg(t.baseUrl, r), s = Wt(Ft(i), {
      baseUrl: a
    });
    return a !== r && !s.serviceLocation && t.serviceLocation && (s.serviceLocation = t.serviceLocation), s;
  });
})) : n, Kg = (n) => {
  const e = Ct(n, "SegmentTemplate")[0], t = Ct(n, "SegmentList")[0], i = t && Ct(t, "SegmentURL").map((h) => Wt({
    tag: "SegmentURL"
  }, Ft(h))), r = Ct(n, "SegmentBase")[0], a = t || e, s = a && Ct(a, "SegmentTimeline")[0], o = t || r || e, u = o && Ct(o, "Initialization")[0], c = e && Ft(e);
  c && u ? c.initialization = u && Ft(u) : c && c.initialization && (c.initialization = {
    sourceURL: c.initialization
  });
  const l = {
    template: c,
    segmentTimeline: s && Ct(s, "S").map((h) => Ft(h)),
    list: t && Wt(Ft(t), {
      segmentUrls: i,
      initialization: Ft(u)
    }),
    base: r && Wt(Ft(r), {
      initialization: Ft(u)
    })
  };
  return Object.keys(l).forEach((h) => {
    l[h] || delete l[h];
  }), l;
}, sR = (n, e, t) => (i) => {
  const r = Ct(i, "BaseURL"), a = fl(e, r), s = Wt(n, Ft(i)), o = Kg(i);
  return a.map((u) => ({
    segmentInfo: Wt(t, o),
    attributes: Wt(s, u)
  }));
}, oR = (n) => n.reduce((e, t) => {
  const i = Ft(t);
  i.schemeIdUri && (i.schemeIdUri = i.schemeIdUri.toLowerCase());
  const r = aR[i.schemeIdUri];
  if (r) {
    e[r] = {
      attributes: i
    };
    const a = Ct(t, "cenc:pssh")[0];
    if (a) {
      const s = po(a);
      e[r].pssh = s && vU(s);
    }
  }
  return e;
}, {}), uR = (n) => {
  if (n.schemeIdUri === "urn:scte:dash:cc:cea-608:2015")
    return (typeof n.value != "string" ? [] : n.value.split(";")).map((t) => {
      let i, r;
      return r = t, /^CC\d=/.test(t) ? [i, r] = t.split("=") : /^CC\d$/.test(t) && (i = t), {
        channel: i,
        language: r
      };
    });
  if (n.schemeIdUri === "urn:scte:dash:cc:cea-708:2015")
    return (typeof n.value != "string" ? [] : n.value.split(";")).map((t) => {
      const i = {
        // service or channel number 1-63
        channel: void 0,
        // language is a 3ALPHA per ISO 639.2/B
        // field is required
        language: void 0,
        // BIT 1/0 or ?
        // default value is 1, meaning 16:9 aspect ratio, 0 is 4:3, ? is unknown
        aspectRatio: 1,
        // BIT 1/0
        // easy reader flag indicated the text is tailed to the needs of beginning readers
        // default 0, or off
        easyReader: 0,
        // BIT 1/0
        // If 3d metadata is present (CEA-708.1) then 1
        // default 0
        "3D": 0
      };
      if (/=/.test(t)) {
        const [r, a = ""] = t.split("=");
        i.channel = r, i.language = t, a.split(",").forEach((s) => {
          const [o, u] = s.split(":");
          o === "lang" ? i.language = u : o === "er" ? i.easyReader = Number(u) : o === "war" ? i.aspectRatio = Number(u) : o === "3D" && (i["3D"] = Number(u));
        });
      } else
        i.language = t;
      return i.channel && (i.channel = "SERVICE" + i.channel), i;
    });
}, cR = (n) => _a(Ct(n.node, "EventStream").map((e) => {
  const t = Ft(e), i = t.schemeIdUri;
  return Ct(e, "Event").map((r) => {
    const a = Ft(r), s = a.presentationTime || 0, o = t.timescale || 1, u = a.duration || 0, c = s / o + n.attributes.start;
    return {
      schemeIdUri: i,
      value: t.value,
      id: a.id,
      start: c,
      end: c + u / o,
      messageData: po(r) || a.messageData,
      contentEncoding: t.contentEncoding,
      presentationTimeOffset: t.presentationTimeOffset || 0
    };
  });
})), lR = (n, e, t) => (i) => {
  const r = Ft(i), a = fl(e, Ct(i, "BaseURL")), s = Ct(i, "Role")[0], o = {
    role: Ft(s)
  };
  let u = Wt(n, r, o);
  const c = Ct(i, "Accessibility")[0], l = uR(Ft(c));
  l && (u = Wt(u, {
    captionServices: l
  }));
  const h = Ct(i, "Label")[0];
  if (h && h.childNodes.length) {
    const b = h.childNodes[0].nodeValue.trim();
    u = Wt(u, {
      label: b
    });
  }
  const f = oR(Ct(i, "ContentProtection"));
  Object.keys(f).length && (u = Wt(u, {
    contentProtection: f
  }));
  const d = Kg(i), y = Ct(i, "Representation"), m = Wt(t, d);
  return _a(y.map(sR(u, a, m)));
}, dR = (n, e) => (t, i) => {
  const r = fl(e, Ct(t.node, "BaseURL")), a = Wt(n, {
    periodStart: t.attributes.start
  });
  typeof t.attributes.duration == "number" && (a.periodDuration = t.attributes.duration);
  const s = Ct(t.node, "AdaptationSet"), o = Kg(t.node);
  return _a(s.map(lR(a, r, o)));
}, fR = (n, e) => {
  if (n.length > 1 && e({
    type: "warn",
    message: "The MPD manifest should contain no more than one ContentSteering tag"
  }), !n.length)
    return null;
  const t = Wt({
    serverURL: po(n[0])
  }, Ft(n[0]));
  return t.queryBeforeStart = t.queryBeforeStart === "true", t;
}, hR = ({
  attributes: n,
  priorPeriodAttributes: e,
  mpdType: t
}) => typeof n.start == "number" ? n.start : e && typeof e.start == "number" && typeof e.duration == "number" ? e.start + e.duration : !e && t === "static" ? 0 : null, pR = (n, e = {}) => {
  const {
    manifestUri: t = "",
    NOW: i = Date.now(),
    clientOffset: r = 0,
    // TODO: For now, we are expecting an eventHandler callback function
    // to be passed into the mpd parser as an option.
    // In the future, we should enable stream parsing by using the Stream class from vhs-utils.
    // This will support new features including a standardized event handler.
    // See the m3u8 parser for examples of how stream parsing is currently used for HLS parsing.
    // https://github.com/videojs/vhs-utils/blob/88d6e10c631e57a5af02c5a62bc7376cd456b4f5/src/stream.js#L9
    eventHandler: a = function() {
    }
  } = e, s = Ct(n, "Period");
  if (!s.length)
    throw new Error(Ta.INVALID_NUMBER_OF_PERIOD);
  const o = Ct(n, "Location"), u = Ft(n), c = fl([{
    baseUrl: t
  }], Ct(n, "BaseURL")), l = Ct(n, "ContentSteering");
  u.type = u.type || "static", u.sourceDuration = u.mediaPresentationDuration || 0, u.NOW = i, u.clientOffset = r, o.length && (u.locations = o.map(po));
  const h = [];
  return s.forEach((f, d) => {
    const y = Ft(f), m = h[d - 1];
    y.start = hR({
      attributes: y,
      priorPeriodAttributes: m ? m.attributes : null,
      mpdType: u.type
    }), h.push({
      node: f,
      attributes: y
    });
  }), {
    locations: u.locations,
    contentSteeringInfo: fR(l, a),
    // TODO: There are occurences where this `representationInfo` array contains undesired
    // duplicates. This generally occurs when there are multiple BaseURL nodes that are
    // direct children of the MPD node. When we attempt to resolve URLs from a combination of the
    // parent BaseURL and a child BaseURL, and the value does not resolve,
    // we end up returning the child BaseURL multiple times.
    // We need to determine a way to remove these duplicates in a safe way.
    // See: https://github.com/videojs/mpd-parser/pull/17#discussion_r162750527
    representationInfo: _a(h.map(dR(u, c))),
    eventStream: _a(h.map(cR))
  };
}, bD = (n) => {
  if (n === "")
    throw new Error(Ta.DASH_EMPTY_MANIFEST);
  const e = new EU.DOMParser();
  let t, i;
  try {
    t = e.parseFromString(n, "application/xml"), i = t && t.documentElement.tagName === "MPD" ? t.documentElement : null;
  } catch {
  }
  if (!i || i && i.getElementsByTagName("parsererror").length > 0)
    throw new Error(Ta.DASH_INVALID_XML);
  return i;
}, mR = (n) => {
  const e = Ct(n, "UTCTiming")[0];
  if (!e)
    return null;
  const t = Ft(e);
  switch (t.schemeIdUri) {
    case "urn:mpeg:dash:utc:http-head:2014":
    case "urn:mpeg:dash:utc:http-head:2012":
      t.method = "HEAD";
      break;
    case "urn:mpeg:dash:utc:http-xsdate:2014":
    case "urn:mpeg:dash:utc:http-iso:2014":
    case "urn:mpeg:dash:utc:http-xsdate:2012":
    case "urn:mpeg:dash:utc:http-iso:2012":
      t.method = "GET";
      break;
    case "urn:mpeg:dash:utc:direct:2014":
    case "urn:mpeg:dash:utc:direct:2012":
      t.method = "DIRECT", t.value = Date.parse(t.value);
      break;
    case "urn:mpeg:dash:utc:http-ntp:2014":
    case "urn:mpeg:dash:utc:ntp:2014":
    case "urn:mpeg:dash:utc:sntp:2014":
    default:
      throw new Error(Ta.UNSUPPORTED_UTC_TIMING_SCHEME);
  }
  return t;
}, gR = (n, e = {}) => {
  const t = pR(bD(n), e), i = nR(t.representationInfo);
  return GU({
    dashPlaylists: i,
    locations: t.locations,
    contentSteering: t.contentSteeringInfo,
    sidxMapping: e.sidxMapping,
    previousManifest: e.previousManifest,
    eventStream: t.eventStream
  });
}, bR = (n) => mR(bD(n));
var Tp, l_;
function yR() {
  if (l_) return Tp;
  l_ = 1;
  var n = Math.pow(2, 32), e = function(t) {
    var i = new DataView(t.buffer, t.byteOffset, t.byteLength), r;
    return i.getBigUint64 ? (r = i.getBigUint64(0), r < Number.MAX_SAFE_INTEGER ? Number(r) : r) : i.getUint32(0) * n + i.getUint32(4);
  };
  return Tp = {
    getUint64: e,
    MAX_UINT32: n
  }, Tp;
}
var wp, d_;
function vR() {
  if (d_) return wp;
  d_ = 1;
  var n = yR().getUint64, e = function(t) {
    var i = new DataView(t.buffer, t.byteOffset, t.byteLength), r = {
      version: t[0],
      flags: new Uint8Array(t.subarray(1, 4)),
      references: [],
      referenceId: i.getUint32(4),
      timescale: i.getUint32(8)
    }, a = 12;
    r.version === 0 ? (r.earliestPresentationTime = i.getUint32(a), r.firstOffset = i.getUint32(a + 4), a += 8) : (r.earliestPresentationTime = n(t.subarray(a)), r.firstOffset = n(t.subarray(a + 8)), a += 16), a += 2;
    var s = i.getUint16(a);
    for (a += 2; s > 0; a += 12, s--)
      r.references.push({
        referenceType: (t[a] & 128) >>> 7,
        referencedSize: i.getUint32(a) & 2147483647,
        subsegmentDuration: i.getUint32(a + 4),
        startsWithSap: !!(t[a + 8] & 128),
        sapType: (t[a + 8] & 112) >>> 4,
        sapDeltaTime: i.getUint32(a + 8) & 268435455
      });
    return r;
  };
  return wp = e, wp;
}
var xR = vR();
const _R = /* @__PURE__ */ Qt(xR);
var TR = Ke([73, 68, 51]), wR = function(e, t) {
  t === void 0 && (t = 0), e = Ke(e);
  var i = e[t + 5], r = e[t + 6] << 21 | e[t + 7] << 14 | e[t + 8] << 7 | e[t + 9], a = (i & 16) >> 4;
  return a ? r + 20 : r + 10;
}, ws = function n(e, t) {
  return t === void 0 && (t = 0), e = Ke(e), e.length - t < 10 || !St(e, TR, {
    offset: t
  }) ? t : (t += wR(e, t), n(e, t));
}, f_ = function(e) {
  return typeof e == "string" ? lD(e) : e;
}, ER = function(e) {
  return Array.isArray(e) ? e.map(function(t) {
    return f_(t);
  }) : [f_(e)];
}, DR = function n(e, t, i) {
  i === void 0 && (i = !1), t = ER(t), e = Ke(e);
  var r = [];
  if (!t.length)
    return r;
  for (var a = 0; a < e.length; ) {
    var s = (e[a] << 24 | e[a + 1] << 16 | e[a + 2] << 8 | e[a + 3]) >>> 0, o = e.subarray(a + 4, a + 8);
    if (s === 0)
      break;
    var u = a + s;
    if (u > e.length) {
      if (i)
        break;
      u = e.length;
    }
    var c = e.subarray(a + 8, u);
    St(o, t[0]) && (t.length === 1 ? r.push(c) : r.push.apply(r, n(c, t.slice(1), i))), a = u;
  }
  return r;
}, vu = {
  EBML: Ke([26, 69, 223, 163]),
  DocType: Ke([66, 130]),
  Segment: Ke([24, 83, 128, 103]),
  SegmentInfo: Ke([21, 73, 169, 102]),
  Tracks: Ke([22, 84, 174, 107]),
  Track: Ke([174]),
  TrackNumber: Ke([215]),
  DefaultDuration: Ke([35, 227, 131]),
  TrackEntry: Ke([174]),
  TrackType: Ke([131]),
  FlagDefault: Ke([136]),
  CodecID: Ke([134]),
  CodecPrivate: Ke([99, 162]),
  VideoTrack: Ke([224]),
  AudioTrack: Ke([225]),
  // Not used yet, but will be used for live webm/mkv
  // see https://www.matroska.org/technical/basics.html#block-structure
  // see https://www.matroska.org/technical/basics.html#simpleblock-structure
  Cluster: Ke([31, 67, 182, 117]),
  Timestamp: Ke([231]),
  TimestampScale: Ke([42, 215, 177]),
  BlockGroup: Ke([160]),
  BlockDuration: Ke([155]),
  Block: Ke([161]),
  SimpleBlock: Ke([163])
}, cm = [128, 64, 32, 16, 8, 4, 2, 1], SR = function(e) {
  for (var t = 1, i = 0; i < cm.length && !(e & cm[i]); i++)
    t++;
  return t;
}, uc = function(e, t, i, r) {
  i === void 0 && (i = !0), r === void 0 && (r = !1);
  var a = SR(e[t]), s = e.subarray(t, t + a);
  return i && (s = Array.prototype.slice.call(e, t, t + a), s[0] ^= cm[a - 1]), {
    length: a,
    value: fU(s, {
      signed: r
    }),
    bytes: s
  };
}, h_ = function n(e) {
  return typeof e == "string" ? e.match(/.{1,2}/g).map(function(t) {
    return n(t);
  }) : typeof e == "number" ? hU(e) : e;
}, CR = function(e) {
  return Array.isArray(e) ? e.map(function(t) {
    return h_(t);
  }) : [h_(e)];
}, AR = function n(e, t, i) {
  if (i >= t.length)
    return t.length;
  var r = uc(t, i, !1);
  if (St(e.bytes, r.bytes))
    return i;
  var a = uc(t, i + r.length);
  return n(e, t, i + a.length + a.value + r.length);
}, p_ = function n(e, t) {
  t = CR(t), e = Ke(e);
  var i = [];
  if (!t.length)
    return i;
  for (var r = 0; r < e.length; ) {
    var a = uc(e, r, !1), s = uc(e, r + a.length), o = r + a.length + s.length;
    s.value === 127 && (s.value = AR(a, e, o), s.value !== e.length && (s.value -= o));
    var u = o + s.value > e.length ? e.length : o + s.value, c = e.subarray(o, u);
    St(t[0], a.bytes) && (t.length === 1 ? i.push(c) : i = i.concat(n(c, t.slice(1))));
    var l = a.length + s.length + c.length;
    r += l;
  }
  return i;
}, kR = Ke([0, 0, 0, 1]), IR = Ke([0, 0, 1]), UR = Ke([0, 0, 3]), RR = function(e) {
  for (var t = [], i = 1; i < e.length - 2; )
    St(e.subarray(i, i + 3), UR) && (t.push(i + 2), i++), i++;
  if (t.length === 0)
    return e;
  var r = e.length - t.length, a = new Uint8Array(r), s = 0;
  for (i = 0; i < r; s++, i++)
    s === t[0] && (s++, t.shift()), a[i] = e[s];
  return a;
}, yD = function(e, t, i, r) {
  e = Ke(e), i = [].concat(i);
  for (var a = 0, s, o = 0; a < e.length && (o < r || s); ) {
    var u = void 0;
    if (St(e.subarray(a), kR) ? u = 4 : St(e.subarray(a), IR) && (u = 3), !u) {
      a++;
      continue;
    }
    if (o++, s)
      return RR(e.subarray(s, a));
    var c = void 0;
    t === "h264" ? c = e[a + u] & 31 : t === "h265" && (c = e[a + u] >> 1 & 63), i.indexOf(c) !== -1 && (s = a + u), a += u + (t === "h264" ? 1 : 2);
  }
  return e.subarray(0, 0);
}, OR = function(e, t, i) {
  return yD(e, "h264", t, i);
}, LR = function(e, t, i) {
  return yD(e, "h265", t, i);
}, sn = {
  // "webm" string literal in hex
  webm: Ke([119, 101, 98, 109]),
  // "matroska" string literal in hex
  matroska: Ke([109, 97, 116, 114, 111, 115, 107, 97]),
  // "fLaC" string literal in hex
  flac: Ke([102, 76, 97, 67]),
  // "OggS" string literal in hex
  ogg: Ke([79, 103, 103, 83]),
  // ac-3 sync byte, also works for ec-3 as that is simply a codec
  // of ac-3
  ac3: Ke([11, 119]),
  // "RIFF" string literal in hex used for wav and avi
  riff: Ke([82, 73, 70, 70]),
  // "AVI" string literal in hex
  avi: Ke([65, 86, 73]),
  // "WAVE" string literal in hex
  wav: Ke([87, 65, 86, 69]),
  // "ftyp3g" string literal in hex
  "3gp": Ke([102, 116, 121, 112, 51, 103]),
  // "ftyp" string literal in hex
  mp4: Ke([102, 116, 121, 112]),
  // "styp" string literal in hex
  fmp4: Ke([115, 116, 121, 112]),
  // "ftypqt" string literal in hex
  mov: Ke([102, 116, 121, 112, 113, 116]),
  // moov string literal in hex
  moov: Ke([109, 111, 111, 118]),
  // moof string literal in hex
  moof: Ke([109, 111, 111, 102])
}, wa = {
  aac: function(e) {
    var t = ws(e);
    return St(e, [255, 16], {
      offset: t,
      mask: [255, 22]
    });
  },
  mp3: function(e) {
    var t = ws(e);
    return St(e, [255, 2], {
      offset: t,
      mask: [255, 6]
    });
  },
  webm: function(e) {
    var t = p_(e, [vu.EBML, vu.DocType])[0];
    return St(t, sn.webm);
  },
  mkv: function(e) {
    var t = p_(e, [vu.EBML, vu.DocType])[0];
    return St(t, sn.matroska);
  },
  mp4: function(e) {
    if (wa["3gp"](e) || wa.mov(e))
      return !1;
    if (St(e, sn.mp4, {
      offset: 4
    }) || St(e, sn.fmp4, {
      offset: 4
    }) || St(e, sn.moof, {
      offset: 4
    }) || St(e, sn.moov, {
      offset: 4
    }))
      return !0;
  },
  mov: function(e) {
    return St(e, sn.mov, {
      offset: 4
    });
  },
  "3gp": function(e) {
    return St(e, sn["3gp"], {
      offset: 4
    });
  },
  ac3: function(e) {
    var t = ws(e);
    return St(e, sn.ac3, {
      offset: t
    });
  },
  ts: function(e) {
    if (e.length < 189 && e.length >= 1)
      return e[0] === 71;
    for (var t = 0; t + 188 < e.length && t < 188; ) {
      if (e[t] === 71 && e[t + 188] === 71)
        return !0;
      t += 1;
    }
    return !1;
  },
  flac: function(e) {
    var t = ws(e);
    return St(e, sn.flac, {
      offset: t
    });
  },
  ogg: function(e) {
    return St(e, sn.ogg);
  },
  avi: function(e) {
    return St(e, sn.riff) && St(e, sn.avi, {
      offset: 8
    });
  },
  wav: function(e) {
    return St(e, sn.riff) && St(e, sn.wav, {
      offset: 8
    });
  },
  h264: function(e) {
    return OR(e, 7, 3).length;
  },
  h265: function(e) {
    return LR(e, [32, 33], 3).length;
  }
}, lm = Object.keys(wa).filter(function(n) {
  return n !== "ts" && n !== "h264" && n !== "h265";
}).concat(["ts", "h264", "h265"]);
lm.forEach(function(n) {
  var e = wa[n];
  wa[n] = function(t) {
    return e(Ke(t));
  };
});
var PR = wa, Yg = function(e) {
  e = Ke(e);
  for (var t = 0; t < lm.length; t++) {
    var i = lm[t];
    if (PR[i](e))
      return i;
  }
  return "";
}, FR = function(e) {
  return DR(e, ["moof"]).length > 0;
}, Ep, m_;
function NR() {
  if (m_) return Ep;
  m_ = 1;
  var n = 9e4, e, t, i, r, a, s, o;
  return e = function(u) {
    return u * n;
  }, t = function(u, c) {
    return u * c;
  }, i = function(u) {
    return u / n;
  }, r = function(u, c) {
    return u / c;
  }, a = function(u, c) {
    return e(r(u, c));
  }, s = function(u, c) {
    return t(i(u), c);
  }, o = function(u, c, l) {
    return i(l ? u : u - c);
  }, Ep = {
    ONE_SECOND_IN_TS: n,
    secondsToVideoTs: e,
    secondsToAudioTs: t,
    videoTsToSeconds: i,
    audioTsToSeconds: r,
    audioTsToVideoTs: a,
    videoTsToAudioTs: s,
    metadataTsToSeconds: o
  }, Ep;
}
var Ar = NR();
/**
 * @license
 * Video.js 8.23.4 <http://videojs.com/>
 * Copyright Brightcove, Inc. <https://www.brightcove.com/>
 * Available under Apache License Version 2.0
 * <https://github.com/videojs/video.js/blob/main/LICENSE>
 *
 * Includes vtt.js <https://github.com/mozilla/vtt.js>
 * Available under Apache License Version 2.0
 * <https://github.com/mozilla/vtt.js/blob/main/LICENSE>
 */
var dm = "8.23.4";
const ki = {}, nr = function(n, e) {
  return ki[n] = ki[n] || [], e && (ki[n] = ki[n].concat(e)), ki[n];
}, MR = function(n, e) {
  nr(n, e);
}, vD = function(n, e) {
  const t = nr(n).indexOf(e);
  return t <= -1 ? !1 : (ki[n] = ki[n].slice(), ki[n].splice(t, 1), !0);
}, BR = function(n, e) {
  nr(n, [].concat(e).map((t) => {
    const i = (...r) => (vD(n, i), t(...r));
    return i;
  }));
}, cc = {
  prefixed: !0
}, Gu = [
  ["requestFullscreen", "exitFullscreen", "fullscreenElement", "fullscreenEnabled", "fullscreenchange", "fullscreenerror", "fullscreen"],
  // WebKit
  ["webkitRequestFullscreen", "webkitExitFullscreen", "webkitFullscreenElement", "webkitFullscreenEnabled", "webkitfullscreenchange", "webkitfullscreenerror", "-webkit-full-screen"]
], g_ = Gu[0];
let Es;
for (let n = 0; n < Gu.length; n++)
  if (Gu[n][1] in Be) {
    Es = Gu[n];
    break;
  }
if (Es) {
  for (let n = 0; n < Es.length; n++)
    cc[g_[n]] = Es[n];
  cc.prefixed = Es[0] !== g_[0];
}
let fn = [];
const jR = (n, e, t) => (i, r, a) => {
  const s = e.levels[r], o = new RegExp(`^(${s})$`);
  let u = n;
  if (i !== "log" && a.unshift(i.toUpperCase() + ":"), t && (u = `%c${n}`, a.unshift(t)), a.unshift(u + ":"), fn) {
    fn.push([].concat(a));
    const l = fn.length - 1e3;
    fn.splice(0, l > 0 ? l : 0);
  }
  if (!me.console)
    return;
  let c = me.console[i];
  !c && i === "debug" && (c = me.console.info || me.console.log), !(!c || !s || !o.test(i)) && c[Array.isArray(a) ? "apply" : "call"](me.console, a);
};
function fm(n, e = ":", t = "") {
  let i = "info", r;
  function a(...s) {
    r("log", i, s);
  }
  return r = jR(n, a, t), a.createLogger = (s, o, u) => {
    const c = o !== void 0 ? o : e, l = u !== void 0 ? u : t, h = `${n} ${c} ${s}`;
    return fm(h, c, l);
  }, a.createNewLogger = (s, o, u) => fm(s, o, u), a.levels = {
    all: "debug|log|warn|error",
    off: "",
    debug: "debug|log|warn|error",
    info: "log|warn|error",
    warn: "warn|error",
    error: "error",
    DEFAULT: i
  }, a.level = (s) => {
    if (typeof s == "string") {
      if (!a.levels.hasOwnProperty(s))
        throw new Error(`"${s}" in not a valid log level`);
      i = s;
    }
    return i;
  }, a.history = () => fn ? [].concat(fn) : [], a.history.filter = (s) => (fn || []).filter((o) => new RegExp(`.*${s}.*`).test(o[0])), a.history.clear = () => {
    fn && (fn.length = 0);
  }, a.history.disable = () => {
    fn !== null && (fn.length = 0, fn = null);
  }, a.history.enable = () => {
    fn === null && (fn = []);
  }, a.error = (...s) => r("error", i, s), a.warn = (...s) => r("warn", i, s), a.debug = (...s) => r("debug", i, s), a;
}
const at = fm("VIDEOJS"), xD = at.createLogger, qR = Object.prototype.toString, _D = function(n) {
  return xi(n) ? Object.keys(n) : [];
};
function ua(n, e) {
  _D(n).forEach((t) => e(n[t], t));
}
function TD(n, e, t = 0) {
  return _D(n).reduce((i, r) => e(i, n[r], r), t);
}
function xi(n) {
  return !!n && typeof n == "object";
}
function Ea(n) {
  return xi(n) && qR.call(n) === "[object Object]" && n.constructor === Object;
}
function yt(...n) {
  const e = {};
  return n.forEach((t) => {
    t && ua(t, (i, r) => {
      if (!Ea(i)) {
        e[r] = i;
        return;
      }
      Ea(e[r]) || (e[r] = {}), e[r] = yt(e[r], i);
    });
  }), e;
}
function wD(n = {}) {
  const e = [];
  for (const t in n)
    if (n.hasOwnProperty(t)) {
      const i = n[t];
      e.push(i);
    }
  return e;
}
function hl(n, e, t, i = !0) {
  const r = (s) => Object.defineProperty(n, e, {
    value: s,
    enumerable: !0,
    writable: !0
  }), a = {
    configurable: !0,
    enumerable: !0,
    get() {
      const s = t();
      return r(s), s;
    }
  };
  return i && (a.set = r), Object.defineProperty(n, e, a);
}
var WR = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  each: ua,
  reduce: TD,
  isObject: xi,
  isPlain: Ea,
  merge: yt,
  values: wD,
  defineLazyProperty: hl
});
let Qg = !1, ED = null, ai = !1, DD, SD = !1, ca = !1, la = !1, _i = !1, Zg = null, pl = null;
const VR = !!(me.cast && me.cast.framework && me.cast.framework.CastReceiverContext);
let CD = null, lc = !1, ml = !1, dc = !1, gl = !1, fc = !1, hc = !1, pc = !1;
const Qs = !!(Pa() && ("ontouchstart" in me || me.navigator.maxTouchPoints || me.DocumentTouch && me.document instanceof me.DocumentTouch)), $i = me.navigator && me.navigator.userAgentData;
$i && $i.platform && $i.brands && (ai = $i.platform === "Android", ca = !!$i.brands.find((n) => n.brand === "Microsoft Edge"), la = !!$i.brands.find((n) => n.brand === "Chromium"), _i = !ca && la, Zg = pl = ($i.brands.find((n) => n.brand === "Chromium") || {}).version || null, ml = $i.platform === "Windows");
if (!la) {
  const n = me.navigator && me.navigator.userAgent || "";
  Qg = /iPod/i.test(n), ED = (function() {
    const e = n.match(/OS (\d+)_/i);
    return e && e[1] ? e[1] : null;
  })(), ai = /Android/i.test(n), DD = (function() {
    const e = n.match(/Android (\d+)(?:\.(\d+))?(?:\.(\d+))*/i);
    if (!e)
      return null;
    const t = e[1] && parseFloat(e[1]), i = e[2] && parseFloat(e[2]);
    return t && i ? parseFloat(e[1] + "." + e[2]) : t || null;
  })(), SD = /Firefox/i.test(n), ca = /Edg/i.test(n), la = /Chrome/i.test(n) || /CriOS/i.test(n), _i = !ca && la, Zg = pl = (function() {
    const e = n.match(/(Chrome|CriOS)\/(\d+)/);
    return e && e[2] ? parseFloat(e[2]) : null;
  })(), CD = (function() {
    const e = /MSIE\s(\d+)\.\d/.exec(n);
    let t = e && parseFloat(e[1]);
    return !t && /Trident\/7.0/i.test(n) && /rv:11.0/.test(n) && (t = 11), t;
  })(), fc = /Tizen/i.test(n), hc = /Web0S/i.test(n), pc = fc || hc, lc = /Safari/i.test(n) && !_i && !ai && !ca && !pc, ml = /Windows/i.test(n), dc = /iPad/i.test(n) || lc && Qs && !/iPhone/i.test(n), gl = /iPhone/i.test(n) && !dc;
}
const Gt = gl || dc || Qg, bl = (lc || Gt) && !_i;
var AD = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  get IS_IPOD() {
    return Qg;
  },
  get IOS_VERSION() {
    return ED;
  },
  get IS_ANDROID() {
    return ai;
  },
  get ANDROID_VERSION() {
    return DD;
  },
  get IS_FIREFOX() {
    return SD;
  },
  get IS_EDGE() {
    return ca;
  },
  get IS_CHROMIUM() {
    return la;
  },
  get IS_CHROME() {
    return _i;
  },
  get CHROMIUM_VERSION() {
    return Zg;
  },
  get CHROME_VERSION() {
    return pl;
  },
  IS_CHROMECAST_RECEIVER: VR,
  get IE_VERSION() {
    return CD;
  },
  get IS_SAFARI() {
    return lc;
  },
  get IS_WINDOWS() {
    return ml;
  },
  get IS_IPAD() {
    return dc;
  },
  get IS_IPHONE() {
    return gl;
  },
  get IS_TIZEN() {
    return fc;
  },
  get IS_WEBOS() {
    return hc;
  },
  get IS_SMART_TV() {
    return pc;
  },
  TOUCH_ENABLED: Qs,
  IS_IOS: Gt,
  IS_ANY_SAFARI: bl
});
function b_(n) {
  return typeof n == "string" && !!n.trim();
}
function HR(n) {
  if (n.indexOf(" ") >= 0)
    throw new Error("class has illegal whitespace characters");
}
function Pa() {
  return Be === me.document;
}
function Fa(n) {
  return xi(n) && n.nodeType === 1;
}
function kD() {
  try {
    return me.parent !== me.self;
  } catch {
    return !0;
  }
}
function ID(n) {
  return function(e, t) {
    if (!b_(e))
      return Be[n](null);
    b_(t) && (t = Be.querySelector(t));
    const i = Fa(t) ? t : Be;
    return i[n] && i[n](e);
  };
}
function Ye(n = "div", e = {}, t = {}, i) {
  const r = Be.createElement(n);
  return Object.getOwnPropertyNames(e).forEach(function(a) {
    const s = e[a];
    a === "textContent" ? lr(r, s) : (r[a] !== s || a === "tabIndex") && (r[a] = s);
  }), Object.getOwnPropertyNames(t).forEach(function(a) {
    r.setAttribute(a, t[a]);
  }), i && Jg(r, i), r;
}
function lr(n, e) {
  return typeof n.textContent > "u" ? n.innerText = e : n.textContent = e, n;
}
function hm(n, e) {
  e.firstChild ? e.insertBefore(n, e.firstChild) : e.appendChild(n);
}
function Os(n, e) {
  return HR(e), n.classList.contains(e);
}
function Rr(n, ...e) {
  return n.classList.add(...e.reduce((t, i) => t.concat(i.split(/\s+/)), [])), n;
}
function yl(n, ...e) {
  return n ? (n.classList.remove(...e.reduce((t, i) => t.concat(i.split(/\s+/)), [])), n) : (at.warn("removeClass was called with an element that doesn't exist"), null);
}
function UD(n, e, t) {
  return typeof t == "function" && (t = t(n, e)), typeof t != "boolean" && (t = void 0), e.split(/\s+/).forEach((i) => n.classList.toggle(i, t)), n;
}
function RD(n, e) {
  Object.getOwnPropertyNames(e).forEach(function(t) {
    const i = e[t];
    i === null || typeof i > "u" || i === !1 ? n.removeAttribute(t) : n.setAttribute(t, i === !0 ? "" : i);
  });
}
function Ki(n) {
  const e = {}, t = ["autoplay", "controls", "playsinline", "loop", "muted", "default", "defaultMuted"];
  if (n && n.attributes && n.attributes.length > 0) {
    const i = n.attributes;
    for (let r = i.length - 1; r >= 0; r--) {
      const a = i[r].name;
      let s = i[r].value;
      t.includes(a) && (s = s !== null), e[a] = s;
    }
  }
  return e;
}
function OD(n, e) {
  return n.getAttribute(e);
}
function Da(n, e, t) {
  n.setAttribute(e, t);
}
function vl(n, e) {
  n.removeAttribute(e);
}
function LD() {
  Be.body.focus(), Be.onselectstart = function() {
    return !1;
  };
}
function PD() {
  Be.onselectstart = function() {
    return !0;
  };
}
function Sa(n) {
  if (n && n.getBoundingClientRect && n.parentNode) {
    const e = n.getBoundingClientRect(), t = {};
    return ["bottom", "height", "left", "right", "top", "width"].forEach((i) => {
      e[i] !== void 0 && (t[i] = e[i]);
    }), t.height || (t.height = parseFloat(Ca(n, "height"))), t.width || (t.width = parseFloat(Ca(n, "width"))), t;
  }
}
function Zs(n) {
  if (!n || n && !n.offsetParent)
    return {
      left: 0,
      top: 0,
      width: 0,
      height: 0
    };
  const e = n.offsetWidth, t = n.offsetHeight;
  let i = 0, r = 0;
  for (; n.offsetParent && n !== Be[cc.fullscreenElement]; )
    i += n.offsetLeft, r += n.offsetTop, n = n.offsetParent;
  return {
    left: i,
    top: r,
    width: e,
    height: t
  };
}
function xl(n, e) {
  const t = {
    x: 0,
    y: 0
  };
  if (Gt) {
    let l = n;
    for (; l && l.nodeName.toLowerCase() !== "html"; ) {
      const h = Ca(l, "transform");
      if (/^matrix/.test(h)) {
        const f = h.slice(7, -1).split(/,\s/).map(Number);
        t.x += f[4], t.y += f[5];
      } else if (/^matrix3d/.test(h)) {
        const f = h.slice(9, -1).split(/,\s/).map(Number);
        t.x += f[12], t.y += f[13];
      }
      if (l.assignedSlot && l.assignedSlot.parentElement && me.WebKitCSSMatrix) {
        const f = me.getComputedStyle(l.assignedSlot.parentElement).transform, d = new me.WebKitCSSMatrix(f);
        t.x += d.m41, t.y += d.m42;
      }
      l = l.parentNode || l.host;
    }
  }
  const i = {}, r = Zs(e.target), a = Zs(n), s = a.width, o = a.height;
  let u = e.offsetY - (a.top - r.top), c = e.offsetX - (a.left - r.left);
  return e.changedTouches && (c = e.changedTouches[0].pageX - a.left, u = e.changedTouches[0].pageY + a.top, Gt && (c -= t.x, u -= t.y)), i.y = 1 - Math.max(0, Math.min(1, u / o)), i.x = Math.max(0, Math.min(1, c / s)), i;
}
function FD(n) {
  return xi(n) && n.nodeType === 3;
}
function _l(n) {
  for (; n.firstChild; )
    n.removeChild(n.firstChild);
  return n;
}
function ND(n) {
  return typeof n == "function" && (n = n()), (Array.isArray(n) ? n : [n]).map((e) => {
    if (typeof e == "function" && (e = e()), Fa(e) || FD(e))
      return e;
    if (typeof e == "string" && /\S/.test(e))
      return Be.createTextNode(e);
  }).filter((e) => e);
}
function Jg(n, e) {
  return ND(e).forEach((t) => n.appendChild(t)), n;
}
function MD(n, e) {
  return Jg(_l(n), e);
}
function Js(n) {
  return n.button === void 0 && n.buttons === void 0 || n.button === 0 && n.buttons === void 0 || n.type === "mouseup" && n.button === 0 && n.buttons === 0 || n.type === "mousedown" && n.button === 0 && n.buttons === 0 ? !0 : !(n.button !== 0 || n.buttons !== 1);
}
const ir = ID("querySelector"), BD = ID("querySelectorAll");
function Ca(n, e) {
  if (!n || !e)
    return "";
  if (typeof me.getComputedStyle == "function") {
    let t;
    try {
      t = me.getComputedStyle(n);
    } catch {
      return "";
    }
    return t ? t.getPropertyValue(e) || t[e] : "";
  }
  return "";
}
function jD(n) {
  [...Be.styleSheets].forEach((e) => {
    try {
      const t = [...e.cssRules].map((r) => r.cssText).join(""), i = Be.createElement("style");
      i.textContent = t, n.document.head.appendChild(i);
    } catch {
      const i = Be.createElement("link");
      i.rel = "stylesheet", i.type = e.type, i.media = e.media.mediaText, i.href = e.href, n.document.head.appendChild(i);
    }
  });
}
var qD = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  isReal: Pa,
  isEl: Fa,
  isInFrame: kD,
  createEl: Ye,
  textContent: lr,
  prependTo: hm,
  hasClass: Os,
  addClass: Rr,
  removeClass: yl,
  toggleClass: UD,
  setAttributes: RD,
  getAttributes: Ki,
  getAttribute: OD,
  setAttribute: Da,
  removeAttribute: vl,
  blockTextSelection: LD,
  unblockTextSelection: PD,
  getBoundingClientRect: Sa,
  findPosition: Zs,
  getPointerPosition: xl,
  isTextNode: FD,
  emptyEl: _l,
  normalizeContent: ND,
  appendContent: Jg,
  insertContent: MD,
  isSingleLeftClick: Js,
  $: ir,
  $$: BD,
  computedStyle: Ca,
  copyStyleSheetsToWindow: jD
});
let WD = !1, pm;
const zR = function() {
  if (pm.options.autoSetup === !1)
    return;
  const n = Array.prototype.slice.call(Be.getElementsByTagName("video")), e = Array.prototype.slice.call(Be.getElementsByTagName("audio")), t = Array.prototype.slice.call(Be.getElementsByTagName("video-js")), i = n.concat(e, t);
  if (i && i.length > 0)
    for (let r = 0, a = i.length; r < a; r++) {
      const s = i[r];
      if (s && s.getAttribute)
        s.player === void 0 && s.getAttribute("data-setup") !== null && pm(s);
      else {
        mm(1);
        break;
      }
    }
  else WD || mm(1);
};
function mm(n, e) {
  Pa() && (e && (pm = e), me.setTimeout(zR, n));
}
function gm() {
  WD = !0, me.removeEventListener("load", gm);
}
Pa() && (Be.readyState === "complete" ? gm() : me.addEventListener("load", gm));
const VD = function(n) {
  const e = Be.createElement("style");
  return e.className = n, e;
}, HD = function(n, e) {
  n.styleSheet ? n.styleSheet.cssText = e : n.textContent = e;
};
var un = /* @__PURE__ */ new WeakMap();
const $R = 3;
let GR = $R;
function Mn() {
  return GR++;
}
function y_(n, e) {
  if (!un.has(n))
    return;
  const t = un.get(n);
  t.handlers[e].length === 0 && (delete t.handlers[e], n.removeEventListener ? n.removeEventListener(e, t.dispatcher, !1) : n.detachEvent && n.detachEvent("on" + e, t.dispatcher)), Object.getOwnPropertyNames(t.handlers).length <= 0 && (delete t.handlers, delete t.dispatcher, delete t.disabled), Object.getOwnPropertyNames(t).length === 0 && un.delete(n);
}
function e0(n, e, t, i) {
  t.forEach(function(r) {
    n(e, r, i);
  });
}
function Tl(n) {
  if (n.fixed_)
    return n;
  function e() {
    return !0;
  }
  function t() {
    return !1;
  }
  if (!n || !n.isPropagationStopped || !n.isImmediatePropagationStopped) {
    const i = n || me.event;
    n = {};
    const r = ["layerX", "layerY", "keyLocation", "path", "webkitMovementX", "webkitMovementY", "mozPressure", "mozInputSource"];
    for (const a in i)
      r.includes(a) || a === "returnValue" && i.preventDefault || (n[a] = i[a]);
    if (n.target || (n.target = n.srcElement || Be), n.relatedTarget || (n.relatedTarget = n.fromElement === n.target ? n.toElement : n.fromElement), n.preventDefault = function() {
      i.preventDefault && i.preventDefault(), n.returnValue = !1, i.returnValue = !1, n.defaultPrevented = !0;
    }, n.defaultPrevented = !1, n.stopPropagation = function() {
      i.stopPropagation && i.stopPropagation(), n.cancelBubble = !0, i.cancelBubble = !0, n.isPropagationStopped = e;
    }, n.isPropagationStopped = t, n.stopImmediatePropagation = function() {
      i.stopImmediatePropagation && i.stopImmediatePropagation(), n.isImmediatePropagationStopped = e, n.stopPropagation();
    }, n.isImmediatePropagationStopped = t, n.clientX !== null && n.clientX !== void 0) {
      const a = Be.documentElement, s = Be.body;
      n.pageX = n.clientX + (a && a.scrollLeft || s && s.scrollLeft || 0) - (a && a.clientLeft || s && s.clientLeft || 0), n.pageY = n.clientY + (a && a.scrollTop || s && s.scrollTop || 0) - (a && a.clientTop || s && s.clientTop || 0);
    }
    n.which = n.charCode || n.keyCode, n.button !== null && n.button !== void 0 && (n.button = n.button & 1 ? 0 : n.button & 4 ? 1 : n.button & 2 ? 2 : 0);
  }
  return n.fixed_ = !0, n;
}
let xu;
const XR = function() {
  if (typeof xu != "boolean") {
    xu = !1;
    try {
      const n = Object.defineProperty({}, "passive", {
        get() {
          xu = !0;
        }
      });
      me.addEventListener("test", null, n), me.removeEventListener("test", null, n);
    } catch {
    }
  }
  return xu;
}, KR = ["touchstart", "touchmove"];
function En(n, e, t) {
  if (Array.isArray(e))
    return e0(En, n, e, t);
  un.has(n) || un.set(n, {});
  const i = un.get(n);
  if (i.handlers || (i.handlers = {}), i.handlers[e] || (i.handlers[e] = []), t.guid || (t.guid = Mn()), i.handlers[e].push(t), i.dispatcher || (i.disabled = !1, i.dispatcher = function(r, a) {
    if (i.disabled)
      return;
    r = Tl(r);
    const s = i.handlers[r.type];
    if (s) {
      const o = s.slice(0);
      for (let u = 0, c = o.length; u < c && !r.isImmediatePropagationStopped(); u++)
        try {
          o[u].call(n, r, a);
        } catch (l) {
          at.error(l);
        }
    }
  }), i.handlers[e].length === 1)
    if (n.addEventListener) {
      let r = !1;
      XR() && KR.indexOf(e) > -1 && (r = {
        passive: !0
      }), n.addEventListener(e, i.dispatcher, r);
    } else n.attachEvent && n.attachEvent("on" + e, i.dispatcher);
}
function Xt(n, e, t) {
  if (!un.has(n))
    return;
  const i = un.get(n);
  if (!i.handlers)
    return;
  if (Array.isArray(e))
    return e0(Xt, n, e, t);
  const r = function(s, o) {
    i.handlers[o] = [], y_(s, o);
  };
  if (e === void 0) {
    for (const s in i.handlers)
      Object.prototype.hasOwnProperty.call(i.handlers || {}, s) && r(n, s);
    return;
  }
  const a = i.handlers[e];
  if (a) {
    if (!t) {
      r(n, e);
      return;
    }
    if (t.guid)
      for (let s = 0; s < a.length; s++)
        a[s].guid === t.guid && a.splice(s--, 1);
    y_(n, e);
  }
}
function Na(n, e, t) {
  const i = un.has(n) ? un.get(n) : {}, r = n.parentNode || n.ownerDocument;
  if (typeof e == "string" ? e = {
    type: e,
    target: n
  } : e.target || (e.target = n), e = Tl(e), i.dispatcher && i.dispatcher.call(n, e, t), r && !e.isPropagationStopped() && e.bubbles === !0)
    Na.call(null, r, e, t);
  else if (!r && !e.defaultPrevented && e.target && e.target[e.type]) {
    un.has(e.target) || un.set(e.target, {});
    const a = un.get(e.target);
    e.target[e.type] && (a.disabled = !0, typeof e.target[e.type] == "function" && e.target[e.type](), a.disabled = !1);
  }
  return !e.defaultPrevented;
}
function wl(n, e, t) {
  if (Array.isArray(e))
    return e0(wl, n, e, t);
  const i = function() {
    Xt(n, e, i), t.apply(this, arguments);
  };
  i.guid = t.guid = t.guid || Mn(), En(n, e, i);
}
function t0(n, e, t) {
  const i = function() {
    Xt(n, e, i), t.apply(this, arguments);
  };
  i.guid = t.guid = t.guid || Mn(), En(n, e, i);
}
var YR = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  fixEvent: Tl,
  on: En,
  off: Xt,
  trigger: Na,
  one: wl,
  any: t0
});
const Bn = 30, _t = function(n, e, t) {
  e.guid || (e.guid = Mn());
  const i = e.bind(n);
  return i.guid = t ? t + "_" + e.guid : e.guid, i;
}, Ti = function(n, e) {
  let t = me.performance.now();
  return function(...r) {
    const a = me.performance.now();
    a - t >= e && (n(...r), t = a);
  };
}, zD = function(n, e, t, i = me) {
  let r;
  const a = () => {
    i.clearTimeout(r), r = null;
  }, s = function() {
    const o = this, u = arguments;
    let c = function() {
      r = null, c = null, t || n.apply(o, u);
    };
    !r && t && n.apply(o, u), i.clearTimeout(r), r = i.setTimeout(c, e);
  };
  return s.cancel = a, s;
};
var QR = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  UPDATE_REFRESH_INTERVAL: Bn,
  bind_: _t,
  throttle: Ti,
  debounce: zD
});
let ys;
class Dn {
  /**
   * Adds an `event listener` to an instance of an `EventTarget`. An `event listener` is a
   * function that will get called when an event with a certain name gets triggered.
   *
   * @param {string|string[]} type
   *        An event name or an array of event names.
   *
   * @param {Function} fn
   *        The function to call with `EventTarget`s
   */
  on(e, t) {
    const i = this.addEventListener;
    this.addEventListener = () => {
    }, En(this, e, t), this.addEventListener = i;
  }
  /**
   * Removes an `event listener` for a specific event from an instance of `EventTarget`.
   * This makes it so that the `event listener` will no longer get called when the
   * named event happens.
   *
   * @param {string|string[]} type
   *        An event name or an array of event names.
   *
   * @param {Function} fn
   *        The function to remove.
   */
  off(e, t) {
    Xt(this, e, t);
  }
  /**
   * This function will add an `event listener` that gets triggered only once. After the
   * first trigger it will get removed. This is like adding an `event listener`
   * with {@link EventTarget#on} that calls {@link EventTarget#off} on itself.
   *
   * @param {string|string[]} type
   *        An event name or an array of event names.
   *
   * @param {Function} fn
   *        The function to be called once for each event name.
   */
  one(e, t) {
    const i = this.addEventListener;
    this.addEventListener = () => {
    }, wl(this, e, t), this.addEventListener = i;
  }
  /**
   * This function will add an `event listener` that gets triggered only once and is
   * removed from all events. This is like adding an array of `event listener`s
   * with {@link EventTarget#on} that calls {@link EventTarget#off} on all events the
   * first time it is triggered.
   *
   * @param {string|string[]} type
   *        An event name or an array of event names.
   *
   * @param {Function} fn
   *        The function to be called once for each event name.
   */
  any(e, t) {
    const i = this.addEventListener;
    this.addEventListener = () => {
    }, t0(this, e, t), this.addEventListener = i;
  }
  /**
   * This function causes an event to happen. This will then cause any `event listeners`
   * that are waiting for that event, to get called. If there are no `event listeners`
   * for an event then nothing will happen.
   *
   * If the name of the `Event` that is being triggered is in `EventTarget.allowedEvents_`.
   * Trigger will also call the `on` + `uppercaseEventName` function.
   *
   * Example:
   * 'click' is in `EventTarget.allowedEvents_`, so, trigger will attempt to call
   * `onClick` if it exists.
   *
   * @param {string|EventTarget~Event|Object} event
   *        The name of the event, an `Event`, or an object with a key of type set to
   *        an event name.
   */
  trigger(e) {
    const t = e.type || e;
    typeof e == "string" && (e = {
      type: t
    }), e = Tl(e), this.allowedEvents_[t] && this["on" + t] && this["on" + t](e), Na(this, e);
  }
  queueTrigger(e) {
    ys || (ys = /* @__PURE__ */ new Map());
    const t = e.type || e;
    let i = ys.get(this);
    i || (i = /* @__PURE__ */ new Map(), ys.set(this, i));
    const r = i.get(t);
    i.delete(t), me.clearTimeout(r);
    const a = me.setTimeout(() => {
      i.delete(t), i.size === 0 && (i = null, ys.delete(this)), this.trigger(e);
    }, 0);
    i.set(t, a);
  }
}
Dn.prototype.allowedEvents_ = {};
Dn.prototype.addEventListener = Dn.prototype.on;
Dn.prototype.removeEventListener = Dn.prototype.off;
Dn.prototype.dispatchEvent = Dn.prototype.trigger;
const El = (n) => typeof n.name == "function" ? n.name() : typeof n.name == "string" ? n.name : n.name_ ? n.name_ : n.constructor && n.constructor.name ? n.constructor.name : typeof n, Oi = (n) => n instanceof Dn || !!n.eventBusEl_ && ["on", "one", "off", "trigger"].every((e) => typeof n[e] == "function"), ZR = (n, e) => {
  Oi(n) ? e() : (n.eventedCallbacks || (n.eventedCallbacks = []), n.eventedCallbacks.push(e));
}, bm = (n) => (
  // The regex here verifies that the `type` contains at least one non-
  // whitespace character.
  typeof n == "string" && /\S/.test(n) || Array.isArray(n) && !!n.length
), mc = (n, e, t) => {
  if (!n || !n.nodeName && !Oi(n))
    throw new Error(`Invalid target for ${El(e)}#${t}; must be a DOM node or evented object.`);
}, $D = (n, e, t) => {
  if (!bm(n))
    throw new Error(`Invalid event type for ${El(e)}#${t}; must be a non-empty string or array.`);
}, GD = (n, e, t) => {
  if (typeof n != "function")
    throw new Error(`Invalid listener for ${El(e)}#${t}; must be a function.`);
}, Dp = (n, e, t) => {
  const i = e.length < 3 || e[0] === n || e[0] === n.eventBusEl_;
  let r, a, s;
  return i ? (r = n.eventBusEl_, e.length >= 3 && e.shift(), [a, s] = e) : (r = e[0], a = e[1], s = e[2]), mc(r, n, t), $D(a, n, t), GD(s, n, t), s = _t(n, s), {
    isTargetingSelf: i,
    target: r,
    type: a,
    listener: s
  };
}, Er = (n, e, t, i) => {
  mc(n, n, e), n.nodeName ? YR[e](n, t, i) : n[e](t, i);
}, JR = {
  /**
   * Add a listener to an event (or events) on this object or another evented
   * object.
   *
   * @param  {string|Array|Element|Object} targetOrType
   *         If this is a string or array, it represents the event type(s)
   *         that will trigger the listener.
   *
   *         Another evented object can be passed here instead, which will
   *         cause the listener to listen for events on _that_ object.
   *
   *         In either case, the listener's `this` value will be bound to
   *         this object.
   *
   * @param  {string|Array|Function} typeOrListener
   *         If the first argument was a string or array, this should be the
   *         listener function. Otherwise, this is a string or array of event
   *         type(s).
   *
   * @param  {Function} [listener]
   *         If the first argument was another evented object, this will be
   *         the listener function.
   */
  on(...n) {
    const {
      isTargetingSelf: e,
      target: t,
      type: i,
      listener: r
    } = Dp(this, n, "on");
    if (Er(t, "on", i, r), !e) {
      const a = () => this.off(t, i, r);
      a.guid = r.guid;
      const s = () => this.off("dispose", a);
      s.guid = r.guid, Er(this, "on", "dispose", a), Er(t, "on", "dispose", s);
    }
  },
  /**
   * Add a listener to an event (or events) on this object or another evented
   * object. The listener will be called once per event and then removed.
   *
   * @param  {string|Array|Element|Object} targetOrType
   *         If this is a string or array, it represents the event type(s)
   *         that will trigger the listener.
   *
   *         Another evented object can be passed here instead, which will
   *         cause the listener to listen for events on _that_ object.
   *
   *         In either case, the listener's `this` value will be bound to
   *         this object.
   *
   * @param  {string|Array|Function} typeOrListener
   *         If the first argument was a string or array, this should be the
   *         listener function. Otherwise, this is a string or array of event
   *         type(s).
   *
   * @param  {Function} [listener]
   *         If the first argument was another evented object, this will be
   *         the listener function.
   */
  one(...n) {
    const {
      isTargetingSelf: e,
      target: t,
      type: i,
      listener: r
    } = Dp(this, n, "one");
    if (e)
      Er(t, "one", i, r);
    else {
      const a = (...s) => {
        this.off(t, i, a), r.apply(null, s);
      };
      a.guid = r.guid, Er(t, "one", i, a);
    }
  },
  /**
   * Add a listener to an event (or events) on this object or another evented
   * object. The listener will only be called once for the first event that is triggered
   * then removed.
   *
   * @param  {string|Array|Element|Object} targetOrType
   *         If this is a string or array, it represents the event type(s)
   *         that will trigger the listener.
   *
   *         Another evented object can be passed here instead, which will
   *         cause the listener to listen for events on _that_ object.
   *
   *         In either case, the listener's `this` value will be bound to
   *         this object.
   *
   * @param  {string|Array|Function} typeOrListener
   *         If the first argument was a string or array, this should be the
   *         listener function. Otherwise, this is a string or array of event
   *         type(s).
   *
   * @param  {Function} [listener]
   *         If the first argument was another evented object, this will be
   *         the listener function.
   */
  any(...n) {
    const {
      isTargetingSelf: e,
      target: t,
      type: i,
      listener: r
    } = Dp(this, n, "any");
    if (e)
      Er(t, "any", i, r);
    else {
      const a = (...s) => {
        this.off(t, i, a), r.apply(null, s);
      };
      a.guid = r.guid, Er(t, "any", i, a);
    }
  },
  /**
   * Removes listener(s) from event(s) on an evented object.
   *
   * @param  {string|Array|Element|Object} [targetOrType]
   *         If this is a string or array, it represents the event type(s).
   *
   *         Another evented object can be passed here instead, in which case
   *         ALL 3 arguments are _required_.
   *
   * @param  {string|Array|Function} [typeOrListener]
   *         If the first argument was a string or array, this may be the
   *         listener function. Otherwise, this is a string or array of event
   *         type(s).
   *
   * @param  {Function} [listener]
   *         If the first argument was another evented object, this will be
   *         the listener function; otherwise, _all_ listeners bound to the
   *         event type(s) will be removed.
   */
  off(n, e, t) {
    if (!n || bm(n))
      Xt(this.eventBusEl_, n, e);
    else {
      const i = n, r = e;
      mc(i, this, "off"), $D(r, this, "off"), GD(t, this, "off"), t = _t(this, t), this.off("dispose", t), i.nodeName ? (Xt(i, r, t), Xt(i, "dispose", t)) : Oi(i) && (i.off(r, t), i.off("dispose", t));
    }
  },
  /**
   * Fire an event on this evented object, causing its listeners to be called.
   *
   * @param   {string|Object} event
   *          An event type or an object with a type property.
   *
   * @param   {Object} [hash]
   *          An additional object to pass along to listeners.
   *
   * @return {boolean}
   *          Whether or not the default behavior was prevented.
   */
  trigger(n, e) {
    mc(this.eventBusEl_, this, "trigger");
    const t = n && typeof n != "string" ? n.type : n;
    if (!bm(t))
      throw new Error(`Invalid event type for ${El(this)}#trigger; must be a non-empty string or object with a type key that has a non-empty value.`);
    return Na(this.eventBusEl_, n, e);
  }
};
function n0(n, e = {}) {
  const {
    eventBusKey: t
  } = e;
  if (t) {
    if (!n[t].nodeName)
      throw new Error(`The eventBusKey "${t}" does not refer to an element.`);
    n.eventBusEl_ = n[t];
  } else
    n.eventBusEl_ = Ye("span", {
      className: "vjs-event-bus"
    });
  return Object.assign(n, JR), n.eventedCallbacks && n.eventedCallbacks.forEach((i) => {
    i();
  }), n.on("dispose", () => {
    n.off(), [n, n.el_, n.eventBusEl_].forEach(function(i) {
      i && un.has(i) && un.delete(i);
    }), me.setTimeout(() => {
      n.eventBusEl_ = null;
    }, 0);
  }), n;
}
const eO = {
  /**
   * A hash containing arbitrary keys and values representing the state of
   * the object.
   *
   * @type {Object}
   */
  state: {},
  /**
   * Set the state of an object by mutating its
   * {@link module:stateful~StatefulMixin.state|state} object in place.
   *
   * @fires   module:stateful~StatefulMixin#statechanged
   * @param   {Object|Function} stateUpdates
   *          A new set of properties to shallow-merge into the plugin state.
   *          Can be a plain object or a function returning a plain object.
   *
   * @return {Object|undefined}
   *          An object containing changes that occurred. If no changes
   *          occurred, returns `undefined`.
   */
  setState(n) {
    typeof n == "function" && (n = n());
    let e;
    return ua(n, (t, i) => {
      this.state[i] !== t && (e = e || {}, e[i] = {
        from: this.state[i],
        to: t
      }), this.state[i] = t;
    }), e && Oi(this) && this.trigger({
      changes: e,
      type: "statechanged"
    }), e;
  }
};
function XD(n, e) {
  return Object.assign(n, eO), n.state = Object.assign({}, n.state, e), typeof n.handleStateChanged == "function" && Oi(n) && n.on("statechanged", n.handleStateChanged), n;
}
const Ls = function(n) {
  return typeof n != "string" ? n : n.replace(/./, (e) => e.toLowerCase());
}, Rt = function(n) {
  return typeof n != "string" ? n : n.replace(/./, (e) => e.toUpperCase());
}, KD = function(n, e) {
  return Rt(n) === Rt(e);
};
var tO = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  toLowerCase: Ls,
  toTitleCase: Rt,
  titleCaseEquals: KD
});
class Pe {
  /**
   * Creates an instance of this class.
   *
   * @param {Player} player
   *        The `Player` that this class should be attached to.
   *
   * @param {Object} [options]
   *        The key/value store of component options.
   *
   * @param {Object[]} [options.children]
   *        An array of children objects to initialize this component with. Children objects have
   *        a name property that will be used if more than one component of the same type needs to be
   *        added.
   *
   * @param  {string} [options.className]
   *         A class or space separated list of classes to add the component
   *
   * @param {ReadyCallback} [ready]
   *        Function that gets called when the `Component` is ready.
   */
  constructor(e, t, i) {
    if (!e && this.play ? this.player_ = e = this : this.player_ = e, this.isDisposed_ = !1, this.parentComponent_ = null, this.options_ = yt({}, this.options_), t = this.options_ = yt(this.options_, t), this.id_ = t.id || t.el && t.el.id, !this.id_) {
      const r = e && e.id && e.id() || "no_player";
      this.id_ = `${r}_component_${Mn()}`;
    }
    this.name_ = t.name || null, t.el ? this.el_ = t.el : t.createEl !== !1 && (this.el_ = this.createEl()), t.className && this.el_ && t.className.split(" ").forEach((r) => this.addClass(r)), ["on", "off", "one", "any", "trigger"].forEach((r) => {
      this[r] = void 0;
    }), t.evented !== !1 && (n0(this, {
      eventBusKey: this.el_ ? "el_" : null
    }), this.handleLanguagechange = this.handleLanguagechange.bind(this), this.on(this.player_, "languagechange", this.handleLanguagechange)), XD(this, this.constructor.defaultState), this.children_ = [], this.childIndex_ = {}, this.childNameIndex_ = {}, this.setTimeoutIds_ = /* @__PURE__ */ new Set(), this.setIntervalIds_ = /* @__PURE__ */ new Set(), this.rafIds_ = /* @__PURE__ */ new Set(), this.namedRafs_ = /* @__PURE__ */ new Map(), this.clearingTimersOnDispose_ = !1, t.initChildren !== !1 && this.initChildren(), this.ready(i), t.reportTouchActivity !== !1 && this.enableTouchActivity();
  }
  // `on`, `off`, `one`, `any` and `trigger` are here so tsc includes them in definitions.
  // They are replaced or removed in the constructor
  /**
   * Adds an `event listener` to an instance of an `EventTarget`. An `event listener` is a
   * function that will get called when an event with a certain name gets triggered.
   *
   * @param {string|string[]} type
   *        An event name or an array of event names.
   *
   * @param {Function} fn
   *        The function to call with `EventTarget`s
   */
  /**
   * Removes an `event listener` for a specific event from an instance of `EventTarget`.
   * This makes it so that the `event listener` will no longer get called when the
   * named event happens.
   *
   * @param {string|string[]} type
   *        An event name or an array of event names.
   *
   * @param {Function} [fn]
   *        The function to remove. If not specified, all listeners managed by Video.js will be removed.
   */
  /**
   * This function will add an `event listener` that gets triggered only once. After the
   * first trigger it will get removed. This is like adding an `event listener`
   * with {@link EventTarget#on} that calls {@link EventTarget#off} on itself.
   *
   * @param {string|string[]} type
   *        An event name or an array of event names.
   *
   * @param {Function} fn
   *        The function to be called once for each event name.
   */
  /**
   * This function will add an `event listener` that gets triggered only once and is
   * removed from all events. This is like adding an array of `event listener`s
   * with {@link EventTarget#on} that calls {@link EventTarget#off} on all events the
   * first time it is triggered.
   *
   * @param {string|string[]} type
   *        An event name or an array of event names.
   *
   * @param {Function} fn
   *        The function to be called once for each event name.
   */
  /**
   * This function causes an event to happen. This will then cause any `event listeners`
   * that are waiting for that event, to get called. If there are no `event listeners`
   * for an event then nothing will happen.
   *
   * If the name of the `Event` that is being triggered is in `EventTarget.allowedEvents_`.
   * Trigger will also call the `on` + `uppercaseEventName` function.
   *
   * Example:
   * 'click' is in `EventTarget.allowedEvents_`, so, trigger will attempt to call
   * `onClick` if it exists.
   *
   * @param {string|Event|Object} event
   *        The name of the event, an `Event`, or an object with a key of type set to
   *        an event name.
   *
   * @param {Object} [hash]
   *        Optionally extra argument to pass through to an event listener
   */
  /**
   * Dispose of the `Component` and all child components.
   *
   * @fires Component#dispose
   *
   * @param {Object} options
   * @param {Element} options.originalEl element with which to replace player element
   */
  dispose(e = {}) {
    if (!this.isDisposed_) {
      if (this.readyQueue_ && (this.readyQueue_.length = 0), this.trigger({
        type: "dispose",
        bubbles: !1
      }), this.isDisposed_ = !0, this.children_)
        for (let t = this.children_.length - 1; t >= 0; t--)
          this.children_[t].dispose && this.children_[t].dispose();
      this.children_ = null, this.childIndex_ = null, this.childNameIndex_ = null, this.parentComponent_ = null, this.el_ && (this.el_.parentNode && (e.restoreEl ? this.el_.parentNode.replaceChild(e.restoreEl, this.el_) : this.el_.parentNode.removeChild(this.el_)), this.el_ = null), this.player_ = null;
    }
  }
  /**
   * Determine whether or not this component has been disposed.
   *
   * @return {boolean}
   *         If the component has been disposed, will be `true`. Otherwise, `false`.
   */
  isDisposed() {
    return !!this.isDisposed_;
  }
  /**
   * Return the {@link Player} that the `Component` has attached to.
   *
   * @return {Player}
   *         The player that this `Component` has attached to.
   */
  player() {
    return this.player_;
  }
  /**
   * Deep merge of options objects with new options.
   * > Note: When both `obj` and `options` contain properties whose values are objects.
   *         The two properties get merged using {@link module:obj.merge}
   *
   * @param {Object} obj
   *        The object that contains new options.
   *
   * @return {Object}
   *         A new object of `this.options_` and `obj` merged together.
   */
  options(e) {
    return e ? (this.options_ = yt(this.options_, e), this.options_) : this.options_;
  }
  /**
   * Get the `Component`s DOM element
   *
   * @return {Element}
   *         The DOM element for this `Component`.
   */
  el() {
    return this.el_;
  }
  /**
   * Create the `Component`s DOM element.
   *
   * @param {string} [tagName]
   *        Element's DOM node type. e.g. 'div'
   *
   * @param {Object} [properties]
   *        An object of properties that should be set.
   *
   * @param {Object} [attributes]
   *        An object of attributes that should be set.
   *
   * @return {Element}
   *         The element that gets created.
   */
  createEl(e, t, i) {
    return Ye(e, t, i);
  }
  /**
   * Localize a string given the string in english.
   *
   * If tokens are provided, it'll try and run a simple token replacement on the provided string.
   * The tokens it looks for look like `{1}` with the index being 1-indexed into the tokens array.
   *
   * If a `defaultValue` is provided, it'll use that over `string`,
   * if a value isn't found in provided language files.
   * This is useful if you want to have a descriptive key for token replacement
   * but have a succinct localized string and not require `en.json` to be included.
   *
   * Currently, it is used for the progress bar timing.
   * ```js
   * {
   *   "progress bar timing: currentTime={1} duration={2}": "{1} of {2}"
   * }
   * ```
   * It is then used like so:
   * ```js
   * this.localize('progress bar timing: currentTime={1} duration{2}',
   *               [this.player_.currentTime(), this.player_.duration()],
   *               '{1} of {2}');
   * ```
   *
   * Which outputs something like: `01:23 of 24:56`.
   *
   *
   * @param {string} string
   *        The string to localize and the key to lookup in the language files.
   * @param {string[]} [tokens]
   *        If the current item has token replacements, provide the tokens here.
   * @param {string} [defaultValue]
   *        Defaults to `string`. Can be a default value to use for token replacement
   *        if the lookup key is needed to be separate.
   *
   * @return {string}
   *         The localized string or if no localization exists the english string.
   */
  localize(e, t, i = e) {
    const r = this.player_.language && this.player_.language(), a = this.player_.languages && this.player_.languages(), s = a && a[r], o = r && r.split("-")[0], u = a && a[o];
    let c = i;
    return s && s[e] ? c = s[e] : u && u[e] && (c = u[e]), t && (c = c.replace(/\{(\d+)\}/g, function(l, h) {
      const f = t[h - 1];
      let d = f;
      return typeof f > "u" && (d = l), d;
    })), c;
  }
  /**
   * Handles language change for the player in components. Should be overridden by sub-components.
   *
   * @abstract
   */
  handleLanguagechange() {
  }
  /**
   * Return the `Component`s DOM element. This is where children get inserted.
   * This will usually be the the same as the element returned in {@link Component#el}.
   *
   * @return {Element}
   *         The content element for this `Component`.
   */
  contentEl() {
    return this.contentEl_ || this.el_;
  }
  /**
   * Get this `Component`s ID
   *
   * @return {string}
   *         The id of this `Component`
   */
  id() {
    return this.id_;
  }
  /**
   * Get the `Component`s name. The name gets used to reference the `Component`
   * and is set during registration.
   *
   * @return {string}
   *         The name of this `Component`.
   */
  name() {
    return this.name_;
  }
  /**
   * Get an array of all child components
   *
   * @return {Array}
   *         The children
   */
  children() {
    return this.children_;
  }
  /**
   * Returns the child `Component` with the given `id`.
   *
   * @param {string} id
   *        The id of the child `Component` to get.
   *
   * @return {Component|undefined}
   *         The child `Component` with the given `id` or undefined.
   */
  getChildById(e) {
    return this.childIndex_[e];
  }
  /**
   * Returns the child `Component` with the given `name`.
   *
   * @param {string} name
   *        The name of the child `Component` to get.
   *
   * @return {Component|undefined}
   *         The child `Component` with the given `name` or undefined.
   */
  getChild(e) {
    if (e)
      return this.childNameIndex_[e];
  }
  /**
   * Returns the descendant `Component` following the givent
   * descendant `names`. For instance ['foo', 'bar', 'baz'] would
   * try to get 'foo' on the current component, 'bar' on the 'foo'
   * component and 'baz' on the 'bar' component and return undefined
   * if any of those don't exist.
   *
   * @param {...string[]|...string} names
   *        The name of the child `Component` to get.
   *
   * @return {Component|undefined}
   *         The descendant `Component` following the given descendant
   *         `names` or undefined.
   */
  getDescendant(...e) {
    e = e.reduce((i, r) => i.concat(r), []);
    let t = this;
    for (let i = 0; i < e.length; i++)
      if (t = t.getChild(e[i]), !t || !t.getChild)
        return;
    return t;
  }
  /**
   * Adds an SVG icon element to another element or component.
   *
   * @param {string} iconName
   *        The name of icon. A list of all the icon names can be found at 'sandbox/svg-icons.html'
   *
   * @param {Element} [el=this.el()]
   *        Element to set the title on. Defaults to the current Component's element.
   *
   * @return {Element}
   *        The newly created icon element.
   */
  setIcon(e, t = this.el()) {
    if (!this.player_.options_.experimentalSvgIcons)
      return;
    const i = "http://www.w3.org/2000/svg", r = Ye("span", {
      className: "vjs-icon-placeholder vjs-svg-icon"
    }, {
      "aria-hidden": "true"
    }), a = Be.createElementNS(i, "svg");
    a.setAttributeNS(null, "viewBox", "0 0 512 512");
    const s = Be.createElementNS(i, "use");
    return a.appendChild(s), s.setAttributeNS(null, "href", `#vjs-icon-${e}`), r.appendChild(a), this.iconIsSet_ ? t.replaceChild(r, t.querySelector(".vjs-icon-placeholder")) : t.appendChild(r), this.iconIsSet_ = !0, r;
  }
  /**
   * Add a child `Component` inside the current `Component`.
   *
   * @param {string|Component} child
   *        The name or instance of a child to add.
   *
   * @param {Object} [options={}]
   *        The key/value store of options that will get passed to children of
   *        the child.
   *
   * @param {number} [index=this.children_.length]
   *        The index to attempt to add a child into.
   *
   *
   * @return {Component}
   *         The `Component` that gets added as a child. When using a string the
   *         `Component` will get created by this process.
   */
  addChild(e, t = {}, i = this.children_.length) {
    let r, a;
    if (typeof e == "string") {
      a = Rt(e);
      const s = t.componentClass || a;
      t.name = a;
      const o = Pe.getComponent(s);
      if (!o)
        throw new Error(`Component ${s} does not exist`);
      if (typeof o != "function")
        return null;
      r = new o(this.player_ || this, t);
    } else
      r = e;
    if (r.parentComponent_ && r.parentComponent_.removeChild(r), this.children_.splice(i, 0, r), r.parentComponent_ = this, typeof r.id == "function" && (this.childIndex_[r.id()] = r), a = a || r.name && Rt(r.name()), a && (this.childNameIndex_[a] = r, this.childNameIndex_[Ls(a)] = r), typeof r.el == "function" && r.el()) {
      let s = null;
      this.children_[i + 1] && (this.children_[i + 1].el_ ? s = this.children_[i + 1].el_ : Fa(this.children_[i + 1]) && (s = this.children_[i + 1])), this.contentEl().insertBefore(r.el(), s);
    }
    return r;
  }
  /**
   * Remove a child `Component` from this `Component`s list of children. Also removes
   * the child `Component`s element from this `Component`s element.
   *
   * @param {string|Component} component
   *       The name or instance of a child to remove.
   */
  removeChild(e) {
    if (typeof e == "string" && (e = this.getChild(e)), !e || !this.children_)
      return;
    let t = !1;
    for (let r = this.children_.length - 1; r >= 0; r--)
      if (this.children_[r] === e) {
        t = !0, this.children_.splice(r, 1);
        break;
      }
    if (!t)
      return;
    e.parentComponent_ = null, this.childIndex_[e.id()] = null, this.childNameIndex_[Rt(e.name())] = null, this.childNameIndex_[Ls(e.name())] = null;
    const i = e.el();
    i && i.parentNode === this.contentEl() && this.contentEl().removeChild(e.el());
  }
  /**
   * Add and initialize default child `Component`s based upon options.
   */
  initChildren() {
    const e = this.options_.children;
    if (e) {
      const t = this.options_, i = (s) => {
        const o = s.name;
        let u = s.opts;
        if (t[o] !== void 0 && (u = t[o]), u === !1)
          return;
        u === !0 && (u = {}), u.playerOptions = this.options_.playerOptions;
        const c = this.addChild(o, u);
        c && (this[o] = c);
      };
      let r;
      const a = Pe.getComponent("Tech");
      Array.isArray(e) ? r = e : r = Object.keys(e), r.concat(Object.keys(this.options_).filter(function(s) {
        return !r.some(function(o) {
          return typeof o == "string" ? s === o : s === o.name;
        });
      })).map((s) => {
        let o, u;
        return typeof s == "string" ? (o = s, u = e[o] || this.options_[o] || {}) : (o = s.name, u = s), {
          name: o,
          opts: u
        };
      }).filter((s) => {
        const o = Pe.getComponent(s.opts.componentClass || Rt(s.name));
        return o && !a.isTech(o);
      }).forEach(i);
    }
  }
  /**
   * Builds the default DOM class name. Should be overridden by sub-components.
   *
   * @return {string}
   *         The DOM class name for this object.
   *
   * @abstract
   */
  buildCSSClass() {
    return "";
  }
  /**
   * Bind a listener to the component's ready state.
   * Different from event listeners in that if the ready event has already happened
   * it will trigger the function immediately.
   *
   * @param {ReadyCallback} fn
   *        Function that gets called when the `Component` is ready.
   */
  ready(e, t = !1) {
    if (e) {
      if (!this.isReady_) {
        this.readyQueue_ = this.readyQueue_ || [], this.readyQueue_.push(e);
        return;
      }
      t ? e.call(this) : this.setTimeout(e, 1);
    }
  }
  /**
   * Trigger all the ready listeners for this `Component`.
   *
   * @fires Component#ready
   */
  triggerReady() {
    this.isReady_ = !0, this.setTimeout(function() {
      const e = this.readyQueue_;
      this.readyQueue_ = [], e && e.length > 0 && e.forEach(function(t) {
        t.call(this);
      }, this), this.trigger("ready");
    }, 1);
  }
  /**
   * Find a single DOM element matching a `selector`. This can be within the `Component`s
   * `contentEl()` or another custom context.
   *
   * @param {string} selector
   *        A valid CSS selector, which will be passed to `querySelector`.
   *
   * @param {Element|string} [context=this.contentEl()]
   *        A DOM element within which to query. Can also be a selector string in
   *        which case the first matching element will get used as context. If
   *        missing `this.contentEl()` gets used. If  `this.contentEl()` returns
   *        nothing it falls back to `document`.
   *
   * @return {Element|null}
   *         the dom element that was found, or null
   *
   * @see [Information on CSS Selectors](https://developer.mozilla.org/en-US/docs/Web/Guide/CSS/Getting_Started/Selectors)
   */
  $(e, t) {
    return ir(e, t || this.contentEl());
  }
  /**
   * Finds all DOM element matching a `selector`. This can be within the `Component`s
   * `contentEl()` or another custom context.
   *
   * @param {string} selector
   *        A valid CSS selector, which will be passed to `querySelectorAll`.
   *
   * @param {Element|string} [context=this.contentEl()]
   *        A DOM element within which to query. Can also be a selector string in
   *        which case the first matching element will get used as context. If
   *        missing `this.contentEl()` gets used. If  `this.contentEl()` returns
   *        nothing it falls back to `document`.
   *
   * @return {NodeList}
   *         a list of dom elements that were found
   *
   * @see [Information on CSS Selectors](https://developer.mozilla.org/en-US/docs/Web/Guide/CSS/Getting_Started/Selectors)
   */
  $$(e, t) {
    return BD(e, t || this.contentEl());
  }
  /**
   * Check if a component's element has a CSS class name.
   *
   * @param {string} classToCheck
   *        CSS class name to check.
   *
   * @return {boolean}
   *         - True if the `Component` has the class.
   *         - False if the `Component` does not have the class`
   */
  hasClass(e) {
    return Os(this.el_, e);
  }
  /**
   * Add a CSS class name to the `Component`s element.
   *
   * @param {...string} classesToAdd
   *        One or more CSS class name to add.
   */
  addClass(...e) {
    Rr(this.el_, ...e);
  }
  /**
   * Remove a CSS class name from the `Component`s element.
   *
   * @param {...string} classesToRemove
   *        One or more CSS class name to remove.
   */
  removeClass(...e) {
    yl(this.el_, ...e);
  }
  /**
   * Add or remove a CSS class name from the component's element.
   * - `classToToggle` gets added when {@link Component#hasClass} would return false.
   * - `classToToggle` gets removed when {@link Component#hasClass} would return true.
   *
   * @param  {string} classToToggle
   *         The class to add or remove. Passed to DOMTokenList's toggle()
   *
   * @param  {boolean|Dom.PredicateCallback} [predicate]
   *         A boolean or function that returns a boolean. Passed to DOMTokenList's toggle().
   */
  toggleClass(e, t) {
    UD(this.el_, e, t);
  }
  /**
   * Show the `Component`s element if it is hidden by removing the
   * 'vjs-hidden' class name from it.
   */
  show() {
    this.removeClass("vjs-hidden");
  }
  /**
   * Hide the `Component`s element if it is currently showing by adding the
   * 'vjs-hidden` class name to it.
   */
  hide() {
    this.addClass("vjs-hidden");
  }
  /**
   * Lock a `Component`s element in its visible state by adding the 'vjs-lock-showing'
   * class name to it. Used during fadeIn/fadeOut.
   *
   * @private
   */
  lockShowing() {
    this.addClass("vjs-lock-showing");
  }
  /**
   * Unlock a `Component`s element from its visible state by removing the 'vjs-lock-showing'
   * class name from it. Used during fadeIn/fadeOut.
   *
   * @private
   */
  unlockShowing() {
    this.removeClass("vjs-lock-showing");
  }
  /**
   * Get the value of an attribute on the `Component`s element.
   *
   * @param {string} attribute
   *        Name of the attribute to get the value from.
   *
   * @return {string|null}
   *         - The value of the attribute that was asked for.
   *         - Can be an empty string on some browsers if the attribute does not exist
   *           or has no value
   *         - Most browsers will return null if the attribute does not exist or has
   *           no value.
   *
   * @see [DOM API]{@link https://developer.mozilla.org/en-US/docs/Web/API/Element/getAttribute}
   */
  getAttribute(e) {
    return OD(this.el_, e);
  }
  /**
   * Set the value of an attribute on the `Component`'s element
   *
   * @param {string} attribute
   *        Name of the attribute to set.
   *
   * @param {string} value
   *        Value to set the attribute to.
   *
   * @see [DOM API]{@link https://developer.mozilla.org/en-US/docs/Web/API/Element/setAttribute}
   */
  setAttribute(e, t) {
    Da(this.el_, e, t);
  }
  /**
   * Remove an attribute from the `Component`s element.
   *
   * @param {string} attribute
   *        Name of the attribute to remove.
   *
   * @see [DOM API]{@link https://developer.mozilla.org/en-US/docs/Web/API/Element/removeAttribute}
   */
  removeAttribute(e) {
    vl(this.el_, e);
  }
  /**
   * Get or set the width of the component based upon the CSS styles.
   * See {@link Component#dimension} for more detailed information.
   *
   * @param {number|string} [num]
   *        The width that you want to set postfixed with '%', 'px' or nothing.
   *
   * @param {boolean} [skipListeners]
   *        Skip the componentresize event trigger
   *
   * @return {number|undefined}
   *         The width when getting, zero if there is no width
   */
  width(e, t) {
    return this.dimension("width", e, t);
  }
  /**
   * Get or set the height of the component based upon the CSS styles.
   * See {@link Component#dimension} for more detailed information.
   *
   * @param {number|string} [num]
   *        The height that you want to set postfixed with '%', 'px' or nothing.
   *
   * @param {boolean} [skipListeners]
   *        Skip the componentresize event trigger
   *
   * @return {number|undefined}
   *         The height when getting, zero if there is no height
   */
  height(e, t) {
    return this.dimension("height", e, t);
  }
  /**
   * Set both the width and height of the `Component` element at the same time.
   *
   * @param  {number|string} width
   *         Width to set the `Component`s element to.
   *
   * @param  {number|string} height
   *         Height to set the `Component`s element to.
   */
  dimensions(e, t) {
    this.width(e, !0), this.height(t);
  }
  /**
   * Get or set width or height of the `Component` element. This is the shared code
   * for the {@link Component#width} and {@link Component#height}.
   *
   * Things to know:
   * - If the width or height in an number this will return the number postfixed with 'px'.
   * - If the width/height is a percent this will return the percent postfixed with '%'
   * - Hidden elements have a width of 0 with `window.getComputedStyle`. This function
   *   defaults to the `Component`s `style.width` and falls back to `window.getComputedStyle`.
   *   See [this]{@link http://www.foliotek.com/devblog/getting-the-width-of-a-hidden-element-with-jquery-using-width/}
   *   for more information
   * - If you want the computed style of the component, use {@link Component#currentWidth}
   *   and {@link {Component#currentHeight}
   *
   * @fires Component#componentresize
   *
   * @param {string} widthOrHeight
   8        'width' or 'height'
   *
   * @param  {number|string} [num]
   8         New dimension
   *
   * @param  {boolean} [skipListeners]
   *         Skip componentresize event trigger
   *
   * @return {number|undefined}
   *         The dimension when getting or 0 if unset
   */
  dimension(e, t, i) {
    if (t !== void 0) {
      (t === null || t !== t) && (t = 0), ("" + t).indexOf("%") !== -1 || ("" + t).indexOf("px") !== -1 ? this.el_.style[e] = t : t === "auto" ? this.el_.style[e] = "" : this.el_.style[e] = t + "px", i || this.trigger("componentresize");
      return;
    }
    if (!this.el_)
      return 0;
    const r = this.el_.style[e], a = r.indexOf("px");
    return parseInt(a !== -1 ? r.slice(0, a) : this.el_["offset" + Rt(e)], 10);
  }
  /**
   * Get the computed width or the height of the component's element.
   *
   * Uses `window.getComputedStyle`.
   *
   * @param {string} widthOrHeight
   *        A string containing 'width' or 'height'. Whichever one you want to get.
   *
   * @return {number}
   *         The dimension that gets asked for or 0 if nothing was set
   *         for that dimension.
   */
  currentDimension(e) {
    let t = 0;
    if (e !== "width" && e !== "height")
      throw new Error("currentDimension only accepts width or height value");
    if (t = Ca(this.el_, e), t = parseFloat(t), t === 0 || isNaN(t)) {
      const i = `offset${Rt(e)}`;
      t = this.el_[i];
    }
    return t;
  }
  /**
   * An object that contains width and height values of the `Component`s
   * computed style. Uses `window.getComputedStyle`.
   *
   * @typedef {Object} Component~DimensionObject
   *
   * @property {number} width
   *           The width of the `Component`s computed style.
   *
   * @property {number} height
   *           The height of the `Component`s computed style.
   */
  /**
   * Get an object that contains computed width and height values of the
   * component's element.
   *
   * Uses `window.getComputedStyle`.
   *
   * @return {Component~DimensionObject}
   *         The computed dimensions of the component's element.
   */
  currentDimensions() {
    return {
      width: this.currentDimension("width"),
      height: this.currentDimension("height")
    };
  }
  /**
   * Get the computed width of the component's element.
   *
   * Uses `window.getComputedStyle`.
   *
   * @return {number}
   *         The computed width of the component's element.
   */
  currentWidth() {
    return this.currentDimension("width");
  }
  /**
   * Get the computed height of the component's element.
   *
   * Uses `window.getComputedStyle`.
   *
   * @return {number}
   *         The computed height of the component's element.
   */
  currentHeight() {
    return this.currentDimension("height");
  }
  /**
   * Retrieves the position and size information of the component's element.
   *
   * @return {Object} An object with `boundingClientRect` and `center` properties.
   *         - `boundingClientRect`: An object with properties `x`, `y`, `width`,
   *           `height`, `top`, `right`, `bottom`, and `left`, representing
   *           the bounding rectangle of the element.
   *         - `center`: An object with properties `x` and `y`, representing
   *           the center point of the element. `width` and `height` are set to 0.
   */
  getPositions() {
    const e = this.el_.getBoundingClientRect(), t = {
      x: e.x,
      y: e.y,
      width: e.width,
      height: e.height,
      top: e.top,
      right: e.right,
      bottom: e.bottom,
      left: e.left
    }, i = {
      x: e.left + e.width / 2,
      y: e.top + e.height / 2,
      width: 0,
      height: 0,
      top: e.top + e.height / 2,
      right: e.left + e.width / 2,
      bottom: e.top + e.height / 2,
      left: e.left + e.width / 2
    };
    return {
      boundingClientRect: t,
      center: i
    };
  }
  /**
   * Set the focus to this component
   */
  focus() {
    this.el_.focus();
  }
  /**
   * Remove the focus from this component
   */
  blur() {
    this.el_.blur();
  }
  /**
   * When this Component receives a `keydown` event which it does not process,
   *  it passes the event to the Player for handling.
   *
   * @param {KeyboardEvent} event
   *        The `keydown` event that caused this function to be called.
   */
  handleKeyDown(e) {
    this.player_ && (e.key !== "Tab" && !(this.player_.options_.playerOptions.spatialNavigation && this.player_.options_.playerOptions.spatialNavigation.enabled) && e.stopPropagation(), this.player_.handleKeyDown(e));
  }
  /**
   * Many components used to have a `handleKeyPress` method, which was poorly
   * named because it listened to a `keydown` event. This method name now
   * delegates to `handleKeyDown`. This means anyone calling `handleKeyPress`
   * will not see their method calls stop working.
   *
   * @param {KeyboardEvent} event
   *        The event that caused this function to be called.
   */
  handleKeyPress(e) {
    this.handleKeyDown(e);
  }
  /**
   * Emit a 'tap' events when touch event support gets detected. This gets used to
   * support toggling the controls through a tap on the video. They get enabled
   * because every sub-component would have extra overhead otherwise.
   *
   * @protected
   * @fires Component#tap
   * @listens Component#touchstart
   * @listens Component#touchmove
   * @listens Component#touchleave
   * @listens Component#touchcancel
   * @listens Component#touchend
    */
  emitTapEvents() {
    let e = 0, t = null;
    const i = 10, r = 200;
    let a;
    this.on("touchstart", function(o) {
      o.touches.length === 1 && (t = {
        pageX: o.touches[0].pageX,
        pageY: o.touches[0].pageY
      }, e = me.performance.now(), a = !0);
    }), this.on("touchmove", function(o) {
      if (o.touches.length > 1)
        a = !1;
      else if (t) {
        const u = o.touches[0].pageX - t.pageX, c = o.touches[0].pageY - t.pageY;
        Math.sqrt(u * u + c * c) > i && (a = !1);
      }
    });
    const s = function() {
      a = !1;
    };
    this.on("touchleave", s), this.on("touchcancel", s), this.on("touchend", function(o) {
      t = null, a === !0 && me.performance.now() - e < r && (o.preventDefault(), this.trigger("tap"));
    });
  }
  /**
   * This function reports user activity whenever touch events happen. This can get
   * turned off by any sub-components that wants touch events to act another way.
   *
   * Report user touch activity when touch events occur. User activity gets used to
   * determine when controls should show/hide. It is simple when it comes to mouse
   * events, because any mouse event should show the controls. So we capture mouse
   * events that bubble up to the player and report activity when that happens.
   * With touch events it isn't as easy as `touchstart` and `touchend` toggle player
   * controls. So touch events can't help us at the player level either.
   *
   * User activity gets checked asynchronously. So what could happen is a tap event
   * on the video turns the controls off. Then the `touchend` event bubbles up to
   * the player. Which, if it reported user activity, would turn the controls right
   * back on. We also don't want to completely block touch events from bubbling up.
   * Furthermore a `touchmove` event and anything other than a tap, should not turn
   * controls back on.
   *
   * @listens Component#touchstart
   * @listens Component#touchmove
   * @listens Component#touchend
   * @listens Component#touchcancel
   */
  enableTouchActivity() {
    if (!this.player() || !this.player().reportUserActivity)
      return;
    const e = _t(this.player(), this.player().reportUserActivity);
    let t;
    this.on("touchstart", function() {
      e(), this.clearInterval(t), t = this.setInterval(e, 250);
    });
    const i = function(r) {
      e(), this.clearInterval(t);
    };
    this.on("touchmove", e), this.on("touchend", i), this.on("touchcancel", i);
  }
  /**
   * A callback that has no parameters and is bound into `Component`s context.
   *
   * @callback Component~GenericCallback
   * @this Component
   */
  /**
   * Creates a function that runs after an `x` millisecond timeout. This function is a
   * wrapper around `window.setTimeout`. There are a few reasons to use this one
   * instead though:
   * 1. It gets cleared via  {@link Component#clearTimeout} when
   *    {@link Component#dispose} gets called.
   * 2. The function callback will gets turned into a {@link Component~GenericCallback}
   *
   * > Note: You can't use `window.clearTimeout` on the id returned by this function. This
   *         will cause its dispose listener not to get cleaned up! Please use
   *         {@link Component#clearTimeout} or {@link Component#dispose} instead.
   *
   * @param {Component~GenericCallback} fn
   *        The function that will be run after `timeout`.
   *
   * @param {number} timeout
   *        Timeout in milliseconds to delay before executing the specified function.
   *
   * @return {number}
   *         Returns a timeout ID that gets used to identify the timeout. It can also
   *         get used in {@link Component#clearTimeout} to clear the timeout that
   *         was set.
   *
   * @listens Component#dispose
   * @see [Similar to]{@link https://developer.mozilla.org/en-US/docs/Web/API/WindowTimers/setTimeout}
   */
  setTimeout(e, t) {
    var i;
    return e = _t(this, e), this.clearTimersOnDispose_(), i = me.setTimeout(() => {
      this.setTimeoutIds_.has(i) && this.setTimeoutIds_.delete(i), e();
    }, t), this.setTimeoutIds_.add(i), i;
  }
  /**
   * Clears a timeout that gets created via `window.setTimeout` or
   * {@link Component#setTimeout}. If you set a timeout via {@link Component#setTimeout}
   * use this function instead of `window.clearTimout`. If you don't your dispose
   * listener will not get cleaned up until {@link Component#dispose}!
   *
   * @param {number} timeoutId
   *        The id of the timeout to clear. The return value of
   *        {@link Component#setTimeout} or `window.setTimeout`.
   *
   * @return {number}
   *         Returns the timeout id that was cleared.
   *
   * @see [Similar to]{@link https://developer.mozilla.org/en-US/docs/Web/API/WindowTimers/clearTimeout}
   */
  clearTimeout(e) {
    return this.setTimeoutIds_.has(e) && (this.setTimeoutIds_.delete(e), me.clearTimeout(e)), e;
  }
  /**
   * Creates a function that gets run every `x` milliseconds. This function is a wrapper
   * around `window.setInterval`. There are a few reasons to use this one instead though.
   * 1. It gets cleared via  {@link Component#clearInterval} when
   *    {@link Component#dispose} gets called.
   * 2. The function callback will be a {@link Component~GenericCallback}
   *
   * @param {Component~GenericCallback} fn
   *        The function to run every `x` seconds.
   *
   * @param {number} interval
   *        Execute the specified function every `x` milliseconds.
   *
   * @return {number}
   *         Returns an id that can be used to identify the interval. It can also be be used in
   *         {@link Component#clearInterval} to clear the interval.
   *
   * @listens Component#dispose
   * @see [Similar to]{@link https://developer.mozilla.org/en-US/docs/Web/API/WindowTimers/setInterval}
   */
  setInterval(e, t) {
    e = _t(this, e), this.clearTimersOnDispose_();
    const i = me.setInterval(e, t);
    return this.setIntervalIds_.add(i), i;
  }
  /**
   * Clears an interval that gets created via `window.setInterval` or
   * {@link Component#setInterval}. If you set an interval via {@link Component#setInterval}
   * use this function instead of `window.clearInterval`. If you don't your dispose
   * listener will not get cleaned up until {@link Component#dispose}!
   *
   * @param {number} intervalId
   *        The id of the interval to clear. The return value of
   *        {@link Component#setInterval} or `window.setInterval`.
   *
   * @return {number}
   *         Returns the interval id that was cleared.
   *
   * @see [Similar to]{@link https://developer.mozilla.org/en-US/docs/Web/API/WindowTimers/clearInterval}
   */
  clearInterval(e) {
    return this.setIntervalIds_.has(e) && (this.setIntervalIds_.delete(e), me.clearInterval(e)), e;
  }
  /**
   * Queues up a callback to be passed to requestAnimationFrame (rAF), but
   * with a few extra bonuses:
   *
   * - Supports browsers that do not support rAF by falling back to
   *   {@link Component#setTimeout}.
   *
   * - The callback is turned into a {@link Component~GenericCallback} (i.e.
   *   bound to the component).
   *
   * - Automatic cancellation of the rAF callback is handled if the component
   *   is disposed before it is called.
   *
   * @param  {Component~GenericCallback} fn
   *         A function that will be bound to this component and executed just
   *         before the browser's next repaint.
   *
   * @return {number}
   *         Returns an rAF ID that gets used to identify the timeout. It can
   *         also be used in {@link Component#cancelAnimationFrame} to cancel
   *         the animation frame callback.
   *
   * @listens Component#dispose
   * @see [Similar to]{@link https://developer.mozilla.org/en-US/docs/Web/API/window/requestAnimationFrame}
   */
  requestAnimationFrame(e) {
    this.clearTimersOnDispose_();
    var t;
    return e = _t(this, e), t = me.requestAnimationFrame(() => {
      this.rafIds_.has(t) && this.rafIds_.delete(t), e();
    }), this.rafIds_.add(t), t;
  }
  /**
   * Request an animation frame, but only one named animation
   * frame will be queued. Another will never be added until
   * the previous one finishes.
   *
   * @param {string} name
   *        The name to give this requestAnimationFrame
   *
   * @param  {Component~GenericCallback} fn
   *         A function that will be bound to this component and executed just
   *         before the browser's next repaint.
   */
  requestNamedAnimationFrame(e, t) {
    this.namedRafs_.has(e) && this.cancelNamedAnimationFrame(e), this.clearTimersOnDispose_(), t = _t(this, t);
    const i = this.requestAnimationFrame(() => {
      t(), this.namedRafs_.has(e) && this.namedRafs_.delete(e);
    });
    return this.namedRafs_.set(e, i), e;
  }
  /**
   * Cancels a current named animation frame if it exists.
   *
   * @param {string} name
   *        The name of the requestAnimationFrame to cancel.
   */
  cancelNamedAnimationFrame(e) {
    this.namedRafs_.has(e) && (this.cancelAnimationFrame(this.namedRafs_.get(e)), this.namedRafs_.delete(e));
  }
  /**
   * Cancels a queued callback passed to {@link Component#requestAnimationFrame}
   * (rAF).
   *
   * If you queue an rAF callback via {@link Component#requestAnimationFrame},
   * use this function instead of `window.cancelAnimationFrame`. If you don't,
   * your dispose listener will not get cleaned up until {@link Component#dispose}!
   *
   * @param {number} id
   *        The rAF ID to clear. The return value of {@link Component#requestAnimationFrame}.
   *
   * @return {number}
   *         Returns the rAF ID that was cleared.
   *
   * @see [Similar to]{@link https://developer.mozilla.org/en-US/docs/Web/API/window/cancelAnimationFrame}
   */
  cancelAnimationFrame(e) {
    return this.rafIds_.has(e) && (this.rafIds_.delete(e), me.cancelAnimationFrame(e)), e;
  }
  /**
   * A function to setup `requestAnimationFrame`, `setTimeout`,
   * and `setInterval`, clearing on dispose.
   *
   * > Previously each timer added and removed dispose listeners on it's own.
   * For better performance it was decided to batch them all, and use `Set`s
   * to track outstanding timer ids.
   *
   * @private
   */
  clearTimersOnDispose_() {
    this.clearingTimersOnDispose_ || (this.clearingTimersOnDispose_ = !0, this.one("dispose", () => {
      [["namedRafs_", "cancelNamedAnimationFrame"], ["rafIds_", "cancelAnimationFrame"], ["setTimeoutIds_", "clearTimeout"], ["setIntervalIds_", "clearInterval"]].forEach(([e, t]) => {
        this[e].forEach((i, r) => this[t](r));
      }), this.clearingTimersOnDispose_ = !1;
    }));
  }
  /**
    * Decide whether an element is actually disabled or not.
    *
    * @function isActuallyDisabled
    * @param element {Node}
    * @return {boolean}
    *
    * @see {@link https://html.spec.whatwg.org/multipage/semantics-other.html#concept-element-disabled}
    */
  getIsDisabled() {
    return !!this.el_.disabled;
  }
  /**
    * Decide whether the element is expressly inert or not.
    *
    * @see {@link https://html.spec.whatwg.org/multipage/interaction.html#expressly-inert}
    * @function isExpresslyInert
    * @param element {Node}
    * @return {boolean}
    */
  getIsExpresslyInert() {
    return this.el_.inert && !this.el_.ownerDocument.documentElement.inert;
  }
  /**
   * Determine whether or not this component can be considered as focusable component.
   *
   * @param {HTMLElement} el - The HTML element representing the component.
   * @return {boolean}
   *         If the component can be focused, will be `true`. Otherwise, `false`.
   */
  getIsFocusable(e) {
    return (e || this.el_).tabIndex >= 0 && !(this.getIsDisabled() || this.getIsExpresslyInert());
  }
  /**
   * Determine whether or not this component is currently visible/enabled/etc...
   *
   * @param {HTMLElement} el - The HTML element representing the component.
   * @return {boolean}
   *         If the component can is currently visible & enabled, will be `true`. Otherwise, `false`.
   */
  getIsAvailableToBeFocused(e) {
    function t(a) {
      const s = me.getComputedStyle(a, null), o = s.getPropertyValue("visibility");
      return s.getPropertyValue("display") !== "none" && !["hidden", "collapse"].includes(o);
    }
    function i(a) {
      return !(!t(a.parentElement) || !t(a) || a.style.opacity === "0" || me.getComputedStyle(a).height === "0px" || me.getComputedStyle(a).width === "0px");
    }
    function r(a) {
      if (a.offsetWidth + a.offsetHeight + a.getBoundingClientRect().height + a.getBoundingClientRect().width === 0)
        return !1;
      const s = {
        x: a.getBoundingClientRect().left + a.offsetWidth / 2,
        y: a.getBoundingClientRect().top + a.offsetHeight / 2
      };
      if (s.x < 0 || s.x > (Be.documentElement.clientWidth || me.innerWidth) || s.y < 0 || s.y > (Be.documentElement.clientHeight || me.innerHeight))
        return !1;
      let o = Be.elementFromPoint(s.x, s.y);
      for (; o; ) {
        if (o === a)
          return !0;
        if (o.parentNode)
          o = o.parentNode;
        else
          return !1;
      }
    }
    return e || (e = this.el()), !!(r(e) && i(e) && (!e.parentElement || e.tabIndex >= 0));
  }
  /**
   * Register a `Component` with `videojs` given the name and the component.
   *
   * > NOTE: {@link Tech}s should not be registered as a `Component`. {@link Tech}s
   *         should be registered using {@link Tech.registerTech} or
   *         {@link videojs:videojs.registerTech}.
   *
   * > NOTE: This function can also be seen on videojs as
   *         {@link videojs:videojs.registerComponent}.
   *
   * @param {string} name
   *        The name of the `Component` to register.
   *
   * @param {Component} ComponentToRegister
   *        The `Component` class to register.
   *
   * @return {Component}
   *         The `Component` that was registered.
   */
  static registerComponent(e, t) {
    if (typeof e != "string" || !e)
      throw new Error(`Illegal component name, "${e}"; must be a non-empty string.`);
    const i = Pe.getComponent("Tech"), r = i && i.isTech(t), a = Pe === t || Pe.prototype.isPrototypeOf(t.prototype);
    if (r || !a) {
      let o;
      throw r ? o = "techs must be registered using Tech.registerTech()" : o = "must be a Component subclass", new Error(`Illegal component, "${e}"; ${o}.`);
    }
    e = Rt(e), Pe.components_ || (Pe.components_ = {});
    const s = Pe.getComponent("Player");
    if (e === "Player" && s && s.players) {
      const o = s.players, u = Object.keys(o);
      if (o && u.length > 0) {
        for (let c = 0; c < u.length; c++)
          if (o[u[c]] !== null)
            throw new Error("Can not register Player component after player has been created.");
      }
    }
    return Pe.components_[e] = t, Pe.components_[Ls(e)] = t, t;
  }
  /**
   * Get a `Component` based on the name it was registered with.
   *
   * @param {string} name
   *        The Name of the component to get.
   *
   * @return {typeof Component}
   *         The `Component` that got registered under the given name.
   */
  static getComponent(e) {
    if (!(!e || !Pe.components_))
      return Pe.components_[e];
  }
}
Pe.registerComponent("Component", Pe);
function nO(n, e, t) {
  if (typeof e != "number" || e < 0 || e > t)
    throw new Error(`Failed to execute '${n}' on 'TimeRanges': The index provided (${e}) is non-numeric or out of bounds (0-${t}).`);
}
function v_(n, e, t, i) {
  return nO(n, i, t.length - 1), t[i][e];
}
function Sp(n) {
  let e;
  return n === void 0 || n.length === 0 ? e = {
    length: 0,
    start() {
      throw new Error("This TimeRanges object is empty");
    },
    end() {
      throw new Error("This TimeRanges object is empty");
    }
  } : e = {
    length: n.length,
    start: v_.bind(null, "start", 0, n),
    end: v_.bind(null, "end", 1, n)
  }, me.Symbol && me.Symbol.iterator && (e[me.Symbol.iterator] = () => (n || []).values()), e;
}
function ii(n, e) {
  return Array.isArray(n) ? Sp(n) : n === void 0 || e === void 0 ? Sp() : Sp([[n, e]]);
}
const YD = function(n, e) {
  n = n < 0 ? 0 : n;
  let t = Math.floor(n % 60), i = Math.floor(n / 60 % 60), r = Math.floor(n / 3600);
  const a = Math.floor(e / 60 % 60), s = Math.floor(e / 3600);
  return (isNaN(n) || n === 1 / 0) && (r = i = t = "-"), r = r > 0 || s > 0 ? r + ":" : "", i = ((r || a >= 10) && i < 10 ? "0" + i : i) + ":", t = t < 10 ? "0" + t : t, r + i + t;
};
let i0 = YD;
function QD(n) {
  i0 = n;
}
function ZD() {
  i0 = YD;
}
function Nr(n, e = n) {
  return i0(n, e);
}
var iO = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  createTimeRanges: ii,
  createTimeRange: ii,
  setFormatTime: QD,
  resetFormatTime: ZD,
  formatTime: Nr
});
function JD(n, e) {
  let t = 0, i, r;
  if (!e)
    return 0;
  (!n || !n.length) && (n = ii(0, 0));
  for (let a = 0; a < n.length; a++)
    i = n.start(a), r = n.end(a), r > e && (r = e), t += r - i;
  return t / e;
}
function It(n) {
  if (n instanceof It)
    return n;
  typeof n == "number" ? this.code = n : typeof n == "string" ? this.message = n : xi(n) && (typeof n.code == "number" && (this.code = n.code), Object.assign(this, n)), this.message || (this.message = It.defaultMessages[this.code] || "");
}
It.prototype.code = 0;
It.prototype.message = "";
It.prototype.status = null;
It.prototype.metadata = null;
It.errorTypes = ["MEDIA_ERR_CUSTOM", "MEDIA_ERR_ABORTED", "MEDIA_ERR_NETWORK", "MEDIA_ERR_DECODE", "MEDIA_ERR_SRC_NOT_SUPPORTED", "MEDIA_ERR_ENCRYPTED"];
It.defaultMessages = {
  1: "You aborted the media playback",
  2: "A network error caused the media download to fail part-way.",
  3: "The media playback was aborted due to a corruption problem or because the media used features your browser did not support.",
  4: "The media could not be loaded, either because the server or network failed or because the format is not supported.",
  5: "The media is encrypted and we do not have the keys to decrypt it."
};
It.MEDIA_ERR_CUSTOM = 0;
It.prototype.MEDIA_ERR_CUSTOM = 0;
It.MEDIA_ERR_ABORTED = 1;
It.prototype.MEDIA_ERR_ABORTED = 1;
It.MEDIA_ERR_NETWORK = 2;
It.prototype.MEDIA_ERR_NETWORK = 2;
It.MEDIA_ERR_DECODE = 3;
It.prototype.MEDIA_ERR_DECODE = 3;
It.MEDIA_ERR_SRC_NOT_SUPPORTED = 4;
It.prototype.MEDIA_ERR_SRC_NOT_SUPPORTED = 4;
It.MEDIA_ERR_ENCRYPTED = 5;
It.prototype.MEDIA_ERR_ENCRYPTED = 5;
function Ps(n) {
  return n != null && typeof n.then == "function";
}
function mi(n) {
  Ps(n) && n.then(null, (e) => {
  });
}
const ym = function(n) {
  return ["kind", "label", "language", "id", "inBandMetadataTrackDispatchType", "mode", "src"].reduce((t, i, r) => (n[i] && (t[i] = n[i]), t), {
    cues: n.cues && Array.prototype.map.call(n.cues, function(t) {
      return {
        startTime: t.startTime,
        endTime: t.endTime,
        text: t.text,
        id: t.id
      };
    })
  });
}, rO = function(n) {
  const e = n.$$("track"), t = Array.prototype.map.call(e, (r) => r.track);
  return Array.prototype.map.call(e, function(r) {
    const a = ym(r.track);
    return r.src && (a.src = r.src), a;
  }).concat(Array.prototype.filter.call(n.textTracks(), function(r) {
    return t.indexOf(r) === -1;
  }).map(ym));
}, aO = function(n, e) {
  return n.forEach(function(t) {
    const i = e.addRemoteTextTrack(t).track;
    !t.src && t.cues && t.cues.forEach((r) => i.addCue(r));
  }), e.textTracks();
};
var vm = {
  textTracksToJson: rO,
  jsonToTextTracks: aO,
  trackToJson: ym
};
const Cp = "vjs-modal-dialog";
class Ma extends Pe {
  /**
   * Creates an instance of this class.
   *
   * @param {Player} player
   *        The `Player` that this class should be attached to.
   *
   * @param {Object} [options]
   *        The key/value store of player options.
   *
   * @param {ContentDescriptor} [options.content=undefined]
   *        Provide customized content for this modal.
   *
   * @param {string} [options.description]
   *        A text description for the modal, primarily for accessibility.
   *
   * @param {boolean} [options.fillAlways=false]
   *        Normally, modals are automatically filled only the first time
   *        they open. This tells the modal to refresh its content
   *        every time it opens.
   *
   * @param {string} [options.label]
   *        A text label for the modal, primarily for accessibility.
   *
   * @param {boolean} [options.pauseOnOpen=true]
   *        If `true`, playback will will be paused if playing when
   *        the modal opens, and resumed when it closes.
   *
   * @param {boolean} [options.temporary=true]
   *        If `true`, the modal can only be opened once; it will be
   *        disposed as soon as it's closed.
   *
   * @param {boolean} [options.uncloseable=false]
   *        If `true`, the user will not be able to close the modal
   *        through the UI in the normal ways. Programmatic closing is
   *        still possible.
   */
  constructor(e, t) {
    super(e, t), this.handleKeyDown_ = (i) => this.handleKeyDown(i), this.close_ = (i) => this.close(i), this.opened_ = this.hasBeenOpened_ = this.hasBeenFilled_ = !1, this.closeable(!this.options_.uncloseable), this.content(this.options_.content), this.contentEl_ = Ye("div", {
      className: `${Cp}-content`
    }, {
      role: "document"
    }), this.descEl_ = Ye("p", {
      className: `${Cp}-description vjs-control-text`,
      id: this.el().getAttribute("aria-describedby")
    }), lr(this.descEl_, this.description()), this.el_.appendChild(this.descEl_), this.el_.appendChild(this.contentEl_);
  }
  /**
   * Create the `ModalDialog`'s DOM element
   *
   * @return {Element}
   *         The DOM element that gets created.
   */
  createEl() {
    return super.createEl("div", {
      className: this.buildCSSClass(),
      tabIndex: -1
    }, {
      "aria-describedby": `${this.id()}_description`,
      "aria-hidden": "true",
      "aria-label": this.label(),
      role: "dialog",
      "aria-live": "polite"
    });
  }
  dispose() {
    this.contentEl_ = null, this.descEl_ = null, this.previouslyActiveEl_ = null, super.dispose();
  }
  /**
   * Builds the default DOM `className`.
   *
   * @return {string}
   *         The DOM `className` for this object.
   */
  buildCSSClass() {
    return `${Cp} vjs-hidden ${super.buildCSSClass()}`;
  }
  /**
   * Returns the label string for this modal. Primarily used for accessibility.
   *
   * @return {string}
   *         the localized or raw label of this modal.
   */
  label() {
    return this.localize(this.options_.label || "Modal Window");
  }
  /**
   * Returns the description string for this modal. Primarily used for
   * accessibility.
   *
   * @return {string}
   *         The localized or raw description of this modal.
   */
  description() {
    let e = this.options_.description || this.localize("This is a modal window.");
    return this.closeable() && (e += " " + this.localize("This modal can be closed by pressing the Escape key or activating the close button.")), e;
  }
  /**
   * Opens the modal.
   *
   * @fires ModalDialog#beforemodalopen
   * @fires ModalDialog#modalopen
   */
  open() {
    if (this.opened_) {
      this.options_.fillAlways && this.fill();
      return;
    }
    const e = this.player();
    this.trigger("beforemodalopen"), this.opened_ = !0, (this.options_.fillAlways || !this.hasBeenOpened_ && !this.hasBeenFilled_) && this.fill(), this.wasPlaying_ = !e.paused(), this.options_.pauseOnOpen && this.wasPlaying_ && e.pause(), this.on("keydown", this.handleKeyDown_), this.hadControls_ = e.controls(), e.controls(!1), this.show(), this.conditionalFocus_(), this.el().setAttribute("aria-hidden", "false"), this.trigger("modalopen"), this.hasBeenOpened_ = !0;
  }
  /**
   * If the `ModalDialog` is currently open or closed.
   *
   * @param  {boolean} [value]
   *         If given, it will open (`true`) or close (`false`) the modal.
   *
   * @return {boolean}
   *         the current open state of the modaldialog
   */
  opened(e) {
    return typeof e == "boolean" && this[e ? "open" : "close"](), this.opened_;
  }
  /**
   * Closes the modal, does nothing if the `ModalDialog` is
   * not open.
   *
   * @fires ModalDialog#beforemodalclose
   * @fires ModalDialog#modalclose
   */
  close() {
    if (!this.opened_)
      return;
    const e = this.player();
    this.trigger("beforemodalclose"), this.opened_ = !1, this.wasPlaying_ && this.options_.pauseOnOpen && e.play(), this.off("keydown", this.handleKeyDown_), this.hadControls_ && e.controls(!0), this.hide(), this.el().setAttribute("aria-hidden", "true"), this.trigger({
      type: "modalclose",
      bubbles: !0
    }), this.conditionalBlur_(), this.options_.temporary && this.dispose();
  }
  /**
   * Check to see if the `ModalDialog` is closeable via the UI.
   *
   * @param  {boolean} [value]
   *         If given as a boolean, it will set the `closeable` option.
   *
   * @return {boolean}
   *         Returns the final value of the closable option.
   */
  closeable(e) {
    if (typeof e == "boolean") {
      const t = this.closeable_ = !!e;
      let i = this.getChild("closeButton");
      if (t && !i) {
        const r = this.contentEl_;
        this.contentEl_ = this.el_, i = this.addChild("closeButton", {
          controlText: "Close Modal Dialog"
        }), this.contentEl_ = r, this.on(i, "close", this.close_);
      }
      !t && i && (this.off(i, "close", this.close_), this.removeChild(i), i.dispose());
    }
    return this.closeable_;
  }
  /**
   * Fill the modal's content element with the modal's "content" option.
   * The content element will be emptied before this change takes place.
   */
  fill() {
    this.fillWith(this.content());
  }
  /**
   * Fill the modal's content element with arbitrary content.
   * The content element will be emptied before this change takes place.
   *
   * @fires ModalDialog#beforemodalfill
   * @fires ModalDialog#modalfill
   *
   * @param {ContentDescriptor} [content]
   *        The same rules apply to this as apply to the `content` option.
   */
  fillWith(e) {
    const t = this.contentEl(), i = t.parentNode, r = t.nextSibling;
    this.trigger("beforemodalfill"), this.hasBeenFilled_ = !0, i.removeChild(t), this.empty(), MD(t, e), this.trigger("modalfill"), r ? i.insertBefore(t, r) : i.appendChild(t);
    const a = this.getChild("closeButton");
    a && i.appendChild(a.el_), this.trigger("aftermodalfill");
  }
  /**
   * Empties the content element. This happens anytime the modal is filled.
   *
   * @fires ModalDialog#beforemodalempty
   * @fires ModalDialog#modalempty
   */
  empty() {
    this.trigger("beforemodalempty"), _l(this.contentEl()), this.trigger("modalempty");
  }
  /**
   * Gets or sets the modal content, which gets normalized before being
   * rendered into the DOM.
   *
   * This does not update the DOM or fill the modal, but it is called during
   * that process.
   *
   * @param  {ContentDescriptor} [value]
   *         If defined, sets the internal content value to be used on the
   *         next call(s) to `fill`. This value is normalized before being
   *         inserted. To "clear" the internal content value, pass `null`.
   *
   * @return {ContentDescriptor}
   *         The current content of the modal dialog
   */
  content(e) {
    return typeof e < "u" && (this.content_ = e), this.content_;
  }
  /**
   * conditionally focus the modal dialog if focus was previously on the player.
   *
   * @private
   */
  conditionalFocus_() {
    const e = Be.activeElement, t = this.player_.el_;
    this.previouslyActiveEl_ = null, (t.contains(e) || t === e) && (this.previouslyActiveEl_ = e, this.focus());
  }
  /**
   * conditionally blur the element and refocus the last focused element
   *
   * @private
   */
  conditionalBlur_() {
    this.previouslyActiveEl_ && (this.previouslyActiveEl_.focus(), this.previouslyActiveEl_ = null);
  }
  /**
   * Keydown handler. Attached when modal is focused.
   *
   * @listens keydown
   */
  handleKeyDown(e) {
    if (this.trigger({
      type: "modalKeydown",
      originalEvent: e,
      target: this,
      bubbles: !0
    }), e.stopPropagation(), e.key === "Escape" && this.closeable()) {
      e.preventDefault(), this.close();
      return;
    }
    if (e.key !== "Tab")
      return;
    const t = this.focusableEls_(), i = this.el_.querySelector(":focus");
    let r;
    for (let a = 0; a < t.length; a++)
      if (i === t[a]) {
        r = a;
        break;
      }
    Be.activeElement === this.el_ && (r = 0), e.shiftKey && r === 0 ? (t[t.length - 1].focus(), e.preventDefault()) : !e.shiftKey && r === t.length - 1 && (t[0].focus(), e.preventDefault());
  }
  /**
   * get all focusable elements
   *
   * @private
   */
  focusableEls_() {
    const e = this.el_.querySelectorAll("*");
    return Array.prototype.filter.call(e, (t) => (t instanceof me.HTMLAnchorElement || t instanceof me.HTMLAreaElement) && t.hasAttribute("href") || (t instanceof me.HTMLInputElement || t instanceof me.HTMLSelectElement || t instanceof me.HTMLTextAreaElement || t instanceof me.HTMLButtonElement) && !t.hasAttribute("disabled") || t instanceof me.HTMLIFrameElement || t instanceof me.HTMLObjectElement || t instanceof me.HTMLEmbedElement || t.hasAttribute("tabindex") && t.getAttribute("tabindex") !== -1 || t.hasAttribute("contenteditable"));
  }
}
Ma.prototype.options_ = {
  pauseOnOpen: !0,
  temporary: !0
};
Pe.registerComponent("ModalDialog", Ma);
class Mr extends Dn {
  /**
   * Create an instance of this class
   *
   * @param { Track[] } tracks
   *        A list of tracks to initialize the list with.
   *
   * @abstract
   */
  constructor(e = []) {
    super(), this.tracks_ = [], Object.defineProperty(this, "length", {
      get() {
        return this.tracks_.length;
      }
    });
    for (let t = 0; t < e.length; t++)
      this.addTrack(e[t]);
  }
  /**
   * Add a {@link Track} to the `TrackList`
   *
   * @param {Track} track
   *        The audio, video, or text track to add to the list.
   *
   * @fires TrackList#addtrack
   */
  addTrack(e) {
    const t = this.tracks_.length;
    "" + t in this || Object.defineProperty(this, t, {
      get() {
        return this.tracks_[t];
      }
    }), this.tracks_.indexOf(e) === -1 && (this.tracks_.push(e), this.trigger({
      track: e,
      type: "addtrack",
      target: this
    })), e.labelchange_ = () => {
      this.trigger({
        track: e,
        type: "labelchange",
        target: this
      });
    }, Oi(e) && e.addEventListener("labelchange", e.labelchange_);
  }
  /**
   * Remove a {@link Track} from the `TrackList`
   *
   * @param {Track} rtrack
   *        The audio, video, or text track to remove from the list.
   *
   * @fires TrackList#removetrack
   */
  removeTrack(e) {
    let t;
    for (let i = 0, r = this.length; i < r; i++)
      if (this[i] === e) {
        t = this[i], t.off && t.off(), this.tracks_.splice(i, 1);
        break;
      }
    t && this.trigger({
      track: t,
      type: "removetrack",
      target: this
    });
  }
  /**
   * Get a Track from the TrackList by a tracks id
   *
   * @param {string} id - the id of the track to get
   * @method getTrackById
   * @return {Track}
   * @private
   */
  getTrackById(e) {
    let t = null;
    for (let i = 0, r = this.length; i < r; i++) {
      const a = this[i];
      if (a.id === e) {
        t = a;
        break;
      }
    }
    return t;
  }
}
Mr.prototype.allowedEvents_ = {
  change: "change",
  addtrack: "addtrack",
  removetrack: "removetrack",
  labelchange: "labelchange"
};
for (const n in Mr.prototype.allowedEvents_)
  Mr.prototype["on" + n] = null;
const Ap = function(n, e) {
  for (let t = 0; t < n.length; t++)
    !Object.keys(n[t]).length || e.id === n[t].id || (n[t].enabled = !1);
};
class eS extends Mr {
  /**
   * Create an instance of this class.
   *
   * @param {AudioTrack[]} [tracks=[]]
   *        A list of `AudioTrack` to instantiate the list with.
   */
  constructor(e = []) {
    for (let t = e.length - 1; t >= 0; t--)
      if (e[t].enabled) {
        Ap(e, e[t]);
        break;
      }
    super(e), this.changing_ = !1;
  }
  /**
   * Add an {@link AudioTrack} to the `AudioTrackList`.
   *
   * @param {AudioTrack} track
   *        The AudioTrack to add to the list
   *
   * @fires TrackList#addtrack
   */
  addTrack(e) {
    e.enabled && Ap(this, e), super.addTrack(e), e.addEventListener && (e.enabledChange_ = () => {
      this.changing_ || (this.changing_ = !0, Ap(this, e), this.changing_ = !1, this.trigger("change"));
    }, e.addEventListener("enabledchange", e.enabledChange_));
  }
  removeTrack(e) {
    super.removeTrack(e), e.removeEventListener && e.enabledChange_ && (e.removeEventListener("enabledchange", e.enabledChange_), e.enabledChange_ = null);
  }
}
const kp = function(n, e) {
  for (let t = 0; t < n.length; t++)
    !Object.keys(n[t]).length || e.id === n[t].id || (n[t].selected = !1);
};
class tS extends Mr {
  /**
   * Create an instance of this class.
   *
   * @param {VideoTrack[]} [tracks=[]]
   *        A list of `VideoTrack` to instantiate the list with.
   */
  constructor(e = []) {
    for (let t = e.length - 1; t >= 0; t--)
      if (e[t].selected) {
        kp(e, e[t]);
        break;
      }
    super(e), this.changing_ = !1, Object.defineProperty(this, "selectedIndex", {
      get() {
        for (let t = 0; t < this.length; t++)
          if (this[t].selected)
            return t;
        return -1;
      },
      set() {
      }
    });
  }
  /**
   * Add a {@link VideoTrack} to the `VideoTrackList`.
   *
   * @param {VideoTrack} track
   *        The VideoTrack to add to the list
   *
   * @fires TrackList#addtrack
   */
  addTrack(e) {
    e.selected && kp(this, e), super.addTrack(e), e.addEventListener && (e.selectedChange_ = () => {
      this.changing_ || (this.changing_ = !0, kp(this, e), this.changing_ = !1, this.trigger("change"));
    }, e.addEventListener("selectedchange", e.selectedChange_));
  }
  removeTrack(e) {
    super.removeTrack(e), e.removeEventListener && e.selectedChange_ && (e.removeEventListener("selectedchange", e.selectedChange_), e.selectedChange_ = null);
  }
}
class r0 extends Mr {
  /**
   * Add a {@link TextTrack} to the `TextTrackList`
   *
   * @param {TextTrack} track
   *        The text track to add to the list.
   *
   * @fires TrackList#addtrack
   */
  addTrack(e) {
    super.addTrack(e), this.queueChange_ || (this.queueChange_ = () => this.queueTrigger("change")), this.triggerSelectedlanguagechange || (this.triggerSelectedlanguagechange_ = () => this.trigger("selectedlanguagechange")), e.addEventListener("modechange", this.queueChange_), ["metadata", "chapters"].indexOf(e.kind) === -1 && e.addEventListener("modechange", this.triggerSelectedlanguagechange_);
  }
  removeTrack(e) {
    super.removeTrack(e), e.removeEventListener && (this.queueChange_ && e.removeEventListener("modechange", this.queueChange_), this.selectedlanguagechange_ && e.removeEventListener("modechange", this.triggerSelectedlanguagechange_));
  }
  /**
   * Creates a serializable array of objects that contains serialized copies
   * of each text track.
   *
   * @return {Object[]} A serializable list of objects for the text track list
   */
  toJSON() {
    return this.tracks_.map((e) => e.toJSON());
  }
}
class sO {
  /**
   * Create an instance of this class.
   *
   * @param {HtmlTrackElement[]} [tracks=[]]
   *        A list of `HtmlTrackElement` to instantiate the list with.
   */
  constructor(e = []) {
    this.trackElements_ = [], Object.defineProperty(this, "length", {
      get() {
        return this.trackElements_.length;
      }
    });
    for (let t = 0, i = e.length; t < i; t++)
      this.addTrackElement_(e[t]);
  }
  /**
   * Add an {@link HtmlTrackElement} to the `HtmlTrackElementList`
   *
   * @param {HtmlTrackElement} trackElement
   *        The track element to add to the list.
   *
   * @private
   */
  addTrackElement_(e) {
    const t = this.trackElements_.length;
    "" + t in this || Object.defineProperty(this, t, {
      get() {
        return this.trackElements_[t];
      }
    }), this.trackElements_.indexOf(e) === -1 && this.trackElements_.push(e);
  }
  /**
   * Get an {@link HtmlTrackElement} from the `HtmlTrackElementList` given an
   * {@link TextTrack}.
   *
   * @param {TextTrack} track
   *        The track associated with a track element.
   *
   * @return {HtmlTrackElement|undefined}
   *         The track element that was found or undefined.
   *
   * @private
   */
  getTrackElementByTrack_(e) {
    let t;
    for (let i = 0, r = this.trackElements_.length; i < r; i++)
      if (e === this.trackElements_[i].track) {
        t = this.trackElements_[i];
        break;
      }
    return t;
  }
  /**
   * Remove a {@link HtmlTrackElement} from the `HtmlTrackElementList`
   *
   * @param {HtmlTrackElement} trackElement
   *        The track element to remove from the list.
   *
   * @private
   */
  removeTrackElement_(e) {
    for (let t = 0, i = this.trackElements_.length; t < i; t++)
      if (e === this.trackElements_[t]) {
        this.trackElements_[t].track && typeof this.trackElements_[t].track.off == "function" && this.trackElements_[t].track.off(), typeof this.trackElements_[t].off == "function" && this.trackElements_[t].off(), this.trackElements_.splice(t, 1);
        break;
      }
  }
}
class gc {
  /**
   * Create an instance of this class..
   *
   * @param {Array} cues
   *        A list of cues to be initialized with
   */
  constructor(e) {
    gc.prototype.setCues_.call(this, e), Object.defineProperty(this, "length", {
      get() {
        return this.length_;
      }
    });
  }
  /**
   * A setter for cues in this list. Creates getters
   * an an index for the cues.
   *
   * @param {Array} cues
   *        An array of cues to set
   *
   * @private
   */
  setCues_(e) {
    const t = this.length || 0;
    let i = 0;
    const r = e.length;
    this.cues_ = e, this.length_ = e.length;
    const a = function(s) {
      "" + s in this || Object.defineProperty(this, "" + s, {
        get() {
          return this.cues_[s];
        }
      });
    };
    if (t < r)
      for (i = t; i < r; i++)
        a.call(this, i);
  }
  /**
   * Get a `TextTrackCue` that is currently in the `TextTrackCueList` by id.
   *
   * @param {string} id
   *        The id of the cue that should be searched for.
   *
   * @return {TextTrackCueList~TextTrackCue|null}
   *         A single cue or null if none was found.
   */
  getCueById(e) {
    let t = null;
    for (let i = 0, r = this.length; i < r; i++) {
      const a = this[i];
      if (a.id === e) {
        t = a;
        break;
      }
    }
    return t;
  }
}
const oO = {
  alternative: "alternative",
  captions: "captions",
  main: "main",
  sign: "sign",
  subtitles: "subtitles",
  commentary: "commentary"
}, uO = {
  alternative: "alternative",
  descriptions: "descriptions",
  main: "main",
  "main-desc": "main-desc",
  translation: "translation",
  commentary: "commentary"
}, cO = {
  subtitles: "subtitles",
  captions: "captions",
  descriptions: "descriptions",
  chapters: "chapters",
  metadata: "metadata"
}, x_ = {
  disabled: "disabled",
  hidden: "hidden",
  showing: "showing"
};
class a0 extends Dn {
  /**
   * Create an instance of this class.
   *
   * @param {Object} [options={}]
   *        Object of option names and values
   *
   * @param {string} [options.kind='']
   *        A valid kind for the track type you are creating.
   *
   * @param {string} [options.id='vjs_track_' + Guid.newGUID()]
   *        A unique id for this AudioTrack.
   *
   * @param {string} [options.label='']
   *        The menu label for this track.
   *
   * @param {string} [options.language='']
   *        A valid two character language code.
   *
   * @abstract
   */
  constructor(e = {}) {
    super();
    const t = {
      id: e.id || "vjs_track_" + Mn(),
      kind: e.kind || "",
      language: e.language || ""
    };
    let i = e.label || "";
    for (const r in t)
      Object.defineProperty(this, r, {
        get() {
          return t[r];
        },
        set() {
        }
      });
    Object.defineProperty(this, "label", {
      get() {
        return i;
      },
      set(r) {
        r !== i && (i = r, this.trigger("labelchange"));
      }
    });
  }
}
const s0 = function(n) {
  return new URL(n, Be.baseURI);
}, nS = function(n) {
  return new URL(n, Be.baseURI).href;
}, o0 = function(n) {
  if (typeof n == "string") {
    const t = n.split("?")[0].replace(/\/+$/, "").match(/\.([^.\/]+)$/);
    return t ? t[1].toLowerCase() : "";
  }
  return "";
}, Dl = function(n, e = me.location) {
  return s0(n).origin !== e.origin;
};
var lO = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  parseUrl: s0,
  getAbsoluteURL: nS,
  getFileExtension: o0,
  isCrossOrigin: Dl
});
const __ = function(n, e) {
  const t = new me.WebVTT.Parser(me, me.vttjs, me.WebVTT.StringDecoder()), i = [];
  t.oncue = function(r) {
    e.addCue(r);
  }, t.onparsingerror = function(r) {
    i.push(r);
  }, t.onflush = function() {
    e.trigger({
      type: "loadeddata",
      target: e
    });
  }, t.parse(n), i.length > 0 && (me.console && me.console.groupCollapsed && me.console.groupCollapsed(`Text Track parsing errors for ${e.src}`), i.forEach((r) => at.error(r)), me.console && me.console.groupEnd && me.console.groupEnd()), t.flush();
}, T_ = function(n, e) {
  const t = {
    uri: n
  }, i = Dl(n);
  i && (t.cors = i);
  const r = e.tech_.crossOrigin() === "use-credentials";
  r && (t.withCredentials = r), aD(t, _t(this, function(a, s, o) {
    if (a)
      return at.error(a, s);
    e.loaded_ = !0, typeof me.WebVTT != "function" ? e.tech_ && e.tech_.any(["vttjsloaded", "vttjserror"], (u) => {
      if (u.type === "vttjserror") {
        at.error(`vttjs failed to load, stopping trying to process ${e.src}`);
        return;
      }
      return __(o, e);
    }) : __(o, e);
  }));
};
class mo extends a0 {
  /**
   * Create an instance of this class.
   *
   * @param {Object} options={}
   *        Object of option names and values
   *
   * @param {Tech} options.tech
   *        A reference to the tech that owns this TextTrack.
   *
   * @param {TextTrack~Kind} [options.kind='subtitles']
   *        A valid text track kind.
   *
   * @param {TextTrack~Mode} [options.mode='disabled']
   *        A valid text track mode.
   *
   * @param {string} [options.id='vjs_track_' + Guid.newGUID()]
   *        A unique id for this TextTrack.
   *
   * @param {string} [options.label='']
   *        The menu label for this track.
   *
   * @param {string} [options.language='']
   *        A valid two character language code.
   *
   * @param {string} [options.srclang='']
   *        A valid two character language code. An alternative, but deprioritized
   *        version of `options.language`
   *
   * @param {string} [options.src]
   *        A url to TextTrack cues.
   *
   * @param {boolean} [options.default]
   *        If this track should default to on or off.
   */
  constructor(e = {}) {
    if (!e.tech)
      throw new Error("A tech was not provided.");
    const t = yt(e, {
      kind: cO[e.kind] || "subtitles",
      language: e.language || e.srclang || ""
    });
    let i = x_[t.mode] || "disabled";
    const r = t.default;
    (t.kind === "metadata" || t.kind === "chapters") && (i = "hidden"), super(t), this.tech_ = t.tech, this.cues_ = [], this.activeCues_ = [], this.preload_ = this.tech_.preloadTextTracks !== !1;
    const a = new gc(this.cues_), s = new gc(this.activeCues_);
    let o = !1;
    this.timeupdateHandler = _t(this, function(c = {}) {
      if (!this.tech_.isDisposed()) {
        if (!this.tech_.isReady_) {
          c.type !== "timeupdate" && (this.rvf_ = this.tech_.requestVideoFrameCallback(this.timeupdateHandler));
          return;
        }
        this.activeCues = this.activeCues, o && (this.trigger("cuechange"), o = !1), c.type !== "timeupdate" && (this.rvf_ = this.tech_.requestVideoFrameCallback(this.timeupdateHandler));
      }
    });
    const u = () => {
      this.stopTracking();
    };
    this.tech_.one("dispose", u), i !== "disabled" && this.startTracking(), Object.defineProperties(this, {
      /**
       * @memberof TextTrack
       * @member {boolean} default
       *         If this track was set to be on or off by default. Cannot be changed after
       *         creation.
       * @instance
       *
       * @readonly
       */
      default: {
        get() {
          return r;
        },
        set() {
        }
      },
      /**
       * @memberof TextTrack
       * @member {string} mode
       *         Set the mode of this TextTrack to a valid {@link TextTrack~Mode}. Will
       *         not be set if setting to an invalid mode.
       * @instance
       *
       * @fires TextTrack#modechange
       */
      mode: {
        get() {
          return i;
        },
        set(c) {
          x_[c] && i !== c && (i = c, !this.preload_ && i !== "disabled" && this.cues.length === 0 && T_(this.src, this), this.stopTracking(), i !== "disabled" && this.startTracking(), this.trigger("modechange"));
        }
      },
      /**
       * @memberof TextTrack
       * @member {TextTrackCueList} cues
       *         The text track cue list for this TextTrack.
       * @instance
       */
      cues: {
        get() {
          return this.loaded_ ? a : null;
        },
        set() {
        }
      },
      /**
       * @memberof TextTrack
       * @member {TextTrackCueList} activeCues
       *         The list text track cues that are currently active for this TextTrack.
       * @instance
       */
      activeCues: {
        get() {
          if (!this.loaded_)
            return null;
          if (this.cues.length === 0)
            return s;
          const c = this.tech_.currentTime(), l = [];
          for (let h = 0, f = this.cues.length; h < f; h++) {
            const d = this.cues[h];
            d.startTime <= c && d.endTime >= c && l.push(d);
          }
          if (o = !1, l.length !== this.activeCues_.length)
            o = !0;
          else
            for (let h = 0; h < l.length; h++)
              this.activeCues_.indexOf(l[h]) === -1 && (o = !0);
          return this.activeCues_ = l, s.setCues_(this.activeCues_), s;
        },
        // /!\ Keep this setter empty (see the timeupdate handler above)
        set() {
        }
      }
    }), t.src ? (this.src = t.src, this.preload_ || (this.loaded_ = !0), (this.preload_ || t.kind !== "subtitles" && t.kind !== "captions") && T_(this.src, this)) : this.loaded_ = !0;
  }
  startTracking() {
    this.rvf_ = this.tech_.requestVideoFrameCallback(this.timeupdateHandler), this.tech_.on("timeupdate", this.timeupdateHandler);
  }
  stopTracking() {
    this.rvf_ && (this.tech_.cancelVideoFrameCallback(this.rvf_), this.rvf_ = void 0), this.tech_.off("timeupdate", this.timeupdateHandler);
  }
  /**
   * Add a cue to the internal list of cues.
   *
   * @param {TextTrack~Cue} cue
   *        The cue to add to our internal list
   */
  addCue(e) {
    let t = e;
    if (!("getCueAsHTML" in t)) {
      t = new me.vttjs.VTTCue(e.startTime, e.endTime, e.text);
      for (const r in e)
        r in t || (t[r] = e[r]);
      t.id = e.id, t.originalCue_ = e;
    }
    const i = this.tech_.textTracks();
    for (let r = 0; r < i.length; r++)
      i[r] !== this && i[r].removeCue(t);
    this.cues_.push(t), this.cues.setCues_(this.cues_);
  }
  /**
   * Creates a copy of the text track and makes it serializable
   * by removing circular dependencies.
   *
   * @return {Object} The track information as a serializable object
   */
  toJSON() {
    return vm.trackToJson(this);
  }
  /**
   * Remove a cue from our internal list
   *
   * @param {TextTrack~Cue} removeCue
   *        The cue to remove from our internal list
   */
  removeCue(e) {
    let t = this.cues_.length;
    for (; t--; ) {
      const i = this.cues_[t];
      if (i === e || i.originalCue_ && i.originalCue_ === e) {
        this.cues_.splice(t, 1), this.cues.setCues_(this.cues_);
        break;
      }
    }
  }
}
mo.prototype.allowedEvents_ = {
  cuechange: "cuechange"
};
class iS extends a0 {
  /**
   * Create an instance of this class.
   *
   * @param {Object} [options={}]
   *        Object of option names and values
   *
   * @param {AudioTrack~Kind} [options.kind='']
   *        A valid audio track kind
   *
   * @param {string} [options.id='vjs_track_' + Guid.newGUID()]
   *        A unique id for this AudioTrack.
   *
   * @param {string} [options.label='']
   *        The menu label for this track.
   *
   * @param {string} [options.language='']
   *        A valid two character language code.
   *
   * @param {boolean} [options.enabled]
   *        If this track is the one that is currently playing. If this track is part of
   *        an {@link AudioTrackList}, only one {@link AudioTrack} will be enabled.
   */
  constructor(e = {}) {
    const t = yt(e, {
      kind: uO[e.kind] || ""
    });
    super(t);
    let i = !1;
    Object.defineProperty(this, "enabled", {
      get() {
        return i;
      },
      set(r) {
        typeof r != "boolean" || r === i || (i = r, this.trigger("enabledchange"));
      }
    }), t.enabled && (this.enabled = t.enabled), this.loaded_ = !0;
  }
}
class rS extends a0 {
  /**
   * Create an instance of this class.
   *
   * @param {Object} [options={}]
   *        Object of option names and values
   *
   * @param {string} [options.kind='']
   *        A valid {@link VideoTrack~Kind}
   *
   * @param {string} [options.id='vjs_track_' + Guid.newGUID()]
   *        A unique id for this AudioTrack.
   *
   * @param {string} [options.label='']
   *        The menu label for this track.
   *
   * @param {string} [options.language='']
   *        A valid two character language code.
   *
   * @param {boolean} [options.selected]
   *        If this track is the one that is currently playing.
   */
  constructor(e = {}) {
    const t = yt(e, {
      kind: oO[e.kind] || ""
    });
    super(t);
    let i = !1;
    Object.defineProperty(this, "selected", {
      get() {
        return i;
      },
      set(r) {
        typeof r != "boolean" || r === i || (i = r, this.trigger("selectedchange"));
      }
    }), t.selected && (this.selected = t.selected);
  }
}
class Fi extends Dn {
  /**
   * Create an instance of this class.
   *
   * @param {Object} options={}
   *        Object of option names and values
   *
   * @param {Tech} options.tech
   *        A reference to the tech that owns this HTMLTrackElement.
   *
   * @param {TextTrack~Kind} [options.kind='subtitles']
   *        A valid text track kind.
   *
   * @param {TextTrack~Mode} [options.mode='disabled']
   *        A valid text track mode.
   *
   * @param {string} [options.id='vjs_track_' + Guid.newGUID()]
   *        A unique id for this TextTrack.
   *
   * @param {string} [options.label='']
   *        The menu label for this track.
   *
   * @param {string} [options.language='']
   *        A valid two character language code.
   *
   * @param {string} [options.srclang='']
   *        A valid two character language code. An alternative, but deprioritized
   *        version of `options.language`
   *
   * @param {string} [options.src]
   *        A url to TextTrack cues.
   *
   * @param {boolean} [options.default]
   *        If this track should default to on or off.
   */
  constructor(e = {}) {
    super();
    let t;
    const i = new mo(e);
    this.kind = i.kind, this.src = i.src, this.srclang = i.language, this.label = i.label, this.default = i.default, Object.defineProperties(this, {
      /**
       * @memberof HTMLTrackElement
       * @member {HTMLTrackElement~ReadyState} readyState
       *         The current ready state of the track element.
       * @instance
       */
      readyState: {
        get() {
          return t;
        }
      },
      /**
       * @memberof HTMLTrackElement
       * @member {TextTrack} track
       *         The underlying TextTrack object.
       * @instance
       *
       */
      track: {
        get() {
          return i;
        }
      }
    }), t = Fi.NONE, i.addEventListener("loadeddata", () => {
      t = Fi.LOADED, this.trigger({
        type: "load",
        target: this
      });
    });
  }
}
Fi.prototype.allowedEvents_ = {
  load: "load"
};
Fi.NONE = 0;
Fi.LOADING = 1;
Fi.LOADED = 2;
Fi.ERROR = 3;
const Nn = {
  audio: {
    ListClass: eS,
    TrackClass: iS,
    capitalName: "Audio"
  },
  video: {
    ListClass: tS,
    TrackClass: rS,
    capitalName: "Video"
  },
  text: {
    ListClass: r0,
    TrackClass: mo,
    capitalName: "Text"
  }
};
Object.keys(Nn).forEach(function(n) {
  Nn[n].getterName = `${n}Tracks`, Nn[n].privateName = `${n}Tracks_`;
});
const Aa = {
  remoteText: {
    ListClass: r0,
    TrackClass: mo,
    capitalName: "RemoteText",
    getterName: "remoteTextTracks",
    privateName: "remoteTextTracks_"
  },
  remoteTextEl: {
    ListClass: sO,
    TrackClass: Fi,
    capitalName: "RemoteTextTrackEls",
    getterName: "remoteTextTrackEls",
    privateName: "remoteTextTrackEls_"
  }
}, on = Object.assign({}, Nn, Aa);
Aa.names = Object.keys(Aa);
Nn.names = Object.keys(Nn);
on.names = [].concat(Aa.names).concat(Nn.names);
function dO(n, e, t, i, r = {}) {
  const a = n.textTracks();
  r.kind = e, t && (r.label = t), i && (r.language = i), r.tech = n;
  const s = new on.text.TrackClass(r);
  return a.addTrack(s), s;
}
class tt extends Pe {
  /**
  * Create an instance of this Tech.
  *
  * @param {Object} [options]
  *        The key/value store of player options.
  *
  * @param {Function} [ready]
  *        Callback function to call when the `HTML5` Tech is ready.
  */
  constructor(e = {}, t = function() {
  }) {
    e.reportTouchActivity = !1, super(null, e, t), this.onDurationChange_ = (i) => this.onDurationChange(i), this.trackProgress_ = (i) => this.trackProgress(i), this.trackCurrentTime_ = (i) => this.trackCurrentTime(i), this.stopTrackingCurrentTime_ = (i) => this.stopTrackingCurrentTime(i), this.disposeSourceHandler_ = (i) => this.disposeSourceHandler(i), this.queuedHanders_ = /* @__PURE__ */ new Set(), this.hasStarted_ = !1, this.on("playing", function() {
      this.hasStarted_ = !0;
    }), this.on("loadstart", function() {
      this.hasStarted_ = !1;
    }), on.names.forEach((i) => {
      const r = on[i];
      e && e[r.getterName] && (this[r.privateName] = e[r.getterName]);
    }), this.featuresProgressEvents || this.manualProgressOn(), this.featuresTimeupdateEvents || this.manualTimeUpdatesOn(), ["Text", "Audio", "Video"].forEach((i) => {
      e[`native${i}Tracks`] === !1 && (this[`featuresNative${i}Tracks`] = !1);
    }), e.nativeCaptions === !1 || e.nativeTextTracks === !1 ? this.featuresNativeTextTracks = !1 : (e.nativeCaptions === !0 || e.nativeTextTracks === !0) && (this.featuresNativeTextTracks = !0), this.featuresNativeTextTracks || this.emulateTextTracks(), this.preloadTextTracks = e.preloadTextTracks !== !1, this.autoRemoteTextTracks_ = new on.text.ListClass(), this.initTrackListeners(), e.nativeControlsForTouch || this.emitTapEvents(), this.constructor && (this.name_ = this.constructor.name || "Unknown Tech");
  }
  /**
   * A special function to trigger source set in a way that will allow player
   * to re-trigger if the player or tech are not ready yet.
   *
   * @fires Tech#sourceset
   * @param {string} src The source string at the time of the source changing.
   */
  triggerSourceset(e) {
    this.isReady_ || this.one("ready", () => this.setTimeout(() => this.triggerSourceset(e), 1)), this.trigger({
      src: e,
      type: "sourceset"
    });
  }
  /* Fallbacks for unsupported event types
  ================================================================================ */
  /**
   * Polyfill the `progress` event for browsers that don't support it natively.
   *
   * @see {@link Tech#trackProgress}
   */
  manualProgressOn() {
    this.on("durationchange", this.onDurationChange_), this.manualProgress = !0, this.one("ready", this.trackProgress_);
  }
  /**
   * Turn off the polyfill for `progress` events that was created in
   * {@link Tech#manualProgressOn}
   */
  manualProgressOff() {
    this.manualProgress = !1, this.stopTrackingProgress(), this.off("durationchange", this.onDurationChange_);
  }
  /**
   * This is used to trigger a `progress` event when the buffered percent changes. It
   * sets an interval function that will be called every 500 milliseconds to check if the
   * buffer end percent has changed.
   *
   * > This function is called by {@link Tech#manualProgressOn}
   *
   * @param {Event} event
   *        The `ready` event that caused this to run.
   *
   * @listens Tech#ready
   * @fires Tech#progress
   */
  trackProgress(e) {
    this.stopTrackingProgress(), this.progressInterval = this.setInterval(_t(this, function() {
      const t = this.bufferedPercent();
      this.bufferedPercent_ !== t && this.trigger("progress"), this.bufferedPercent_ = t, t === 1 && this.stopTrackingProgress();
    }), 500);
  }
  /**
   * Update our internal duration on a `durationchange` event by calling
   * {@link Tech#duration}.
   *
   * @param {Event} event
   *        The `durationchange` event that caused this to run.
   *
   * @listens Tech#durationchange
   */
  onDurationChange(e) {
    this.duration_ = this.duration();
  }
  /**
   * Get and create a `TimeRange` object for buffering.
   *
   * @return {TimeRange}
   *         The time range object that was created.
   */
  buffered() {
    return ii(0, 0);
  }
  /**
   * Get the percentage of the current video that is currently buffered.
   *
   * @return {number}
   *         A number from 0 to 1 that represents the decimal percentage of the
   *         video that is buffered.
   *
   */
  bufferedPercent() {
    return JD(this.buffered(), this.duration_);
  }
  /**
   * Turn off the polyfill for `progress` events that was created in
   * {@link Tech#manualProgressOn}
   * Stop manually tracking progress events by clearing the interval that was set in
   * {@link Tech#trackProgress}.
   */
  stopTrackingProgress() {
    this.clearInterval(this.progressInterval);
  }
  /**
   * Polyfill the `timeupdate` event for browsers that don't support it.
   *
   * @see {@link Tech#trackCurrentTime}
   */
  manualTimeUpdatesOn() {
    this.manualTimeUpdates = !0, this.on("play", this.trackCurrentTime_), this.on("pause", this.stopTrackingCurrentTime_);
  }
  /**
   * Turn off the polyfill for `timeupdate` events that was created in
   * {@link Tech#manualTimeUpdatesOn}
   */
  manualTimeUpdatesOff() {
    this.manualTimeUpdates = !1, this.stopTrackingCurrentTime(), this.off("play", this.trackCurrentTime_), this.off("pause", this.stopTrackingCurrentTime_);
  }
  /**
   * Sets up an interval function to track current time and trigger `timeupdate` every
   * 250 milliseconds.
   *
   * @listens Tech#play
   * @triggers Tech#timeupdate
   */
  trackCurrentTime() {
    this.currentTimeInterval && this.stopTrackingCurrentTime(), this.currentTimeInterval = this.setInterval(function() {
      this.trigger({
        type: "timeupdate",
        target: this,
        manuallyTriggered: !0
      });
    }, 250);
  }
  /**
   * Stop the interval function created in {@link Tech#trackCurrentTime} so that the
   * `timeupdate` event is no longer triggered.
   *
   * @listens {Tech#pause}
   */
  stopTrackingCurrentTime() {
    this.clearInterval(this.currentTimeInterval), this.trigger({
      type: "timeupdate",
      target: this,
      manuallyTriggered: !0
    });
  }
  /**
   * Turn off all event polyfills, clear the `Tech`s {@link AudioTrackList},
   * {@link VideoTrackList}, and {@link TextTrackList}, and dispose of this Tech.
   *
   * @fires Component#dispose
   */
  dispose() {
    this.clearTracks(Nn.names), this.manualProgress && this.manualProgressOff(), this.manualTimeUpdates && this.manualTimeUpdatesOff(), super.dispose();
  }
  /**
   * Clear out a single `TrackList` or an array of `TrackLists` given their names.
   *
   * > Note: Techs without source handlers should call this between sources for `video`
   *         & `audio` tracks. You don't want to use them between tracks!
   *
   * @param {string[]|string} types
   *        TrackList names to clear, valid names are `video`, `audio`, and
   *        `text`.
   */
  clearTracks(e) {
    e = [].concat(e), e.forEach((t) => {
      const i = this[`${t}Tracks`]() || [];
      let r = i.length;
      for (; r--; ) {
        const a = i[r];
        t === "text" && this.removeRemoteTextTrack(a), i.removeTrack(a);
      }
    });
  }
  /**
   * Remove any TextTracks added via addRemoteTextTrack that are
   * flagged for automatic garbage collection
   */
  cleanupAutoTextTracks() {
    const e = this.autoRemoteTextTracks_ || [];
    let t = e.length;
    for (; t--; ) {
      const i = e[t];
      this.removeRemoteTextTrack(i);
    }
  }
  /**
   * Reset the tech, which will removes all sources and reset the internal readyState.
   *
   * @abstract
   */
  reset() {
  }
  /**
   * Get the value of `crossOrigin` from the tech.
   *
   * @abstract
   *
   * @see {Html5#crossOrigin}
   */
  crossOrigin() {
  }
  /**
   * Set the value of `crossOrigin` on the tech.
   *
   * @abstract
   *
   * @param {string} crossOrigin the crossOrigin value
   * @see {Html5#setCrossOrigin}
   */
  setCrossOrigin() {
  }
  /**
   * Get or set an error on the Tech.
   *
   * @param {MediaError} [err]
   *        Error to set on the Tech
   *
   * @return {MediaError|null}
   *         The current error object on the tech, or null if there isn't one.
   */
  error(e) {
    return e !== void 0 && (this.error_ = new It(e), this.trigger("error")), this.error_;
  }
  /**
   * Returns the `TimeRange`s that have been played through for the current source.
   *
   * > NOTE: This implementation is incomplete. It does not track the played `TimeRange`.
   *         It only checks whether the source has played at all or not.
   *
   * @return {TimeRange}
   *         - A single time range if this video has played
   *         - An empty set of ranges if not.
   */
  played() {
    return this.hasStarted_ ? ii(0, 0) : ii();
  }
  /**
   * Start playback
   *
   * @abstract
   *
   * @see {Html5#play}
   */
  play() {
  }
  /**
   * Set whether we are scrubbing or not
   *
   * @abstract
   * @param {boolean} _isScrubbing
   *                  - true for we are currently scrubbing
   *                  - false for we are no longer scrubbing
   *
   * @see {Html5#setScrubbing}
   */
  setScrubbing(e) {
  }
  /**
   * Get whether we are scrubbing or not
   *
   * @abstract
   *
   * @see {Html5#scrubbing}
   */
  scrubbing() {
  }
  /**
   * Causes a manual time update to occur if {@link Tech#manualTimeUpdatesOn} was
   * previously called.
   *
   * @param {number} _seconds
   *        Set the current time of the media to this.
   * @fires Tech#timeupdate
   */
  setCurrentTime(e) {
    this.manualTimeUpdates && this.trigger({
      type: "timeupdate",
      target: this,
      manuallyTriggered: !0
    });
  }
  /**
   * Turn on listeners for {@link VideoTrackList}, {@link {AudioTrackList}, and
   * {@link TextTrackList} events.
   *
   * This adds {@link EventTarget~EventListeners} for `addtrack`, and  `removetrack`.
   *
   * @fires Tech#audiotrackchange
   * @fires Tech#videotrackchange
   * @fires Tech#texttrackchange
   */
  initTrackListeners() {
    Nn.names.forEach((e) => {
      const t = Nn[e], i = () => {
        this.trigger(`${e}trackchange`);
      }, r = this[t.getterName]();
      r.addEventListener("removetrack", i), r.addEventListener("addtrack", i), this.on("dispose", () => {
        r.removeEventListener("removetrack", i), r.removeEventListener("addtrack", i);
      });
    });
  }
  /**
   * Emulate TextTracks using vtt.js if necessary
   *
   * @fires Tech#vttjsloaded
   * @fires Tech#vttjserror
   */
  addWebVttScript_() {
    if (!me.WebVTT)
      if (Be.body.contains(this.el())) {
        if (!this.options_["vtt.js"] && Ea(V2) && Object.keys(V2).length > 0) {
          this.trigger("vttjsloaded");
          return;
        }
        const e = Be.createElement("script");
        e.src = this.options_["vtt.js"] || "https://vjs.zencdn.net/vttjs/0.14.1/vtt.min.js", e.onload = () => {
          this.trigger("vttjsloaded");
        }, e.onerror = () => {
          this.trigger("vttjserror");
        }, this.on("dispose", () => {
          e.onload = null, e.onerror = null;
        }), me.WebVTT = !0, this.el().parentNode.appendChild(e);
      } else
        this.ready(this.addWebVttScript_);
  }
  /**
   * Emulate texttracks
   *
   */
  emulateTextTracks() {
    const e = this.textTracks(), t = this.remoteTextTracks(), i = (o) => e.addTrack(o.track), r = (o) => e.removeTrack(o.track);
    t.on("addtrack", i), t.on("removetrack", r), this.addWebVttScript_();
    const a = () => this.trigger("texttrackchange"), s = () => {
      a();
      for (let o = 0; o < e.length; o++) {
        const u = e[o];
        u.removeEventListener("cuechange", a), u.mode === "showing" && u.addEventListener("cuechange", a);
      }
    };
    s(), e.addEventListener("change", s), e.addEventListener("addtrack", s), e.addEventListener("removetrack", s), this.on("dispose", function() {
      t.off("addtrack", i), t.off("removetrack", r), e.removeEventListener("change", s), e.removeEventListener("addtrack", s), e.removeEventListener("removetrack", s);
      for (let o = 0; o < e.length; o++)
        e[o].removeEventListener("cuechange", a);
    });
  }
  /**
   * Create and returns a remote {@link TextTrack} object.
   *
   * @param {string} kind
   *        `TextTrack` kind (subtitles, captions, descriptions, chapters, or metadata)
   *
   * @param {string} [label]
   *        Label to identify the text track
   *
   * @param {string} [language]
   *        Two letter language abbreviation
   *
   * @return {TextTrack}
   *         The TextTrack that gets created.
   */
  addTextTrack(e, t, i) {
    if (!e)
      throw new Error("TextTrack kind is required but was not provided");
    return dO(this, e, t, i);
  }
  /**
   * Create an emulated TextTrack for use by addRemoteTextTrack
   *
   * This is intended to be overridden by classes that inherit from
   * Tech in order to create native or custom TextTracks.
   *
   * @param {Object} options
   *        The object should contain the options to initialize the TextTrack with.
   *
   * @param {string} [options.kind]
   *        `TextTrack` kind (subtitles, captions, descriptions, chapters, or metadata).
   *
   * @param {string} [options.label].
   *        Label to identify the text track
   *
   * @param {string} [options.language]
   *        Two letter language abbreviation.
   *
   * @return {HTMLTrackElement}
   *         The track element that gets created.
   */
  createRemoteTextTrack(e) {
    const t = yt(e, {
      tech: this
    });
    return new Aa.remoteTextEl.TrackClass(t);
  }
  /**
   * Creates a remote text track object and returns an html track element.
   *
   * > Note: This can be an emulated {@link HTMLTrackElement} or a native one.
   *
   * @param {Object} options
   *        See {@link Tech#createRemoteTextTrack} for more detailed properties.
   *
   * @param {boolean} [manualCleanup=false]
   *        - When false: the TextTrack will be automatically removed from the video
   *          element whenever the source changes
   *        - When True: The TextTrack will have to be cleaned up manually
   *
   * @return {HTMLTrackElement}
   *         An Html Track Element.
   *
   */
  addRemoteTextTrack(e = {}, t) {
    const i = this.createRemoteTextTrack(e);
    return typeof t != "boolean" && (t = !1), this.remoteTextTrackEls().addTrackElement_(i), this.remoteTextTracks().addTrack(i.track), t === !1 && this.ready(() => this.autoRemoteTextTracks_.addTrack(i.track)), i;
  }
  /**
   * Remove a remote text track from the remote `TextTrackList`.
   *
   * @param {TextTrack} track
   *        `TextTrack` to remove from the `TextTrackList`
   */
  removeRemoteTextTrack(e) {
    const t = this.remoteTextTrackEls().getTrackElementByTrack_(e);
    this.remoteTextTrackEls().removeTrackElement_(t), this.remoteTextTracks().removeTrack(e), this.autoRemoteTextTracks_.removeTrack(e);
  }
  /**
   * Gets available media playback quality metrics as specified by the W3C's Media
   * Playback Quality API.
   *
   * @see [Spec]{@link https://wicg.github.io/media-playback-quality}
   *
   * @return {Object}
   *         An object with supported media playback quality metrics
   *
   * @abstract
   */
  getVideoPlaybackQuality() {
    return {};
  }
  /**
   * Attempt to create a floating video window always on top of other windows
   * so that users may continue consuming media while they interact with other
   * content sites, or applications on their device.
   *
   * @see [Spec]{@link https://wicg.github.io/picture-in-picture}
   *
   * @return {Promise|undefined}
   *         A promise with a Picture-in-Picture window if the browser supports
   *         Promises (or one was passed in as an option). It returns undefined
   *         otherwise.
   *
   * @abstract
   */
  requestPictureInPicture() {
    return Promise.reject();
  }
  /**
   * A method to check for the value of the 'disablePictureInPicture' <video> property.
   * Defaults to true, as it should be considered disabled if the tech does not support pip
   *
   * @abstract
   */
  disablePictureInPicture() {
    return !0;
  }
  /**
   * A method to set or unset the 'disablePictureInPicture' <video> property.
   *
   * @abstract
   */
  setDisablePictureInPicture() {
  }
  /**
   * A fallback implementation of requestVideoFrameCallback using requestAnimationFrame
   *
   * @param {function} cb
   * @return {number} request id
   */
  requestVideoFrameCallback(e) {
    const t = Mn();
    return !this.isReady_ || this.paused() ? (this.queuedHanders_.add(t), this.one("playing", () => {
      this.queuedHanders_.has(t) && (this.queuedHanders_.delete(t), e());
    })) : this.requestNamedAnimationFrame(t, e), t;
  }
  /**
   * A fallback implementation of cancelVideoFrameCallback
   *
   * @param {number} id id of callback to be cancelled
   */
  cancelVideoFrameCallback(e) {
    this.queuedHanders_.has(e) ? this.queuedHanders_.delete(e) : this.cancelNamedAnimationFrame(e);
  }
  /**
   * A method to set a poster from a `Tech`.
   *
   * @abstract
   */
  setPoster() {
  }
  /**
   * A method to check for the presence of the 'playsinline' <video> attribute.
   *
   * @abstract
   */
  playsinline() {
  }
  /**
   * A method to set or unset the 'playsinline' <video> attribute.
   *
   * @abstract
   */
  setPlaysinline() {
  }
  /**
   * Attempt to force override of native audio tracks.
   *
   * @param {boolean} override - If set to true native audio will be overridden,
   * otherwise native audio will potentially be used.
   *
   * @abstract
   */
  overrideNativeAudioTracks(e) {
  }
  /**
   * Attempt to force override of native video tracks.
   *
   * @param {boolean} override - If set to true native video will be overridden,
   * otherwise native video will potentially be used.
   *
   * @abstract
   */
  overrideNativeVideoTracks(e) {
  }
  /**
   * Check if the tech can support the given mime-type.
   *
   * The base tech does not support any type, but source handlers might
   * overwrite this.
   *
   * @param  {string} _type
   *         The mimetype to check for support
   *
   * @return {string}
   *         'probably', 'maybe', or empty string
   *
   * @see [Spec]{@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement/canPlayType}
   *
   * @abstract
   */
  canPlayType(e) {
    return "";
  }
  /**
   * Check if the type is supported by this tech.
   *
   * The base tech does not support any type, but source handlers might
   * overwrite this.
   *
   * @param {string} _type
   *        The media type to check
   * @return {string} Returns the native video element's response
   */
  static canPlayType(e) {
    return "";
  }
  /**
   * Check if the tech can support the given source
   *
   * @param {Object} srcObj
   *        The source object
   * @param {Object} options
   *        The options passed to the tech
   * @return {string} 'probably', 'maybe', or '' (empty string)
   */
  static canPlaySource(e, t) {
    return tt.canPlayType(e.type);
  }
  /*
   * Return whether the argument is a Tech or not.
   * Can be passed either a Class like `Html5` or a instance like `player.tech_`
   *
   * @param {Object} component
   *        The item to check
   *
   * @return {boolean}
   *         Whether it is a tech or not
   *         - True if it is a tech
   *         - False if it is not
   */
  static isTech(e) {
    return e.prototype instanceof tt || e instanceof tt || e === tt;
  }
  /**
   * Registers a `Tech` into a shared list for videojs.
   *
   * @param {string} name
   *        Name of the `Tech` to register.
   *
   * @param {Object} tech
   *        The `Tech` class to register.
   */
  static registerTech(e, t) {
    if (tt.techs_ || (tt.techs_ = {}), !tt.isTech(t))
      throw new Error(`Tech ${e} must be a Tech`);
    if (!tt.canPlayType)
      throw new Error("Techs must have a static canPlayType method on them");
    if (!tt.canPlaySource)
      throw new Error("Techs must have a static canPlaySource method on them");
    return e = Rt(e), tt.techs_[e] = t, tt.techs_[Ls(e)] = t, e !== "Tech" && tt.defaultTechOrder_.push(e), t;
  }
  /**
   * Get a `Tech` from the shared list by name.
   *
   * @param {string} name
   *        `camelCase` or `TitleCase` name of the Tech to get
   *
   * @return {Tech|undefined}
   *         The `Tech` or undefined if there was no tech with the name requested.
   */
  static getTech(e) {
    if (e) {
      if (tt.techs_ && tt.techs_[e])
        return tt.techs_[e];
      if (e = Rt(e), me && me.videojs && me.videojs[e])
        return at.warn(`The ${e} tech was added to the videojs object when it should be registered using videojs.registerTech(name, tech)`), me.videojs[e];
    }
  }
}
on.names.forEach(function(n) {
  const e = on[n];
  tt.prototype[e.getterName] = function() {
    return this[e.privateName] = this[e.privateName] || new e.ListClass(), this[e.privateName];
  };
});
tt.prototype.featuresVolumeControl = !0;
tt.prototype.featuresMuteControl = !0;
tt.prototype.featuresFullscreenResize = !1;
tt.prototype.featuresPlaybackRate = !1;
tt.prototype.featuresProgressEvents = !1;
tt.prototype.featuresSourceset = !1;
tt.prototype.featuresTimeupdateEvents = !1;
tt.prototype.featuresNativeTextTracks = !1;
tt.prototype.featuresVideoFrameCallback = !1;
tt.withSourceHandlers = function(n) {
  n.registerSourceHandler = function(t, i) {
    let r = n.sourceHandlers;
    r || (r = n.sourceHandlers = []), i === void 0 && (i = r.length), r.splice(i, 0, t);
  }, n.canPlayType = function(t) {
    const i = n.sourceHandlers || [];
    let r;
    for (let a = 0; a < i.length; a++)
      if (r = i[a].canPlayType(t), r)
        return r;
    return "";
  }, n.selectSourceHandler = function(t, i) {
    const r = n.sourceHandlers || [];
    let a;
    for (let s = 0; s < r.length; s++)
      if (a = r[s].canHandleSource(t, i), a)
        return r[s];
    return null;
  }, n.canPlaySource = function(t, i) {
    const r = n.selectSourceHandler(t, i);
    return r ? r.canHandleSource(t, i) : "";
  }, ["seekable", "seeking", "duration"].forEach(function(t) {
    const i = this[t];
    typeof i == "function" && (this[t] = function() {
      return this.sourceHandler_ && this.sourceHandler_[t] ? this.sourceHandler_[t].apply(this.sourceHandler_, arguments) : i.apply(this, arguments);
    });
  }, n.prototype), n.prototype.setSource = function(t) {
    let i = n.selectSourceHandler(t, this.options_);
    i || (n.nativeSourceHandler ? i = n.nativeSourceHandler : at.error("No source handler found for the current source.")), this.disposeSourceHandler(), this.off("dispose", this.disposeSourceHandler_), i !== n.nativeSourceHandler && (this.currentSource_ = t), this.sourceHandler_ = i.handleSource(t, this, this.options_), this.one("dispose", this.disposeSourceHandler_);
  }, n.prototype.disposeSourceHandler = function() {
    this.currentSource_ && (this.clearTracks(["audio", "video"]), this.currentSource_ = null), this.cleanupAutoTextTracks(), this.sourceHandler_ && (this.sourceHandler_.dispose && this.sourceHandler_.dispose(), this.sourceHandler_ = null);
  };
};
Pe.registerComponent("Tech", tt);
tt.registerTech("Tech", tt);
tt.defaultTechOrder_ = [];
const Or = {}, bc = {}, yc = {};
function fO(n, e) {
  Or[n] = Or[n] || [], Or[n].push(e);
}
function hO(n, e, t) {
  n.setTimeout(() => Dr(e, Or[e.type], t, n), 1);
}
function pO(n, e) {
  n.forEach((t) => t.setTech && t.setTech(e));
}
function mO(n, e, t) {
  return n.reduceRight(u0(t), e[t]());
}
function gO(n, e, t, i) {
  return e[t](n.reduce(u0(t), i));
}
function w_(n, e, t, i = null) {
  const r = "call" + Rt(t), a = n.reduce(u0(r), i), s = a === yc, o = s ? null : e[t](a);
  return vO(n, t, o, s), o;
}
const bO = {
  buffered: 1,
  currentTime: 1,
  duration: 1,
  muted: 1,
  played: 1,
  paused: 1,
  seekable: 1,
  volume: 1,
  ended: 1
}, yO = {
  setCurrentTime: 1,
  setMuted: 1,
  setVolume: 1
}, E_ = {
  play: 1,
  pause: 1
};
function u0(n) {
  return (e, t) => e === yc ? yc : t[n] ? t[n](e) : e;
}
function vO(n, e, t, i) {
  for (let r = n.length - 1; r >= 0; r--) {
    const a = n[r];
    a[e] && a[e](i, t);
  }
}
function xO(n) {
  bc.hasOwnProperty(n.id()) && delete bc[n.id()];
}
function _O(n, e) {
  const t = bc[n.id()];
  let i = null;
  if (t == null)
    return i = e(n), bc[n.id()] = [[e, i]], i;
  for (let r = 0; r < t.length; r++) {
    const [a, s] = t[r];
    a === e && (i = s);
  }
  return i === null && (i = e(n), t.push([e, i])), i;
}
function Dr(n = {}, e = [], t, i, r = [], a = !1) {
  const [s, ...o] = e;
  if (typeof s == "string")
    Dr(n, Or[s], t, i, r, a);
  else if (s) {
    const u = _O(i, s);
    if (!u.setSource)
      return r.push(u), Dr(n, o, t, i, r, a);
    u.setSource(Object.assign({}, n), function(c, l) {
      if (c)
        return Dr(n, o, t, i, r, a);
      r.push(u), Dr(l, n.type === l.type ? o : Or[l.type], t, i, r, a);
    });
  } else o.length ? Dr(n, o, t, i, r, a) : a ? t(n, r) : Dr(n, Or["*"], t, i, r, !0);
}
const TO = {
  opus: "video/ogg",
  ogv: "video/ogg",
  mp4: "video/mp4",
  mov: "video/mp4",
  m4v: "video/mp4",
  mkv: "video/x-matroska",
  m4a: "audio/mp4",
  mp3: "audio/mpeg",
  aac: "audio/aac",
  caf: "audio/x-caf",
  flac: "audio/flac",
  oga: "audio/ogg",
  wav: "audio/wav",
  m3u8: "application/x-mpegURL",
  mpd: "application/dash+xml",
  jpg: "image/jpeg",
  jpeg: "image/jpeg",
  gif: "image/gif",
  png: "image/png",
  svg: "image/svg+xml",
  webp: "image/webp"
}, vc = function(n = "") {
  const e = o0(n);
  return TO[e.toLowerCase()] || "";
}, wO = (n, e) => {
  if (!e)
    return "";
  if (n.cache_.source.src === e && n.cache_.source.type)
    return n.cache_.source.type;
  const t = n.cache_.sources.filter((r) => r.src === e);
  if (t.length)
    return t[0].type;
  const i = n.$$("source");
  for (let r = 0; r < i.length; r++) {
    const a = i[r];
    if (a.type && a.src && a.src === e)
      return a.type;
  }
  return vc(e);
}, aS = function(n) {
  if (Array.isArray(n)) {
    let e = [];
    n.forEach(function(t) {
      t = aS(t), Array.isArray(t) ? e = e.concat(t) : xi(t) && e.push(t);
    }), n = e;
  } else typeof n == "string" && n.trim() ? n = [D_({
    src: n
  })] : xi(n) && typeof n.src == "string" && n.src && n.src.trim() ? n = [D_(n)] : n = [];
  return n;
};
function D_(n) {
  if (!n.type) {
    const e = vc(n.src);
    e && (n.type = e);
  }
  return n;
}
var EO = `<svg xmlns="http://www.w3.org/2000/svg">
  <defs>
    <symbol viewBox="0 0 48 48" id="vjs-icon-play">
      <path d="M16 10v28l22-14z"></path>
    </symbol>
    <symbol viewBox="0 0 48 48" id="vjs-icon-pause">
      <path d="M12 38h8V10h-8v28zm16-28v28h8V10h-8z"></path>
    </symbol>
    <symbol viewBox="0 0 48 48" id="vjs-icon-audio">
      <path d="M24 2C14.06 2 6 10.06 6 20v14c0 3.31 2.69 6 6 6h6V24h-8v-4c0-7.73 6.27-14 14-14s14 6.27 14 14v4h-8v16h6c3.31 0 6-2.69 6-6V20c0-9.94-8.06-18-18-18z"></path>
    </symbol>
    <symbol viewBox="0 0 48 48" id="vjs-icon-captions">
      <path d="M38 8H10c-2.21 0-4 1.79-4 4v24c0 2.21 1.79 4 4 4h28c2.21 0 4-1.79 4-4V12c0-2.21-1.79-4-4-4zM22 22h-3v-1h-4v6h4v-1h3v2a2 2 0 0 1-2 2h-6a2 2 0 0 1-2-2v-8a2 2 0 0 1 2-2h6a2 2 0 0 1 2 2v2zm14 0h-3v-1h-4v6h4v-1h3v2a2 2 0 0 1-2 2h-6a2 2 0 0 1-2-2v-8a2 2 0 0 1 2-2h6a2 2 0 0 1 2 2v2z"></path>
    </symbol>
    <symbol viewBox="0 0 48 48" id="vjs-icon-subtitles">
      <path d="M40 8H8c-2.21 0-4 1.79-4 4v24c0 2.21 1.79 4 4 4h32c2.21 0 4-1.79 4-4V12c0-2.21-1.79-4-4-4zM8 24h8v4H8v-4zm20 12H8v-4h20v4zm12 0h-8v-4h8v4zm0-8H20v-4h20v4z"></path>
    </symbol>
    <symbol viewBox="0 0 48 48" id="vjs-icon-fullscreen-enter">
      <path d="M14 28h-4v10h10v-4h-6v-6zm-4-8h4v-6h6v-4H10v10zm24 14h-6v4h10V28h-4v6zm-6-24v4h6v6h4V10H28z"></path>
    </symbol>
    <symbol viewBox="0 0 48 48" id="vjs-icon-fullscreen-exit">
      <path d="M10 32h6v6h4V28H10v4zm6-16h-6v4h10V10h-4v6zm12 22h4v-6h6v-4H28v10zm4-22v-6h-4v10h10v-4h-6z"></path>
    </symbol>
    <symbol viewBox="0 0 48 48" id="vjs-icon-play-circle">
      <path d="M20 33l12-9-12-9v18zm4-29C12.95 4 4 12.95 4 24s8.95 20 20 20 20-8.95 20-20S35.05 4 24 4zm0 36c-8.82 0-16-7.18-16-16S15.18 8 24 8s16 7.18 16 16-7.18 16-16 16z"></path>
    </symbol>
    <symbol viewBox="0 0 48 48" id="vjs-icon-volume-mute">
      <path d="M33 24c0-3.53-2.04-6.58-5-8.05v4.42l4.91 4.91c.06-.42.09-.85.09-1.28zm5 0c0 1.88-.41 3.65-1.08 5.28l3.03 3.03C41.25 29.82 42 27 42 24c0-8.56-5.99-15.72-14-17.54v4.13c5.78 1.72 10 7.07 10 13.41zM8.55 6L6 8.55 15.45 18H6v12h8l10 10V26.55l8.51 8.51c-1.34 1.03-2.85 1.86-4.51 2.36v4.13a17.94 17.94 0 0 0 7.37-3.62L39.45 42 42 39.45l-18-18L8.55 6zM24 8l-4.18 4.18L24 16.36V8z"></path>
    </symbol>
    <symbol viewBox="0 0 48 48" id="vjs-icon-volume-low">
      <path d="M14 18v12h8l10 10V8L22 18h-8z"></path>
    </symbol>
    <symbol viewBox="0 0 48 48" id="vjs-icon-volume-medium">
      <path d="M37 24c0-3.53-2.04-6.58-5-8.05v16.11c2.96-1.48 5-4.53 5-8.06zm-27-6v12h8l10 10V8L18 18h-8z"></path>
    </symbol>
    <symbol viewBox="0 0 48 48" id="vjs-icon-volume-high">
      <path d="M6 18v12h8l10 10V8L14 18H6zm27 6c0-3.53-2.04-6.58-5-8.05v16.11c2.96-1.48 5-4.53 5-8.06zM28 6.46v4.13c5.78 1.72 10 7.07 10 13.41s-4.22 11.69-10 13.41v4.13c8.01-1.82 14-8.97 14-17.54S36.01 8.28 28 6.46z"></path>
    </symbol>
    <symbol viewBox="0 0 48 48" id="vjs-icon-spinner">
      <path d="M18.8 21l9.53-16.51C26.94 4.18 25.49 4 24 4c-4.8 0-9.19 1.69-12.64 4.51l7.33 12.69.11-.2zm24.28-3c-1.84-5.85-6.3-10.52-11.99-12.68L23.77 18h19.31zm.52 2H28.62l.58 1 9.53 16.5C41.99 33.94 44 29.21 44 24c0-1.37-.14-2.71-.4-4zm-26.53 4l-7.8-13.5C6.01 14.06 4 18.79 4 24c0 1.37.14 2.71.4 4h14.98l-2.31-4zM4.92 30c1.84 5.85 6.3 10.52 11.99 12.68L24.23 30H4.92zm22.54 0l-7.8 13.51c1.4.31 2.85.49 4.34.49 4.8 0 9.19-1.69 12.64-4.51L29.31 26.8 27.46 30z"></path>
    </symbol>
    <symbol viewBox="0 0 24 24" id="vjs-icon-hd">
      <path d="M19 3H5a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm-8 12H9.5v-2h-2v2H6V9h1.5v2.5h2V9H11v6zm2-6h4c.55 0 1 .45 1 1v4c0 .55-.45 1-1 1h-4V9zm1.5 4.5h2v-3h-2v3z"></path>
    </symbol>
    <symbol viewBox="0 0 48 48" id="vjs-icon-chapters">
      <path d="M6 26h4v-4H6v4zm0 8h4v-4H6v4zm0-16h4v-4H6v4zm8 8h28v-4H14v4zm0 8h28v-4H14v4zm0-20v4h28v-4H14z"></path>
    </symbol>
    <symbol viewBox="0 0 40 40" id="vjs-icon-downloading">
      <path d="M18.208 36.875q-3.208-.292-5.979-1.729-2.771-1.438-4.812-3.729-2.042-2.292-3.188-5.229-1.146-2.938-1.146-6.23 0-6.583 4.334-11.416 4.333-4.834 10.833-5.5v3.166q-5.167.75-8.583 4.646Q6.25 14.75 6.25 19.958q0 5.209 3.396 9.104 3.396 3.896 8.562 4.646zM20 28.417L11.542 20l2.083-2.083 4.917 4.916v-11.25h2.916v11.25l4.875-4.916L28.417 20zm1.792 8.458v-3.167q1.833-.25 3.541-.958 1.709-.708 3.167-1.875l2.333 2.292q-1.958 1.583-4.25 2.541-2.291.959-4.791 1.167zm6.791-27.792q-1.541-1.125-3.25-1.854-1.708-.729-3.541-1.021V3.042q2.5.25 4.77 1.208 2.271.958 4.271 2.5zm4.584 21.584l-2.25-2.25q1.166-1.5 1.854-3.209.687-1.708.937-3.541h3.209q-.292 2.5-1.229 4.791-.938 2.292-2.521 4.209zm.541-12.417q-.291-1.833-.958-3.562-.667-1.73-1.833-3.188l2.375-2.208q1.541 1.916 2.458 4.208.917 2.292 1.167 4.75z"></path>
    </symbol>
    <symbol viewBox="0 0 48 48" id="vjs-icon-file-download">
      <path d="M10.8 40.55q-1.35 0-2.375-1T7.4 37.15v-7.7h3.4v7.7h26.35v-7.7h3.4v7.7q0 1.4-1 2.4t-2.4 1zM24 32.1L13.9 22.05l2.45-2.45 5.95 5.95V7.15h3.4v18.4l5.95-5.95 2.45 2.45z"></path>
    </symbol>
    <symbol viewBox="0 0 48 48" id="vjs-icon-file-download-done">
      <path d="M9.8 40.5v-3.45h28.4v3.45zm9.2-9.05L7.4 19.85l2.45-2.35L19 26.65l19.2-19.2 2.4 2.4z"></path>
    </symbol>
    <symbol viewBox="0 0 48 48" id="vjs-icon-file-download-off">
      <path d="M4.9 4.75L43.25 43.1 41 45.3l-4.75-4.75q-.05.05-.075.025-.025-.025-.075-.025H10.8q-1.35 0-2.375-1T7.4 37.15v-7.7h3.4v7.7h22.05l-7-7-1.85 1.8L13.9 21.9l1.85-1.85L2.7 7zm26.75 14.7l2.45 2.45-3.75 3.8-2.45-2.5zM25.7 7.15V21.1l-3.4-3.45V7.15z"></path>
    </symbol>
    <symbol viewBox="0 0 48 48" id="vjs-icon-share">
      <path d="M36 32.17c-1.52 0-2.89.59-3.93 1.54L17.82 25.4c.11-.45.18-.92.18-1.4s-.07-.95-.18-1.4l14.1-8.23c1.07 1 2.5 1.62 4.08 1.62 3.31 0 6-2.69 6-6s-2.69-6-6-6-6 2.69-6 6c0 .48.07.95.18 1.4l-14.1 8.23c-1.07-1-2.5-1.62-4.08-1.62-3.31 0-6 2.69-6 6s2.69 6 6 6c1.58 0 3.01-.62 4.08-1.62l14.25 8.31c-.1.42-.16.86-.16 1.31A5.83 5.83 0 1 0 36 32.17z"></path>
    </symbol>
    <symbol viewBox="0 0 48 48" id="vjs-icon-cog">
      <path d="M38.86 25.95c.08-.64.14-1.29.14-1.95s-.06-1.31-.14-1.95l4.23-3.31c.38-.3.49-.84.24-1.28l-4-6.93c-.25-.43-.77-.61-1.22-.43l-4.98 2.01c-1.03-.79-2.16-1.46-3.38-1.97L29 4.84c-.09-.47-.5-.84-1-.84h-8c-.5 0-.91.37-.99.84l-.75 5.3a14.8 14.8 0 0 0-3.38 1.97L9.9 10.1a1 1 0 0 0-1.22.43l-4 6.93c-.25.43-.14.97.24 1.28l4.22 3.31C9.06 22.69 9 23.34 9 24s.06 1.31.14 1.95l-4.22 3.31c-.38.3-.49.84-.24 1.28l4 6.93c.25.43.77.61 1.22.43l4.98-2.01c1.03.79 2.16 1.46 3.38 1.97l.75 5.3c.08.47.49.84.99.84h8c.5 0 .91-.37.99-.84l.75-5.3a14.8 14.8 0 0 0 3.38-1.97l4.98 2.01a1 1 0 0 0 1.22-.43l4-6.93c.25-.43.14-.97-.24-1.28l-4.22-3.31zM24 31c-3.87 0-7-3.13-7-7s3.13-7 7-7 7 3.13 7 7-3.13 7-7 7z"></path>
    </symbol>
    <symbol viewBox="0 0 48 48" id="vjs-icon-square">
      <path d="M36 8H12c-2.21 0-4 1.79-4 4v24c0 2.21 1.79 4 4 4h24c2.21 0 4-1.79 4-4V12c0-2.21-1.79-4-4-4zm0 28H12V12h24v24z"></path>
    </symbol>
    <symbol viewBox="0 0 48 48" id="vjs-icon-circle">
      <circle cx="24" cy="24" r="20"></circle>
    </symbol>
    <symbol viewBox="0 0 48 48" id="vjs-icon-circle-outline">
      <path d="M24 4C12.95 4 4 12.95 4 24s8.95 20 20 20 20-8.95 20-20S35.05 4 24 4zm0 36c-8.82 0-16-7.18-16-16S15.18 8 24 8s16 7.18 16 16-7.18 16-16 16z"></path>
    </symbol>
    <symbol viewBox="0 0 48 48" id="vjs-icon-circle-inner-circle">
      <path d="M24 4C12.97 4 4 12.97 4 24s8.97 20 20 20 20-8.97 20-20S35.03 4 24 4zm0 36c-8.82 0-16-7.18-16-16S15.18 8 24 8s16 7.18 16 16-7.18 16-16 16zm6-16c0 3.31-2.69 6-6 6s-6-2.69-6-6 2.69-6 6-6 6 2.69 6 6z"></path>
    </symbol>
    <symbol viewBox="0 0 48 48" id="vjs-icon-cancel">
      <path d="M24 4C12.95 4 4 12.95 4 24s8.95 20 20 20 20-8.95 20-20S35.05 4 24 4zm10 27.17L31.17 34 24 26.83 16.83 34 14 31.17 21.17 24 14 16.83 16.83 14 24 21.17 31.17 14 34 16.83 26.83 24 34 31.17z"></path>
    </symbol>
    <symbol viewBox="0 0 48 48" id="vjs-icon-replay">
      <path d="M24 10V2L14 12l10 10v-8c6.63 0 12 5.37 12 12s-5.37 12-12 12-12-5.37-12-12H8c0 8.84 7.16 16 16 16s16-7.16 16-16-7.16-16-16-16z"></path>
    </symbol>
    <symbol viewBox="0 0 48 48" id="vjs-icon-repeat">
      <path d="M14 14h20v6l8-8-8-8v6H10v12h4v-8zm20 20H14v-6l-8 8 8 8v-6h24V26h-4v8z"></path>
    </symbol>
    <symbol viewBox="0 96 48 48" id="vjs-icon-replay-5">
      <path d="M17.689 98l-8.697 8.696 8.697 8.697 2.486-2.485-4.32-4.319h1.302c4.93 0 9.071 1.722 12.424 5.165 3.352 3.443 5.029 7.638 5.029 12.584h3.55c0-2.958-.553-5.73-1.658-8.313-1.104-2.583-2.622-4.841-4.555-6.774-1.932-1.932-4.19-3.45-6.773-4.555-2.584-1.104-5.355-1.657-8.313-1.657H15.5l4.615-4.615zm-8.08 21.659v13.861h11.357v5.008H9.609V143h12.7c.834 0 1.55-.298 2.146-.894.596-.597.895-1.31.895-2.145v-7.781c0-.835-.299-1.55-.895-2.147a2.929 2.929 0 0 0-2.147-.894h-8.227v-5.096H25.35v-4.384z"></path>
    </symbol>
    <symbol viewBox="0 96 48 48" id="vjs-icon-replay-10">
      <path d="M42.315 125.63c0-4.997-1.694-9.235-5.08-12.713-3.388-3.479-7.571-5.218-12.552-5.218h-1.315l4.363 4.363-2.51 2.51-8.787-8.786L25.221 97l2.45 2.45-4.662 4.663h1.375c2.988 0 5.788.557 8.397 1.673 2.61 1.116 4.892 2.65 6.844 4.602 1.953 1.953 3.487 4.234 4.602 6.844 1.116 2.61 1.674 5.41 1.674 8.398zM8.183 142v-19.657H3.176V117.8h9.643V142zm13.63 0c-1.156 0-2.127-.393-2.912-1.178-.778-.778-1.168-1.746-1.168-2.902v-16.04c0-1.156.393-2.127 1.178-2.912.779-.779 1.746-1.168 2.902-1.168h7.696c1.156 0 2.126.392 2.911 1.177.779.78 1.168 1.747 1.168 2.903v16.04c0 1.156-.392 2.127-1.177 2.912-.779.779-1.746 1.168-2.902 1.168zm.556-4.636h6.583v-15.02H22.37z"></path>
    </symbol>
    <symbol viewBox="0 96 48 48" id="vjs-icon-replay-30">
      <path d="M26.047 97l-8.733 8.732 8.733 8.733 2.496-2.494-4.336-4.338h1.307c4.95 0 9.108 1.73 12.474 5.187 3.367 3.458 5.051 7.668 5.051 12.635h3.565c0-2.97-.556-5.751-1.665-8.346-1.109-2.594-2.633-4.862-4.574-6.802-1.94-1.941-4.208-3.466-6.803-4.575-2.594-1.109-5.375-1.664-8.345-1.664H23.85l4.634-4.634zM2.555 117.531v4.688h10.297v5.25H5.873v4.687h6.979v5.156H2.555V142H13.36c1.061 0 1.95-.395 2.668-1.186.718-.79 1.076-1.772 1.076-2.94v-16.218c0-1.168-.358-2.149-1.076-2.94-.717-.79-1.607-1.185-2.668-1.185zm22.482.14c-1.149 0-2.11.39-2.885 1.165-.78.78-1.172 1.744-1.172 2.893v15.943c0 1.149.388 2.11 1.163 2.885.78.78 1.745 1.172 2.894 1.172h7.649c1.148 0 2.11-.388 2.884-1.163.78-.78 1.17-1.745 1.17-2.894v-15.943c0-1.15-.386-2.111-1.16-2.885-.78-.78-1.746-1.172-2.894-1.172zm.553 4.518h6.545v14.93H25.59z"></path>
    </symbol>
    <symbol viewBox="0 96 48 48" id="vjs-icon-forward-5">
      <path d="M29.508 97l-2.431 2.43 4.625 4.625h-1.364c-2.965 0-5.742.554-8.332 1.66-2.589 1.107-4.851 2.629-6.788 4.566-1.937 1.937-3.458 4.2-4.565 6.788-1.107 2.59-1.66 5.367-1.66 8.331h3.557c0-4.957 1.68-9.16 5.04-12.611 3.36-3.45 7.51-5.177 12.451-5.177h1.304l-4.326 4.33 2.49 2.49 8.715-8.716zm-9.783 21.61v13.89h11.382v5.018H19.725V142h12.727a2.93 2.93 0 0 0 2.15-.896 2.93 2.93 0 0 0 .896-2.15v-7.798c0-.837-.299-1.554-.896-2.152a2.93 2.93 0 0 0-2.15-.896h-8.245V123h11.29v-4.392z"></path>
    </symbol>
    <symbol viewBox="0 96 48 48" id="vjs-icon-forward-10">
      <path d="M23.119 97l-2.386 2.383 4.538 4.538h-1.339c-2.908 0-5.633.543-8.173 1.63-2.54 1.085-4.76 2.577-6.66 4.478-1.9 1.9-3.392 4.12-4.478 6.66-1.085 2.54-1.629 5.264-1.629 8.172h3.49c0-4.863 1.648-8.986 4.944-12.372 3.297-3.385 7.368-5.078 12.216-5.078h1.279l-4.245 4.247 2.443 2.442 8.55-8.55zm-9.52 21.45v4.42h4.871V142h4.513v-23.55zm18.136 0c-1.125 0-2.066.377-2.824 1.135-.764.764-1.148 1.709-1.148 2.834v15.612c0 1.124.38 2.066 1.139 2.824.764.764 1.708 1.145 2.833 1.145h7.489c1.125 0 2.066-.378 2.824-1.136.764-.764 1.145-1.709 1.145-2.833v-15.612c0-1.125-.378-2.067-1.136-2.825-.764-.764-1.708-1.145-2.833-1.145zm.54 4.42h6.408v14.617h-6.407z"></path>
    </symbol>
    <symbol viewBox="0 96 48 48" id="vjs-icon-forward-30">
      <path d="M25.549 97l-2.437 2.434 4.634 4.635H26.38c-2.97 0-5.753.555-8.347 1.664-2.594 1.109-4.861 2.633-6.802 4.574-1.94 1.94-3.465 4.207-4.574 6.802-1.109 2.594-1.664 5.377-1.664 8.347h3.565c0-4.967 1.683-9.178 5.05-12.636 3.366-3.458 7.525-5.187 12.475-5.187h1.307l-4.335 4.338 2.495 2.494 8.732-8.732zm-11.553 20.53v4.689h10.297v5.249h-6.978v4.688h6.978v5.156H13.996V142h10.808c1.06 0 1.948-.395 2.666-1.186.718-.79 1.077-1.771 1.077-2.94v-16.217c0-1.169-.36-2.15-1.077-2.94-.718-.79-1.605-1.186-2.666-1.186zm21.174.168c-1.149 0-2.11.389-2.884 1.163-.78.78-1.172 1.745-1.172 2.894v15.942c0 1.15.388 2.11 1.162 2.885.78.78 1.745 1.17 2.894 1.17h7.649c1.149 0 2.11-.386 2.885-1.16.78-.78 1.17-1.746 1.17-2.895v-15.942c0-1.15-.387-2.11-1.161-2.885-.78-.78-1.745-1.172-2.894-1.172zm.552 4.516h6.542v14.931h-6.542z"></path>
    </symbol>
    <symbol viewBox="0 0 512 512" id="vjs-icon-audio-description">
      <g fill-rule="evenodd"><path d="M227.29 381.351V162.993c50.38-1.017 89.108-3.028 117.631 17.126 27.374 19.342 48.734 56.965 44.89 105.325-4.067 51.155-41.335 94.139-89.776 98.475-24.085 2.155-71.972 0-71.972 0s-.84-1.352-.773-2.568m48.755-54.804c31.43 1.26 53.208-16.633 56.495-45.386 4.403-38.51-21.188-63.552-58.041-60.796v103.612c-.036 1.466.575 2.22 1.546 2.57"></path><path d="M383.78 381.328c13.336 3.71 17.387-11.06 23.215-21.408 12.722-22.571 22.294-51.594 22.445-84.774.221-47.594-18.343-82.517-35.6-106.182h-8.51c-.587 3.874 2.226 7.315 3.865 10.276 13.166 23.762 25.367 56.553 25.54 94.194.2 43.176-14.162 79.278-30.955 107.894"></path><path d="M425.154 381.328c13.336 3.71 17.384-11.061 23.215-21.408 12.721-22.571 22.291-51.594 22.445-84.774.221-47.594-18.343-82.517-35.6-106.182h-8.511c-.586 3.874 2.226 7.315 3.866 10.276 13.166 23.762 25.367 56.553 25.54 94.194.2 43.176-14.162 79.278-30.955 107.894"></path><path d="M466.26 381.328c13.337 3.71 17.385-11.061 23.216-21.408 12.722-22.571 22.292-51.594 22.445-84.774.221-47.594-18.343-82.517-35.6-106.182h-8.51c-.587 3.874 2.225 7.315 3.865 10.276 13.166 23.762 25.367 56.553 25.54 94.194.2 43.176-14.162 79.278-30.955 107.894M4.477 383.005H72.58l18.573-28.484 64.169-.135s.065 19.413.065 28.62h48.756V160.307h-58.816c-5.653 9.537-140.85 222.697-140.85 222.697zm152.667-145.282v71.158l-40.453-.27 40.453-70.888z"></path></g>
    </symbol>
    <symbol viewBox="0 0 48 48" id="vjs-icon-next-item">
      <path d="M12 36l17-12-17-12v24zm20-24v24h4V12h-4z"></path>
    </symbol>
    <symbol viewBox="0 0 48 48" id="vjs-icon-previous-item">
      <path d="M12 12h4v24h-4zm7 12l17 12V12z"></path>
    </symbol>
    <symbol viewBox="0 0 48 48" id="vjs-icon-shuffle">
      <path d="M21.17 18.34L10.83 8 8 10.83l10.34 10.34 2.83-2.83zM29 8l4.09 4.09L8 37.17 10.83 40l25.09-25.09L40 19V8H29zm.66 18.83l-2.83 2.83 6.26 6.26L29 40h11V29l-4.09 4.09-6.25-6.26z"></path>
    </symbol>
    <symbol viewBox="0 0 48 48" id="vjs-icon-cast">
      <path d="M42 6H6c-2.21 0-4 1.79-4 4v6h4v-6h36v28H28v4h14c2.21 0 4-1.79 4-4V10c0-2.21-1.79-4-4-4zM2 36v6h6c0-3.31-2.69-6-6-6zm0-8v4c5.52 0 10 4.48 10 10h4c0-7.73-6.27-14-14-14zm0-8v4c9.94 0 18 8.06 18 18h4c0-12.15-9.85-22-22-22z"></path>
    </symbol>
    <symbol viewBox="0 0 48 48" id="vjs-icon-picture-in-picture-enter">
      <path d="M38 22H22v11.99h16V22zm8 16V9.96C46 7.76 44.2 6 42 6H6C3.8 6 2 7.76 2 9.96V38c0 2.2 1.8 4 4 4h36c2.2 0 4-1.8 4-4zm-4 .04H6V9.94h36v28.1z"></path>
    </symbol>
    <symbol viewBox="0 0 22 18" id="vjs-icon-picture-in-picture-exit">
      <path d="M18 4H4v10h14V4zm4 12V1.98C22 .88 21.1 0 20 0H2C.9 0 0 .88 0 1.98V16c0 1.1.9 2 2 2h18c1.1 0 2-.9 2-2zm-2 .02H2V1.97h18v14.05z"></path>
      <path fill="none" d="M-1-3h24v24H-1z"></path>
    </symbol>
    <symbol viewBox="0 0 1792 1792" id="vjs-icon-facebook">
      <path d="M1343 12v264h-157q-86 0-116 36t-30 108v189h293l-39 296h-254v759H734V905H479V609h255V391q0-186 104-288.5T1115 0q147 0 228 12z"></path>
    </symbol>
    <symbol viewBox="0 0 1792 1792" id="vjs-icon-linkedin">
      <path d="M477 625v991H147V625h330zm21-306q1 73-50.5 122T312 490h-2q-82 0-132-49t-50-122q0-74 51.5-122.5T314 148t133 48.5T498 319zm1166 729v568h-329v-530q0-105-40.5-164.5T1168 862q-63 0-105.5 34.5T999 982q-11 30-11 81v553H659q2-399 2-647t-1-296l-1-48h329v144h-2q20-32 41-56t56.5-52 87-43.5T1285 602q171 0 275 113.5t104 332.5z"></path>
    </symbol>
    <symbol viewBox="0 0 1200 1227" id="vjs-icon-twitter">
      <path d="M714.163 519.284L1160.89 0H1055.03L667.137 450.887L357.328 0H0L468.492 681.821L0 1226.37H105.866L515.491 750.218L842.672 1226.37H1200L714.137 519.284H714.163ZM569.165 687.828L521.697 619.934L144.011 79.6944H306.615L611.412 515.685L658.88 583.579L1055.08 1150.3H892.476L569.165 687.854V687.828Z"/>
    </symbol>
    <symbol viewBox="0 0 1792 1792" id="vjs-icon-tumblr">
      <path d="M1328 1329l80 237q-23 35-111 66t-177 32q-104 2-190.5-26T787 1564t-95-106-55.5-120-16.5-118V676H452V461q72-26 129-69.5t91-90 58-102 34-99T779 12q1-5 4.5-8.5T791 0h244v424h333v252h-334v518q0 30 6.5 56t22.5 52.5 49.5 41.5 81.5 14q78-2 134-29z"></path>
    </symbol>
    <symbol viewBox="0 0 1792 1792" id="vjs-icon-pinterest">
      <path d="M1664 896q0 209-103 385.5T1281.5 1561 896 1664q-111 0-218-32 59-93 78-164 9-34 54-211 20 39 73 67.5t114 28.5q121 0 216-68.5t147-188.5 52-270q0-114-59.5-214T1180 449t-255-63q-105 0-196 29t-154.5 77-109 110.5-67 129.5T377 866q0 104 40 183t117 111q30 12 38-20 2-7 8-31t8-30q6-23-11-43-51-61-51-151 0-151 104.5-259.5T904 517q151 0 235.5 82t84.5 213q0 170-68.5 289T980 1220q-61 0-98-43.5T859 1072q8-35 26.5-93.5t30-103T927 800q0-50-27-83t-77-33q-62 0-105 57t-43 142q0 73 25 122l-99 418q-17 70-13 177-206-91-333-281T128 896q0-209 103-385.5T510.5 231 896 128t385.5 103T1561 510.5 1664 896z"></path>
    </symbol>
  </defs>
</svg>`;
const S_ = fc ? 10009 : hc ? 461 : 8, ea = {
  codes: {
    play: 415,
    pause: 19,
    ff: 417,
    rw: 412,
    back: S_
  },
  names: {
    415: "play",
    19: "pause",
    417: "ff",
    412: "rw",
    [S_]: "back"
  },
  isEventKey(n, e) {
    return e = e.toLowerCase(), !!(this.names[n.keyCode] && this.names[n.keyCode] === e);
  },
  getEventName(n) {
    if (this.names[n.keyCode])
      return this.names[n.keyCode];
    if (this.codes[n.code]) {
      const e = this.codes[n.code];
      return this.names[e];
    }
    return null;
  }
}, C_ = 5;
class DO extends Dn {
  /**
   * Constructs a SpatialNavigation instance with initial settings.
   * Sets up the player instance, and prepares the spatial navigation system.
   *
   * @class
   * @param {Player} player - The Video.js player instance to which the spatial navigation is attached.
   */
  constructor(e) {
    super(), this.player_ = e, this.focusableComponents = [], this.isListening_ = !1, this.isPaused_ = !1, this.onKeyDown_ = this.onKeyDown_.bind(this), this.lastFocusedComponent_ = null;
  }
  /**
   * Starts the spatial navigation by adding a keydown event listener to the video container.
   * This method ensures that the event listener is added only once.
   */
  start() {
    this.isListening_ || (this.player_.on("keydown", this.onKeyDown_), this.player_.on("modalKeydown", this.onKeyDown_), this.player_.on("loadedmetadata", () => {
      this.focus(this.updateFocusableComponents()[0]);
    }), this.player_.on("modalclose", () => {
      this.refocusComponent();
    }), this.player_.on("focusin", this.handlePlayerFocus_.bind(this)), this.player_.on("focusout", this.handlePlayerBlur_.bind(this)), this.isListening_ = !0, this.player_.errorDisplay && this.player_.errorDisplay.on("aftermodalfill", () => {
      this.updateFocusableComponents(), this.focusableComponents.length && (this.focusableComponents.length > 1 ? this.focusableComponents[1].focus() : this.focusableComponents[0].focus());
    }));
  }
  /**
   * Stops the spatial navigation by removing the keydown event listener from the video container.
   * Also sets the `isListening_` flag to false.
   */
  stop() {
    this.player_.off("keydown", this.onKeyDown_), this.isListening_ = !1;
  }
  /**
   * Responds to keydown events for spatial navigation and media control.
   *
   * Determines if spatial navigation or media control is active and handles key inputs accordingly.
   *
   * @param {KeyboardEvent} event - The keydown event to be handled.
   */
  onKeyDown_(e) {
    const t = e.originalEvent ? e.originalEvent : e;
    if (["ArrowLeft", "ArrowRight", "ArrowUp", "ArrowDown"].includes(t.key)) {
      if (this.isPaused_)
        return;
      t.preventDefault();
      const i = t.key.substring(5).toLowerCase();
      this.move(i);
    } else if (ea.isEventKey(t, "play") || ea.isEventKey(t, "pause") || ea.isEventKey(t, "ff") || ea.isEventKey(t, "rw")) {
      t.preventDefault();
      const i = ea.getEventName(t);
      this.performMediaAction_(i);
    } else ea.isEventKey(t, "Back") && e.target && typeof e.target.closeable == "function" && e.target.closeable() && (t.preventDefault(), e.target.close());
  }
  /**
   * Performs media control actions based on the given key input.
   *
   * Controls the playback and seeking functionalities of the media player.
   *
   * @param {string} key - The key representing the media action to be performed.
   *   Accepted keys: 'play', 'pause', 'ff' (fast-forward), 'rw' (rewind).
   */
  performMediaAction_(e) {
    if (this.player_)
      switch (e) {
        case "play":
          this.player_.paused() && this.player_.play();
          break;
        case "pause":
          this.player_.paused() || this.player_.pause();
          break;
        case "ff":
          this.userSeek_(this.player_.currentTime() + C_);
          break;
        case "rw":
          this.userSeek_(this.player_.currentTime() - C_);
          break;
      }
  }
  /**
   * Prevent liveThreshold from causing seeks to seem like they
   * are not happening from a user perspective.
   *
   * @param {number} ct
   *        current time to seek to
   */
  userSeek_(e) {
    this.player_.liveTracker && this.player_.liveTracker.isLive() && this.player_.liveTracker.nextSeekedFromUser(), this.player_.currentTime(e);
  }
  /**
   * Pauses the spatial navigation functionality.
   * This method sets a flag that can be used to temporarily disable the navigation logic.
   */
  pause() {
    this.isPaused_ = !0;
  }
  /**
   * Resumes the spatial navigation functionality if it has been paused.
   * This method resets the pause flag, re-enabling the navigation logic.
   */
  resume() {
    this.isPaused_ = !1;
  }
  /**
   * Handles Player Blur.
   *
   * @param {string|Event|Object} event
   *        The name of the event, an `Event`, or an object with a key of type set to
   *        an event name.
   *
   * Calls for handling of the Player Blur if:
   * *The next focused element is not a child of current focused element &
   * The next focused element is not a child of the Player.
   * *There is no next focused element
   */
  handlePlayerBlur_(e) {
    const t = e.relatedTarget;
    let i = null;
    const r = this.getCurrentComponent(e.target);
    t && (i = !!t.closest(".video-js"), t.classList.contains("vjs-text-track-settings") && !this.isPaused_ && this.searchForTrackSelect_()), (!e.currentTarget.contains(e.relatedTarget) && !i || !t) && (r && r.name() === "CloseButton" ? this.refocusComponent() : (this.pause(), r && r.el() && (this.lastFocusedComponent_ = r)));
  }
  /**
   * Handles the Player focus event.
   *
   * Calls for handling of the Player Focus if current element is focusable.
   */
  handlePlayerFocus_() {
    this.getCurrentComponent() && this.getCurrentComponent().getIsFocusable() && this.resume();
  }
  /**
   * Gets a set of focusable components.
   *
   * @return {Array}
   *         Returns an array of focusable components.
   */
  updateFocusableComponents() {
    const e = this.player_, t = [];
    function i(r) {
      for (const a of r)
        a.hasOwnProperty("el_") && a.getIsFocusable() && a.getIsAvailableToBeFocused(a.el()) && t.push(a), a.hasOwnProperty("children_") && a.children_.length > 0 && i(a.children_);
    }
    return e.children_.forEach((r) => {
      if (r.hasOwnProperty("el_"))
        if (r.getIsFocusable && r.getIsAvailableToBeFocused && r.getIsFocusable() && r.getIsAvailableToBeFocused(r.el())) {
          t.push(r);
          return;
        } else r.hasOwnProperty("children_") && r.children_.length > 0 ? i(r.children_) : r.hasOwnProperty("items") && r.items.length > 0 ? i(r.items) : this.findSuitableDOMChild(r) && t.push(r);
      if (r.name_ === "ErrorDisplay" && r.opened_) {
        const a = r.el_.querySelector(".vjs-errors-ok-button-container");
        a && a.querySelectorAll("button").forEach((o, u) => {
          t.push({
            name: () => "ModalButton" + (u + 1),
            el: () => o,
            getPositions: () => {
              const c = o.getBoundingClientRect(), l = {
                x: c.x,
                y: c.y,
                width: c.width,
                height: c.height,
                top: c.top,
                right: c.right,
                bottom: c.bottom,
                left: c.left
              }, h = {
                x: c.left + c.width / 2,
                y: c.top + c.height / 2,
                width: 0,
                height: 0,
                top: c.top + c.height / 2,
                right: c.left + c.width / 2,
                bottom: c.top + c.height / 2,
                left: c.left + c.width / 2
              };
              return {
                boundingClientRect: l,
                center: h
              };
            },
            // Asume that the following are always focusable
            getIsAvailableToBeFocused: () => !0,
            getIsFocusable: (c) => !0,
            focus: () => o.focus()
          });
        });
      }
    }), this.focusableComponents = t, this.focusableComponents;
  }
  /**
   * Finds a suitable child element within the provided component's DOM element.
   *
   * @param {Object} component - The component containing the DOM element to search within.
   * @return {HTMLElement|null} Returns the suitable child element if found, or null if not found.
   */
  findSuitableDOMChild(e) {
    function t(i) {
      if (e.getIsFocusable(i) && e.getIsAvailableToBeFocused(i))
        return i;
      for (let r = 0; r < i.children.length; r++) {
        const a = i.children[r], s = t(a);
        if (s)
          return s;
      }
      return null;
    }
    return e.el() ? t(e.el()) : null;
  }
  /**
   * Gets the currently focused component from the list of focusable components.
   * If a target element is provided, it uses that element to find the corresponding
   * component. If no target is provided, it defaults to using the document's currently
   * active element.
   *
   * @param {HTMLElement} [target] - The DOM element to check against the focusable components.
   *                                 If not provided, `document.activeElement` is used.
   * @return {Component|null} - Returns the focused component if found among the focusable components,
   *                            otherwise returns null if no matching component is found.
   */
  getCurrentComponent(e) {
    this.updateFocusableComponents();
    const t = e || document.activeElement;
    if (this.focusableComponents.length) {
      for (const i of this.focusableComponents)
        if (i.el() === t)
          return i;
    }
  }
  /**
   * Adds a component to the array of focusable components.
   *
   * @param {Component} component
   *        The `Component` to be added.
   */
  add(e) {
    const t = [...this.focusableComponents];
    e.hasOwnProperty("el_") && e.getIsFocusable() && e.getIsAvailableToBeFocused(e.el()) && t.push(e), this.focusableComponents = t, this.trigger({
      type: "focusableComponentsChanged",
      focusableComponents: this.focusableComponents
    });
  }
  /**
   * Removes component from the array of focusable components.
   *
   * @param {Component} component - The component to be removed from the focusable components array.
   */
  remove(e) {
    for (let t = 0; t < this.focusableComponents.length; t++)
      if (this.focusableComponents[t].name() === e.name()) {
        this.focusableComponents.splice(t, 1), this.trigger({
          type: "focusableComponentsChanged",
          focusableComponents: this.focusableComponents
        });
        return;
      }
  }
  /**
   * Clears array of focusable components.
   */
  clear() {
    this.focusableComponents.length > 0 && (this.focusableComponents = [], this.trigger({
      type: "focusableComponentsChanged",
      focusableComponents: this.focusableComponents
    }));
  }
  /**
   * Navigates to the next focusable component based on the specified direction.
   *
   * @param {string} direction 'up', 'down', 'left', 'right'
   */
  move(e) {
    const t = this.getCurrentComponent();
    if (!t)
      return;
    const i = t.getPositions(), r = this.focusableComponents.filter((s) => s !== t && this.isInDirection_(i.boundingClientRect, s.getPositions().boundingClientRect, e)), a = this.findBestCandidate_(i.center, r, e);
    a ? this.focus(a) : this.trigger({
      type: "endOfFocusableComponents",
      direction: e,
      focusedComponent: t
    });
  }
  /**
   * Finds the best candidate on the current center position,
   * the list of candidates, and the specified navigation direction.
   *
   * @param {Object} currentCenter The center position of the current focused component element.
   * @param {Array} candidates An array of candidate components to receive focus.
   * @param {string} direction The direction of navigation ('up', 'down', 'left', 'right').
   * @return {Object|null} The component that is the best candidate for receiving focus.
   */
  findBestCandidate_(e, t, i) {
    let r = 1 / 0, a = null;
    for (const s of t) {
      const o = s.getPositions().center, u = this.calculateDistance_(e, o, i);
      u < r && (r = u, a = s);
    }
    return a;
  }
  /**
   * Determines if a target rectangle is in the specified navigation direction
   * relative to a source rectangle.
   *
   * @param {Object} srcRect The bounding rectangle of the source element.
   * @param {Object} targetRect The bounding rectangle of the target element.
   * @param {string} direction The navigation direction ('up', 'down', 'left', 'right').
   * @return {boolean} True if the target is in the specified direction relative to the source.
   */
  isInDirection_(e, t, i) {
    switch (i) {
      case "right":
        return t.left >= e.right;
      case "left":
        return t.right <= e.left;
      case "down":
        return t.top >= e.bottom;
      case "up":
        return t.bottom <= e.top;
      default:
        return !1;
    }
  }
  /**
   * Focus the last focused component saved before blur on player.
   */
  refocusComponent() {
    if (this.lastFocusedComponent_) {
      this.player_.userActive() || this.player_.userActive(!0), this.updateFocusableComponents();
      for (let e = 0; e < this.focusableComponents.length; e++)
        if (this.focusableComponents[e].name() === this.lastFocusedComponent_.name()) {
          this.focus(this.focusableComponents[e]);
          return;
        }
    } else
      this.focus(this.updateFocusableComponents()[0]);
  }
  /**
   * Focuses on a given component.
   * If the component is available to be focused, it focuses on the component.
   * If not, it attempts to find a suitable DOM child within the component and focuses on it.
   *
   * @param {Component} component - The component to be focused.
   */
  focus(e) {
    typeof e == "object" && (e.getIsAvailableToBeFocused(e.el()) ? e.focus() : this.findSuitableDOMChild(e) && this.findSuitableDOMChild(e).focus());
  }
  /**
   * Calculates the distance between two points, adjusting the calculation based on
   * the specified navigation direction.
   *
   * @param {Object} center1 The center point of the first element.
   * @param {Object} center2 The center point of the second element.
   * @param {string} direction The direction of navigation ('up', 'down', 'left', 'right').
   * @return {number} The calculated distance between the two centers.
   */
  calculateDistance_(e, t, i) {
    const r = Math.abs(e.x - t.x), a = Math.abs(e.y - t.y);
    let s;
    switch (i) {
      case "right":
      case "left":
        s = r + a * 100;
        break;
      case "up":
        s = a * 2 + r * 0.5;
        break;
      case "down":
        s = a * 5 + r;
        break;
      default:
        s = r + a;
    }
    return s;
  }
  /**
   * This gets called by 'handlePlayerBlur_' if 'spatialNavigation' is enabled.
   * Searches for the first 'TextTrackSelect' inside of modal to focus.
   *
   * @private
   */
  searchForTrackSelect_() {
    const e = this;
    for (const t of e.updateFocusableComponents())
      if (t.constructor.name === "TextTrackSelect") {
        e.focus(t);
        break;
      }
  }
}
class SO extends Pe {
  /**
   * Create an instance of this class.
   *
   * @param {Player} player
   *        The `Player` that this class should attach to.
   *
   * @param {Object} [options]
   *        The key/value store of player options.
   *
   * @param {Function} [ready]
   *        The function that is run when this component is ready.
   */
  constructor(e, t, i) {
    const r = yt({
      createEl: !1
    }, t);
    if (super(e, r, i), !t.playerOptions.sources || t.playerOptions.sources.length === 0)
      for (let a = 0, s = t.playerOptions.techOrder; a < s.length; a++) {
        const o = Rt(s[a]);
        let u = tt.getTech(o);
        if (o || (u = Pe.getComponent(o)), u && u.isSupported()) {
          e.loadTech_(o);
          break;
        }
      }
    else
      e.src(t.playerOptions.sources);
  }
}
Pe.registerComponent("MediaLoader", SO);
class Sl extends Pe {
  /**
   * Creates an instance of this class.
   *
   * @param  {Player} player
   *         The `Player` that this class should be attached to.
   *
   * @param  {Object} [options]
   *         The key/value store of component options.
   *
   * @param  {function} [options.clickHandler]
   *         The function to call when the button is clicked / activated
   *
   * @param  {string} [options.controlText]
   *         The text to set on the button
   *
   * @param  {string} [options.className]
   *         A class or space separated list of classes to add the component
   *
   */
  constructor(e, t) {
    super(e, t), this.options_.controlText && this.controlText(this.options_.controlText), this.handleMouseOver_ = (i) => this.handleMouseOver(i), this.handleMouseOut_ = (i) => this.handleMouseOut(i), this.handleClick_ = (i) => this.handleClick(i), this.handleKeyDown_ = (i) => this.handleKeyDown(i), this.emitTapEvents(), this.enable();
  }
  /**
   * Create the `ClickableComponent`s DOM element.
   *
   * @param {string} [tag=div]
   *        The element's node type.
   *
   * @param {Object} [props={}]
   *        An object of properties that should be set on the element.
   *
   * @param {Object} [attributes={}]
   *        An object of attributes that should be set on the element.
   *
   * @return {Element}
   *         The element that gets created.
   */
  createEl(e = "div", t = {}, i = {}) {
    t = Object.assign({
      className: this.buildCSSClass(),
      tabIndex: 0
    }, t), e === "button" && at.error(`Creating a ClickableComponent with an HTML element of ${e} is not supported; use a Button instead.`), i = Object.assign({
      role: "button"
    }, i), this.tabIndex_ = t.tabIndex;
    const r = Ye(e, t, i);
    return this.player_.options_.experimentalSvgIcons || r.appendChild(Ye("span", {
      className: "vjs-icon-placeholder"
    }, {
      "aria-hidden": !0
    })), this.createControlTextEl(r), r;
  }
  dispose() {
    this.controlTextEl_ = null, super.dispose();
  }
  /**
   * Create a control text element on this `ClickableComponent`
   *
   * @param {Element} [el]
   *        Parent element for the control text.
   *
   * @return {Element}
   *         The control text element that gets created.
   */
  createControlTextEl(e) {
    return this.controlTextEl_ = Ye("span", {
      className: "vjs-control-text"
    }, {
      // let the screen reader user know that the text of the element may change
      "aria-live": "polite"
    }), e && e.appendChild(this.controlTextEl_), this.controlText(this.controlText_, e), this.controlTextEl_;
  }
  /**
   * Get or set the localize text to use for the controls on the `ClickableComponent`.
   *
   * @param {string} [text]
   *        Control text for element.
   *
   * @param {Element} [el=this.el()]
   *        Element to set the title on.
   *
   * @return {string}
   *         - The control text when getting
   */
  controlText(e, t = this.el()) {
    if (e === void 0)
      return this.controlText_ || "Need Text";
    const i = this.localize(e);
    this.controlText_ = e, lr(this.controlTextEl_, i), !this.nonIconControl && !this.player_.options_.noUITitleAttributes && t.setAttribute("title", i);
  }
  /**
   * Builds the default DOM `className`.
   *
   * @return {string}
   *         The DOM `className` for this object.
   */
  buildCSSClass() {
    return `vjs-control vjs-button ${super.buildCSSClass()}`;
  }
  /**
   * Enable this `ClickableComponent`
   */
  enable() {
    this.enabled_ || (this.enabled_ = !0, this.removeClass("vjs-disabled"), this.el_.setAttribute("aria-disabled", "false"), typeof this.tabIndex_ < "u" && this.el_.setAttribute("tabIndex", this.tabIndex_), this.on(["tap", "click"], this.handleClick_), this.on("keydown", this.handleKeyDown_));
  }
  /**
   * Disable this `ClickableComponent`
   */
  disable() {
    this.enabled_ = !1, this.addClass("vjs-disabled"), this.el_.setAttribute("aria-disabled", "true"), typeof this.tabIndex_ < "u" && this.el_.removeAttribute("tabIndex"), this.off("mouseover", this.handleMouseOver_), this.off("mouseout", this.handleMouseOut_), this.off(["tap", "click"], this.handleClick_), this.off("keydown", this.handleKeyDown_);
  }
  /**
   * Handles language change in ClickableComponent for the player in components
   *
   *
   */
  handleLanguagechange() {
    this.controlText(this.controlText_);
  }
  /**
   * Event handler that is called when a `ClickableComponent` receives a
   * `click` or `tap` event.
   *
   * @param {Event} event
   *        The `tap` or `click` event that caused this function to be called.
   *
   * @listens tap
   * @listens click
   * @abstract
   */
  handleClick(e) {
    this.options_.clickHandler && this.options_.clickHandler.call(this, arguments);
  }
  /**
   * Event handler that is called when a `ClickableComponent` receives a
   * `keydown` event.
   *
   * By default, if the key is Space or Enter, it will trigger a `click` event.
   *
   * @param {KeyboardEvent} event
   *        The `keydown` event that caused this function to be called.
   *
   * @listens keydown
   */
  handleKeyDown(e) {
    e.key === " " || e.key === "Enter" ? (e.preventDefault(), e.stopPropagation(), this.trigger("click")) : super.handleKeyDown(e);
  }
}
Pe.registerComponent("ClickableComponent", Sl);
class xm extends Sl {
  /**
   * Create an instance of this class.
   *
   * @param {Player} player
   *        The `Player` that this class should attach to.
   *
   * @param {Object} [options]
   *        The key/value store of player options.
   */
  constructor(e, t) {
    super(e, t), this.update(), this.update_ = (i) => this.update(i), e.on("posterchange", this.update_);
  }
  /**
   * Clean up and dispose of the `PosterImage`.
   */
  dispose() {
    this.player().off("posterchange", this.update_), super.dispose();
  }
  /**
   * Create the `PosterImage`s DOM element.
   *
   * @return {Element}
   *         The element that gets created.
   */
  createEl() {
    return Ye("div", {
      className: "vjs-poster"
    });
  }
  /**
   * Get or set the `PosterImage`'s crossOrigin option.
   *
   * @param {string|null} [value]
   *        The value to set the crossOrigin to. If an argument is
   *        given, must be one of `'anonymous'` or `'use-credentials'`, or 'null'.
   *
   * @return {string|null}
   *         - The current crossOrigin value of the `Player` when getting.
   *         - undefined when setting
   */
  crossOrigin(e) {
    if (typeof e > "u")
      return this.$("img") ? this.$("img").crossOrigin : this.player_.tech_ && this.player_.tech_.isReady_ ? this.player_.crossOrigin() : this.player_.options_.crossOrigin || this.player_.options_.crossorigin || null;
    if (e !== null && e !== "anonymous" && e !== "use-credentials") {
      this.player_.log.warn(`crossOrigin must be null,  "anonymous" or "use-credentials", given "${e}"`);
      return;
    }
    this.$("img") && (this.$("img").crossOrigin = e);
  }
  /**
   * An {@link EventTarget~EventListener} for {@link Player#posterchange} events.
   *
   * @listens Player#posterchange
   *
   * @param {Event} [event]
   *        The `Player#posterchange` event that triggered this function.
   */
  update(e) {
    const t = this.player().poster();
    this.setSrc(t), t ? this.show() : this.hide();
  }
  /**
   * Set the source of the `PosterImage` depending on the display method. (Re)creates
   * the inner picture and img elementss when needed.
   *
   * @param {string} [url]
   *        The URL to the source for the `PosterImage`. If not specified or falsy,
   *        any source and ant inner picture/img are removed.
   */
  setSrc(e) {
    if (!e) {
      this.el_.textContent = "";
      return;
    }
    this.$("img") || this.el_.appendChild(Ye("picture", {
      className: "vjs-poster",
      // Don't want poster to be tabbable.
      tabIndex: -1
    }, {}, Ye("img", {
      loading: "lazy",
      crossOrigin: this.crossOrigin()
    }, {
      alt: ""
    }))), this.$("img").src = e;
  }
  /**
   * An {@link EventTarget~EventListener} for clicks on the `PosterImage`. See
   * {@link ClickableComponent#handleClick} for instances where this will be triggered.
   *
   * @listens tap
   * @listens click
   * @listens keydown
   *
   * @param {Event} event
   +        The `click`, `tap` or `keydown` event that caused this function to be called.
   */
  handleClick(e) {
    this.player_.controls() && (this.player_.tech(!0) && this.player_.tech(!0).focus(), this.player_.paused() ? mi(this.player_.play()) : this.player_.pause());
  }
}
xm.prototype.crossorigin = xm.prototype.crossOrigin;
Pe.registerComponent("PosterImage", xm);
const Ln = "#222", A_ = "#ccc", CO = {
  monospace: "monospace",
  sansSerif: "sans-serif",
  serif: "serif",
  monospaceSansSerif: '"Andale Mono", "Lucida Console", monospace',
  monospaceSerif: '"Courier New", monospace',
  proportionalSansSerif: "sans-serif",
  proportionalSerif: "serif",
  casual: '"Comic Sans MS", Impact, fantasy',
  script: '"Monotype Corsiva", cursive',
  smallcaps: '"Andale Mono", "Lucida Console", monospace, sans-serif'
};
function Ip(n, e) {
  let t;
  if (n.length === 4)
    t = n[1] + n[1] + n[2] + n[2] + n[3] + n[3];
  else if (n.length === 7)
    t = n.slice(1);
  else
    throw new Error("Invalid color code provided, " + n + "; must be formatted as e.g. #f0e or #f604e2.");
  return "rgba(" + parseInt(t.slice(0, 2), 16) + "," + parseInt(t.slice(2, 4), 16) + "," + parseInt(t.slice(4, 6), 16) + "," + e + ")";
}
function fi(n, e, t) {
  try {
    n.style[e] = t;
  } catch {
    return;
  }
}
function k_(n) {
  return n ? `${n}px` : "";
}
class AO extends Pe {
  /**
   * Creates an instance of this class.
   *
   * @param {Player} player
   *        The `Player` that this class should be attached to.
   *
   * @param {Object} [options]
   *        The key/value store of player options.
   *
   * @param {Function} [ready]
   *        The function to call when `TextTrackDisplay` is ready.
   */
  constructor(e, t, i) {
    super(e, t, i);
    const r = (s) => this.updateDisplay(s), a = (s) => {
      this.updateDisplayOverlay(), this.updateDisplay(s);
    };
    e.on("loadstart", (s) => this.toggleDisplay(s)), e.on("useractive", r), e.on("userinactive", r), e.on("texttrackchange", r), e.on("loadedmetadata", (s) => {
      this.updateDisplayOverlay(), this.preselectTrack(s);
    }), e.ready(_t(this, function() {
      if (e.tech_ && e.tech_.featuresNativeTextTracks) {
        this.hide();
        return;
      }
      e.on("fullscreenchange", a), e.on("playerresize", a);
      const s = me.screen.orientation || me, o = me.screen.orientation ? "change" : "orientationchange";
      s.addEventListener(o, a), e.on("dispose", () => s.removeEventListener(o, a));
      const u = this.options_.playerOptions.tracks || [];
      for (let c = 0; c < u.length; c++)
        this.player_.addRemoteTextTrack(u[c], !0);
      this.preselectTrack();
    }));
  }
  /**
  * Preselect a track following this precedence:
  * - matches the previously selected {@link TextTrack}'s language and kind
  * - matches the previously selected {@link TextTrack}'s language only
  * - is the first default captions track
  * - is the first default descriptions track
  *
  * @listens Player#loadstart
  */
  preselectTrack() {
    const e = {
      captions: 1,
      subtitles: 1
    }, t = this.player_.textTracks(), i = this.player_.cache_.selectedLanguage;
    let r, a, s;
    for (let o = 0; o < t.length; o++) {
      const u = t[o];
      i && i.enabled && i.language && i.language === u.language && u.kind in e ? u.kind === i.kind ? s = u : s || (s = u) : i && !i.enabled ? (s = null, r = null, a = null) : u.default && (u.kind === "descriptions" && !r ? r = u : u.kind in e && !a && (a = u));
    }
    s ? s.mode = "showing" : a ? a.mode = "showing" : r && (r.mode = "showing");
  }
  /**
   * Turn display of {@link TextTrack}'s from the current state into the other state.
   * There are only two states:
   * - 'shown'
   * - 'hidden'
   *
   * @listens Player#loadstart
   */
  toggleDisplay() {
    this.player_.tech_ && this.player_.tech_.featuresNativeTextTracks ? this.hide() : this.show();
  }
  /**
   * Create the {@link Component}'s DOM element.
   *
   * @return {Element}
   *         The element that was created.
   */
  createEl() {
    return super.createEl("div", {
      className: "vjs-text-track-display"
    }, {
      translate: "yes",
      "aria-live": "off",
      "aria-atomic": "true"
    });
  }
  /**
   * Clear all displayed {@link TextTrack}s.
   */
  clearDisplay() {
    typeof me.WebVTT == "function" && me.WebVTT.processCues(me, [], this.el_);
  }
  /**
   * Update the displayed {@link TextTrack} when either a {@link Player#texttrackchange},
   * a {@link Player#fullscreenchange}, a {@link Player#useractive}, or a
   * {@link Player#userinactive} is fired.
   *
   * @listens Player#texttrackchange
   * @listens Player#fullscreenchange
   * @listens Player#useractive
   * @listens Player#userinactive
   */
  updateDisplay() {
    const e = this.player_.textTracks(), t = this.options_.allowMultipleShowingTracks;
    if (this.clearDisplay(), t) {
      const s = [];
      for (let o = 0; o < e.length; ++o) {
        const u = e[o];
        u.mode === "showing" && s.push(u);
      }
      this.updateForTrack(s);
      return;
    }
    let i = null, r = null, a = e.length;
    for (; a--; ) {
      const s = e[a];
      s.mode === "showing" && (s.kind === "descriptions" ? i = s : r = s);
    }
    if (r ? (this.getAttribute("aria-live") !== "off" && this.setAttribute("aria-live", "off"), this.updateForTrack(r)) : i && (this.getAttribute("aria-live") !== "assertive" && this.setAttribute("aria-live", "assertive"), this.updateForTrack(i)), !me.CSS.supports("inset", "10px")) {
      const s = this.el_, o = s.querySelectorAll(".vjs-text-track-cue"), u = this.player_.controlBar.el_.getBoundingClientRect().height, c = this.player_.el_.getBoundingClientRect().height;
      s.style = "", fi(s, "position", "relative"), fi(s, "height", c - u + "px"), fi(s, "top", "unset"), pc ? fi(s, "bottom", c + "px") : fi(s, "bottom", "0px"), o.length > 0 && o.forEach((l) => {
        if (l.style.inset) {
          const h = l.style.inset.split(" ");
          h.length === 3 && Object.assign(l.style, {
            top: h[0],
            right: h[1],
            bottom: h[2],
            left: "unset"
          });
        }
      });
    }
  }
  /**
   * Updates the displayed TextTrack to be sure it overlays the video when a either
   * a {@link Player#texttrackchange} or a {@link Player#fullscreenchange} is fired.
   */
  updateDisplayOverlay() {
    if (!this.player_.videoHeight() || !me.CSS.supports("inset-inline: 10px"))
      return;
    const e = this.player_.currentWidth(), t = this.player_.currentHeight(), i = e / t, r = this.player_.videoWidth() / this.player_.videoHeight();
    let a = 0, s = 0;
    Math.abs(i - r) > 0.1 && (i > r ? a = Math.round((e - t * r) / 2) : s = Math.round((t - e / r) / 2)), fi(this.el_, "insetInline", k_(a)), fi(this.el_, "insetBlock", k_(s));
  }
  /**
   * Style {@Link TextTrack} activeCues according to {@Link TextTrackSettings}.
   *
   * @param {TextTrack} track
   *        Text track object containing active cues to style.
   */
  updateDisplayState(e) {
    const t = this.player_.textTrackSettings.getValues(), i = e.activeCues;
    let r = i.length;
    for (; r--; ) {
      const a = i[r];
      if (!a)
        continue;
      const s = a.displayState;
      if (t.color && (s.firstChild.style.color = t.color), t.textOpacity && fi(s.firstChild, "color", Ip(t.color || "#fff", t.textOpacity)), t.backgroundColor && (s.firstChild.style.backgroundColor = t.backgroundColor), t.backgroundOpacity && fi(s.firstChild, "backgroundColor", Ip(t.backgroundColor || "#000", t.backgroundOpacity)), t.windowColor && (t.windowOpacity ? fi(s, "backgroundColor", Ip(t.windowColor, t.windowOpacity)) : s.style.backgroundColor = t.windowColor), t.edgeStyle && (t.edgeStyle === "dropshadow" ? s.firstChild.style.textShadow = `2px 2px 3px ${Ln}, 2px 2px 4px ${Ln}, 2px 2px 5px ${Ln}` : t.edgeStyle === "raised" ? s.firstChild.style.textShadow = `1px 1px ${Ln}, 2px 2px ${Ln}, 3px 3px ${Ln}` : t.edgeStyle === "depressed" ? s.firstChild.style.textShadow = `1px 1px ${A_}, 0 1px ${A_}, -1px -1px ${Ln}, 0 -1px ${Ln}` : t.edgeStyle === "uniform" && (s.firstChild.style.textShadow = `0 0 4px ${Ln}, 0 0 4px ${Ln}, 0 0 4px ${Ln}, 0 0 4px ${Ln}`)), t.fontPercent && t.fontPercent !== 1) {
        const o = me.parseFloat(s.style.fontSize);
        s.style.fontSize = o * t.fontPercent + "px", s.style.height = "auto", s.style.top = "auto";
      }
      t.fontFamily && t.fontFamily !== "default" && (t.fontFamily === "small-caps" ? s.firstChild.style.fontVariant = "small-caps" : s.firstChild.style.fontFamily = CO[t.fontFamily]);
    }
  }
  /**
   * Add an {@link TextTrack} to to the {@link Tech}s {@link TextTrackList}.
   *
   * @param {TextTrack|TextTrack[]} tracks
   *        Text track object or text track array to be added to the list.
   */
  updateForTrack(e) {
    if (Array.isArray(e) || (e = [e]), typeof me.WebVTT != "function" || e.every((i) => !i.activeCues))
      return;
    const t = [];
    for (let i = 0; i < e.length; ++i) {
      const r = e[i];
      for (let a = 0; a < r.activeCues.length; ++a)
        t.push(r.activeCues[a]);
    }
    me.WebVTT.processCues(me, t, this.el_);
    for (let i = 0; i < e.length; ++i) {
      const r = e[i];
      for (let a = 0; a < r.activeCues.length; ++a) {
        const s = r.activeCues[a].displayState;
        Rr(s, "vjs-text-track-cue", "vjs-text-track-cue-" + (r.language ? r.language : i)), r.language && Da(s, "lang", r.language);
      }
      this.player_.textTrackSettings && this.updateDisplayState(r);
    }
  }
}
Pe.registerComponent("TextTrackDisplay", AO);
class kO extends Pe {
  /**
   * Create the `LoadingSpinner`s DOM element.
   *
   * @return {Element}
   *         The dom element that gets created.
   */
  createEl() {
    const e = this.player_.isAudio(), t = this.localize(e ? "Audio Player" : "Video Player"), i = Ye("span", {
      className: "vjs-control-text",
      textContent: this.localize("{1} is loading.", [t])
    }), r = super.createEl("div", {
      className: "vjs-loading-spinner",
      dir: "ltr"
    });
    return r.appendChild(i), r;
  }
  /**
   * Update control text on languagechange
   */
  handleLanguagechange() {
    this.$(".vjs-control-text").textContent = this.localize("{1} is loading.", [this.player_.isAudio() ? "Audio Player" : "Video Player"]);
  }
}
Pe.registerComponent("LoadingSpinner", kO);
let Kt = class extends Sl {
  /**
   * Create the `Button`s DOM element.
   *
   * @param {string} [tag="button"]
   *        The element's node type. This argument is IGNORED: no matter what
   *        is passed, it will always create a `button` element.
   *
   * @param {Object} [props={}]
   *        An object of properties that should be set on the element.
   *
   * @param {Object} [attributes={}]
   *        An object of attributes that should be set on the element.
   *
   * @return {Element}
   *         The element that gets created.
   */
  createEl(e, t = {}, i = {}) {
    e = "button", t = Object.assign({
      className: this.buildCSSClass()
    }, t), i = Object.assign({
      // Necessary since the default button type is "submit"
      type: "button"
    }, i);
    const r = Ye(e, t, i);
    return this.player_.options_.experimentalSvgIcons || r.appendChild(Ye("span", {
      className: "vjs-icon-placeholder"
    }, {
      "aria-hidden": !0
    })), this.createControlTextEl(r), r;
  }
  /**
   * Add a child `Component` inside of this `Button`.
   *
   * @param {string|Component} child
   *        The name or instance of a child to add.
   *
   * @param {Object} [options={}]
   *        The key/value store of options that will get passed to children of
   *        the child.
   *
   * @return {Component}
   *         The `Component` that gets added as a child. When using a string the
   *         `Component` will get created by this process.
   *
   * @deprecated since version 5
   */
  addChild(e, t = {}) {
    const i = this.constructor.name;
    return at.warn(`Adding an actionable (user controllable) child to a Button (${i}) is not supported; use a ClickableComponent instead.`), Pe.prototype.addChild.call(this, e, t);
  }
  /**
   * Enable the `Button` element so that it can be activated or clicked. Use this with
   * {@link Button#disable}.
   */
  enable() {
    super.enable(), this.el_.removeAttribute("disabled");
  }
  /**
   * Disable the `Button` element so that it cannot be activated or clicked. Use this with
   * {@link Button#enable}.
   */
  disable() {
    super.disable(), this.el_.setAttribute("disabled", "disabled");
  }
  /**
   * This gets called when a `Button` has focus and `keydown` is triggered via a key
   * press.
   *
   * @param {KeyboardEvent} event
   *        The event that caused this function to get called.
   *
   * @listens keydown
   */
  handleKeyDown(e) {
    if (e.key === " " || e.key === "Enter") {
      e.stopPropagation();
      return;
    }
    super.handleKeyDown(e);
  }
};
Pe.registerComponent("Button", Kt);
class sS extends Kt {
  constructor(e, t) {
    super(e, t), this.mouseused_ = !1, this.setIcon("play"), this.on("mousedown", (i) => this.handleMouseDown(i));
  }
  /**
   * Builds the default DOM `className`.
   *
   * @return {string}
   *         The DOM `className` for this object. Always returns 'vjs-big-play-button'.
   */
  buildCSSClass() {
    return "vjs-big-play-button";
  }
  /**
   * This gets called when a `BigPlayButton` "clicked". See {@link ClickableComponent}
   * for more detailed information on what a click can be.
   *
   * @param {KeyboardEvent|MouseEvent|TouchEvent} event
   *        The `keydown`, `tap`, or `click` event that caused this function to be
   *        called.
   *
   * @listens tap
   * @listens click
   */
  handleClick(e) {
    const t = this.player_.play();
    if (e.type === "tap" || this.mouseused_ && "clientX" in e && "clientY" in e) {
      mi(t), this.player_.tech(!0) && this.player_.tech(!0).focus();
      return;
    }
    const i = this.player_.getChild("controlBar"), r = i && i.getChild("playToggle");
    if (!r) {
      this.player_.tech(!0).focus();
      return;
    }
    const a = () => r.focus();
    Ps(t) ? t.then(a, () => {
    }) : this.setTimeout(a, 1);
  }
  /**
   * Event handler that is called when a `BigPlayButton` receives a
   * `keydown` event.
   *
   * @param {KeyboardEvent} event
   *        The `keydown` event that caused this function to be called.
   *
   * @listens keydown
   */
  handleKeyDown(e) {
    this.mouseused_ = !1, super.handleKeyDown(e);
  }
  /**
   * Handle `mousedown` events on the `BigPlayButton`.
   *
   * @param {MouseEvent} event
   *        `mousedown` or `touchstart` event that triggered this function
   *
   * @listens mousedown
   */
  handleMouseDown(e) {
    this.mouseused_ = !0;
  }
}
sS.prototype.controlText_ = "Play Video";
Pe.registerComponent("BigPlayButton", sS);
class IO extends Kt {
  /**
  * Creates an instance of the this class.
  *
  * @param  {Player} player
  *         The `Player` that this class should be attached to.
  *
  * @param  {Object} [options]
  *         The key/value store of player options.
  */
  constructor(e, t) {
    super(e, t), this.setIcon("cancel"), this.controlText(t && t.controlText || this.localize("Close"));
  }
  /**
  * Builds the default DOM `className`.
  *
  * @return {string}
  *         The DOM `className` for this object.
  */
  buildCSSClass() {
    return `vjs-close-button ${super.buildCSSClass()}`;
  }
  /**
   * This gets called when a `CloseButton` gets clicked. See
   * {@link ClickableComponent#handleClick} for more information on when
   * this will be triggered
   *
   * @param {Event} event
   *        The `keydown`, `tap`, or `click` event that caused this function to be
   *        called.
   *
   * @listens tap
   * @listens click
   * @fires CloseButton#close
   */
  handleClick(e) {
    this.trigger({
      type: "close",
      bubbles: !1
    });
  }
  /**
   * Event handler that is called when a `CloseButton` receives a
   * `keydown` event.
   *
   * By default, if the key is Esc, it will trigger a `click` event.
   *
   * @param {KeyboardEvent} event
   *        The `keydown` event that caused this function to be called.
   *
   * @listens keydown
   */
  handleKeyDown(e) {
    e.key === "Escape" ? (e.preventDefault(), e.stopPropagation(), this.trigger("click")) : super.handleKeyDown(e);
  }
}
Pe.registerComponent("CloseButton", IO);
class oS extends Kt {
  /**
   * Creates an instance of this class.
   *
   * @param {Player} player
   *        The `Player` that this class should be attached to.
   *
   * @param {Object} [options={}]
   *        The key/value store of player options.
   */
  constructor(e, t = {}) {
    super(e, t), t.replay = t.replay === void 0 || t.replay, this.setIcon("play"), this.on(e, "play", (i) => this.handlePlay(i)), this.on(e, "pause", (i) => this.handlePause(i)), t.replay && this.on(e, "ended", (i) => this.handleEnded(i));
  }
  /**
   * Builds the default DOM `className`.
   *
   * @return {string}
   *         The DOM `className` for this object.
   */
  buildCSSClass() {
    return `vjs-play-control ${super.buildCSSClass()}`;
  }
  /**
   * This gets called when an `PlayToggle` is "clicked". See
   * {@link ClickableComponent} for more detailed information on what a click can be.
   *
   * @param {Event} [event]
   *        The `keydown`, `tap`, or `click` event that caused this function to be
   *        called.
   *
   * @listens tap
   * @listens click
   */
  handleClick(e) {
    this.player_.paused() ? mi(this.player_.play()) : this.player_.pause();
  }
  /**
   * This gets called once after the video has ended and the user seeks so that
   * we can change the replay button back to a play button.
   *
   * @param {Event} [event]
   *        The event that caused this function to run.
   *
   * @listens Player#seeked
   */
  handleSeeked(e) {
    this.removeClass("vjs-ended"), this.player_.paused() ? this.handlePause(e) : this.handlePlay(e);
  }
  /**
   * Add the vjs-playing class to the element so it can change appearance.
   *
   * @param {Event} [event]
   *        The event that caused this function to run.
   *
   * @listens Player#play
   */
  handlePlay(e) {
    this.removeClass("vjs-ended", "vjs-paused"), this.addClass("vjs-playing"), this.setIcon("pause"), this.controlText("Pause");
  }
  /**
   * Add the vjs-paused class to the element so it can change appearance.
   *
   * @param {Event} [event]
   *        The event that caused this function to run.
   *
   * @listens Player#pause
   */
  handlePause(e) {
    this.removeClass("vjs-playing"), this.addClass("vjs-paused"), this.setIcon("play"), this.controlText("Play");
  }
  /**
   * Add the vjs-ended class to the element so it can change appearance
   *
   * @param {Event} [event]
   *        The event that caused this function to run.
   *
   * @listens Player#ended
   */
  handleEnded(e) {
    this.removeClass("vjs-playing"), this.addClass("vjs-ended"), this.setIcon("replay"), this.controlText("Replay"), this.one(this.player_, "seeked", (t) => this.handleSeeked(t));
  }
}
oS.prototype.controlText_ = "Play";
Pe.registerComponent("PlayToggle", oS);
let Ba = class extends Pe {
  /**
   * Creates an instance of this class.
   *
   * @param {Player} player
   *        The `Player` that this class should be attached to.
   *
   * @param {Object} [options]
   *        The key/value store of player options.
   */
  constructor(e, t) {
    super(e, t), this.on(e, ["timeupdate", "ended", "seeking"], (i) => this.update(i)), this.updateTextNode_();
  }
  /**
   * Create the `Component`'s DOM element
   *
   * @return {Element}
   *         The element that was created.
   */
  createEl() {
    const e = this.buildCSSClass(), t = super.createEl("div", {
      className: `${e} vjs-time-control vjs-control`
    }), i = Ye("span", {
      className: "vjs-control-text",
      textContent: `${this.localize(this.labelText_)}`
    }, {
      role: "presentation"
    });
    return t.appendChild(i), this.contentEl_ = Ye("span", {
      className: `${e}-display`
    }, {
      // span elements have no implicit role, but some screen readers (notably VoiceOver)
      // treat them as a break between items in the DOM when using arrow keys
      // (or left-to-right swipes on iOS) to read contents of a page. Using
      // role='presentation' causes VoiceOver to NOT treat this span as a break.
      role: "presentation"
    }), t.appendChild(this.contentEl_), t;
  }
  dispose() {
    this.contentEl_ = null, this.textNode_ = null, super.dispose();
  }
  /**
   * Updates the displayed time according to the `updateContent` function which is defined in the child class.
   *
   * @param {Event} [event]
   *          The `timeupdate`, `ended` or `seeking` (if enableSmoothSeeking is true) event that caused this function to be called.
   */
  update(e) {
    !this.player_.options_.enableSmoothSeeking && e.type === "seeking" || this.updateContent(e);
  }
  /**
   * Updates the time display text node with a new time
   *
   * @param {number} [time=0] the time to update to
   *
   * @private
   */
  updateTextNode_(e = 0) {
    e = Nr(e), this.formattedTime_ !== e && (this.formattedTime_ = e, this.requestNamedAnimationFrame("TimeDisplay#updateTextNode_", () => {
      if (!this.contentEl_)
        return;
      let t = this.textNode_;
      t && this.contentEl_.firstChild !== t && (t = null, at.warn("TimeDisplay#updateTextnode_: Prevented replacement of text node element since it was no longer a child of this node. Appending a new node instead.")), this.textNode_ = Be.createTextNode(this.formattedTime_), this.textNode_ && (t ? this.contentEl_.replaceChild(this.textNode_, t) : this.contentEl_.appendChild(this.textNode_));
    }));
  }
  /**
   * To be filled out in the child class, should update the displayed time
   * in accordance with the fact that the current time has changed.
   *
   * @param {Event} [event]
   *        The `timeupdate`  event that caused this to run.
   *
   * @listens Player#timeupdate
   */
  updateContent(e) {
  }
};
Ba.prototype.labelText_ = "Time";
Ba.prototype.controlText_ = "Time";
Pe.registerComponent("TimeDisplay", Ba);
class c0 extends Ba {
  /**
   * Builds the default DOM `className`.
   *
   * @return {string}
   *         The DOM `className` for this object.
   */
  buildCSSClass() {
    return "vjs-current-time";
  }
  /**
   * Update current time display
   *
   * @param {Event} [event]
   *        The `timeupdate` event that caused this function to run.
   *
   * @listens Player#timeupdate
   */
  updateContent(e) {
    let t;
    this.player_.ended() ? t = this.player_.duration() : e && e.target && typeof e.target.pendingSeekTime == "function" ? t = e.target.pendingSeekTime() : t = this.player_.scrubbing() ? this.player_.getCache().currentTime : this.player_.currentTime(), this.updateTextNode_(t);
  }
}
c0.prototype.labelText_ = "Current Time";
c0.prototype.controlText_ = "Current Time";
Pe.registerComponent("CurrentTimeDisplay", c0);
class l0 extends Ba {
  /**
   * Creates an instance of this class.
   *
   * @param {Player} player
   *        The `Player` that this class should be attached to.
   *
   * @param {Object} [options]
   *        The key/value store of player options.
   */
  constructor(e, t) {
    super(e, t);
    const i = (r) => this.updateContent(r);
    this.on(e, "durationchange", i), this.on(e, "loadstart", i), this.on(e, "loadedmetadata", i);
  }
  /**
   * Builds the default DOM `className`.
   *
   * @return {string}
   *         The DOM `className` for this object.
   */
  buildCSSClass() {
    return "vjs-duration";
  }
  /**
   * Update duration time display.
   *
   * @param {Event} [event]
   *        The `durationchange`, `timeupdate`, or `loadedmetadata` event that caused
   *        this function to be called.
   *
   * @listens Player#durationchange
   * @listens Player#timeupdate
   * @listens Player#loadedmetadata
   */
  updateContent(e) {
    const t = this.player_.duration();
    this.updateTextNode_(t);
  }
}
l0.prototype.labelText_ = "Duration";
l0.prototype.controlText_ = "Duration";
Pe.registerComponent("DurationDisplay", l0);
class UO extends Pe {
  /**
   * Create the component's DOM element
   *
   * @return {Element}
   *         The element that was created.
   */
  createEl() {
    const e = super.createEl("div", {
      className: "vjs-time-control vjs-time-divider"
    }, {
      // this element and its contents can be hidden from assistive techs since
      // it is made extraneous by the announcement of the control text
      // for the current time and duration displays
      "aria-hidden": !0
    }), t = super.createEl("div"), i = super.createEl("span", {
      textContent: "/"
    });
    return t.appendChild(i), e.appendChild(t), e;
  }
}
Pe.registerComponent("TimeDivider", UO);
class d0 extends Ba {
  /**
   * Creates an instance of this class.
   *
   * @param {Player} player
   *        The `Player` that this class should be attached to.
   *
   * @param {Object} [options]
   *        The key/value store of player options.
   */
  constructor(e, t) {
    super(e, t), this.on(e, "durationchange", (i) => this.updateContent(i));
  }
  /**
   * Builds the default DOM `className`.
   *
   * @return {string}
   *         The DOM `className` for this object.
   */
  buildCSSClass() {
    return "vjs-remaining-time";
  }
  /**
   * Create the `Component`'s DOM element with the "minus" character prepend to the time
   *
   * @return {Element}
   *         The element that was created.
   */
  createEl() {
    const e = super.createEl();
    return this.options_.displayNegative !== !1 && e.insertBefore(Ye("span", {}, {
      "aria-hidden": !0
    }, "-"), this.contentEl_), e;
  }
  /**
   * Update remaining time display.
   *
   * @param {Event} [event]
   *        The `timeupdate` or `durationchange` event that caused this to run.
   *
   * @listens Player#timeupdate
   * @listens Player#durationchange
   */
  updateContent(e) {
    if (typeof this.player_.duration() != "number")
      return;
    let t;
    this.player_.ended() ? t = 0 : this.player_.remainingTimeDisplay ? t = this.player_.remainingTimeDisplay() : t = this.player_.remainingTime(), this.updateTextNode_(t);
  }
}
d0.prototype.labelText_ = "Remaining Time";
d0.prototype.controlText_ = "Remaining Time";
Pe.registerComponent("RemainingTimeDisplay", d0);
class RO extends Pe {
  /**
   * Creates an instance of this class.
   *
   * @param {Player} player
   *        The `Player` that this class should be attached to.
   *
   * @param {Object} [options]
   *        The key/value store of player options.
   */
  constructor(e, t) {
    super(e, t), this.updateShowing(), this.on(this.player(), "durationchange", (i) => this.updateShowing(i));
  }
  /**
   * Create the `Component`'s DOM element
   *
   * @return {Element}
   *         The element that was created.
   */
  createEl() {
    const e = super.createEl("div", {
      className: "vjs-live-control vjs-control"
    });
    return this.contentEl_ = Ye("div", {
      className: "vjs-live-display"
    }, {
      "aria-live": "off"
    }), this.contentEl_.appendChild(Ye("span", {
      className: "vjs-control-text",
      textContent: `${this.localize("Stream Type")}`
    })), this.contentEl_.appendChild(Be.createTextNode(this.localize("LIVE"))), e.appendChild(this.contentEl_), e;
  }
  dispose() {
    this.contentEl_ = null, super.dispose();
  }
  /**
   * Check the duration to see if the LiveDisplay should be showing or not. Then show/hide
   * it accordingly
   *
   * @param {Event} [event]
   *        The {@link Player#durationchange} event that caused this function to run.
   *
   * @listens Player#durationchange
   */
  updateShowing(e) {
    this.player().duration() === 1 / 0 ? this.show() : this.hide();
  }
}
Pe.registerComponent("LiveDisplay", RO);
class uS extends Kt {
  /**
   * Creates an instance of this class.
   *
   * @param {Player} player
   *        The `Player` that this class should be attached to.
   *
   * @param {Object} [options]
   *        The key/value store of player options.
   */
  constructor(e, t) {
    super(e, t), this.updateLiveEdgeStatus(), this.player_.liveTracker && (this.updateLiveEdgeStatusHandler_ = (i) => this.updateLiveEdgeStatus(i), this.on(this.player_.liveTracker, "liveedgechange", this.updateLiveEdgeStatusHandler_));
  }
  /**
   * Create the `Component`'s DOM element
   *
   * @return {Element}
   *         The element that was created.
   */
  createEl() {
    const e = super.createEl("button", {
      className: "vjs-seek-to-live-control vjs-control"
    });
    return this.setIcon("circle", e), this.textEl_ = Ye("span", {
      className: "vjs-seek-to-live-text",
      textContent: this.localize("LIVE")
    }, {
      "aria-hidden": "true"
    }), e.appendChild(this.textEl_), e;
  }
  /**
   * Update the state of this button if we are at the live edge
   * or not
   */
  updateLiveEdgeStatus() {
    !this.player_.liveTracker || this.player_.liveTracker.atLiveEdge() ? (this.setAttribute("aria-disabled", !0), this.addClass("vjs-at-live-edge"), this.controlText("Seek to live, currently playing live")) : (this.setAttribute("aria-disabled", !1), this.removeClass("vjs-at-live-edge"), this.controlText("Seek to live, currently behind live"));
  }
  /**
   * On click bring us as near to the live point as possible.
   * This requires that we wait for the next `live-seekable-change`
   * event which will happen every segment length seconds.
   */
  handleClick() {
    this.player_.liveTracker.seekToLiveEdge();
  }
  /**
   * Dispose of the element and stop tracking
   */
  dispose() {
    this.player_.liveTracker && this.off(this.player_.liveTracker, "liveedgechange", this.updateLiveEdgeStatusHandler_), this.textEl_ = null, super.dispose();
  }
}
uS.prototype.controlText_ = "Seek to live, currently playing live";
Pe.registerComponent("SeekToLive", uS);
function go(n, e, t) {
  return n = Number(n), Math.min(t, Math.max(e, isNaN(n) ? e : n));
}
var OO = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  clamp: go
});
class f0 extends Pe {
  /**
  * Create an instance of this class
  *
  * @param {Player} player
  *        The `Player` that this class should be attached to.
  *
  * @param {Object} [options]
  *        The key/value store of player options.
  */
  constructor(e, t) {
    super(e, t), this.handleMouseDown_ = (i) => this.handleMouseDown(i), this.handleMouseUp_ = (i) => this.handleMouseUp(i), this.handleKeyDown_ = (i) => this.handleKeyDown(i), this.handleClick_ = (i) => this.handleClick(i), this.handleMouseMove_ = (i) => this.handleMouseMove(i), this.update_ = (i) => this.update(i), this.bar = this.getChild(this.options_.barName), this.vertical(!!this.options_.vertical), this.enable();
  }
  /**
   * Are controls are currently enabled for this slider or not.
   *
   * @return {boolean}
   *         true if controls are enabled, false otherwise
   */
  enabled() {
    return this.enabled_;
  }
  /**
   * Enable controls for this slider if they are disabled
   */
  enable() {
    this.enabled() || (this.on("mousedown", this.handleMouseDown_), this.on("touchstart", this.handleMouseDown_), this.on("keydown", this.handleKeyDown_), this.on("click", this.handleClick_), this.on(this.player_, "controlsvisible", this.update), this.playerEvent && this.on(this.player_, this.playerEvent, this.update), this.removeClass("disabled"), this.setAttribute("tabindex", 0), this.enabled_ = !0);
  }
  /**
   * Disable controls for this slider if they are enabled
   */
  disable() {
    if (!this.enabled())
      return;
    const e = this.bar.el_.ownerDocument;
    this.off("mousedown", this.handleMouseDown_), this.off("touchstart", this.handleMouseDown_), this.off("keydown", this.handleKeyDown_), this.off("click", this.handleClick_), this.off(this.player_, "controlsvisible", this.update_), this.off(e, "mousemove", this.handleMouseMove_), this.off(e, "mouseup", this.handleMouseUp_), this.off(e, "touchmove", this.handleMouseMove_), this.off(e, "touchend", this.handleMouseUp_), this.removeAttribute("tabindex"), this.addClass("disabled"), this.playerEvent && this.off(this.player_, this.playerEvent, this.update), this.enabled_ = !1;
  }
  /**
   * Create the `Slider`s DOM element.
   *
   * @param {string} type
   *        Type of element to create.
   *
   * @param {Object} [props={}]
   *        List of properties in Object form.
   *
   * @param {Object} [attributes={}]
   *        list of attributes in Object form.
   *
   * @return {Element}
   *         The element that gets created.
   */
  createEl(e, t = {}, i = {}) {
    return t.className = t.className + " vjs-slider", t = Object.assign({
      tabIndex: 0
    }, t), i = Object.assign({
      role: "slider",
      "aria-valuenow": 0,
      "aria-valuemin": 0,
      "aria-valuemax": 100
    }, i), super.createEl(e, t, i);
  }
  /**
   * Handle `mousedown` or `touchstart` events on the `Slider`.
   *
   * @param {MouseEvent} event
   *        `mousedown` or `touchstart` event that triggered this function
   *
   * @listens mousedown
   * @listens touchstart
   * @fires Slider#slideractive
   */
  handleMouseDown(e) {
    const t = this.bar.el_.ownerDocument;
    e.type === "mousedown" && e.preventDefault(), e.type === "touchstart" && !_i && e.preventDefault(), LD(), this.addClass("vjs-sliding"), this.trigger("slideractive"), this.on(t, "mousemove", this.handleMouseMove_), this.on(t, "mouseup", this.handleMouseUp_), this.on(t, "touchmove", this.handleMouseMove_), this.on(t, "touchend", this.handleMouseUp_), this.handleMouseMove(e, !0);
  }
  /**
   * Handle the `mousemove`, `touchmove`, and `mousedown` events on this `Slider`.
   * The `mousemove` and `touchmove` events will only only trigger this function during
   * `mousedown` and `touchstart`. This is due to {@link Slider#handleMouseDown} and
   * {@link Slider#handleMouseUp}.
   *
   * @param {MouseEvent} event
   *        `mousedown`, `mousemove`, `touchstart`, or `touchmove` event that triggered
   *        this function
   * @param {boolean} mouseDown this is a flag that should be set to true if `handleMouseMove` is called directly. It allows us to skip things that should not happen if coming from mouse down but should happen on regular mouse move handler. Defaults to false.
   *
   * @listens mousemove
   * @listens touchmove
   */
  handleMouseMove(e) {
  }
  /**
   * Handle `mouseup` or `touchend` events on the `Slider`.
   *
   * @param {MouseEvent} event
   *        `mouseup` or `touchend` event that triggered this function.
   *
   * @listens touchend
   * @listens mouseup
   * @fires Slider#sliderinactive
   */
  handleMouseUp(e) {
    const t = this.bar.el_.ownerDocument;
    PD(), this.removeClass("vjs-sliding"), this.trigger("sliderinactive"), this.off(t, "mousemove", this.handleMouseMove_), this.off(t, "mouseup", this.handleMouseUp_), this.off(t, "touchmove", this.handleMouseMove_), this.off(t, "touchend", this.handleMouseUp_), this.update();
  }
  /**
   * Update the progress bar of the `Slider`.
   *
   * @return {number}
   *          The percentage of progress the progress bar represents as a
   *          number from 0 to 1.
   */
  update() {
    if (!this.el_ || !this.bar)
      return;
    const e = this.getProgress();
    return e === this.progress_ || (this.progress_ = e, this.requestNamedAnimationFrame("Slider#update", () => {
      const t = this.vertical() ? "height" : "width";
      this.bar.el().style[t] = (e * 100).toFixed(2) + "%";
    })), e;
  }
  /**
   * Get the percentage of the bar that should be filled
   * but clamped and rounded.
   *
   * @return {number}
   *         percentage filled that the slider is
   */
  getProgress() {
    return Number(go(this.getPercent(), 0, 1).toFixed(4));
  }
  /**
   * Calculate distance for slider
   *
   * @param {Event} event
   *        The event that caused this function to run.
   *
   * @return {number}
   *         The current position of the Slider.
   *         - position.x for vertical `Slider`s
   *         - position.y for horizontal `Slider`s
   */
  calculateDistance(e) {
    const t = xl(this.el_, e);
    return this.vertical() ? t.y : t.x;
  }
  /**
   * Handle a `keydown` event on the `Slider`. Watches for left, right, up, and down
   * arrow keys. This function will only be called when the slider has focus. See
   * {@link Slider#handleFocus} and {@link Slider#handleBlur}.
   *
   * @param {KeyboardEvent} event
   *        the `keydown` event that caused this function to run.
   *
   * @listens keydown
   */
  handleKeyDown(e) {
    const t = this.options_.playerOptions.spatialNavigation, i = t && t.enabled, r = t && t.horizontalSeek;
    i ? r && e.key === "ArrowLeft" || !r && e.key === "ArrowDown" ? (e.preventDefault(), e.stopPropagation(), this.stepBack()) : r && e.key === "ArrowRight" || !r && e.key === "ArrowUp" ? (e.preventDefault(), e.stopPropagation(), this.stepForward()) : (this.pendingSeekTime() && (this.pendingSeekTime(null), this.userSeek_(this.player_.currentTime())), super.handleKeyDown(e)) : e.key === "ArrowLeft" || e.key === "ArrowDown" ? (e.preventDefault(), e.stopPropagation(), this.stepBack()) : e.key === "ArrowUp" || e.key === "ArrowRight" ? (e.preventDefault(), e.stopPropagation(), this.stepForward()) : super.handleKeyDown(e);
  }
  /**
   * Listener for click events on slider, used to prevent clicks
   *   from bubbling up to parent elements like button menus.
   *
   * @param {Object} event
   *        Event that caused this object to run
   */
  handleClick(e) {
    e.stopPropagation(), e.preventDefault();
  }
  /**
   * Get/set if slider is horizontal for vertical
   *
   * @param {boolean} [bool]
   *        - true if slider is vertical,
   *        - false is horizontal
   *
   * @return {boolean}
   *         - true if slider is vertical, and getting
   *         - false if the slider is horizontal, and getting
   */
  vertical(e) {
    if (e === void 0)
      return this.vertical_ || !1;
    this.vertical_ = !!e, this.vertical_ ? this.addClass("vjs-slider-vertical") : this.addClass("vjs-slider-horizontal");
  }
}
Pe.registerComponent("Slider", f0);
const Up = (n, e) => go(n / e * 100, 0, 100).toFixed(2) + "%";
class LO extends Pe {
  /**
   * Creates an instance of this class.
   *
   * @param {Player} player
   *        The `Player` that this class should be attached to.
   *
   * @param {Object} [options]
   *        The key/value store of player options.
   */
  constructor(e, t) {
    super(e, t), this.partEls_ = [], this.on(e, "progress", (i) => this.update(i));
  }
  /**
   * Create the `Component`'s DOM element
   *
   * @return {Element}
   *         The element that was created.
   */
  createEl() {
    const e = super.createEl("div", {
      className: "vjs-load-progress"
    }), t = Ye("span", {
      className: "vjs-control-text"
    }), i = Ye("span", {
      textContent: this.localize("Loaded")
    }), r = Be.createTextNode(": ");
    return this.percentageEl_ = Ye("span", {
      className: "vjs-control-text-loaded-percentage",
      textContent: "0%"
    }), e.appendChild(t), t.appendChild(i), t.appendChild(r), t.appendChild(this.percentageEl_), e;
  }
  dispose() {
    this.partEls_ = null, this.percentageEl_ = null, super.dispose();
  }
  /**
   * Update progress bar
   *
   * @param {Event} [event]
   *        The `progress` event that caused this function to run.
   *
   * @listens Player#progress
   */
  update(e) {
    this.requestNamedAnimationFrame("LoadProgressBar#update", () => {
      const t = this.player_.liveTracker, i = this.player_.buffered(), r = t && t.isLive() ? t.seekableEnd() : this.player_.duration(), a = this.player_.bufferedEnd(), s = this.partEls_, o = Up(a, r);
      this.percent_ !== o && (this.el_.style.width = o, lr(this.percentageEl_, o), this.percent_ = o);
      for (let u = 0; u < i.length; u++) {
        const c = i.start(u), l = i.end(u);
        let h = s[u];
        h || (h = this.el_.appendChild(Ye()), s[u] = h), !(h.dataset.start === c && h.dataset.end === l) && (h.dataset.start = c, h.dataset.end = l, h.style.left = Up(c, a), h.style.width = Up(l - c, a));
      }
      for (let u = s.length; u > i.length; u--)
        this.el_.removeChild(s[u - 1]);
      s.length = i.length;
    });
  }
}
Pe.registerComponent("LoadProgressBar", LO);
class PO extends Pe {
  /**
   * Creates an instance of this class.
   *
   * @param {Player} player
   *        The {@link Player} that this class should be attached to.
   *
   * @param {Object} [options]
   *        The key/value store of player options.
   */
  constructor(e, t) {
    super(e, t), this.update = Ti(_t(this, this.update), Bn);
  }
  /**
   * Create the time tooltip DOM element
   *
   * @return {Element}
   *         The element that was created.
   */
  createEl() {
    return super.createEl("div", {
      className: "vjs-time-tooltip"
    }, {
      "aria-hidden": "true"
    });
  }
  /**
   * Updates the position of the time tooltip relative to the `SeekBar`.
   *
   * @param {Object} seekBarRect
   *        The `ClientRect` for the {@link SeekBar} element.
   *
   * @param {number} seekBarPoint
   *        A number from 0 to 1, representing a horizontal reference point
   *        from the left edge of the {@link SeekBar}
   */
  update(e, t, i) {
    const r = Zs(this.el_), a = Sa(this.player_.el()), s = e.width * t;
    if (!a || !r)
      return;
    let o = e.left - a.left + s, u = e.width - s + (a.right - e.right);
    u || (u = e.width - s, o = s);
    let c = r.width / 2;
    o < c ? c += c - o : u < c && (c = u), c < 0 ? c = 0 : c > r.width && (c = r.width), c = Math.round(c), this.el_.style.right = `-${c}px`, this.write(i);
  }
  /**
   * Write the time to the tooltip DOM element.
   *
   * @param {string} content
   *        The formatted time for the tooltip.
   */
  write(e) {
    lr(this.el_, e);
  }
  /**
   * Updates the position of the time tooltip relative to the `SeekBar`.
   *
   * @param {Object} seekBarRect
   *        The `ClientRect` for the {@link SeekBar} element.
   *
   * @param {number} seekBarPoint
   *        A number from 0 to 1, representing a horizontal reference point
   *        from the left edge of the {@link SeekBar}
   *
   * @param {number} time
   *        The time to update the tooltip to, not used during live playback
   *
   * @param {Function} cb
   *        A function that will be called during the request animation frame
   *        for tooltips that need to do additional animations from the default
   */
  updateTime(e, t, i, r) {
    this.requestNamedAnimationFrame("TimeTooltip#updateTime", () => {
      let a;
      const s = this.player_.duration();
      if (this.player_.liveTracker && this.player_.liveTracker.isLive()) {
        const o = this.player_.liveTracker.liveWindow(), u = o - t * o;
        a = (u < 1 ? "" : "-") + Nr(u, o);
      } else
        a = Nr(i, s);
      this.update(e, t, a), r && r();
    });
  }
}
Pe.registerComponent("TimeTooltip", PO);
class h0 extends Pe {
  /**
   * Creates an instance of this class.
   *
   * @param {Player} player
   *        The {@link Player} that this class should be attached to.
   *
   * @param {Object} [options]
   *        The key/value store of player options.
   */
  constructor(e, t) {
    super(e, t), this.setIcon("circle"), this.update = Ti(_t(this, this.update), Bn);
  }
  /**
   * Create the the DOM element for this class.
   *
   * @return {Element}
   *         The element that was created.
   */
  createEl() {
    return super.createEl("div", {
      className: "vjs-play-progress vjs-slider-bar"
    }, {
      "aria-hidden": "true"
    });
  }
  /**
   * Enqueues updates to its own DOM as well as the DOM of its
   * {@link TimeTooltip} child.
   *
   * @param {Object} seekBarRect
   *        The `ClientRect` for the {@link SeekBar} element.
   *
   * @param {number} seekBarPoint
   *        A number from 0 to 1, representing a horizontal reference point
   *        from the left edge of the {@link SeekBar}
   *
   * @param {Event} [event]
   *        The `timeupdate` event that caused this function to run.
   */
  update(e, t, i) {
    const r = this.getChild("timeTooltip");
    if (!r)
      return;
    const a = i && i.target && typeof i.target.pendingSeekTime == "function" ? i.target.pendingSeekTime() : this.player_.scrubbing() ? this.player_.getCache().currentTime : this.player_.currentTime();
    r.updateTime(e, t, a);
  }
}
h0.prototype.options_ = {
  children: []
};
!Gt && !ai && h0.prototype.options_.children.push("timeTooltip");
Pe.registerComponent("PlayProgressBar", h0);
class cS extends Pe {
  /**
   * Creates an instance of this class.
   *
   * @param {Player} player
   *        The {@link Player} that this class should be attached to.
   *
   * @param {Object} [options]
   *        The key/value store of player options.
   */
  constructor(e, t) {
    super(e, t), this.update = Ti(_t(this, this.update), Bn);
  }
  /**
   * Create the DOM element for this class.
   *
   * @return {Element}
   *         The element that was created.
   */
  createEl() {
    return super.createEl("div", {
      className: "vjs-mouse-display"
    });
  }
  /**
   * Enqueues updates to its own DOM as well as the DOM of its
   * {@link TimeTooltip} child.
   *
   * @param {Object} seekBarRect
   *        The `ClientRect` for the {@link SeekBar} element.
   *
   * @param {number} seekBarPoint
   *        A number from 0 to 1, representing a horizontal reference point
   *        from the left edge of the {@link SeekBar}
   */
  update(e, t) {
    const i = t * this.player_.duration();
    this.getChild("timeTooltip").updateTime(e, t, i, () => {
      this.el_.style.left = `${e.width * t}px`;
    });
  }
}
cS.prototype.options_ = {
  children: ["timeTooltip"]
};
Pe.registerComponent("MouseTimeDisplay", cS);
let lS = class dS extends f0 {
  /**
   * Creates an instance of this class.
   *
   * @param {Player} player
   *        The `Player` that this class should be attached to.
   *
   * @param {Object} [options]
   *        The key/value store of player options.
   * @param {number} [options.stepSeconds=5]
   *        The number of seconds to increment on keyboard control
   * @param {number} [options.pageMultiplier=12]
   *        The multiplier of stepSeconds that PgUp/PgDown move the timeline.
   */
  constructor(e, t) {
    t = yt(dS.prototype.options_, t), t.children = [...t.children];
    const i = e.options_.disableSeekWhileScrubbingOnMobile && (Gt || ai) || e.options_.disableSeekWhileScrubbingOnSTV;
    (!Gt && !ai || i) && t.children.splice(1, 0, "mouseTimeDisplay"), super(e, t), this.shouldDisableSeekWhileScrubbing_ = i, this.pendingSeekTime_ = null, this.setEventHandlers_();
  }
  /**
   * Sets the event handlers
   *
   * @private
   */
  setEventHandlers_() {
    this.update_ = _t(this, this.update), this.update = Ti(this.update_, Bn), this.on(this.player_, ["durationchange", "timeupdate"], this.update), this.on(this.player_, ["ended"], this.update_), this.player_.liveTracker && this.on(this.player_.liveTracker, "liveedgechange", this.update), this.updateInterval = null, this.enableIntervalHandler_ = (e) => this.enableInterval_(e), this.disableIntervalHandler_ = (e) => this.disableInterval_(e), this.on(this.player_, ["playing"], this.enableIntervalHandler_), this.on(this.player_, ["ended", "pause", "waiting"], this.disableIntervalHandler_), "hidden" in Be && "visibilityState" in Be && this.on(Be, "visibilitychange", this.toggleVisibility_);
  }
  toggleVisibility_(e) {
    Be.visibilityState === "hidden" ? (this.cancelNamedAnimationFrame("SeekBar#update"), this.cancelNamedAnimationFrame("Slider#update"), this.disableInterval_(e)) : (!this.player_.ended() && !this.player_.paused() && this.enableInterval_(), this.update());
  }
  enableInterval_() {
    this.updateInterval || (this.updateInterval = this.setInterval(this.update, Bn));
  }
  disableInterval_(e) {
    this.player_.liveTracker && this.player_.liveTracker.isLive() && e && e.type !== "ended" || this.updateInterval && (this.clearInterval(this.updateInterval), this.updateInterval = null);
  }
  /**
   * Create the `Component`'s DOM element
   *
   * @return {Element}
   *         The element that was created.
   */
  createEl() {
    return super.createEl("div", {
      className: "vjs-progress-holder"
    }, {
      "aria-label": this.localize("Progress Bar")
    });
  }
  /**
   * This function updates the play progress bar and accessibility
   * attributes to whatever is passed in.
   *
   * @param {Event} [event]
   *        The `timeupdate` or `ended` event that caused this to run.
   *
   * @listens Player#timeupdate
   *
   * @return {number}
   *          The current percent at a number from 0-1
   */
  update(e) {
    if (Be.visibilityState === "hidden")
      return;
    const t = super.update();
    return this.requestNamedAnimationFrame("SeekBar#update", () => {
      const i = this.player_.ended() ? this.player_.duration() : this.getCurrentTime_(), r = this.player_.liveTracker;
      let a = this.player_.duration();
      r && r.isLive() && (a = this.player_.liveTracker.liveCurrentTime()), this.percent_ !== t && (this.el_.setAttribute("aria-valuenow", (t * 100).toFixed(2)), this.percent_ = t), (this.currentTime_ !== i || this.duration_ !== a) && (this.el_.setAttribute("aria-valuetext", this.localize("progress bar timing: currentTime={1} duration={2}", [Nr(i, a), Nr(a, a)], "{1} of {2}")), this.currentTime_ = i, this.duration_ = a), this.bar && this.bar.update(Sa(this.el()), this.getProgress(), e);
    }), t;
  }
  /**
   * Prevent liveThreshold from causing seeks to seem like they
   * are not happening from a user perspective.
   *
   * @param {number} ct
   *        current time to seek to
   */
  userSeek_(e) {
    this.player_.liveTracker && this.player_.liveTracker.isLive() && this.player_.liveTracker.nextSeekedFromUser(), this.player_.currentTime(e);
  }
  /**
   * Get the value of current time but allows for smooth scrubbing,
   * when player can't keep up.
   *
   * @return {number}
   *         The current time value to display
   *
   * @private
   */
  getCurrentTime_() {
    return this.player_.scrubbing() ? this.player_.getCache().currentTime : this.player_.currentTime();
  }
  /**
   * Getter and setter for pendingSeekTime.
   * Ensures the value is clamped between 0 and duration.
   *
   * @param {number|null} [time] - Optional. The new pending seek time, can be a number or null.
   * @return {number|null} - The current pending seek time.
   */
  pendingSeekTime(e) {
    if (e !== void 0)
      if (e !== null) {
        const t = this.player_.duration();
        this.pendingSeekTime_ = Math.max(0, Math.min(e, t));
      } else
        this.pendingSeekTime_ = null;
    return this.pendingSeekTime_;
  }
  /**
   * Get the percentage of media played so far.
   *
   * @return {number}
   *         The percentage of media played so far (0 to 1).
   */
  getPercent() {
    if (this.pendingSeekTime() !== null)
      return this.pendingSeekTime() / this.player_.duration();
    const e = this.getCurrentTime_();
    let t;
    const i = this.player_.liveTracker;
    return i && i.isLive() ? (t = (e - i.seekableStart()) / i.liveWindow(), i.atLiveEdge() && (t = 1)) : t = e / this.player_.duration(), t;
  }
  /**
   * Handle mouse down on seek bar
   *
   * @param {MouseEvent} event
   *        The `mousedown` event that caused this to run.
   *
   * @listens mousedown
   */
  handleMouseDown(e) {
    Js(e) && (e.stopPropagation(), this.videoWasPlaying = !this.player_.paused(), this.shouldDisableSeekWhileScrubbing_ || this.player_.pause(), super.handleMouseDown(e));
  }
  /**
   * Handle mouse move on seek bar
   *
   * @param {MouseEvent} event
   *        The `mousemove` event that caused this to run.
   * @param {boolean} mouseDown this is a flag that should be set to true if `handleMouseMove` is called directly. It allows us to skip things that should not happen if coming from mouse down but should happen on regular mouse move handler. Defaults to false
   *
   * @listens mousemove
   */
  handleMouseMove(e, t = !1) {
    if (!Js(e) || isNaN(this.player_.duration()))
      return;
    !t && !this.player_.scrubbing() && this.player_.scrubbing(!0);
    let i;
    const r = this.calculateDistance(e), a = this.player_.liveTracker;
    if (!a || !a.isLive())
      i = r * this.player_.duration(), i === this.player_.duration() && (i = i - 0.1);
    else {
      if (r >= 0.99) {
        a.seekToLiveEdge();
        return;
      }
      const s = a.seekableStart(), o = a.liveCurrentTime();
      if (i = s + r * a.liveWindow(), i >= o && (i = o), i <= s && (i = s + 0.1), i === 1 / 0)
        return;
    }
    this.shouldDisableSeekWhileScrubbing_ ? this.pendingSeekTime(i) : this.userSeek_(i), this.player_.options_.enableSmoothSeeking && this.update();
  }
  enable() {
    super.enable();
    const e = this.getChild("mouseTimeDisplay");
    e && e.show();
  }
  disable() {
    super.disable();
    const e = this.getChild("mouseTimeDisplay");
    e && e.hide();
  }
  /**
   * Handle mouse up on seek bar
   *
   * @param {MouseEvent} event
   *        The `mouseup` event that caused this to run.
   *
   * @listens mouseup
   */
  handleMouseUp(e) {
    super.handleMouseUp(e), e && e.stopPropagation(), this.player_.scrubbing(!1), this.pendingSeekTime() !== null && (this.userSeek_(this.pendingSeekTime()), this.pendingSeekTime(null)), this.player_.trigger({
      type: "timeupdate",
      target: this,
      manuallyTriggered: !0
    }), this.videoWasPlaying ? mi(this.player_.play()) : this.update_();
  }
  /**
   * Handles pending seek time when `disableSeekWhileScrubbingOnSTV` is enabled.
   *
   * @param {number} stepAmount - The number of seconds to step (positive for forward, negative for backward).
   */
  handlePendingSeek_(e) {
    this.player_.paused() || this.player_.pause();
    const t = this.pendingSeekTime() !== null ? this.pendingSeekTime() : this.player_.currentTime();
    this.pendingSeekTime(t + e), this.player_.trigger({
      type: "timeupdate",
      target: this,
      manuallyTriggered: !0
    });
  }
  /**
   * Move more quickly fast forward for keyboard-only users
   */
  stepForward() {
    this.shouldDisableSeekWhileScrubbing_ ? this.handlePendingSeek_(this.options().stepSeconds) : this.userSeek_(this.player_.currentTime() + this.options().stepSeconds);
  }
  /**
   * Move more quickly rewind for keyboard-only users
   */
  stepBack() {
    this.shouldDisableSeekWhileScrubbing_ ? this.handlePendingSeek_(-this.options().stepSeconds) : this.userSeek_(this.player_.currentTime() - this.options().stepSeconds);
  }
  /**
   * Toggles the playback state of the player
   * This gets called when enter or space is used on the seekbar
   *
   * @param {KeyboardEvent} event
   *        The `keydown` event that caused this function to be called
   *
   */
  handleAction(e) {
    this.pendingSeekTime() !== null && (this.userSeek_(this.pendingSeekTime()), this.pendingSeekTime(null)), this.player_.paused() ? this.player_.play() : this.player_.pause();
  }
  /**
   * Called when this SeekBar has focus and a key gets pressed down.
   * Supports the following keys:
   *
   *   Space or Enter key fire a click event
   *   Home key moves to start of the timeline
   *   End key moves to end of the timeline
   *   Digit "0" through "9" keys move to 0%, 10% ... 80%, 90% of the timeline
   *   PageDown key moves back a larger step than ArrowDown
   *   PageUp key moves forward a large step
   *
   * @param {KeyboardEvent} event
   *        The `keydown` event that caused this function to be called.
   *
   * @listens keydown
   */
  handleKeyDown(e) {
    const t = this.player_.liveTracker;
    if (e.key === " " || e.key === "Enter")
      e.preventDefault(), e.stopPropagation(), this.handleAction(e);
    else if (e.key === "Home")
      e.preventDefault(), e.stopPropagation(), this.userSeek_(0);
    else if (e.key === "End")
      e.preventDefault(), e.stopPropagation(), t && t.isLive() ? this.userSeek_(t.liveCurrentTime()) : this.userSeek_(this.player_.duration());
    else if (/^[0-9]$/.test(e.key)) {
      e.preventDefault(), e.stopPropagation();
      const i = parseInt(e.key, 10) * 0.1;
      t && t.isLive() ? this.userSeek_(t.seekableStart() + t.liveWindow() * i) : this.userSeek_(this.player_.duration() * i);
    } else e.key === "PageDown" ? (e.preventDefault(), e.stopPropagation(), this.userSeek_(this.player_.currentTime() - this.options().stepSeconds * this.options().pageMultiplier)) : e.key === "PageUp" ? (e.preventDefault(), e.stopPropagation(), this.userSeek_(this.player_.currentTime() + this.options().stepSeconds * this.options().pageMultiplier)) : super.handleKeyDown(e);
  }
  dispose() {
    this.disableInterval_(), this.off(this.player_, ["durationchange", "timeupdate"], this.update), this.off(this.player_, ["ended"], this.update_), this.player_.liveTracker && this.off(this.player_.liveTracker, "liveedgechange", this.update), this.off(this.player_, ["playing"], this.enableIntervalHandler_), this.off(this.player_, ["ended", "pause", "waiting"], this.disableIntervalHandler_), "hidden" in Be && "visibilityState" in Be && this.off(Be, "visibilitychange", this.toggleVisibility_), super.dispose();
  }
};
lS.prototype.options_ = {
  children: ["loadProgressBar", "playProgressBar"],
  barName: "playProgressBar",
  stepSeconds: 5,
  pageMultiplier: 12
};
Pe.registerComponent("SeekBar", lS);
let fS = class extends Pe {
  /**
   * Creates an instance of this class.
   *
   * @param {Player} player
   *        The `Player` that this class should be attached to.
   *
   * @param {Object} [options]
   *        The key/value store of player options.
   */
  constructor(e, t) {
    super(e, t), this.handleMouseMove = Ti(_t(this, this.handleMouseMove), Bn), this.throttledHandleMouseSeek = Ti(_t(this, this.handleMouseSeek), Bn), this.handleMouseUpHandler_ = (i) => this.handleMouseUp(i), this.handleMouseDownHandler_ = (i) => this.handleMouseDown(i), this.enable();
  }
  /**
   * Create the `Component`'s DOM element
   *
   * @return {Element}
   *         The element that was created.
   */
  createEl() {
    return super.createEl("div", {
      className: "vjs-progress-control vjs-control"
    });
  }
  /**
   * When the mouse moves over the `ProgressControl`, the pointer position
   * gets passed down to the `MouseTimeDisplay` component.
   *
   * @param {Event} event
   *        The `mousemove` event that caused this function to run.
   *
   * @listen mousemove
   */
  handleMouseMove(e) {
    const t = this.getChild("seekBar");
    if (!t)
      return;
    const i = t.getChild("playProgressBar"), r = t.getChild("mouseTimeDisplay");
    if (!i && !r)
      return;
    const a = t.el(), s = Zs(a);
    let o = xl(a, e).x;
    o = go(o, 0, 1), r && r.update(s, o), i && i.update(s, t.getProgress());
  }
  /**
   * A throttled version of the {@link ProgressControl#handleMouseSeek} listener.
   *
   * @method ProgressControl#throttledHandleMouseSeek
   * @param {Event} event
   *        The `mousemove` event that caused this function to run.
   *
   * @listen mousemove
   * @listen touchmove
   */
  /**
   * Handle `mousemove` or `touchmove` events on the `ProgressControl`.
   *
   * @param {Event} event
   *        `mousedown` or `touchstart` event that triggered this function
   *
   * @listens mousemove
   * @listens touchmove
   */
  handleMouseSeek(e) {
    const t = this.getChild("seekBar");
    t && t.handleMouseMove(e);
  }
  /**
   * Are controls are currently enabled for this progress control.
   *
   * @return {boolean}
   *         true if controls are enabled, false otherwise
   */
  enabled() {
    return this.enabled_;
  }
  /**
   * Disable all controls on the progress control and its children
   */
  disable() {
    if (this.children().forEach((e) => e.disable && e.disable()), !!this.enabled() && (this.off(["mousedown", "touchstart"], this.handleMouseDownHandler_), this.off(this.el_, ["mousemove", "touchmove"], this.handleMouseMove), this.removeListenersAddedOnMousedownAndTouchstart(), this.addClass("disabled"), this.enabled_ = !1, this.player_.scrubbing())) {
      const e = this.getChild("seekBar");
      this.player_.scrubbing(!1), e.videoWasPlaying && mi(this.player_.play());
    }
  }
  /**
   * Enable all controls on the progress control and its children
   */
  enable() {
    this.children().forEach((e) => e.enable && e.enable()), !this.enabled() && (this.on(["mousedown", "touchstart"], this.handleMouseDownHandler_), this.on(this.el_, ["mousemove", "touchmove"], this.handleMouseMove), this.removeClass("disabled"), this.enabled_ = !0);
  }
  /**
   * Cleanup listeners after the user finishes interacting with the progress controls
   */
  removeListenersAddedOnMousedownAndTouchstart() {
    const e = this.el_.ownerDocument;
    this.off(e, "mousemove", this.throttledHandleMouseSeek), this.off(e, "touchmove", this.throttledHandleMouseSeek), this.off(e, "mouseup", this.handleMouseUpHandler_), this.off(e, "touchend", this.handleMouseUpHandler_);
  }
  /**
   * Handle `mousedown` or `touchstart` events on the `ProgressControl`.
   *
   * @param {Event} event
   *        `mousedown` or `touchstart` event that triggered this function
   *
   * @listens mousedown
   * @listens touchstart
   */
  handleMouseDown(e) {
    const t = this.el_.ownerDocument, i = this.getChild("seekBar");
    i && i.handleMouseDown(e), this.on(t, "mousemove", this.throttledHandleMouseSeek), this.on(t, "touchmove", this.throttledHandleMouseSeek), this.on(t, "mouseup", this.handleMouseUpHandler_), this.on(t, "touchend", this.handleMouseUpHandler_);
  }
  /**
   * Handle `mouseup` or `touchend` events on the `ProgressControl`.
   *
   * @param {Event} event
   *        `mouseup` or `touchend` event that triggered this function.
   *
   * @listens touchend
   * @listens mouseup
   */
  handleMouseUp(e) {
    const t = this.getChild("seekBar");
    t && t.handleMouseUp(e), this.removeListenersAddedOnMousedownAndTouchstart();
  }
};
fS.prototype.options_ = {
  children: ["seekBar"]
};
Pe.registerComponent("ProgressControl", fS);
class hS extends Kt {
  /**
   * Creates an instance of this class.
   *
   * @param {Player} player
   *        The `Player` that this class should be attached to.
   *
   * @param {Object} [options]
   *        The key/value store of player options.
   *
   * @listens Player#enterpictureinpicture
   * @listens Player#leavepictureinpicture
   */
  constructor(e, t) {
    super(e, t), this.setIcon("picture-in-picture-enter"), this.on(e, ["enterpictureinpicture", "leavepictureinpicture"], (i) => this.handlePictureInPictureChange(i)), this.on(e, ["disablepictureinpicturechanged", "loadedmetadata"], (i) => this.handlePictureInPictureEnabledChange(i)), this.on(e, ["loadedmetadata", "audioonlymodechange", "audiopostermodechange"], () => this.handlePictureInPictureAudioModeChange()), this.disable();
  }
  /**
   * Builds the default DOM `className`.
   *
   * @return {string}
   *         The DOM `className` for this object.
   */
  buildCSSClass() {
    return `vjs-picture-in-picture-control vjs-hidden ${super.buildCSSClass()}`;
  }
  /**
   * Displays or hides the button depending on the audio mode detection.
   * Exits picture-in-picture if it is enabled when switching to audio mode.
   */
  handlePictureInPictureAudioModeChange() {
    if (!(this.player_.currentType().substring(0, 5) === "audio" || this.player_.audioPosterMode() || this.player_.audioOnlyMode())) {
      this.show();
      return;
    }
    this.player_.isInPictureInPicture() && this.player_.exitPictureInPicture(), this.hide();
  }
  /**
   * Enables or disables button based on availability of a Picture-In-Picture mode.
   *
   * Enabled if
   * - `player.options().enableDocumentPictureInPicture` is true and
   *   window.documentPictureInPicture is available; or
   * - `player.disablePictureInPicture()` is false and
   *   element.requestPictureInPicture is available
   */
  handlePictureInPictureEnabledChange() {
    Be.pictureInPictureEnabled && this.player_.disablePictureInPicture() === !1 || this.player_.options_.enableDocumentPictureInPicture && "documentPictureInPicture" in me ? this.enable() : this.disable();
  }
  /**
   * Handles enterpictureinpicture and leavepictureinpicture on the player and change control text accordingly.
   *
   * @param {Event} [event]
   *        The {@link Player#enterpictureinpicture} or {@link Player#leavepictureinpicture} event that caused this function to be
   *        called.
   *
   * @listens Player#enterpictureinpicture
   * @listens Player#leavepictureinpicture
   */
  handlePictureInPictureChange(e) {
    this.player_.isInPictureInPicture() ? (this.setIcon("picture-in-picture-exit"), this.controlText("Exit Picture-in-Picture")) : (this.setIcon("picture-in-picture-enter"), this.controlText("Picture-in-Picture")), this.handlePictureInPictureEnabledChange();
  }
  /**
   * This gets called when an `PictureInPictureToggle` is "clicked". See
   * {@link ClickableComponent} for more detailed information on what a click can be.
   *
   * @param {Event} [event]
   *        The `keydown`, `tap`, or `click` event that caused this function to be
   *        called.
   *
   * @listens tap
   * @listens click
   */
  handleClick(e) {
    this.player_.isInPictureInPicture() ? this.player_.exitPictureInPicture() : this.player_.requestPictureInPicture();
  }
  /**
   * Show the `Component`s element if it is hidden by removing the
   * 'vjs-hidden' class name from it only in browsers that support the Picture-in-Picture API.
   */
  show() {
    typeof Be.exitPictureInPicture == "function" && super.show();
  }
}
hS.prototype.controlText_ = "Picture-in-Picture";
Pe.registerComponent("PictureInPictureToggle", hS);
class pS extends Kt {
  /**
   * Creates an instance of this class.
   *
   * @param {Player} player
   *        The `Player` that this class should be attached to.
   *
   * @param {Object} [options]
   *        The key/value store of player options.
   */
  constructor(e, t) {
    super(e, t), this.setIcon("fullscreen-enter"), this.on(e, "fullscreenchange", (i) => this.handleFullscreenChange(i)), Be[e.fsApi_.fullscreenEnabled] === !1 && this.disable();
  }
  /**
   * Builds the default DOM `className`.
   *
   * @return {string}
   *         The DOM `className` for this object.
   */
  buildCSSClass() {
    return `vjs-fullscreen-control ${super.buildCSSClass()}`;
  }
  /**
   * Handles fullscreenchange on the player and change control text accordingly.
   *
   * @param {Event} [event]
   *        The {@link Player#fullscreenchange} event that caused this function to be
   *        called.
   *
   * @listens Player#fullscreenchange
   */
  handleFullscreenChange(e) {
    this.player_.isFullscreen() ? (this.controlText("Exit Fullscreen"), this.setIcon("fullscreen-exit")) : (this.controlText("Fullscreen"), this.setIcon("fullscreen-enter"));
  }
  /**
   * This gets called when an `FullscreenToggle` is "clicked". See
   * {@link ClickableComponent} for more detailed information on what a click can be.
   *
   * @param {Event} [event]
   *        The `keydown`, `tap`, or `click` event that caused this function to be
   *        called.
   *
   * @listens tap
   * @listens click
   */
  handleClick(e) {
    this.player_.isFullscreen() ? this.player_.exitFullscreen() : this.player_.requestFullscreen();
  }
}
pS.prototype.controlText_ = "Fullscreen";
Pe.registerComponent("FullscreenToggle", pS);
const FO = function(n, e) {
  e.tech_ && !e.tech_.featuresVolumeControl && n.addClass("vjs-hidden"), n.on(e, "loadstart", function() {
    e.tech_.featuresVolumeControl ? n.removeClass("vjs-hidden") : n.addClass("vjs-hidden");
  });
};
class NO extends Pe {
  /**
   * Create the `Component`'s DOM element
   *
   * @return {Element}
   *         The element that was created.
   */
  createEl() {
    const e = super.createEl("div", {
      className: "vjs-volume-level"
    });
    return this.setIcon("circle", e), e.appendChild(super.createEl("span", {
      className: "vjs-control-text"
    })), e;
  }
}
Pe.registerComponent("VolumeLevel", NO);
class MO extends Pe {
  /**
   * Creates an instance of this class.
   *
   * @param {Player} player
   *        The {@link Player} that this class should be attached to.
   *
   * @param {Object} [options]
   *        The key/value store of player options.
   */
  constructor(e, t) {
    super(e, t), this.update = Ti(_t(this, this.update), Bn);
  }
  /**
   * Create the volume tooltip DOM element
   *
   * @return {Element}
   *         The element that was created.
   */
  createEl() {
    return super.createEl("div", {
      className: "vjs-volume-tooltip"
    }, {
      "aria-hidden": "true"
    });
  }
  /**
   * Updates the position of the tooltip relative to the `VolumeBar` and
   * its content text.
   *
   * @param {Object} rangeBarRect
   *        The `ClientRect` for the {@link VolumeBar} element.
   *
   * @param {number} rangeBarPoint
   *        A number from 0 to 1, representing a horizontal/vertical reference point
   *        from the left edge of the {@link VolumeBar}
   *
   * @param {boolean} vertical
   *        Referees to the Volume control position
   *        in the control bar{@link VolumeControl}
   *
   */
  update(e, t, i, r) {
    if (!i) {
      const a = Sa(this.el_), s = Sa(this.player_.el()), o = e.width * t;
      if (!s || !a)
        return;
      const u = e.left - s.left + o, c = e.width - o + (s.right - e.right);
      let l = a.width / 2;
      u < l ? l += l - u : c < l && (l = c), l < 0 ? l = 0 : l > a.width && (l = a.width), this.el_.style.right = `-${l}px`;
    }
    this.write(`${r}%`);
  }
  /**
   * Write the volume to the tooltip DOM element.
   *
   * @param {string} content
   *        The formatted volume for the tooltip.
   */
  write(e) {
    lr(this.el_, e);
  }
  /**
   * Updates the position of the volume tooltip relative to the `VolumeBar`.
   *
   * @param {Object} rangeBarRect
   *        The `ClientRect` for the {@link VolumeBar} element.
   *
   * @param {number} rangeBarPoint
   *        A number from 0 to 1, representing a horizontal/vertical reference point
   *        from the left edge of the {@link VolumeBar}
   *
   * @param {boolean} vertical
   *        Referees to the Volume control position
   *        in the control bar{@link VolumeControl}
   *
   * @param {number} volume
   *        The volume level to update the tooltip to
   *
   * @param {Function} cb
   *        A function that will be called during the request animation frame
   *        for tooltips that need to do additional animations from the default
   */
  updateVolume(e, t, i, r, a) {
    this.requestNamedAnimationFrame("VolumeLevelTooltip#updateVolume", () => {
      this.update(e, t, i, r.toFixed(0)), a && a();
    });
  }
}
Pe.registerComponent("VolumeLevelTooltip", MO);
class mS extends Pe {
  /**
   * Creates an instance of this class.
   *
   * @param {Player} player
   *        The {@link Player} that this class should be attached to.
   *
   * @param {Object} [options]
   *        The key/value store of player options.
   */
  constructor(e, t) {
    super(e, t), this.update = Ti(_t(this, this.update), Bn);
  }
  /**
   * Create the DOM element for this class.
   *
   * @return {Element}
   *         The element that was created.
   */
  createEl() {
    return super.createEl("div", {
      className: "vjs-mouse-display"
    });
  }
  /**
   * Enquires updates to its own DOM as well as the DOM of its
   * {@link VolumeLevelTooltip} child.
   *
   * @param {Object} rangeBarRect
   *        The `ClientRect` for the {@link VolumeBar} element.
   *
   * @param {number} rangeBarPoint
   *        A number from 0 to 1, representing a horizontal/vertical reference point
   *        from the left edge of the {@link VolumeBar}
   *
   * @param {boolean} vertical
   *        Referees to the Volume control position
   *        in the control bar{@link VolumeControl}
   *
   */
  update(e, t, i) {
    const r = 100 * t;
    this.getChild("volumeLevelTooltip").updateVolume(e, t, i, r, () => {
      i ? this.el_.style.bottom = `${e.height * t}px` : this.el_.style.left = `${e.width * t}px`;
    });
  }
}
mS.prototype.options_ = {
  children: ["volumeLevelTooltip"]
};
Pe.registerComponent("MouseVolumeLevelDisplay", mS);
class Cl extends f0 {
  /**
   * Creates an instance of this class.
   *
   * @param {Player} player
   *        The `Player` that this class should be attached to.
   *
   * @param {Object} [options]
   *        The key/value store of player options.
   */
  constructor(e, t) {
    super(e, t), this.on("slideractive", (i) => this.updateLastVolume_(i)), this.on(e, "volumechange", (i) => this.updateARIAAttributes(i)), e.ready(() => this.updateARIAAttributes());
  }
  /**
   * Create the `Component`'s DOM element
   *
   * @return {Element}
   *         The element that was created.
   */
  createEl() {
    return super.createEl("div", {
      className: "vjs-volume-bar vjs-slider-bar"
    }, {
      "aria-label": this.localize("Volume Level"),
      "aria-live": "polite"
    });
  }
  /**
   * Handle mouse down on volume bar
   *
   * @param {Event} event
   *        The `mousedown` event that caused this to run.
   *
   * @listens mousedown
   */
  handleMouseDown(e) {
    Js(e) && super.handleMouseDown(e);
  }
  /**
   * Handle movement events on the {@link VolumeMenuButton}.
   *
   * @param {Event} event
   *        The event that caused this function to run.
   *
   * @listens mousemove
   */
  handleMouseMove(e) {
    const t = this.getChild("mouseVolumeLevelDisplay");
    if (t) {
      const i = this.el(), r = Sa(i), a = this.vertical();
      let s = xl(i, e);
      s = a ? s.y : s.x, s = go(s, 0, 1), t.update(r, s, a);
    }
    Js(e) && (this.checkMuted(), this.player_.volume(this.calculateDistance(e)));
  }
  /**
   * If the player is muted unmute it.
   */
  checkMuted() {
    this.player_.muted() && this.player_.muted(!1);
  }
  /**
   * Get percent of volume level
   *
   * @return {number}
   *         Volume level percent as a decimal number.
   */
  getPercent() {
    return this.player_.muted() ? 0 : this.player_.volume();
  }
  /**
   * Increase volume level for keyboard users
   */
  stepForward() {
    this.checkMuted(), this.player_.volume(this.player_.volume() + 0.1);
  }
  /**
   * Decrease volume level for keyboard users
   */
  stepBack() {
    this.checkMuted(), this.player_.volume(this.player_.volume() - 0.1);
  }
  /**
   * Update ARIA accessibility attributes
   *
   * @param {Event} [event]
   *        The `volumechange` event that caused this function to run.
   *
   * @listens Player#volumechange
   */
  updateARIAAttributes(e) {
    const t = this.player_.muted() ? 0 : this.volumeAsPercentage_();
    this.el_.setAttribute("aria-valuenow", t), this.el_.setAttribute("aria-valuetext", t + "%");
  }
  /**
   * Returns the current value of the player volume as a percentage
   *
   * @private
   */
  volumeAsPercentage_() {
    return Math.round(this.player_.volume() * 100);
  }
  /**
   * When user starts dragging the VolumeBar, store the volume and listen for
   * the end of the drag. When the drag ends, if the volume was set to zero,
   * set lastVolume to the stored volume.
   *
   * @listens slideractive
   * @private
   */
  updateLastVolume_() {
    const e = this.player_.volume();
    this.one("sliderinactive", () => {
      this.player_.volume() === 0 && this.player_.lastVolume_(e);
    });
  }
}
Cl.prototype.options_ = {
  children: ["volumeLevel"],
  barName: "volumeLevel"
};
!Gt && !ai && Cl.prototype.options_.children.splice(0, 0, "mouseVolumeLevelDisplay");
Cl.prototype.playerEvent = "volumechange";
Pe.registerComponent("VolumeBar", Cl);
class gS extends Pe {
  /**
   * Creates an instance of this class.
   *
   * @param {Player} player
   *        The `Player` that this class should be attached to.
   *
   * @param {Object} [options={}]
   *        The key/value store of player options.
   */
  constructor(e, t = {}) {
    t.vertical = t.vertical || !1, (typeof t.volumeBar > "u" || Ea(t.volumeBar)) && (t.volumeBar = t.volumeBar || {}, t.volumeBar.vertical = t.vertical), super(e, t), FO(this, e), this.throttledHandleMouseMove = Ti(_t(this, this.handleMouseMove), Bn), this.handleMouseUpHandler_ = (i) => this.handleMouseUp(i), this.on("mousedown", (i) => this.handleMouseDown(i)), this.on("touchstart", (i) => this.handleMouseDown(i)), this.on("mousemove", (i) => this.handleMouseMove(i)), this.on(this.volumeBar, ["focus", "slideractive"], () => {
      this.volumeBar.addClass("vjs-slider-active"), this.addClass("vjs-slider-active"), this.trigger("slideractive");
    }), this.on(this.volumeBar, ["blur", "sliderinactive"], () => {
      this.volumeBar.removeClass("vjs-slider-active"), this.removeClass("vjs-slider-active"), this.trigger("sliderinactive");
    });
  }
  /**
   * Create the `Component`'s DOM element
   *
   * @return {Element}
   *         The element that was created.
   */
  createEl() {
    let e = "vjs-volume-horizontal";
    return this.options_.vertical && (e = "vjs-volume-vertical"), super.createEl("div", {
      className: `vjs-volume-control vjs-control ${e}`
    });
  }
  /**
   * Handle `mousedown` or `touchstart` events on the `VolumeControl`.
   *
   * @param {Event} event
   *        `mousedown` or `touchstart` event that triggered this function
   *
   * @listens mousedown
   * @listens touchstart
   */
  handleMouseDown(e) {
    const t = this.el_.ownerDocument;
    this.on(t, "mousemove", this.throttledHandleMouseMove), this.on(t, "touchmove", this.throttledHandleMouseMove), this.on(t, "mouseup", this.handleMouseUpHandler_), this.on(t, "touchend", this.handleMouseUpHandler_);
  }
  /**
   * Handle `mouseup` or `touchend` events on the `VolumeControl`.
   *
   * @param {Event} event
   *        `mouseup` or `touchend` event that triggered this function.
   *
   * @listens touchend
   * @listens mouseup
   */
  handleMouseUp(e) {
    const t = this.el_.ownerDocument;
    this.off(t, "mousemove", this.throttledHandleMouseMove), this.off(t, "touchmove", this.throttledHandleMouseMove), this.off(t, "mouseup", this.handleMouseUpHandler_), this.off(t, "touchend", this.handleMouseUpHandler_);
  }
  /**
   * Handle `mousedown` or `touchstart` events on the `VolumeControl`.
   *
   * @param {Event} event
   *        `mousedown` or `touchstart` event that triggered this function
   *
   * @listens mousedown
   * @listens touchstart
   */
  handleMouseMove(e) {
    this.volumeBar.handleMouseMove(e);
  }
}
gS.prototype.options_ = {
  children: ["volumeBar"]
};
Pe.registerComponent("VolumeControl", gS);
const BO = function(n, e) {
  e.tech_ && !e.tech_.featuresMuteControl && n.addClass("vjs-hidden"), n.on(e, "loadstart", function() {
    e.tech_.featuresMuteControl ? n.removeClass("vjs-hidden") : n.addClass("vjs-hidden");
  });
};
class bS extends Kt {
  /**
   * Creates an instance of this class.
   *
   * @param {Player} player
   *        The `Player` that this class should be attached to.
   *
   * @param {Object} [options]
   *        The key/value store of player options.
   */
  constructor(e, t) {
    super(e, t), BO(this, e), this.on(e, ["loadstart", "volumechange"], (i) => this.update(i));
  }
  /**
   * Builds the default DOM `className`.
   *
   * @return {string}
   *         The DOM `className` for this object.
   */
  buildCSSClass() {
    return `vjs-mute-control ${super.buildCSSClass()}`;
  }
  /**
   * This gets called when an `MuteToggle` is "clicked". See
   * {@link ClickableComponent} for more detailed information on what a click can be.
   *
   * @param {Event} [event]
   *        The `keydown`, `tap`, or `click` event that caused this function to be
   *        called.
   *
   * @listens tap
   * @listens click
   */
  handleClick(e) {
    const t = this.player_.volume(), i = this.player_.lastVolume_();
    if (t === 0) {
      const r = i < 0.1 ? 0.1 : i;
      this.player_.volume(r), this.player_.muted(!1);
    } else
      this.player_.muted(!this.player_.muted());
  }
  /**
   * Update the `MuteToggle` button based on the state of `volume` and `muted`
   * on the player.
   *
   * @param {Event} [event]
   *        The {@link Player#loadstart} event if this function was called
   *        through an event.
   *
   * @listens Player#loadstart
   * @listens Player#volumechange
   */
  update(e) {
    this.updateIcon_(), this.updateControlText_();
  }
  /**
   * Update the appearance of the `MuteToggle` icon.
   *
   * Possible states (given `level` variable below):
   * - 0: crossed out
   * - 1: zero bars of volume
   * - 2: one bar of volume
   * - 3: two bars of volume
   *
   * @private
   */
  updateIcon_() {
    const e = this.player_.volume();
    let t = 3;
    this.setIcon("volume-high"), Gt && this.player_.tech_ && this.player_.tech_.el_ && this.player_.muted(this.player_.tech_.el_.muted), e === 0 || this.player_.muted() ? (this.setIcon("volume-mute"), t = 0) : e < 0.33 ? (this.setIcon("volume-low"), t = 1) : e < 0.67 && (this.setIcon("volume-medium"), t = 2), yl(this.el_, [0, 1, 2, 3].reduce((i, r) => i + `${r ? " " : ""}vjs-vol-${r}`, "")), Rr(this.el_, `vjs-vol-${t}`);
  }
  /**
   * If `muted` has changed on the player, update the control text
   * (`title` attribute on `vjs-mute-control` element and content of
   * `vjs-control-text` element).
   *
   * @private
   */
  updateControlText_() {
    const t = this.player_.muted() || this.player_.volume() === 0 ? "Unmute" : "Mute";
    this.controlText() !== t && this.controlText(t);
  }
}
bS.prototype.controlText_ = "Mute";
Pe.registerComponent("MuteToggle", bS);
class yS extends Pe {
  /**
   * Creates an instance of this class.
   *
   * @param {Player} player
   *        The `Player` that this class should be attached to.
   *
   * @param {Object} [options={}]
   *        The key/value store of player options.
   */
  constructor(e, t = {}) {
    typeof t.inline < "u" ? t.inline = t.inline : t.inline = !0, (typeof t.volumeControl > "u" || Ea(t.volumeControl)) && (t.volumeControl = t.volumeControl || {}, t.volumeControl.vertical = !t.inline), super(e, t), this.handleKeyPressHandler_ = (i) => this.handleKeyPress(i), this.on(e, ["loadstart"], (i) => this.volumePanelState_(i)), this.on(this.muteToggle, "keyup", (i) => this.handleKeyPress(i)), this.on(this.volumeControl, "keyup", (i) => this.handleVolumeControlKeyUp(i)), this.on("keydown", (i) => this.handleKeyPress(i)), this.on("mouseover", (i) => this.handleMouseOver(i)), this.on("mouseout", (i) => this.handleMouseOut(i)), this.on(this.volumeControl, ["slideractive"], this.sliderActive_), this.on(this.volumeControl, ["sliderinactive"], this.sliderInactive_);
  }
  /**
   * Add vjs-slider-active class to the VolumePanel
   *
   * @listens VolumeControl#slideractive
   * @private
   */
  sliderActive_() {
    this.addClass("vjs-slider-active");
  }
  /**
   * Removes vjs-slider-active class to the VolumePanel
   *
   * @listens VolumeControl#sliderinactive
   * @private
   */
  sliderInactive_() {
    this.removeClass("vjs-slider-active");
  }
  /**
   * Adds vjs-hidden or vjs-mute-toggle-only to the VolumePanel
   * depending on MuteToggle and VolumeControl state
   *
   * @listens Player#loadstart
   * @private
   */
  volumePanelState_() {
    this.volumeControl.hasClass("vjs-hidden") && this.muteToggle.hasClass("vjs-hidden") && this.addClass("vjs-hidden"), this.volumeControl.hasClass("vjs-hidden") && !this.muteToggle.hasClass("vjs-hidden") && this.addClass("vjs-mute-toggle-only");
  }
  /**
   * Create the `Component`'s DOM element
   *
   * @return {Element}
   *         The element that was created.
   */
  createEl() {
    let e = "vjs-volume-panel-horizontal";
    return this.options_.inline || (e = "vjs-volume-panel-vertical"), super.createEl("div", {
      className: `vjs-volume-panel vjs-control ${e}`
    });
  }
  /**
   * Dispose of the `volume-panel` and all child components.
   */
  dispose() {
    this.handleMouseOut(), super.dispose();
  }
  /**
   * Handles `keyup` events on the `VolumeControl`, looking for ESC, which closes
   * the volume panel and sets focus on `MuteToggle`.
   *
   * @param {Event} event
   *        The `keyup` event that caused this function to be called.
   *
   * @listens keyup
   */
  handleVolumeControlKeyUp(e) {
    e.key === "Escape" && this.muteToggle.focus();
  }
  /**
   * This gets called when a `VolumePanel` gains hover via a `mouseover` event.
   * Turns on listening for `mouseover` event. When they happen it
   * calls `this.handleMouseOver`.
   *
   * @param {Event} event
   *        The `mouseover` event that caused this function to be called.
   *
   * @listens mouseover
   */
  handleMouseOver(e) {
    this.addClass("vjs-hover"), En(Be, "keyup", this.handleKeyPressHandler_);
  }
  /**
   * This gets called when a `VolumePanel` gains hover via a `mouseout` event.
   * Turns on listening for `mouseout` event. When they happen it
   * calls `this.handleMouseOut`.
   *
   * @param {Event} event
   *        The `mouseout` event that caused this function to be called.
   *
   * @listens mouseout
   */
  handleMouseOut(e) {
    this.removeClass("vjs-hover"), Xt(Be, "keyup", this.handleKeyPressHandler_);
  }
  /**
   * Handles `keyup` event on the document or `keydown` event on the `VolumePanel`,
   * looking for ESC, which hides the `VolumeControl`.
   *
   * @param {Event} event
   *        The keypress that triggered this event.
   *
   * @listens keydown | keyup
   */
  handleKeyPress(e) {
    e.key === "Escape" && this.handleMouseOut();
  }
}
yS.prototype.options_ = {
  children: ["muteToggle", "volumeControl"]
};
Pe.registerComponent("VolumePanel", yS);
class vS extends Kt {
  constructor(e, t) {
    super(e, t), this.validOptions = [5, 10, 30], this.skipTime = this.getSkipForwardTime(), this.skipTime && this.validOptions.includes(this.skipTime) ? (this.setIcon(`forward-${this.skipTime}`), this.controlText(this.localize("Skip forward {1} seconds", [this.skipTime.toLocaleString(e.language())])), this.show()) : this.hide();
  }
  getSkipForwardTime() {
    const e = this.options_.playerOptions;
    return e.controlBar && e.controlBar.skipButtons && e.controlBar.skipButtons.forward;
  }
  buildCSSClass() {
    return `vjs-skip-forward-${this.getSkipForwardTime()} ${super.buildCSSClass()}`;
  }
  /**
   * On click, skips forward in the duration/seekable range by a configurable amount of seconds.
   * If the time left in the duration/seekable range is less than the configured 'skip forward' time,
   * skips to end of duration/seekable range.
   *
   * Handle a click on a `SkipForward` button
   *
   * @param {EventTarget~Event} event
   *        The `click` event that caused this function
   *        to be called
   */
  handleClick(e) {
    if (isNaN(this.player_.duration()))
      return;
    const t = this.player_.currentTime(), i = this.player_.liveTracker, r = i && i.isLive() ? i.seekableEnd() : this.player_.duration();
    let a;
    t + this.skipTime <= r ? a = t + this.skipTime : a = r, this.player_.currentTime(a);
  }
  /**
   * Update control text on languagechange
   */
  handleLanguagechange() {
    this.controlText(this.localize("Skip forward {1} seconds", [this.skipTime]));
  }
}
vS.prototype.controlText_ = "Skip Forward";
Pe.registerComponent("SkipForward", vS);
class xS extends Kt {
  constructor(e, t) {
    super(e, t), this.validOptions = [5, 10, 30], this.skipTime = this.getSkipBackwardTime(), this.skipTime && this.validOptions.includes(this.skipTime) ? (this.setIcon(`replay-${this.skipTime}`), this.controlText(this.localize("Skip backward {1} seconds", [this.skipTime.toLocaleString(e.language())])), this.show()) : this.hide();
  }
  getSkipBackwardTime() {
    const e = this.options_.playerOptions;
    return e.controlBar && e.controlBar.skipButtons && e.controlBar.skipButtons.backward;
  }
  buildCSSClass() {
    return `vjs-skip-backward-${this.getSkipBackwardTime()} ${super.buildCSSClass()}`;
  }
  /**
   * On click, skips backward in the video by a configurable amount of seconds.
   * If the current time in the video is less than the configured 'skip backward' time,
   * skips to beginning of video or seekable range.
   *
   * Handle a click on a `SkipBackward` button
   *
   * @param {EventTarget~Event} event
   *        The `click` event that caused this function
   *        to be called
   */
  handleClick(e) {
    const t = this.player_.currentTime(), i = this.player_.liveTracker, r = i && i.isLive() && i.seekableStart();
    let a;
    r && t - this.skipTime <= r ? a = r : t >= this.skipTime ? a = t - this.skipTime : a = 0, this.player_.currentTime(a);
  }
  /**
   * Update control text on languagechange
   */
  handleLanguagechange() {
    this.controlText(this.localize("Skip backward {1} seconds", [this.skipTime]));
  }
}
xS.prototype.controlText_ = "Skip Backward";
Pe.registerComponent("SkipBackward", xS);
class _S extends Pe {
  /**
   * Create an instance of this class.
   *
   * @param {Player} player
   *        the player that this component should attach to
   *
   * @param {Object} [options]
   *        Object of option names and values
   *
   */
  constructor(e, t) {
    super(e, t), t && (this.menuButton_ = t.menuButton), this.focusedChild_ = -1, this.on("keydown", (i) => this.handleKeyDown(i)), this.boundHandleBlur_ = (i) => this.handleBlur(i), this.boundHandleTapClick_ = (i) => this.handleTapClick(i);
  }
  /**
   * Add event listeners to the {@link MenuItem}.
   *
   * @param {Object} component
   *        The instance of the `MenuItem` to add listeners to.
   *
   */
  addEventListenerForItem(e) {
    e instanceof Pe && (this.on(e, "blur", this.boundHandleBlur_), this.on(e, ["tap", "click"], this.boundHandleTapClick_));
  }
  /**
   * Remove event listeners from the {@link MenuItem}.
   *
   * @param {Object} component
   *        The instance of the `MenuItem` to remove listeners.
   *
   */
  removeEventListenerForItem(e) {
    e instanceof Pe && (this.off(e, "blur", this.boundHandleBlur_), this.off(e, ["tap", "click"], this.boundHandleTapClick_));
  }
  /**
   * This method will be called indirectly when the component has been added
   * before the component adds to the new menu instance by `addItem`.
   * In this case, the original menu instance will remove the component
   * by calling `removeChild`.
   *
   * @param {Object} component
   *        The instance of the `MenuItem`
   */
  removeChild(e) {
    typeof e == "string" && (e = this.getChild(e)), this.removeEventListenerForItem(e), super.removeChild(e);
  }
  /**
   * Add a {@link MenuItem} to the menu.
   *
   * @param {Object|string} component
   *        The name or instance of the `MenuItem` to add.
   *
   */
  addItem(e) {
    const t = this.addChild(e);
    t && this.addEventListenerForItem(t);
  }
  /**
   * Create the `Menu`s DOM element.
   *
   * @return {Element}
   *         the element that was created
   */
  createEl() {
    const e = this.options_.contentElType || "ul";
    this.contentEl_ = Ye(e, {
      className: "vjs-menu-content"
    }), this.contentEl_.setAttribute("role", "menu");
    const t = super.createEl("div", {
      append: this.contentEl_,
      className: "vjs-menu"
    });
    return t.appendChild(this.contentEl_), En(t, "click", function(i) {
      i.preventDefault(), i.stopImmediatePropagation();
    }), t;
  }
  dispose() {
    this.contentEl_ = null, this.boundHandleBlur_ = null, this.boundHandleTapClick_ = null, super.dispose();
  }
  /**
   * Called when a `MenuItem` loses focus.
   *
   * @param {Event} event
   *        The `blur` event that caused this function to be called.
   *
   * @listens blur
   */
  handleBlur(e) {
    const t = e.relatedTarget || Be.activeElement;
    if (!this.children().some((i) => i.el() === t)) {
      const i = this.menuButton_;
      i && i.buttonPressed_ && t !== i.el().firstChild && i.unpressButton();
    }
  }
  /**
   * Called when a `MenuItem` gets clicked or tapped.
   *
   * @param {Event} event
   *        The `click` or `tap` event that caused this function to be called.
   *
   * @listens click,tap
   */
  handleTapClick(e) {
    if (this.menuButton_) {
      this.menuButton_.unpressButton();
      const t = this.children();
      if (!Array.isArray(t))
        return;
      const i = t.filter((r) => r.el() === e.target)[0];
      if (!i)
        return;
      i.name() !== "CaptionSettingsMenuItem" && this.menuButton_.focus();
    }
  }
  /**
   * Handle a `keydown` event on this menu. This listener is added in the constructor.
   *
   * @param {KeyboardEvent} event
   *        A `keydown` event that happened on the menu.
   *
   * @listens keydown
   */
  handleKeyDown(e) {
    e.key === "ArrowLeft" || e.key === "ArrowDown" ? (e.preventDefault(), e.stopPropagation(), this.stepForward()) : (e.key === "ArrowRight" || e.key === "ArrowUp") && (e.preventDefault(), e.stopPropagation(), this.stepBack());
  }
  /**
   * Move to next (lower) menu item for keyboard users.
   */
  stepForward() {
    let e = 0;
    this.focusedChild_ !== void 0 && (e = this.focusedChild_ + 1), this.focus(e);
  }
  /**
   * Move to previous (higher) menu item for keyboard users.
   */
  stepBack() {
    let e = 0;
    this.focusedChild_ !== void 0 && (e = this.focusedChild_ - 1), this.focus(e);
  }
  /**
   * Set focus on a {@link MenuItem} in the `Menu`.
   *
   * @param {Object|string} [item=0]
   *        Index of child item set focus on.
   */
  focus(e = 0) {
    const t = this.children().slice();
    t.length && t[0].hasClass("vjs-menu-title") && t.shift(), t.length > 0 && (e < 0 ? e = 0 : e >= t.length && (e = t.length - 1), this.focusedChild_ = e, t[e].el_.focus());
  }
}
Pe.registerComponent("Menu", _S);
let p0 = class extends Pe {
  /**
   * Creates an instance of this class.
   *
   * @param {Player} player
   *        The `Player` that this class should be attached to.
   *
   * @param {Object} [options={}]
   *        The key/value store of player options.
   */
  constructor(e, t = {}) {
    super(e, t), this.menuButton_ = new Kt(e, t), this.menuButton_.controlText(this.controlText_), this.menuButton_.el_.setAttribute("aria-haspopup", "true");
    const i = Kt.prototype.buildCSSClass();
    this.menuButton_.el_.className = this.buildCSSClass() + " " + i, this.menuButton_.removeClass("vjs-control"), this.addChild(this.menuButton_), this.update(), this.enabled_ = !0;
    const r = (a) => this.handleClick(a);
    this.handleMenuKeyUp_ = (a) => this.handleMenuKeyUp(a), this.on(this.menuButton_, "tap", r), this.on(this.menuButton_, "click", r), this.on(this.menuButton_, "keydown", (a) => this.handleKeyDown(a)), this.on(this.menuButton_, "mouseenter", () => {
      this.addClass("vjs-hover"), this.menu.show(), En(Be, "keyup", this.handleMenuKeyUp_);
    }), this.on("mouseleave", (a) => this.handleMouseLeave(a)), this.on("keydown", (a) => this.handleSubmenuKeyDown(a));
  }
  /**
   * Update the menu based on the current state of its items.
   */
  update() {
    const e = this.createMenu();
    this.menu && (this.menu.dispose(), this.removeChild(this.menu)), this.menu = e, this.addChild(e), this.buttonPressed_ = !1, this.menuButton_.el_.setAttribute("aria-expanded", "false"), this.items && this.items.length <= this.hideThreshold_ ? (this.hide(), this.menu.contentEl_.removeAttribute("role")) : (this.show(), this.menu.contentEl_.setAttribute("role", "menu"));
  }
  /**
   * Create the menu and add all items to it.
   *
   * @return {Menu}
   *         The constructed menu
   */
  createMenu() {
    const e = new _S(this.player_, {
      menuButton: this
    });
    if (this.hideThreshold_ = 0, this.options_.title) {
      const t = Ye("li", {
        className: "vjs-menu-title",
        textContent: Rt(this.options_.title),
        tabIndex: -1
      }), i = new Pe(this.player_, {
        el: t
      });
      e.addItem(i);
    }
    if (this.items = this.createItems(), this.items)
      for (let t = 0; t < this.items.length; t++)
        e.addItem(this.items[t]);
    return e;
  }
  /**
   * Create the list of menu items. Specific to each subclass.
   *
   * @abstract
   */
  createItems() {
  }
  /**
   * Create the `MenuButtons`s DOM element.
   *
   * @return {Element}
   *         The element that gets created.
   */
  createEl() {
    return super.createEl("div", {
      className: this.buildWrapperCSSClass()
    }, {});
  }
  /**
   * Overwrites the `setIcon` method from `Component`.
   * In this case, we want the icon to be appended to the menuButton.
   *
   * @param {string} name
   *         The icon name to be added.
   */
  setIcon(e) {
    super.setIcon(e, this.menuButton_.el_);
  }
  /**
   * Allow sub components to stack CSS class names for the wrapper element
   *
   * @return {string}
   *         The constructed wrapper DOM `className`
   */
  buildWrapperCSSClass() {
    let e = "vjs-menu-button";
    this.options_.inline === !0 ? e += "-inline" : e += "-popup";
    const t = Kt.prototype.buildCSSClass();
    return `vjs-menu-button ${e} ${t} ${super.buildCSSClass()}`;
  }
  /**
   * Builds the default DOM `className`.
   *
   * @return {string}
   *         The DOM `className` for this object.
   */
  buildCSSClass() {
    let e = "vjs-menu-button";
    return this.options_.inline === !0 ? e += "-inline" : e += "-popup", `vjs-menu-button ${e} ${super.buildCSSClass()}`;
  }
  /**
   * Get or set the localized control text that will be used for accessibility.
   *
   * > NOTE: This will come from the internal `menuButton_` element.
   *
   * @param {string} [text]
   *        Control text for element.
   *
   * @param {Element} [el=this.menuButton_.el()]
   *        Element to set the title on.
   *
   * @return {string}
   *         - The control text when getting
   */
  controlText(e, t = this.menuButton_.el()) {
    return this.menuButton_.controlText(e, t);
  }
  /**
   * Dispose of the `menu-button` and all child components.
   */
  dispose() {
    this.handleMouseLeave(), super.dispose();
  }
  /**
   * Handle a click on a `MenuButton`.
   * See {@link ClickableComponent#handleClick} for instances where this is called.
   *
   * @param {Event} event
   *        The `keydown`, `tap`, or `click` event that caused this function to be
   *        called.
   *
   * @listens tap
   * @listens click
   */
  handleClick(e) {
    this.buttonPressed_ ? this.unpressButton() : this.pressButton();
  }
  /**
   * Handle `mouseleave` for `MenuButton`.
   *
   * @param {Event} event
   *        The `mouseleave` event that caused this function to be called.
   *
   * @listens mouseleave
   */
  handleMouseLeave(e) {
    this.removeClass("vjs-hover"), Xt(Be, "keyup", this.handleMenuKeyUp_);
  }
  /**
   * Set the focus to the actual button, not to this element
   */
  focus() {
    this.menuButton_.focus();
  }
  /**
   * Remove the focus from the actual button, not this element
   */
  blur() {
    this.menuButton_.blur();
  }
  /**
   * Handle tab, escape, down arrow, and up arrow keys for `MenuButton`. See
   * {@link ClickableComponent#handleKeyDown} for instances where this is called.
   *
   * @param {Event} event
   *        The `keydown` event that caused this function to be called.
   *
   * @listens keydown
   */
  handleKeyDown(e) {
    e.key === "Escape" || e.key === "Tab" ? (this.buttonPressed_ && this.unpressButton(), !e.key === "Tab" && (e.preventDefault(), this.menuButton_.focus())) : (e.key === "Up" || e.key === "Down" && !(this.player_.options_.playerOptions.spatialNavigation && this.player_.options_.playerOptions.spatialNavigation.enabled)) && (this.buttonPressed_ || (e.preventDefault(), this.pressButton()));
  }
  /**
   * Handle a `keyup` event on a `MenuButton`. The listener for this is added in
   * the constructor.
   *
   * @param {Event} event
   *        Key press event
   *
   * @listens keyup
   */
  handleMenuKeyUp(e) {
    (e.key === "Escape" || e.key === "Tab") && this.removeClass("vjs-hover");
  }
  /**
   * This method name now delegates to `handleSubmenuKeyDown`. This means
   * anyone calling `handleSubmenuKeyPress` will not see their method calls
   * stop working.
   *
   * @param {Event} event
   *        The event that caused this function to be called.
   */
  handleSubmenuKeyPress(e) {
    this.handleSubmenuKeyDown(e);
  }
  /**
   * Handle a `keydown` event on a sub-menu. The listener for this is added in
   * the constructor.
   *
   * @param {Event} event
   *        Key press event
   *
   * @listens keydown
   */
  handleSubmenuKeyDown(e) {
    (e.key === "Escape" || e.key === "Tab") && (this.buttonPressed_ && this.unpressButton(), !e.key === "Tab" && (e.preventDefault(), this.menuButton_.focus()));
  }
  /**
   * Put the current `MenuButton` into a pressed state.
   */
  pressButton() {
    if (this.enabled_) {
      if (this.buttonPressed_ = !0, this.menu.show(), this.menu.lockShowing(), this.menuButton_.el_.setAttribute("aria-expanded", "true"), Gt && kD())
        return;
      this.menu.focus();
    }
  }
  /**
   * Take the current `MenuButton` out of a pressed state.
   */
  unpressButton() {
    this.enabled_ && (this.buttonPressed_ = !1, this.menu.unlockShowing(), this.menu.hide(), this.menuButton_.el_.setAttribute("aria-expanded", "false"));
  }
  /**
   * Disable the `MenuButton`. Don't allow it to be clicked.
   */
  disable() {
    this.unpressButton(), this.enabled_ = !1, this.addClass("vjs-disabled"), this.menuButton_.disable();
  }
  /**
   * Enable the `MenuButton`. Allow it to be clicked.
   */
  enable() {
    this.enabled_ = !0, this.removeClass("vjs-disabled"), this.menuButton_.enable();
  }
};
Pe.registerComponent("MenuButton", p0);
class m0 extends p0 {
  /**
   * Creates an instance of this class.
   *
   * @param {Player} player
   *        The `Player` that this class should be attached to.
   *
   * @param {Object} [options]
   *        The key/value store of player options.
   */
  constructor(e, t) {
    const i = t.tracks;
    if (super(e, t), this.items.length <= 1 && this.hide(), !i)
      return;
    const r = _t(this, this.update);
    i.addEventListener("removetrack", r), i.addEventListener("addtrack", r), i.addEventListener("labelchange", r), this.player_.on("ready", r), this.player_.on("dispose", function() {
      i.removeEventListener("removetrack", r), i.removeEventListener("addtrack", r), i.removeEventListener("labelchange", r);
    });
  }
}
Pe.registerComponent("TrackButton", m0);
let bo = class extends Sl {
  /**
   * Creates an instance of the this class.
   *
   * @param {Player} player
   *        The `Player` that this class should be attached to.
   *
   * @param {Object} [options={}]
   *        The key/value store of player options.
   *
   */
  constructor(e, t) {
    super(e, t), this.selectable = t.selectable, this.isSelected_ = t.selected || !1, this.multiSelectable = t.multiSelectable, this.selected(this.isSelected_), this.selectable ? this.multiSelectable ? this.el_.setAttribute("role", "menuitemcheckbox") : this.el_.setAttribute("role", "menuitemradio") : this.el_.setAttribute("role", "menuitem");
  }
  /**
   * Create the `MenuItem's DOM element
   *
   * @param {string} [type=li]
   *        Element's node type, not actually used, always set to `li`.
   *
   * @param {Object} [props={}]
   *        An object of properties that should be set on the element
   *
   * @param {Object} [attrs={}]
   *        An object of attributes that should be set on the element
   *
   * @return {Element}
   *         The element that gets created.
   */
  createEl(e, t, i) {
    this.nonIconControl = !0;
    const r = super.createEl("li", Object.assign({
      className: "vjs-menu-item",
      tabIndex: -1
    }, t), i), a = Ye("span", {
      className: "vjs-menu-item-text",
      textContent: this.localize(this.options_.label)
    });
    return this.player_.options_.experimentalSvgIcons ? r.appendChild(a) : r.replaceChild(a, r.querySelector(".vjs-icon-placeholder")), r;
  }
  /**
   * Ignore keys which are used by the menu, but pass any other ones up. See
   * {@link ClickableComponent#handleKeyDown} for instances where this is called.
   *
   * @param {KeyboardEvent} event
   *        The `keydown` event that caused this function to be called.
   *
   * @listens keydown
   */
  handleKeyDown(e) {
    ["Tab", "Escape", "ArrowUp", "ArrowLeft", "ArrowRight", "ArrowDown"].includes(e.key) || super.handleKeyDown(e);
  }
  /**
   * Any click on a `MenuItem` puts it into the selected state.
   * See {@link ClickableComponent#handleClick} for instances where this is called.
   *
   * @param {Event} event
   *        The `keydown`, `tap`, or `click` event that caused this function to be
   *        called.
   *
   * @listens tap
   * @listens click
   */
  handleClick(e) {
    this.selected(!0);
  }
  /**
   * Set the state for this menu item as selected or not.
   *
   * @param {boolean} selected
   *        if the menu item is selected or not
   */
  selected(e) {
    this.selectable && (e ? (this.addClass("vjs-selected"), this.el_.setAttribute("aria-checked", "true"), this.controlText(", selected"), this.isSelected_ = !0) : (this.removeClass("vjs-selected"), this.el_.setAttribute("aria-checked", "false"), this.controlText(""), this.isSelected_ = !1));
  }
};
Pe.registerComponent("MenuItem", bo);
class yo extends bo {
  /**
   * Creates an instance of this class.
   *
   * @param {Player} player
   *        The `Player` that this class should be attached to.
   *
   * @param {Object} [options]
   *        The key/value store of player options.
   */
  constructor(e, t) {
    const i = t.track, r = e.textTracks();
    t.label = i.label || i.language || "Unknown", t.selected = i.mode === "showing", super(e, t), this.track = i, this.kinds = (t.kinds || [t.kind || this.track.kind]).filter(Boolean);
    const a = (...o) => {
      this.handleTracksChange.apply(this, o);
    }, s = (...o) => {
      this.handleSelectedLanguageChange.apply(this, o);
    };
    if (e.on(["loadstart", "texttrackchange"], a), r.addEventListener("change", a), r.addEventListener("selectedlanguagechange", s), this.on("dispose", function() {
      e.off(["loadstart", "texttrackchange"], a), r.removeEventListener("change", a), r.removeEventListener("selectedlanguagechange", s);
    }), r.onchange === void 0) {
      let o;
      this.on(["tap", "click"], function() {
        if (typeof me.Event != "object")
          try {
            o = new me.Event("change");
          } catch {
          }
        o || (o = Be.createEvent("Event"), o.initEvent("change", !0, !0)), r.dispatchEvent(o);
      });
    }
    this.handleTracksChange();
  }
  /**
   * This gets called when an `TextTrackMenuItem` is "clicked". See
   * {@link ClickableComponent} for more detailed information on what a click can be.
   *
   * @param {Event} event
   *        The `keydown`, `tap`, or `click` event that caused this function to be
   *        called.
   *
   * @listens tap
   * @listens click
   */
  handleClick(e) {
    const t = this.track, i = this.player_.textTracks();
    if (super.handleClick(e), !!i)
      for (let r = 0; r < i.length; r++) {
        const a = i[r];
        this.kinds.indexOf(a.kind) !== -1 && (a === t ? a.mode !== "showing" && (a.mode = "showing") : a.mode !== "disabled" && (a.mode = "disabled"));
      }
  }
  /**
   * Handle text track list change
   *
   * @param {Event} event
   *        The `change` event that caused this function to be called.
   *
   * @listens TextTrackList#change
   */
  handleTracksChange(e) {
    const t = this.track.mode === "showing";
    t !== this.isSelected_ && this.selected(t);
  }
  handleSelectedLanguageChange(e) {
    if (this.track.mode === "showing") {
      const t = this.player_.cache_.selectedLanguage;
      if (t && t.enabled && t.language === this.track.language && t.kind !== this.track.kind)
        return;
      this.player_.cache_.selectedLanguage = {
        enabled: !0,
        language: this.track.language,
        kind: this.track.kind
      };
    }
  }
  dispose() {
    this.track = null, super.dispose();
  }
}
Pe.registerComponent("TextTrackMenuItem", yo);
class TS extends yo {
  /**
   * Creates an instance of this class.
   *
   * @param {Player} player
   *        The `Player` that this class should be attached to.
   *
   * @param {Object} [options]
   *        The key/value store of player options.
   */
  constructor(e, t) {
    t.track = {
      player: e,
      // it is no longer necessary to store `kind` or `kinds` on the track itself
      // since they are now stored in the `kinds` property of all instances of
      // TextTrackMenuItem, but this will remain for backwards compatibility
      kind: t.kind,
      kinds: t.kinds,
      default: !1,
      mode: "disabled"
    }, t.kinds || (t.kinds = [t.kind]), t.label ? t.track.label = t.label : t.track.label = t.kinds.join(" and ") + " off", t.selectable = !0, t.multiSelectable = !1, super(e, t);
  }
  /**
   * Handle text track change
   *
   * @param {Event} event
   *        The event that caused this function to run
   */
  handleTracksChange(e) {
    const t = this.player().textTracks();
    let i = !0;
    for (let r = 0, a = t.length; r < a; r++) {
      const s = t[r];
      if (this.options_.kinds.indexOf(s.kind) > -1 && s.mode === "showing") {
        i = !1;
        break;
      }
    }
    i !== this.isSelected_ && this.selected(i);
  }
  handleSelectedLanguageChange(e) {
    const t = this.player().textTracks();
    let i = !0;
    for (let r = 0, a = t.length; r < a; r++) {
      const s = t[r];
      if (["captions", "descriptions", "subtitles"].indexOf(s.kind) > -1 && s.mode === "showing") {
        i = !1;
        break;
      }
    }
    i && (this.player_.cache_.selectedLanguage = {
      enabled: !1
    });
  }
  /**
   * Update control text and label on languagechange
   */
  handleLanguagechange() {
    this.$(".vjs-menu-item-text").textContent = this.player_.localize(this.options_.label), super.handleLanguagechange();
  }
}
Pe.registerComponent("OffTextTrackMenuItem", TS);
class ja extends m0 {
  /**
   * Creates an instance of this class.
   *
   * @param {Player} player
   *        The `Player` that this class should be attached to.
   *
   * @param {Object} [options={}]
   *        The key/value store of player options.
   */
  constructor(e, t = {}) {
    t.tracks = e.textTracks(), super(e, t);
  }
  /**
   * Create a menu item for each text track
   *
   * @param {TextTrackMenuItem[]} [items=[]]
   *        Existing array of items to use during creation
   *
   * @return {TextTrackMenuItem[]}
   *         Array of menu items that were created
   */
  createItems(e = [], t = yo) {
    let i;
    this.label_ && (i = `${this.label_} off`), e.push(new TS(this.player_, {
      kinds: this.kinds_,
      kind: this.kind_,
      label: i
    })), this.hideThreshold_ += 1;
    const r = this.player_.textTracks();
    Array.isArray(this.kinds_) || (this.kinds_ = [this.kind_]);
    for (let a = 0; a < r.length; a++) {
      const s = r[a];
      if (this.kinds_.indexOf(s.kind) > -1) {
        const o = new t(this.player_, {
          track: s,
          kinds: this.kinds_,
          kind: this.kind_,
          // MenuItem is selectable
          selectable: !0,
          // MenuItem is NOT multiSelectable (i.e. only one can be marked "selected" at a time)
          multiSelectable: !1
        });
        o.addClass(`vjs-${s.kind}-menu-item`), e.push(o);
      }
    }
    return e;
  }
}
Pe.registerComponent("TextTrackButton", ja);
class wS extends bo {
  /**
   * Creates an instance of this class.
   *
   * @param {Player} player
   *        The `Player` that this class should be attached to.
   *
   * @param {Object} [options]
   *        The key/value store of player options.
   */
  constructor(e, t) {
    const i = t.track, r = t.cue, a = e.currentTime();
    t.selectable = !0, t.multiSelectable = !1, t.label = r.text, t.selected = r.startTime <= a && a < r.endTime, super(e, t), this.track = i, this.cue = r;
  }
  /**
   * This gets called when an `ChaptersTrackMenuItem` is "clicked". See
   * {@link ClickableComponent} for more detailed information on what a click can be.
   *
   * @param {Event} [event]
   *        The `keydown`, `tap`, or `click` event that caused this function to be
   *        called.
   *
   * @listens tap
   * @listens click
   */
  handleClick(e) {
    super.handleClick(), this.player_.currentTime(this.cue.startTime);
  }
}
Pe.registerComponent("ChaptersTrackMenuItem", wS);
class g0 extends ja {
  /**
   * Creates an instance of this class.
   *
   * @param {Player} player
   *        The `Player` that this class should be attached to.
   *
   * @param {Object} [options]
   *        The key/value store of player options.
   *
   * @param {Function} [ready]
   *        The function to call when this function is ready.
   */
  constructor(e, t, i) {
    super(e, t, i), this.setIcon("chapters"), this.selectCurrentItem_ = () => {
      this.items.forEach((r) => {
        r.selected(this.track_.activeCues[0] === r.cue);
      });
    };
  }
  /**
   * Builds the default DOM `className`.
   *
   * @return {string}
   *         The DOM `className` for this object.
   */
  buildCSSClass() {
    return `vjs-chapters-button ${super.buildCSSClass()}`;
  }
  buildWrapperCSSClass() {
    return `vjs-chapters-button ${super.buildWrapperCSSClass()}`;
  }
  /**
   * Update the menu based on the current state of its items.
   *
   * @param {Event} [event]
   *        An event that triggered this function to run.
   *
   * @listens TextTrackList#addtrack
   * @listens TextTrackList#removetrack
   * @listens TextTrackList#change
   */
  update(e) {
    if (e && e.track && e.track.kind !== "chapters")
      return;
    const t = this.findChaptersTrack();
    t !== this.track_ ? (this.setTrack(t), super.update()) : (!this.items || t && t.cues && t.cues.length !== this.items.length) && super.update();
  }
  /**
   * Set the currently selected track for the chapters button.
   *
   * @param {TextTrack} track
   *        The new track to select. Nothing will change if this is the currently selected
   *        track.
   */
  setTrack(e) {
    if (this.track_ !== e) {
      if (this.updateHandler_ || (this.updateHandler_ = this.update.bind(this)), this.track_) {
        const t = this.player_.remoteTextTrackEls().getTrackElementByTrack_(this.track_);
        t && t.removeEventListener("load", this.updateHandler_), this.track_.removeEventListener("cuechange", this.selectCurrentItem_), this.track_ = null;
      }
      if (this.track_ = e, this.track_) {
        this.track_.mode = "hidden";
        const t = this.player_.remoteTextTrackEls().getTrackElementByTrack_(this.track_);
        t && t.addEventListener("load", this.updateHandler_), this.track_.addEventListener("cuechange", this.selectCurrentItem_);
      }
    }
  }
  /**
   * Find the track object that is currently in use by this ChaptersButton
   *
   * @return {TextTrack|undefined}
   *         The current track or undefined if none was found.
   */
  findChaptersTrack() {
    const e = this.player_.textTracks() || [];
    for (let t = e.length - 1; t >= 0; t--) {
      const i = e[t];
      if (i.kind === this.kind_)
        return i;
    }
  }
  /**
   * Get the caption for the ChaptersButton based on the track label. This will also
   * use the current tracks localized kind as a fallback if a label does not exist.
   *
   * @return {string}
   *         The tracks current label or the localized track kind.
   */
  getMenuCaption() {
    return this.track_ && this.track_.label ? this.track_.label : this.localize(Rt(this.kind_));
  }
  /**
   * Create menu from chapter track
   *
   * @return {Menu}
   *         New menu for the chapter buttons
   */
  createMenu() {
    return this.options_.title = this.getMenuCaption(), super.createMenu();
  }
  /**
   * Create a menu item for each text track
   *
   * @return  {TextTrackMenuItem[]}
   *         Array of menu items
   */
  createItems() {
    const e = [];
    if (!this.track_)
      return e;
    const t = this.track_.cues;
    if (!t)
      return e;
    for (let i = 0, r = t.length; i < r; i++) {
      const a = t[i], s = new wS(this.player_, {
        track: this.track_,
        cue: a
      });
      e.push(s);
    }
    return e;
  }
}
g0.prototype.kind_ = "chapters";
g0.prototype.controlText_ = "Chapters";
Pe.registerComponent("ChaptersButton", g0);
class b0 extends ja {
  /**
   * Creates an instance of this class.
   *
   * @param {Player} player
   *        The `Player` that this class should be attached to.
   *
   * @param {Object} [options]
   *        The key/value store of player options.
   *
   * @param {Function} [ready]
   *        The function to call when this component is ready.
   */
  constructor(e, t, i) {
    super(e, t, i), this.setIcon("audio-description");
    const r = e.textTracks(), a = _t(this, this.handleTracksChange);
    r.addEventListener("change", a), this.on("dispose", function() {
      r.removeEventListener("change", a);
    });
  }
  /**
   * Handle text track change
   *
   * @param {Event} event
   *        The event that caused this function to run
   *
   * @listens TextTrackList#change
   */
  handleTracksChange(e) {
    const t = this.player().textTracks();
    let i = !1;
    for (let r = 0, a = t.length; r < a; r++) {
      const s = t[r];
      if (s.kind !== this.kind_ && s.mode === "showing") {
        i = !0;
        break;
      }
    }
    i ? this.disable() : this.enable();
  }
  /**
   * Builds the default DOM `className`.
   *
   * @return {string}
   *         The DOM `className` for this object.
   */
  buildCSSClass() {
    return `vjs-descriptions-button ${super.buildCSSClass()}`;
  }
  buildWrapperCSSClass() {
    return `vjs-descriptions-button ${super.buildWrapperCSSClass()}`;
  }
}
b0.prototype.kind_ = "descriptions";
b0.prototype.controlText_ = "Descriptions";
Pe.registerComponent("DescriptionsButton", b0);
class y0 extends ja {
  /**
   * Creates an instance of this class.
   *
   * @param {Player} player
   *        The `Player` that this class should be attached to.
   *
   * @param {Object} [options]
   *        The key/value store of player options.
   *
   * @param {Function} [ready]
   *        The function to call when this component is ready.
   */
  constructor(e, t, i) {
    super(e, t, i), this.setIcon("subtitles");
  }
  /**
   * Builds the default DOM `className`.
   *
   * @return {string}
   *         The DOM `className` for this object.
   */
  buildCSSClass() {
    return `vjs-subtitles-button ${super.buildCSSClass()}`;
  }
  buildWrapperCSSClass() {
    return `vjs-subtitles-button ${super.buildWrapperCSSClass()}`;
  }
}
y0.prototype.kind_ = "subtitles";
y0.prototype.controlText_ = "Subtitles";
Pe.registerComponent("SubtitlesButton", y0);
class v0 extends yo {
  /**
   * Creates an instance of this class.
   *
   * @param {Player} player
   *        The `Player` that this class should be attached to.
   *
   * @param {Object} [options]
   *        The key/value store of player options.
   */
  constructor(e, t) {
    t.track = {
      player: e,
      kind: t.kind,
      label: t.kind + " settings",
      selectable: !1,
      default: !1,
      mode: "disabled"
    }, t.selectable = !1, t.name = "CaptionSettingsMenuItem", super(e, t), this.addClass("vjs-texttrack-settings"), this.controlText(", opens " + t.kind + " settings dialog");
  }
  /**
   * This gets called when an `CaptionSettingsMenuItem` is "clicked". See
   * {@link ClickableComponent} for more detailed information on what a click can be.
   *
   * @param {Event} [event]
   *        The `keydown`, `tap`, or `click` event that caused this function to be
   *        called.
   *
   * @listens tap
   * @listens click
   */
  handleClick(e) {
    this.player().getChild("textTrackSettings").open();
  }
  /**
   * Update control text and label on languagechange
   */
  handleLanguagechange() {
    this.$(".vjs-menu-item-text").textContent = this.player_.localize(this.options_.kind + " settings"), super.handleLanguagechange();
  }
}
Pe.registerComponent("CaptionSettingsMenuItem", v0);
class x0 extends ja {
  /**
   * Creates an instance of this class.
   *
   * @param {Player} player
   *        The `Player` that this class should be attached to.
   *
   * @param {Object} [options]
   *        The key/value store of player options.
   *
   * @param {Function} [ready]
   *        The function to call when this component is ready.
   */
  constructor(e, t, i) {
    super(e, t, i), this.setIcon("captions");
  }
  /**
   * Builds the default DOM `className`.
   *
   * @return {string}
   *         The DOM `className` for this object.
   */
  buildCSSClass() {
    return `vjs-captions-button ${super.buildCSSClass()}`;
  }
  buildWrapperCSSClass() {
    return `vjs-captions-button ${super.buildWrapperCSSClass()}`;
  }
  /**
   * Create caption menu items
   *
   * @return {CaptionSettingsMenuItem[]}
   *         The array of current menu items.
   */
  createItems() {
    const e = [];
    return !(this.player().tech_ && this.player().tech_.featuresNativeTextTracks) && this.player().getChild("textTrackSettings") && (e.push(new v0(this.player_, {
      kind: this.kind_
    })), this.hideThreshold_ += 1), super.createItems(e);
  }
}
x0.prototype.kind_ = "captions";
x0.prototype.controlText_ = "Captions";
Pe.registerComponent("CaptionsButton", x0);
class ES extends yo {
  createEl(e, t, i) {
    const r = super.createEl(e, t, i), a = r.querySelector(".vjs-menu-item-text");
    return this.options_.track.kind === "captions" && (this.player_.options_.experimentalSvgIcons ? this.setIcon("captions", r) : a.appendChild(Ye("span", {
      className: "vjs-icon-placeholder"
    }, {
      "aria-hidden": !0
    })), a.appendChild(Ye("span", {
      className: "vjs-control-text",
      // space added as the text will visually flow with the
      // label
      textContent: ` ${this.localize("Captions")}`
    }))), r;
  }
}
Pe.registerComponent("SubsCapsMenuItem", ES);
class _0 extends ja {
  /**
   * Creates an instance of this class.
   *
   * @param {Player} player
   *        The `Player` that this class should be attached to.
   *
   * @param {Object} [options]
   *        The key/value store of player options.
   *
   * @param {Function} [ready]
   *        The function to call when this component is ready.
   */
  constructor(e, t = {}) {
    super(e, t), this.label_ = "subtitles", this.setIcon("subtitles"), ["en", "en-us", "en-ca", "fr-ca"].indexOf(this.player_.language_) > -1 && (this.label_ = "captions", this.setIcon("captions")), this.menuButton_.controlText(Rt(this.label_));
  }
  /**
   * Builds the default DOM `className`.
   *
   * @return {string}
   *         The DOM `className` for this object.
   */
  buildCSSClass() {
    return `vjs-subs-caps-button ${super.buildCSSClass()}`;
  }
  buildWrapperCSSClass() {
    return `vjs-subs-caps-button ${super.buildWrapperCSSClass()}`;
  }
  /**
   * Create caption/subtitles menu items
   *
   * @return {CaptionSettingsMenuItem[]}
   *         The array of current menu items.
   */
  createItems() {
    let e = [];
    return !(this.player().tech_ && this.player().tech_.featuresNativeTextTracks) && this.player().getChild("textTrackSettings") && (e.push(new v0(this.player_, {
      kind: this.label_
    })), this.hideThreshold_ += 1), e = super.createItems(e, ES), e;
  }
}
_0.prototype.kinds_ = ["captions", "subtitles"];
_0.prototype.controlText_ = "Subtitles";
Pe.registerComponent("SubsCapsButton", _0);
class DS extends bo {
  /**
   * Creates an instance of this class.
   *
   * @param {Player} player
   *        The `Player` that this class should be attached to.
   *
   * @param {Object} [options]
   *        The key/value store of player options.
   */
  constructor(e, t) {
    const i = t.track, r = e.audioTracks();
    t.label = i.label || i.language || "Unknown", t.selected = i.enabled, super(e, t), this.track = i, this.addClass(`vjs-${i.kind}-menu-item`);
    const a = (...s) => {
      this.handleTracksChange.apply(this, s);
    };
    r.addEventListener("change", a), this.on("dispose", () => {
      r.removeEventListener("change", a);
    });
  }
  createEl(e, t, i) {
    const r = super.createEl(e, t, i), a = r.querySelector(".vjs-menu-item-text");
    return ["main-desc", "descriptions"].indexOf(this.options_.track.kind) >= 0 && (a.appendChild(Ye("span", {
      className: "vjs-icon-placeholder"
    }, {
      "aria-hidden": !0
    })), a.appendChild(Ye("span", {
      className: "vjs-control-text",
      textContent: " " + this.localize("Descriptions")
    }))), r;
  }
  /**
   * This gets called when an `AudioTrackMenuItem is "clicked". See {@link ClickableComponent}
   * for more detailed information on what a click can be.
   *
   * @param {Event} [event]
   *        The `keydown`, `tap`, or `click` event that caused this function to be
   *        called.
   *
   * @listens tap
   * @listens click
   */
  handleClick(e) {
    if (super.handleClick(e), this.track.enabled = !0, this.player_.tech_.featuresNativeAudioTracks) {
      const t = this.player_.audioTracks();
      for (let i = 0; i < t.length; i++) {
        const r = t[i];
        r !== this.track && (r.enabled = r === this.track);
      }
    }
  }
  /**
   * Handle any {@link AudioTrack} change.
   *
   * @param {Event} [event]
   *        The {@link AudioTrackList#change} event that caused this to run.
   *
   * @listens AudioTrackList#change
   */
  handleTracksChange(e) {
    this.selected(this.track.enabled);
  }
}
Pe.registerComponent("AudioTrackMenuItem", DS);
class SS extends m0 {
  /**
   * Creates an instance of this class.
   *
   * @param {Player} player
   *        The `Player` that this class should be attached to.
   *
   * @param {Object} [options={}]
   *        The key/value store of player options.
   */
  constructor(e, t = {}) {
    t.tracks = e.audioTracks(), super(e, t), this.setIcon("audio");
  }
  /**
   * Builds the default DOM `className`.
   *
   * @return {string}
   *         The DOM `className` for this object.
   */
  buildCSSClass() {
    return `vjs-audio-button ${super.buildCSSClass()}`;
  }
  buildWrapperCSSClass() {
    return `vjs-audio-button ${super.buildWrapperCSSClass()}`;
  }
  /**
   * Create a menu item for each audio track
   *
   * @param {AudioTrackMenuItem[]} [items=[]]
   *        An array of existing menu items to use.
   *
   * @return {AudioTrackMenuItem[]}
   *         An array of menu items
   */
  createItems(e = []) {
    this.hideThreshold_ = 1;
    const t = this.player_.audioTracks();
    for (let i = 0; i < t.length; i++) {
      const r = t[i];
      e.push(new DS(this.player_, {
        track: r,
        // MenuItem is selectable
        selectable: !0,
        // MenuItem is NOT multiSelectable (i.e. only one can be marked "selected" at a time)
        multiSelectable: !1
      }));
    }
    return e;
  }
}
SS.prototype.controlText_ = "Audio Track";
Pe.registerComponent("AudioTrackButton", SS);
class T0 extends bo {
  /**
   * Creates an instance of this class.
   *
   * @param {Player} player
   *        The `Player` that this class should be attached to.
   *
   * @param {Object} [options]
   *        The key/value store of player options.
   */
  constructor(e, t) {
    const i = t.rate, r = parseFloat(i, 10);
    t.label = i, t.selected = r === e.playbackRate(), t.selectable = !0, t.multiSelectable = !1, super(e, t), this.label = i, this.rate = r, this.on(e, "ratechange", (a) => this.update(a));
  }
  /**
   * This gets called when an `PlaybackRateMenuItem` is "clicked". See
   * {@link ClickableComponent} for more detailed information on what a click can be.
   *
   * @param {Event} [event]
   *        The `keydown`, `tap`, or `click` event that caused this function to be
   *        called.
   *
   * @listens tap
   * @listens click
   */
  handleClick(e) {
    super.handleClick(), this.player().playbackRate(this.rate);
  }
  /**
   * Update the PlaybackRateMenuItem when the playbackrate changes.
   *
   * @param {Event} [event]
   *        The `ratechange` event that caused this function to run.
   *
   * @listens Player#ratechange
   */
  update(e) {
    this.selected(this.player().playbackRate() === this.rate);
  }
}
T0.prototype.contentElType = "button";
Pe.registerComponent("PlaybackRateMenuItem", T0);
class CS extends p0 {
  /**
   * Creates an instance of this class.
   *
   * @param {Player} player
   *        The `Player` that this class should be attached to.
   *
   * @param {Object} [options]
   *        The key/value store of player options.
   */
  constructor(e, t) {
    super(e, t), this.menuButton_.el_.setAttribute("aria-describedby", this.labelElId_), this.updateVisibility(), this.updateLabel(), this.on(e, "loadstart", (i) => this.updateVisibility(i)), this.on(e, "ratechange", (i) => this.updateLabel(i)), this.on(e, "playbackrateschange", (i) => this.handlePlaybackRateschange(i));
  }
  /**
   * Create the `Component`'s DOM element
   *
   * @return {Element}
   *         The element that was created.
   */
  createEl() {
    const e = super.createEl();
    return this.labelElId_ = "vjs-playback-rate-value-label-" + this.id_, this.labelEl_ = Ye("div", {
      className: "vjs-playback-rate-value",
      id: this.labelElId_,
      textContent: "1x"
    }), e.appendChild(this.labelEl_), e;
  }
  dispose() {
    this.labelEl_ = null, super.dispose();
  }
  /**
   * Builds the default DOM `className`.
   *
   * @return {string}
   *         The DOM `className` for this object.
   */
  buildCSSClass() {
    return `vjs-playback-rate ${super.buildCSSClass()}`;
  }
  buildWrapperCSSClass() {
    return `vjs-playback-rate ${super.buildWrapperCSSClass()}`;
  }
  /**
   * Create the list of menu items. Specific to each subclass.
   *
   */
  createItems() {
    const e = this.playbackRates(), t = [];
    for (let i = e.length - 1; i >= 0; i--)
      t.push(new T0(this.player(), {
        rate: e[i] + "x"
      }));
    return t;
  }
  /**
   * On playbackrateschange, update the menu to account for the new items.
   *
   * @listens Player#playbackrateschange
   */
  handlePlaybackRateschange(e) {
    this.update();
  }
  /**
   * Get possible playback rates
   *
   * @return {Array}
   *         All possible playback rates
   */
  playbackRates() {
    const e = this.player();
    return e.playbackRates && e.playbackRates() || [];
  }
  /**
   * Get whether playback rates is supported by the tech
   * and an array of playback rates exists
   *
   * @return {boolean}
   *         Whether changing playback rate is supported
   */
  playbackRateSupported() {
    return this.player().tech_ && this.player().tech_.featuresPlaybackRate && this.playbackRates() && this.playbackRates().length > 0;
  }
  /**
   * Hide playback rate controls when they're no playback rate options to select
   *
   * @param {Event} [event]
   *        The event that caused this function to run.
   *
   * @listens Player#loadstart
   */
  updateVisibility(e) {
    this.playbackRateSupported() ? this.removeClass("vjs-hidden") : this.addClass("vjs-hidden");
  }
  /**
   * Update button label when rate changed
   *
   * @param {Event} [event]
   *        The event that caused this function to run.
   *
   * @listens Player#ratechange
   */
  updateLabel(e) {
    this.playbackRateSupported() && (this.labelEl_.textContent = this.player().playbackRate() + "x");
  }
}
CS.prototype.controlText_ = "Playback Rate";
Pe.registerComponent("PlaybackRateMenuButton", CS);
class AS extends Pe {
  /**
  * Builds the default DOM `className`.
  *
  * @return {string}
  *         The DOM `className` for this object.
  */
  buildCSSClass() {
    return `vjs-spacer ${super.buildCSSClass()}`;
  }
  /**
   * Create the `Component`'s DOM element
   *
   * @return {Element}
   *         The element that was created.
   */
  createEl(e = "div", t = {}, i = {}) {
    return t.className || (t.className = this.buildCSSClass()), super.createEl(e, t, i);
  }
}
Pe.registerComponent("Spacer", AS);
class jO extends AS {
  /**
   * Builds the default DOM `className`.
   *
   * @return {string}
   *         The DOM `className` for this object.
   */
  buildCSSClass() {
    return `vjs-custom-control-spacer ${super.buildCSSClass()}`;
  }
  /**
   * Create the `Component`'s DOM element
   *
   * @return {Element}
   *         The element that was created.
   */
  createEl() {
    return super.createEl("div", {
      className: this.buildCSSClass(),
      // No-flex/table-cell mode requires there be some content
      // in the cell to fill the remaining space of the table.
      textContent: ""
    });
  }
}
Pe.registerComponent("CustomControlSpacer", jO);
class kS extends Pe {
  /**
   * Create the `Component`'s DOM element
   *
   * @return {Element}
   *         The element that was created.
   */
  createEl() {
    return super.createEl("div", {
      className: "vjs-control-bar",
      dir: "ltr"
    });
  }
}
kS.prototype.options_ = {
  children: ["playToggle", "skipBackward", "skipForward", "volumePanel", "currentTimeDisplay", "timeDivider", "durationDisplay", "progressControl", "liveDisplay", "seekToLive", "remainingTimeDisplay", "customControlSpacer", "playbackRateMenuButton", "chaptersButton", "descriptionsButton", "subsCapsButton", "audioTrackButton", "pictureInPictureToggle", "fullscreenToggle"]
};
Pe.registerComponent("ControlBar", kS);
class IS extends Ma {
  /**
   * Creates an instance of this class.
   *
   * @param  {Player} player
   *         The `Player` that this class should be attached to.
   *
   * @param  {Object} [options]
   *         The key/value store of player options.
   */
  constructor(e, t) {
    super(e, t), this.on(e, "error", (i) => {
      this.open(i);
    });
  }
  /**
   * Builds the default DOM `className`.
   *
   * @return {string}
   *         The DOM `className` for this object.
   *
   * @deprecated Since version 5.
   */
  buildCSSClass() {
    return `vjs-error-display ${super.buildCSSClass()}`;
  }
  /**
   * Gets the localized error message based on the `Player`s error.
   *
   * @return {string}
   *         The `Player`s error message localized or an empty string.
   */
  content() {
    const e = this.player().error();
    return e ? this.localize(e.message) : "";
  }
}
IS.prototype.options_ = Object.assign({}, Ma.prototype.options_, {
  pauseOnOpen: !1,
  fillAlways: !0,
  temporary: !1,
  uncloseable: !0
});
Pe.registerComponent("ErrorDisplay", IS);
class US extends Pe {
  /**
   * Creates an instance of this class.
   *
   * @param {Player} player
   *        The `Player` that this class should be attached to.
   *
   * @param {Object} [options]
   *        The key/value store of player options.
   *
   * @param {ContentDescriptor} [options.content=undefined]
   *        Provide customized content for this modal.
   *
   * @param {string} [options.legendId]
   *        A text with part of an string to create atribute of aria-labelledby.
   *
   * @param {string} [options.id]
   *        A text with part of an string to create atribute of aria-labelledby.
   *
   * @param {Array} [options.SelectOptions]
   *        Array that contains the value & textContent of for each of the
   *        options elements.
   */
  constructor(e, t = {}) {
    super(e, t), this.el_.setAttribute("aria-labelledby", this.selectLabelledbyIds);
  }
  /**
   * Create the `TextTrackSelect`'s DOM element
   *
   * @return {Element}
   *         The DOM element that gets created.
   */
  createEl() {
    return this.selectLabelledbyIds = [this.options_.legendId, this.options_.labelId].join(" ").trim(), Ye("select", {
      id: this.options_.id
    }, {}, this.options_.SelectOptions.map((t) => {
      const i = (this.options_.labelId ? this.options_.labelId : `vjs-track-option-${Mn()}`) + "-" + t[1].replace(/\W+/g, ""), r = Ye("option", {
        id: i,
        value: this.localize(t[0]),
        textContent: this.localize(t[1])
      });
      return r.setAttribute("aria-labelledby", `${this.selectLabelledbyIds} ${i}`), r;
    }));
  }
}
Pe.registerComponent("TextTrackSelect", US);
class Lr extends Pe {
  /**
   * Creates an instance of this class.
   *
   * @param {Player} player
   *        The `Player` that this class should be attached to.
   *
   * @param {Object} [options]
   *        The key/value store of player options.
   *
   * @param {ContentDescriptor} [options.content=undefined]
   *        Provide customized content for this modal.
   *
   * @param {string} [options.legendId]
   *        A text with part of an string to create atribute of aria-labelledby.
   *        It passes to 'TextTrackSelect'.
   *
   * @param {string} [options.id]
   *        A text with part of an string to create atribute of aria-labelledby.
   *        It passes to 'TextTrackSelect'.
   *
   * @param {string} [options.legendText]
   *        A text to use as the text content of the legend element.
   *
   * @param {Array} [options.selects]
   *        Array that contains the selects that are use to create 'selects'
   *        components.
   *
   * @param {Array} [options.SelectOptions]
   *        Array that contains the value & textContent of for each of the
   *        options elements, it passes to 'TextTrackSelect'.
   *
   * @param {string} [options.type]
   *        Conditions if some DOM elements will be added to the fieldset
   *        component.
   *
   * @param {Object} [options.selectConfigs]
   *        Object with the following properties that are the selects configurations:
   *        backgroundColor, backgroundOpacity, color, edgeStyle, fontFamily,
   *        fontPercent, textOpacity, windowColor, windowOpacity.
   *        These properties are use to configure the 'TextTrackSelect' Component.
   */
  constructor(e, t = {}) {
    super(e, t);
    const i = Ye("legend", {
      textContent: this.localize(this.options_.legendText),
      id: this.options_.legendId
    });
    this.el().appendChild(i);
    const r = this.options_.selects;
    for (const a of r) {
      const s = this.options_.selectConfigs[a], o = s.className, u = s.id.replace("%s", this.options_.id_);
      let c = null;
      const l = `vjs_select_${Mn()}`;
      if (this.options_.type === "colors") {
        c = Ye("span", {
          className: o
        });
        const f = Ye("label", {
          id: u,
          className: "vjs-label",
          textContent: this.localize(s.label)
        });
        f.setAttribute("for", l), c.appendChild(f);
      }
      const h = new US(e, {
        SelectOptions: s.options,
        legendId: this.options_.legendId,
        id: l,
        labelId: u
      });
      this.addChild(h), this.options_.type === "colors" && (c.appendChild(h.el()), this.el().appendChild(c));
    }
  }
  /**
   * Create the `TextTrackFieldset`'s DOM element
   *
   * @return {Element}
   *         The DOM element that gets created.
   */
  createEl() {
    return Ye("fieldset", {
      // Prefixing classes of elements within a player with "vjs-"
      // is a convention used in Video.js.
      className: this.options_.className
    });
  }
}
Pe.registerComponent("TextTrackFieldset", Lr);
class RS extends Pe {
  /**
   * Creates an instance of this class.
   *
   * @param {Player} player
   *        The `Player` that this class should be attached to.
   *
   * @param {Object} [options]
   *        The key/value store of player options.
   *
   * @param {ContentDescriptor} [options.content=undefined]
   *        Provide customized content for this modal.
   *
   * @param {Array} [options.fieldSets]
   *        Array that contains the configurations for the selects.
   *
   * @param {Object} [options.selectConfigs]
   *        Object with the following properties that are the select confugations:
   *        backgroundColor, backgroundOpacity, color, edgeStyle, fontFamily,
   *        fontPercent, textOpacity, windowColor, windowOpacity.
   *        it passes to 'TextTrackFieldset'.
   */
  constructor(e, t = {}) {
    super(e, t);
    const i = this.options_.textTrackComponentid, r = new Lr(e, {
      id_: i,
      legendId: `captions-text-legend-${i}`,
      legendText: this.localize("Text"),
      className: "vjs-fg vjs-track-setting",
      selects: this.options_.fieldSets[0],
      selectConfigs: this.options_.selectConfigs,
      type: "colors"
    });
    this.addChild(r);
    const a = new Lr(e, {
      id_: i,
      legendId: `captions-background-${i}`,
      legendText: this.localize("Text Background"),
      className: "vjs-bg vjs-track-setting",
      selects: this.options_.fieldSets[1],
      selectConfigs: this.options_.selectConfigs,
      type: "colors"
    });
    this.addChild(a);
    const s = new Lr(e, {
      id_: i,
      legendId: `captions-window-${i}`,
      legendText: this.localize("Caption Area Background"),
      className: "vjs-window vjs-track-setting",
      selects: this.options_.fieldSets[2],
      selectConfigs: this.options_.selectConfigs,
      type: "colors"
    });
    this.addChild(s);
  }
  /**
   * Create the `TextTrackSettingsColors`'s DOM element
   *
   * @return {Element}
   *         The DOM element that gets created.
   */
  createEl() {
    return Ye("div", {
      className: "vjs-track-settings-colors"
    });
  }
}
Pe.registerComponent("TextTrackSettingsColors", RS);
class OS extends Pe {
  /**
   * Creates an instance of this class.
   *
   * @param {Player} player
   *        The `Player` that this class should be attached to.
   *
   * @param {Object} [options]
   *        The key/value store of player options.
   *
   * @param {ContentDescriptor} [options.content=undefined]
   *        Provide customized content for this modal.
   *
   * @param {Array} [options.fieldSets]
   *        Array that contains the configurations for the selects.
   *
   * @param {Object} [options.selectConfigs]
   *        Object with the following properties that are the select confugations:
   *        backgroundColor, backgroundOpacity, color, edgeStyle, fontFamily,
   *        fontPercent, textOpacity, windowColor, windowOpacity.
   *        it passes to 'TextTrackFieldset'.
   */
  constructor(e, t = {}) {
    super(e, t);
    const i = this.options_.textTrackComponentid, r = new Lr(e, {
      id_: i,
      legendId: `captions-font-size-${i}`,
      legendText: "Font Size",
      className: "vjs-font-percent vjs-track-setting",
      selects: this.options_.fieldSets[0],
      selectConfigs: this.options_.selectConfigs,
      type: "font"
    });
    this.addChild(r);
    const a = new Lr(e, {
      id_: i,
      legendId: `captions-edge-style-${i}`,
      legendText: this.localize("Text Edge Style"),
      className: "vjs-edge-style vjs-track-setting",
      selects: this.options_.fieldSets[1],
      selectConfigs: this.options_.selectConfigs,
      type: "font"
    });
    this.addChild(a);
    const s = new Lr(e, {
      id_: i,
      legendId: `captions-font-family-${i}`,
      legendText: this.localize("Font Family"),
      className: "vjs-font-family vjs-track-setting",
      selects: this.options_.fieldSets[2],
      selectConfigs: this.options_.selectConfigs,
      type: "font"
    });
    this.addChild(s);
  }
  /**
   * Create the `TextTrackSettingsFont`'s DOM element
   *
   * @return {Element}
   *         The DOM element that gets created.
   */
  createEl() {
    return Ye("div", {
      className: "vjs-track-settings-font"
    });
  }
}
Pe.registerComponent("TextTrackSettingsFont", OS);
class LS extends Pe {
  constructor(e, t = {}) {
    super(e, t);
    const i = new Kt(e, {
      controlText: this.localize("restore all settings to the default values"),
      className: "vjs-default-button"
    });
    i.el().classList.remove("vjs-control", "vjs-button"), i.el().textContent = this.localize("Reset"), this.addChild(i);
    const r = this.localize("Done"), a = new Kt(e, {
      controlText: r,
      className: "vjs-done-button"
    });
    a.el().classList.remove("vjs-control", "vjs-button"), a.el().textContent = r, this.addChild(a);
  }
  /**
   * Create the `TrackSettingsControls`'s DOM element
   *
   * @return {Element}
   *         The DOM element that gets created.
   */
  createEl() {
    return Ye("div", {
      className: "vjs-track-settings-controls"
    });
  }
}
Pe.registerComponent("TrackSettingsControls", LS);
const Rp = "vjs-text-track-settings", I_ = ["#000", "Black"], U_ = ["#00F", "Blue"], R_ = ["#0FF", "Cyan"], O_ = ["#0F0", "Green"], L_ = ["#F0F", "Magenta"], P_ = ["#F00", "Red"], F_ = ["#FFF", "White"], N_ = ["#FF0", "Yellow"], Op = ["1", "Opaque"], Lp = ["0.5", "Semi-Transparent"], M_ = ["0", "Transparent"], Yi = {
  backgroundColor: {
    selector: ".vjs-bg-color > select",
    id: "captions-background-color-%s",
    label: "Color",
    options: [I_, F_, P_, O_, U_, N_, L_, R_],
    className: "vjs-bg-color"
  },
  backgroundOpacity: {
    selector: ".vjs-bg-opacity > select",
    id: "captions-background-opacity-%s",
    label: "Opacity",
    options: [Op, Lp, M_],
    className: "vjs-bg-opacity vjs-opacity"
  },
  color: {
    selector: ".vjs-text-color > select",
    id: "captions-foreground-color-%s",
    label: "Color",
    options: [F_, I_, P_, O_, U_, N_, L_, R_],
    className: "vjs-text-color"
  },
  edgeStyle: {
    selector: ".vjs-edge-style > select",
    id: "",
    label: "Text Edge Style",
    options: [["none", "None"], ["raised", "Raised"], ["depressed", "Depressed"], ["uniform", "Uniform"], ["dropshadow", "Drop shadow"]]
  },
  fontFamily: {
    selector: ".vjs-font-family > select",
    id: "",
    label: "Font Family",
    options: [["proportionalSansSerif", "Proportional Sans-Serif"], ["monospaceSansSerif", "Monospace Sans-Serif"], ["proportionalSerif", "Proportional Serif"], ["monospaceSerif", "Monospace Serif"], ["casual", "Casual"], ["script", "Script"], ["small-caps", "Small Caps"]]
  },
  fontPercent: {
    selector: ".vjs-font-percent > select",
    id: "",
    label: "Font Size",
    options: [["0.50", "50%"], ["0.75", "75%"], ["1.00", "100%"], ["1.25", "125%"], ["1.50", "150%"], ["1.75", "175%"], ["2.00", "200%"], ["3.00", "300%"], ["4.00", "400%"]],
    default: 2,
    parser: (n) => n === "1.00" ? null : Number(n)
  },
  textOpacity: {
    selector: ".vjs-text-opacity > select",
    id: "captions-foreground-opacity-%s",
    label: "Opacity",
    options: [Op, Lp],
    className: "vjs-text-opacity vjs-opacity"
  },
  // Options for this object are defined below.
  windowColor: {
    selector: ".vjs-window-color > select",
    id: "captions-window-color-%s",
    label: "Color",
    className: "vjs-window-color"
  },
  // Options for this object are defined below.
  windowOpacity: {
    selector: ".vjs-window-opacity > select",
    id: "captions-window-opacity-%s",
    label: "Opacity",
    options: [M_, Lp, Op],
    className: "vjs-window-opacity vjs-opacity"
  }
};
Yi.windowColor.options = Yi.backgroundColor.options;
function PS(n, e) {
  if (e && (n = e(n)), n && n !== "none")
    return n;
}
function qO(n, e) {
  const t = n.options[n.options.selectedIndex].value;
  return PS(t, e);
}
function WO(n, e, t) {
  if (e) {
    for (let i = 0; i < n.options.length; i++)
      if (PS(n.options[i].value, t) === e) {
        n.selectedIndex = i;
        break;
      }
  }
}
class VO extends Ma {
  /**
   * Creates an instance of this class.
   *
   * @param {Player} player
   *         The `Player` that this class should be attached to.
   *
   * @param {Object} [options]
   *         The key/value store of player options.
   */
  constructor(e, t) {
    t.temporary = !1, super(e, t), this.updateDisplay = this.updateDisplay.bind(this), this.fill(), this.hasBeenOpened_ = this.hasBeenFilled_ = !0, this.renderModalComponents(e), this.endDialog = Ye("p", {
      className: "vjs-control-text",
      textContent: this.localize("End of dialog window.")
    }), this.el().appendChild(this.endDialog), this.setDefaults(), t.persistTextTrackSettings === void 0 && (this.options_.persistTextTrackSettings = this.options_.playerOptions.persistTextTrackSettings), this.bindFunctionsToSelectsAndButtons(), this.options_.persistTextTrackSettings && this.restoreSettings();
  }
  renderModalComponents(e) {
    const t = new RS(e, {
      textTrackComponentid: this.id_,
      selectConfigs: Yi,
      fieldSets: [["color", "textOpacity"], ["backgroundColor", "backgroundOpacity"], ["windowColor", "windowOpacity"]]
    });
    this.addChild(t);
    const i = new OS(e, {
      textTrackComponentid: this.id_,
      selectConfigs: Yi,
      fieldSets: [["fontPercent"], ["edgeStyle"], ["fontFamily"]]
    });
    this.addChild(i);
    const r = new LS(e);
    this.addChild(r);
  }
  bindFunctionsToSelectsAndButtons() {
    this.on(this.$(".vjs-done-button"), ["click", "tap"], () => {
      this.saveSettings(), this.close();
    }), this.on(this.$(".vjs-default-button"), ["click", "tap"], () => {
      this.setDefaults(), this.updateDisplay();
    }), ua(Yi, (e) => {
      this.on(this.$(e.selector), "change", this.updateDisplay);
    });
  }
  dispose() {
    this.endDialog = null, super.dispose();
  }
  label() {
    return this.localize("Caption Settings Dialog");
  }
  description() {
    return this.localize("Beginning of dialog window. Escape will cancel and close the window.");
  }
  buildCSSClass() {
    return super.buildCSSClass() + " vjs-text-track-settings";
  }
  /**
   * Gets an object of text track settings (or null).
   *
   * @return {Object}
   *         An object with config values parsed from the DOM or localStorage.
   */
  getValues() {
    return TD(Yi, (e, t, i) => {
      const r = qO(this.$(t.selector), t.parser);
      return r !== void 0 && (e[i] = r), e;
    }, {});
  }
  /**
   * Sets text track settings from an object of values.
   *
   * @param {Object} values
   *        An object with config values parsed from the DOM or localStorage.
   */
  setValues(e) {
    ua(Yi, (t, i) => {
      WO(this.$(t.selector), e[i], t.parser);
    });
  }
  /**
   * Sets all `<select>` elements to their default values.
   */
  setDefaults() {
    ua(Yi, (e) => {
      const t = e.hasOwnProperty("default") ? e.default : 0;
      this.$(e.selector).selectedIndex = t;
    });
  }
  /**
   * Restore texttrack settings from localStorage
   */
  restoreSettings() {
    let e;
    try {
      e = JSON.parse(me.localStorage.getItem(Rp));
    } catch (t) {
      at.warn(t);
    }
    e && this.setValues(e);
  }
  /**
   * Save text track settings to localStorage
   */
  saveSettings() {
    if (!this.options_.persistTextTrackSettings)
      return;
    const e = this.getValues();
    try {
      Object.keys(e).length ? me.localStorage.setItem(Rp, JSON.stringify(e)) : me.localStorage.removeItem(Rp);
    } catch (t) {
      at.warn(t);
    }
  }
  /**
   * Update display of text track settings
   */
  updateDisplay() {
    const e = this.player_.getChild("textTrackDisplay");
    e && e.updateDisplay();
  }
  /**
   * Repopulate dialog with new localizations on languagechange
   */
  handleLanguagechange() {
    this.fill(), this.renderModalComponents(this.player_), this.bindFunctionsToSelectsAndButtons();
  }
}
Pe.registerComponent("TextTrackSettings", VO);
class HO extends Pe {
  /**
   * Create the ResizeManager.
   *
   * @param {Object} player
   *        The `Player` that this class should be attached to.
   *
   * @param {Object} [options]
   *        The key/value store of ResizeManager options.
   *
   * @param {Object} [options.ResizeObserver]
   *        A polyfill for ResizeObserver can be passed in here.
   *        If this is set to null it will ignore the native ResizeObserver and fall back to the iframe fallback.
   */
  constructor(e, t) {
    let i = t.ResizeObserver || me.ResizeObserver;
    t.ResizeObserver === null && (i = !1);
    const r = yt({
      createEl: !i,
      reportTouchActivity: !1
    }, t);
    super(e, r), this.ResizeObserver = t.ResizeObserver || me.ResizeObserver, this.loadListener_ = null, this.resizeObserver_ = null, this.debouncedHandler_ = zD(() => {
      this.resizeHandler();
    }, 100, !1, this), i ? (this.resizeObserver_ = new this.ResizeObserver(this.debouncedHandler_), this.resizeObserver_.observe(e.el())) : (this.loadListener_ = () => {
      if (!this.el_ || !this.el_.contentWindow)
        return;
      const a = this.debouncedHandler_;
      let s = this.unloadListener_ = function() {
        Xt(this, "resize", a), Xt(this, "unload", s), s = null;
      };
      En(this.el_.contentWindow, "unload", s), En(this.el_.contentWindow, "resize", a);
    }, this.one("load", this.loadListener_));
  }
  createEl() {
    return super.createEl("iframe", {
      className: "vjs-resize-manager",
      tabIndex: -1,
      title: this.localize("No content")
    }, {
      "aria-hidden": "true"
    });
  }
  /**
   * Called when a resize is triggered on the iframe or a resize is observed via the ResizeObserver
   *
   * @fires Player#playerresize
   */
  resizeHandler() {
    !this.player_ || !this.player_.trigger || this.player_.trigger("playerresize");
  }
  dispose() {
    this.debouncedHandler_ && this.debouncedHandler_.cancel(), this.resizeObserver_ && (this.player_.el() && this.resizeObserver_.unobserve(this.player_.el()), this.resizeObserver_.disconnect()), this.loadListener_ && this.off("load", this.loadListener_), this.el_ && this.el_.contentWindow && this.unloadListener_ && this.unloadListener_.call(this.el_.contentWindow), this.ResizeObserver = null, this.resizeObserver = null, this.debouncedHandler_ = null, this.loadListener_ = null, super.dispose();
  }
}
Pe.registerComponent("ResizeManager", HO);
const zO = {
  trackingThreshold: 20,
  liveTolerance: 15
};
class $O extends Pe {
  /**
   * Creates an instance of this class.
   *
   * @param {Player} player
   *        The `Player` that this class should be attached to.
   *
   * @param {Object} [options]
   *        The key/value store of player options.
   *
   * @param {number} [options.trackingThreshold=20]
   *        Number of seconds of live window (seekableEnd - seekableStart) that
   *        media needs to have before the liveui will be shown.
   *
   * @param {number} [options.liveTolerance=15]
   *        Number of seconds behind live that we have to be
   *        before we will be considered non-live. Note that this will only
   *        be used when playing at the live edge. This allows large seekable end
   *        changes to not effect whether we are live or not.
   */
  constructor(e, t) {
    const i = yt(zO, t, {
      createEl: !1
    });
    super(e, i), this.trackLiveHandler_ = () => this.trackLive_(), this.handlePlay_ = (r) => this.handlePlay(r), this.handleFirstTimeupdate_ = (r) => this.handleFirstTimeupdate(r), this.handleSeeked_ = (r) => this.handleSeeked(r), this.seekToLiveEdge_ = (r) => this.seekToLiveEdge(r), this.reset_(), this.on(this.player_, "durationchange", (r) => this.handleDurationchange(r)), this.on(this.player_, "canplay", () => this.toggleTracking());
  }
  /**
   * all the functionality for tracking when seek end changes
   * and for tracking how far past seek end we should be
   */
  trackLive_() {
    const e = this.player_.seekable();
    if (!e || !e.length)
      return;
    const t = Number(me.performance.now().toFixed(4)), i = this.lastTime_ === -1 ? 0 : (t - this.lastTime_) / 1e3;
    this.lastTime_ = t, this.pastSeekEnd_ = this.pastSeekEnd() + i;
    const r = this.liveCurrentTime(), a = this.player_.currentTime();
    let s = this.player_.paused() || this.seekedBehindLive_ || Math.abs(r - a) > this.options_.liveTolerance;
    (!this.timeupdateSeen_ || r === 1 / 0) && (s = !1), s !== this.behindLiveEdge_ && (this.behindLiveEdge_ = s, this.trigger("liveedgechange"));
  }
  /**
   * handle a durationchange event on the player
   * and start/stop tracking accordingly.
   */
  handleDurationchange() {
    this.toggleTracking();
  }
  /**
   * start/stop tracking
   */
  toggleTracking() {
    this.player_.duration() === 1 / 0 && this.liveWindow() >= this.options_.trackingThreshold ? (this.player_.options_.liveui && this.player_.addClass("vjs-liveui"), this.startTracking()) : (this.player_.removeClass("vjs-liveui"), this.stopTracking());
  }
  /**
   * start tracking live playback
   */
  startTracking() {
    this.isTracking() || (this.timeupdateSeen_ || (this.timeupdateSeen_ = this.player_.hasStarted()), this.trackingInterval_ = this.setInterval(this.trackLiveHandler_, Bn), this.trackLive_(), this.on(this.player_, ["play", "pause"], this.trackLiveHandler_), this.timeupdateSeen_ ? this.on(this.player_, "seeked", this.handleSeeked_) : (this.one(this.player_, "play", this.handlePlay_), this.one(this.player_, "timeupdate", this.handleFirstTimeupdate_)));
  }
  /**
   * handle the first timeupdate on the player if it wasn't already playing
   * when live tracker started tracking.
   */
  handleFirstTimeupdate() {
    this.timeupdateSeen_ = !0, this.on(this.player_, "seeked", this.handleSeeked_);
  }
  /**
   * Keep track of what time a seek starts, and listen for seeked
   * to find where a seek ends.
   */
  handleSeeked() {
    const e = Math.abs(this.liveCurrentTime() - this.player_.currentTime());
    this.seekedBehindLive_ = this.nextSeekedFromUser_ && e > 2, this.nextSeekedFromUser_ = !1, this.trackLive_();
  }
  /**
   * handle the first play on the player, and make sure that we seek
   * right to the live edge.
   */
  handlePlay() {
    this.one(this.player_, "timeupdate", this.seekToLiveEdge_);
  }
  /**
   * Stop tracking, and set all internal variables to
   * their initial value.
   */
  reset_() {
    this.lastTime_ = -1, this.pastSeekEnd_ = 0, this.lastSeekEnd_ = -1, this.behindLiveEdge_ = !0, this.timeupdateSeen_ = !1, this.seekedBehindLive_ = !1, this.nextSeekedFromUser_ = !1, this.clearInterval(this.trackingInterval_), this.trackingInterval_ = null, this.off(this.player_, ["play", "pause"], this.trackLiveHandler_), this.off(this.player_, "seeked", this.handleSeeked_), this.off(this.player_, "play", this.handlePlay_), this.off(this.player_, "timeupdate", this.handleFirstTimeupdate_), this.off(this.player_, "timeupdate", this.seekToLiveEdge_);
  }
  /**
   * The next seeked event is from the user. Meaning that any seek
   * > 2s behind live will be considered behind live for real and
   * liveTolerance will be ignored.
   */
  nextSeekedFromUser() {
    this.nextSeekedFromUser_ = !0;
  }
  /**
   * stop tracking live playback
   */
  stopTracking() {
    this.isTracking() && (this.reset_(), this.trigger("liveedgechange"));
  }
  /**
   * A helper to get the player seekable end
   * so that we don't have to null check everywhere
   *
   * @return {number}
   *         The furthest seekable end or Infinity.
   */
  seekableEnd() {
    const e = this.player_.seekable(), t = [];
    let i = e ? e.length : 0;
    for (; i--; )
      t.push(e.end(i));
    return t.length ? t.sort()[t.length - 1] : 1 / 0;
  }
  /**
   * A helper to get the player seekable start
   * so that we don't have to null check everywhere
   *
   * @return {number}
   *         The earliest seekable start or 0.
   */
  seekableStart() {
    const e = this.player_.seekable(), t = [];
    let i = e ? e.length : 0;
    for (; i--; )
      t.push(e.start(i));
    return t.length ? t.sort()[0] : 0;
  }
  /**
   * Get the live time window aka
   * the amount of time between seekable start and
   * live current time.
   *
   * @return {number}
   *         The amount of seconds that are seekable in
   *         the live video.
   */
  liveWindow() {
    const e = this.liveCurrentTime();
    return e === 1 / 0 ? 0 : e - this.seekableStart();
  }
  /**
   * Determines if the player is live, only checks if this component
   * is tracking live playback or not
   *
   * @return {boolean}
   *         Whether liveTracker is tracking
   */
  isLive() {
    return this.isTracking();
  }
  /**
   * Determines if currentTime is at the live edge and won't fall behind
   * on each seekableendchange
   *
   * @return {boolean}
   *         Whether playback is at the live edge
   */
  atLiveEdge() {
    return !this.behindLiveEdge();
  }
  /**
   * get what we expect the live current time to be
   *
   * @return {number}
   *         The expected live current time
   */
  liveCurrentTime() {
    return this.pastSeekEnd() + this.seekableEnd();
  }
  /**
   * The number of seconds that have occurred after seekable end
   * changed. This will be reset to 0 once seekable end changes.
   *
   * @return {number}
   *         Seconds past the current seekable end
   */
  pastSeekEnd() {
    const e = this.seekableEnd();
    return this.lastSeekEnd_ !== -1 && e !== this.lastSeekEnd_ && (this.pastSeekEnd_ = 0), this.lastSeekEnd_ = e, this.pastSeekEnd_;
  }
  /**
   * If we are currently behind the live edge, aka currentTime will be
   * behind on a seekableendchange
   *
   * @return {boolean}
   *         If we are behind the live edge
   */
  behindLiveEdge() {
    return this.behindLiveEdge_;
  }
  /**
   * Whether live tracker is currently tracking or not.
   */
  isTracking() {
    return typeof this.trackingInterval_ == "number";
  }
  /**
   * Seek to the live edge if we are behind the live edge
   */
  seekToLiveEdge() {
    this.seekedBehindLive_ = !1, !this.atLiveEdge() && (this.nextSeekedFromUser_ = !1, this.player_.currentTime(this.liveCurrentTime()));
  }
  /**
   * Dispose of liveTracker
   */
  dispose() {
    this.stopTracking(), super.dispose();
  }
}
Pe.registerComponent("LiveTracker", $O);
class GO extends Pe {
  constructor(e, t) {
    super(e, t), this.on("statechanged", (i) => this.updateDom_()), this.updateDom_();
  }
  /**
   * Create the `TitleBar`'s DOM element
   *
   * @return {Element}
   *         The element that was created.
   */
  createEl() {
    return this.els = {
      title: Ye("div", {
        className: "vjs-title-bar-title",
        id: `vjs-title-bar-title-${Mn()}`
      }),
      description: Ye("div", {
        className: "vjs-title-bar-description",
        id: `vjs-title-bar-description-${Mn()}`
      })
    }, Ye("div", {
      className: "vjs-title-bar"
    }, {}, wD(this.els));
  }
  /**
   * Updates the DOM based on the component's state object.
   */
  updateDom_() {
    const e = this.player_.tech_, t = e && e.el_, i = {
      title: "aria-labelledby",
      description: "aria-describedby"
    };
    ["title", "description"].forEach((r) => {
      const a = this.state[r], s = this.els[r], o = i[r];
      _l(s), a && lr(s, a), t && (t.removeAttribute(o), a && t.setAttribute(o, s.id));
    }), this.state.title || this.state.description ? this.show() : this.hide();
  }
  /**
   * Update the contents of the title bar component with new title and
   * description text.
   *
   * If both title and description are missing, the title bar will be hidden.
   *
   * If either title or description are present, the title bar will be visible.
   *
   * NOTE: Any previously set value will be preserved. To unset a previously
   * set value, you must pass an empty string or null.
   *
   * For example:
   *
   * ```
   * update({title: 'foo', description: 'bar'}) // title: 'foo', description: 'bar'
   * update({description: 'bar2'}) // title: 'foo', description: 'bar2'
   * update({title: ''}) // title: '', description: 'bar2'
   * update({title: 'foo', description: null}) // title: 'foo', description: null
   * ```
   *
   * @param  {Object} [options={}]
   *         An options object. When empty, the title bar will be hidden.
   *
   * @param  {string} [options.title]
   *         A title to display in the title bar.
   *
   * @param  {string} [options.description]
   *         A description to display in the title bar.
   */
  update(e) {
    this.setState(e);
  }
  /**
   * Dispose the component.
   */
  dispose() {
    const e = this.player_.tech_, t = e && e.el_;
    t && (t.removeAttribute("aria-labelledby"), t.removeAttribute("aria-describedby")), super.dispose(), this.els = null;
  }
}
Pe.registerComponent("TitleBar", GO);
const XO = {
  initialDisplay: 4e3,
  position: [],
  takeFocus: !1
};
class KO extends Kt {
  /**
   * TransientButton constructor
   *
   * @param {Player} player The button's player
   * @param {TransientButtonOptions} options Options for the transient button
   */
  constructor(e, t) {
    t = yt(XO, t), super(e, t), this.controlText(t.controlText), this.hide(), this.on(this.player_, ["useractive", "userinactive"], (i) => {
      this.removeClass("force-display");
    });
  }
  /**
   * Return CSS class including position classes
   *
   * @return {string} CSS class list
   */
  buildCSSClass() {
    return `vjs-transient-button focus-visible ${this.options_.position.map((e) => `vjs-${e}`).join(" ")}`;
  }
  /**
   * Create the button element
   *
   * @return {HTMLButtonElement} The button element
   */
  createEl() {
    const e = Ye("button", {}, {
      type: "button",
      class: this.buildCSSClass()
    }, Ye("span"));
    return this.controlTextEl_ = e.querySelector("span"), e;
  }
  /**
   * Show the button. The button will remain visible for the `initialDisplay` time, default 4s,
   * and when there is user activity.
   */
  show() {
    super.show(), this.addClass("force-display"), this.options_.takeFocus && this.el().focus({
      preventScroll: !0
    }), this.forceDisplayTimeout = this.player_.setTimeout(() => {
      this.removeClass("force-display");
    }, this.options_.initialDisplay);
  }
  /**
   * Hide the display, even if during the `initialDisplay` time.
   */
  hide() {
    this.removeClass("force-display"), super.hide();
  }
  /**
   * Dispose the component
   */
  dispose() {
    this.player_.clearTimeout(this.forceDisplayTimeout), super.dispose();
  }
}
Pe.registerComponent("TransientButton", KO);
const _m = (n) => {
  const e = n.el();
  if (e.hasAttribute("src"))
    return n.triggerSourceset(e.src), !0;
  const t = n.$$("source"), i = [];
  let r = "";
  if (!t.length)
    return !1;
  for (let a = 0; a < t.length; a++) {
    const s = t[a].src;
    s && i.indexOf(s) === -1 && i.push(s);
  }
  return i.length ? (i.length === 1 && (r = i[0]), n.triggerSourceset(r), !0) : !1;
}, YO = Object.defineProperty({}, "innerHTML", {
  get() {
    return this.cloneNode(!0).innerHTML;
  },
  set(n) {
    const e = Be.createElement(this.nodeName.toLowerCase());
    e.innerHTML = n;
    const t = Be.createDocumentFragment();
    for (; e.childNodes.length; )
      t.appendChild(e.childNodes[0]);
    return this.innerText = "", me.Element.prototype.appendChild.call(this, t), this.innerHTML;
  }
}), FS = (n, e) => {
  let t = {};
  for (let i = 0; i < n.length && (t = Object.getOwnPropertyDescriptor(n[i], e), !(t && t.set && t.get)); i++)
    ;
  return t.enumerable = !0, t.configurable = !0, t;
}, QO = (n) => FS([n.el(), me.HTMLMediaElement.prototype, me.Element.prototype, YO], "innerHTML"), B_ = function(n) {
  const e = n.el();
  if (e.resetSourceWatch_)
    return;
  const t = {}, i = QO(n), r = (a) => (...s) => {
    const o = a.apply(e, s);
    return _m(n), o;
  };
  ["append", "appendChild", "insertAdjacentHTML"].forEach((a) => {
    e[a] && (t[a] = e[a], e[a] = r(t[a]));
  }), Object.defineProperty(e, "innerHTML", yt(i, {
    set: r(i.set)
  })), e.resetSourceWatch_ = () => {
    e.resetSourceWatch_ = null, Object.keys(t).forEach((a) => {
      e[a] = t[a];
    }), Object.defineProperty(e, "innerHTML", i);
  }, n.one("sourceset", e.resetSourceWatch_);
}, ZO = Object.defineProperty({}, "src", {
  get() {
    return this.hasAttribute("src") ? nS(me.Element.prototype.getAttribute.call(this, "src")) : "";
  },
  set(n) {
    return me.Element.prototype.setAttribute.call(this, "src", n), n;
  }
}), JO = (n) => FS([n.el(), me.HTMLMediaElement.prototype, ZO], "src"), e9 = function(n) {
  if (!n.featuresSourceset)
    return;
  const e = n.el();
  if (e.resetSourceset_)
    return;
  const t = JO(n), i = e.setAttribute, r = e.load;
  Object.defineProperty(e, "src", yt(t, {
    set: (a) => {
      const s = t.set.call(e, a);
      return n.triggerSourceset(e.src), s;
    }
  })), e.setAttribute = (a, s) => {
    const o = i.call(e, a, s);
    return /src/i.test(a) && n.triggerSourceset(e.src), o;
  }, e.load = () => {
    const a = r.call(e);
    return _m(n) || (n.triggerSourceset(""), B_(n)), a;
  }, e.currentSrc ? n.triggerSourceset(e.currentSrc) : _m(n) || B_(n), e.resetSourceset_ = () => {
    e.resetSourceset_ = null, e.load = r, e.setAttribute = i, Object.defineProperty(e, "src", t), e.resetSourceWatch_ && e.resetSourceWatch_();
  };
};
class ze extends tt {
  /**
  * Create an instance of this Tech.
  *
  * @param {Object} [options]
  *        The key/value store of player options.
  *
  * @param {Function} [ready]
  *        Callback function to call when the `HTML5` Tech is ready.
  */
  constructor(e, t) {
    super(e, t);
    const i = e.source;
    let r = !1;
    if (this.featuresVideoFrameCallback = this.featuresVideoFrameCallback && this.el_.tagName === "VIDEO", i && (this.el_.currentSrc !== i.src || e.tag && e.tag.initNetworkState_ === 3) ? this.setSource(i) : this.handleLateInit_(this.el_), e.enableSourceset && this.setupSourcesetHandling_(), this.isScrubbing_ = !1, this.el_.hasChildNodes()) {
      const a = this.el_.childNodes;
      let s = a.length;
      const o = [];
      for (; s--; ) {
        const u = a[s];
        u.nodeName.toLowerCase() === "track" && (this.featuresNativeTextTracks ? (this.remoteTextTrackEls().addTrackElement_(u), this.remoteTextTracks().addTrack(u.track), this.textTracks().addTrack(u.track), !r && !this.el_.hasAttribute("crossorigin") && Dl(u.src) && (r = !0)) : o.push(u));
      }
      for (let u = 0; u < o.length; u++)
        this.el_.removeChild(o[u]);
    }
    this.proxyNativeTracks_(), this.featuresNativeTextTracks && r && at.warn(`Text Tracks are being loaded from another origin but the crossorigin attribute isn't used.
This may prevent text tracks from loading.`), this.restoreMetadataTracksInIOSNativePlayer_(), (Qs || gl) && e.nativeControlsForTouch === !0 && this.setControls(!0), this.proxyWebkitFullscreen_(), this.triggerReady();
  }
  /**
   * Dispose of `HTML5` media element and remove all tracks.
   */
  dispose() {
    this.el_ && this.el_.resetSourceset_ && this.el_.resetSourceset_(), ze.disposeMediaElement(this.el_), this.options_ = null, super.dispose();
  }
  /**
   * Modify the media element so that we can detect when
   * the source is changed. Fires `sourceset` just after the source has changed
   */
  setupSourcesetHandling_() {
    e9(this);
  }
  /**
   * When a captions track is enabled in the iOS Safari native player, all other
   * tracks are disabled (including metadata tracks), which nulls all of their
   * associated cue points. This will restore metadata tracks to their pre-fullscreen
   * state in those cases so that cue points are not needlessly lost.
   *
   * @private
   */
  restoreMetadataTracksInIOSNativePlayer_() {
    const e = this.textTracks();
    let t;
    const i = () => {
      t = [];
      for (let a = 0; a < e.length; a++) {
        const s = e[a];
        s.kind === "metadata" && t.push({
          track: s,
          storedMode: s.mode
        });
      }
    };
    i(), e.addEventListener("change", i), this.on("dispose", () => e.removeEventListener("change", i));
    const r = () => {
      for (let a = 0; a < t.length; a++) {
        const s = t[a];
        s.track.mode === "disabled" && s.track.mode !== s.storedMode && (s.track.mode = s.storedMode);
      }
      e.removeEventListener("change", r);
    };
    this.on("webkitbeginfullscreen", () => {
      e.removeEventListener("change", i), e.removeEventListener("change", r), e.addEventListener("change", r);
    }), this.on("webkitendfullscreen", () => {
      e.removeEventListener("change", i), e.addEventListener("change", i), e.removeEventListener("change", r);
    });
  }
  /**
   * Attempt to force override of tracks for the given type
   *
   * @param {string} type - Track type to override, possible values include 'Audio',
   * 'Video', and 'Text'.
   * @param {boolean} override - If set to true native audio/video will be overridden,
   * otherwise native audio/video will potentially be used.
   * @private
   */
  overrideNative_(e, t) {
    if (t !== this[`featuresNative${e}Tracks`])
      return;
    const i = e.toLowerCase();
    this[`${i}TracksListeners_`] && Object.keys(this[`${i}TracksListeners_`]).forEach((r) => {
      this.el()[`${i}Tracks`].removeEventListener(r, this[`${i}TracksListeners_`][r]);
    }), this[`featuresNative${e}Tracks`] = !t, this[`${i}TracksListeners_`] = null, this.proxyNativeTracksForType_(i);
  }
  /**
   * Attempt to force override of native audio tracks.
   *
   * @param {boolean} override - If set to true native audio will be overridden,
   * otherwise native audio will potentially be used.
   */
  overrideNativeAudioTracks(e) {
    this.overrideNative_("Audio", e);
  }
  /**
   * Attempt to force override of native video tracks.
   *
   * @param {boolean} override - If set to true native video will be overridden,
   * otherwise native video will potentially be used.
   */
  overrideNativeVideoTracks(e) {
    this.overrideNative_("Video", e);
  }
  /**
   * Proxy native track list events for the given type to our track
   * lists if the browser we are playing in supports that type of track list.
   *
   * @param {string} name - Track type; values include 'audio', 'video', and 'text'
   * @private
   */
  proxyNativeTracksForType_(e) {
    const t = Nn[e], i = this.el()[t.getterName], r = this[t.getterName]();
    if (!this[`featuresNative${t.capitalName}Tracks`] || !i || !i.addEventListener)
      return;
    const a = {
      change: (o) => {
        const u = {
          type: "change",
          target: r,
          currentTarget: r,
          srcElement: r
        };
        r.trigger(u), e === "text" && this[Aa.remoteText.getterName]().trigger(u);
      },
      addtrack(o) {
        r.addTrack(o.track);
      },
      removetrack(o) {
        r.removeTrack(o.track);
      }
    }, s = function() {
      const o = [];
      for (let u = 0; u < r.length; u++) {
        let c = !1;
        for (let l = 0; l < i.length; l++)
          if (i[l] === r[u]) {
            c = !0;
            break;
          }
        c || o.push(r[u]);
      }
      for (; o.length; )
        r.removeTrack(o.shift());
    };
    this[t.getterName + "Listeners_"] = a, Object.keys(a).forEach((o) => {
      const u = a[o];
      i.addEventListener(o, u), this.on("dispose", (c) => i.removeEventListener(o, u));
    }), this.on("loadstart", s), this.on("dispose", (o) => this.off("loadstart", s));
  }
  /**
   * Proxy all native track list events to our track lists if the browser we are playing
   * in supports that type of track list.
   *
   * @private
   */
  proxyNativeTracks_() {
    Nn.names.forEach((e) => {
      this.proxyNativeTracksForType_(e);
    });
  }
  /**
   * Create the `Html5` Tech's DOM element.
   *
   * @return {Element}
   *         The element that gets created.
   */
  createEl() {
    let e = this.options_.tag;
    if (!e || !(this.options_.playerElIngest || this.movingMediaElementInDOM)) {
      if (e) {
        const i = e.cloneNode(!0);
        e.parentNode && e.parentNode.insertBefore(i, e), ze.disposeMediaElement(e), e = i;
      } else {
        e = Be.createElement("video");
        const i = this.options_.tag && Ki(this.options_.tag), r = yt({}, i);
        (!Qs || this.options_.nativeControlsForTouch !== !0) && delete r.controls, RD(e, Object.assign(r, {
          id: this.options_.techId,
          class: "vjs-tech"
        }));
      }
      e.playerId = this.options_.playerId;
    }
    typeof this.options_.preload < "u" && Da(e, "preload", this.options_.preload), this.options_.disablePictureInPicture !== void 0 && (e.disablePictureInPicture = this.options_.disablePictureInPicture);
    const t = ["loop", "muted", "playsinline", "autoplay"];
    for (let i = 0; i < t.length; i++) {
      const r = t[i], a = this.options_[r];
      typeof a < "u" && (a ? Da(e, r, r) : vl(e, r), e[r] = a);
    }
    return e;
  }
  /**
   * This will be triggered if the loadstart event has already fired, before videojs was
   * ready. Two known examples of when this can happen are:
   * 1. If we're loading the playback object after it has started loading
   * 2. The media is already playing the (often with autoplay on) then
   *
   * This function will fire another loadstart so that videojs can catchup.
   *
   * @fires Tech#loadstart
   *
   * @return {undefined}
   *         returns nothing.
   */
  handleLateInit_(e) {
    if (e.networkState === 0 || e.networkState === 3)
      return;
    if (e.readyState === 0) {
      let i = !1;
      const r = function() {
        i = !0;
      };
      this.on("loadstart", r);
      const a = function() {
        i || this.trigger("loadstart");
      };
      this.on("loadedmetadata", a), this.ready(function() {
        this.off("loadstart", r), this.off("loadedmetadata", a), i || this.trigger("loadstart");
      });
      return;
    }
    const t = ["loadstart"];
    t.push("loadedmetadata"), e.readyState >= 2 && t.push("loadeddata"), e.readyState >= 3 && t.push("canplay"), e.readyState >= 4 && t.push("canplaythrough"), this.ready(function() {
      t.forEach(function(i) {
        this.trigger(i);
      }, this);
    });
  }
  /**
   * Set whether we are scrubbing or not.
   * This is used to decide whether we should use `fastSeek` or not.
   * `fastSeek` is used to provide trick play on Safari browsers.
   *
   * @param {boolean} isScrubbing
   *                  - true for we are currently scrubbing
   *                  - false for we are no longer scrubbing
   */
  setScrubbing(e) {
    this.isScrubbing_ = e;
  }
  /**
   * Get whether we are scrubbing or not.
   *
   * @return {boolean} isScrubbing
   *                  - true for we are currently scrubbing
   *                  - false for we are no longer scrubbing
   */
  scrubbing() {
    return this.isScrubbing_;
  }
  /**
   * Set current time for the `HTML5` tech.
   *
   * @param {number} seconds
   *        Set the current time of the media to this.
   */
  setCurrentTime(e) {
    try {
      this.isScrubbing_ && this.el_.fastSeek && bl ? this.el_.fastSeek(e) : this.el_.currentTime = e;
    } catch (t) {
      at(t, "Video is not ready. (Video.js)");
    }
  }
  /**
   * Get the current duration of the HTML5 media element.
   *
   * @return {number}
   *         The duration of the media or 0 if there is no duration.
   */
  duration() {
    if (this.el_.duration === 1 / 0 && ai && _i && this.el_.currentTime === 0) {
      const e = () => {
        this.el_.currentTime > 0 && (this.el_.duration === 1 / 0 && this.trigger("durationchange"), this.off("timeupdate", e));
      };
      return this.on("timeupdate", e), NaN;
    }
    return this.el_.duration || NaN;
  }
  /**
   * Get the current width of the HTML5 media element.
   *
   * @return {number}
   *         The width of the HTML5 media element.
   */
  width() {
    return this.el_.offsetWidth;
  }
  /**
   * Get the current height of the HTML5 media element.
   *
   * @return {number}
   *         The height of the HTML5 media element.
   */
  height() {
    return this.el_.offsetHeight;
  }
  /**
   * Proxy iOS `webkitbeginfullscreen` and `webkitendfullscreen` into
   * `fullscreenchange` event.
   *
   * @private
   * @fires fullscreenchange
   * @listens webkitendfullscreen
   * @listens webkitbeginfullscreen
   * @listens webkitbeginfullscreen
   */
  proxyWebkitFullscreen_() {
    if (!("webkitDisplayingFullscreen" in this.el_))
      return;
    const e = function() {
      this.trigger("fullscreenchange", {
        isFullscreen: !1
      }), this.el_.controls && !this.options_.nativeControlsForTouch && this.controls() && (this.el_.controls = !1);
    }, t = function() {
      "webkitPresentationMode" in this.el_ && this.el_.webkitPresentationMode !== "picture-in-picture" && (this.one("webkitendfullscreen", e), this.trigger("fullscreenchange", {
        isFullscreen: !0,
        // set a flag in case another tech triggers fullscreenchange
        nativeIOSFullscreen: !0
      }));
    };
    this.on("webkitbeginfullscreen", t), this.on("dispose", () => {
      this.off("webkitbeginfullscreen", t), this.off("webkitendfullscreen", e);
    });
  }
  /**
   * Check if fullscreen is supported on the video el.
   *
   * @return {boolean}
   *         - True if fullscreen is supported.
   *         - False if fullscreen is not supported.
   */
  supportsFullScreen() {
    return typeof this.el_.webkitEnterFullScreen == "function";
  }
  /**
   * Request that the `HTML5` Tech enter fullscreen.
   */
  enterFullScreen() {
    const e = this.el_;
    if (e.paused && e.networkState <= e.HAVE_METADATA)
      mi(this.el_.play()), this.setTimeout(function() {
        e.pause();
        try {
          e.webkitEnterFullScreen();
        } catch (t) {
          this.trigger("fullscreenerror", t);
        }
      }, 0);
    else
      try {
        e.webkitEnterFullScreen();
      } catch (t) {
        this.trigger("fullscreenerror", t);
      }
  }
  /**
   * Request that the `HTML5` Tech exit fullscreen.
   */
  exitFullScreen() {
    if (!this.el_.webkitDisplayingFullscreen) {
      this.trigger("fullscreenerror", new Error("The video is not fullscreen"));
      return;
    }
    this.el_.webkitExitFullScreen();
  }
  /**
   * Create a floating video window always on top of other windows so that users may
   * continue consuming media while they interact with other content sites, or
   * applications on their device.
   *
   * @see [Spec]{@link https://wicg.github.io/picture-in-picture}
   *
   * @return {Promise}
   *         A promise with a Picture-in-Picture window.
   */
  requestPictureInPicture() {
    return this.el_.requestPictureInPicture();
  }
  /**
   * Native requestVideoFrameCallback if supported by browser/tech, or fallback
   * Don't use rVCF on Safari when DRM is playing, as it doesn't fire
   * Needs to be checked later than the constructor
   * This will be a false positive for clear sources loaded after a Fairplay source
   *
   * @param {function} cb function to call
   * @return {number} id of request
   */
  requestVideoFrameCallback(e) {
    return this.featuresVideoFrameCallback && !this.el_.webkitKeys ? this.el_.requestVideoFrameCallback(e) : super.requestVideoFrameCallback(e);
  }
  /**
   * Native or fallback requestVideoFrameCallback
   *
   * @param {number} id request id to cancel
   */
  cancelVideoFrameCallback(e) {
    this.featuresVideoFrameCallback && !this.el_.webkitKeys ? this.el_.cancelVideoFrameCallback(e) : super.cancelVideoFrameCallback(e);
  }
  /**
   * A getter/setter for the `Html5` Tech's source object.
   * > Note: Please use {@link Html5#setSource}
   *
   * @param {Tech~SourceObject} [src]
   *        The source object you want to set on the `HTML5` techs element.
   *
   * @return {Tech~SourceObject|undefined}
   *         - The current source object when a source is not passed in.
   *         - undefined when setting
   *
   * @deprecated Since version 5.
   */
  src(e) {
    if (e === void 0)
      return this.el_.src;
    this.setSrc(e);
  }
  /**
   * Add a <source> element to the <video> element.
   *
   * @param {string} srcUrl
   *        The URL of the video source.
   *
   * @param {string} [mimeType]
   *        The MIME type of the video source. Optional but recommended.
   *
   * @return {boolean}
   *         Returns true if the source element was successfully added, false otherwise.
   */
  addSourceElement(e, t) {
    if (!e)
      return at.error("Invalid source URL."), !1;
    const i = {
      src: e
    };
    t && (i.type = t);
    const r = Ye("source", {}, i);
    return this.el_.appendChild(r), !0;
  }
  /**
   * Remove a <source> element from the <video> element by its URL.
   *
   * @param {string} srcUrl
   *        The URL of the source to remove.
   *
   * @return {boolean}
   *         Returns true if the source element was successfully removed, false otherwise.
   */
  removeSourceElement(e) {
    if (!e)
      return at.error("Source URL is required to remove the source element."), !1;
    const t = this.el_.querySelectorAll("source");
    for (const i of t)
      if (i.src === e)
        return this.el_.removeChild(i), !0;
    return at.warn(`No matching source element found with src: ${e}`), !1;
  }
  /**
   * Reset the tech by removing all sources and then calling
   * {@link Html5.resetMediaElement}.
   */
  reset() {
    ze.resetMediaElement(this.el_);
  }
  /**
   * Get the current source on the `HTML5` Tech. Falls back to returning the source from
   * the HTML5 media element.
   *
   * @return {Tech~SourceObject}
   *         The current source object from the HTML5 tech. With a fallback to the
   *         elements source.
   */
  currentSrc() {
    return this.currentSource_ ? this.currentSource_.src : this.el_.currentSrc;
  }
  /**
   * Set controls attribute for the HTML5 media Element.
   *
   * @param {string} val
   *        Value to set the controls attribute to
   */
  setControls(e) {
    this.el_.controls = !!e;
  }
  /**
   * Create and returns a remote {@link TextTrack} object.
   *
   * @param {string} kind
   *        `TextTrack` kind (subtitles, captions, descriptions, chapters, or metadata)
   *
   * @param {string} [label]
   *        Label to identify the text track
   *
   * @param {string} [language]
   *        Two letter language abbreviation
   *
   * @return {TextTrack}
   *         The TextTrack that gets created.
   */
  addTextTrack(e, t, i) {
    return this.featuresNativeTextTracks ? this.el_.addTextTrack(e, t, i) : super.addTextTrack(e, t, i);
  }
  /**
   * Creates either native TextTrack or an emulated TextTrack depending
   * on the value of `featuresNativeTextTracks`
   *
   * @param {Object} options
   *        The object should contain the options to initialize the TextTrack with.
   *
   * @param {string} [options.kind]
   *        `TextTrack` kind (subtitles, captions, descriptions, chapters, or metadata).
   *
   * @param {string} [options.label]
   *        Label to identify the text track
   *
   * @param {string} [options.language]
   *        Two letter language abbreviation.
   *
   * @param {boolean} [options.default]
   *        Default this track to on.
   *
   * @param {string} [options.id]
   *        The internal id to assign this track.
   *
   * @param {string} [options.src]
   *        A source url for the track.
   *
   * @return {HTMLTrackElement}
   *         The track element that gets created.
   */
  createRemoteTextTrack(e) {
    if (!this.featuresNativeTextTracks)
      return super.createRemoteTextTrack(e);
    const t = Be.createElement("track");
    return e.kind && (t.kind = e.kind), e.label && (t.label = e.label), (e.language || e.srclang) && (t.srclang = e.language || e.srclang), e.default && (t.default = e.default), e.id && (t.id = e.id), e.src && (t.src = e.src), t;
  }
  /**
   * Creates a remote text track object and returns an html track element.
   *
   * @param {Object} options The object should contain values for
   * kind, language, label, and src (location of the WebVTT file)
   * @param {boolean} [manualCleanup=false] if set to true, the TextTrack
   * will not be removed from the TextTrackList and HtmlTrackElementList
   * after a source change
   * @return {HTMLTrackElement} An Html Track Element.
   * This can be an emulated {@link HTMLTrackElement} or a native one.
   *
   */
  addRemoteTextTrack(e, t) {
    const i = super.addRemoteTextTrack(e, t);
    return this.featuresNativeTextTracks && this.el().appendChild(i), i;
  }
  /**
   * Remove remote `TextTrack` from `TextTrackList` object
   *
   * @param {TextTrack} track
   *        `TextTrack` object to remove
   */
  removeRemoteTextTrack(e) {
    if (super.removeRemoteTextTrack(e), this.featuresNativeTextTracks) {
      const t = this.$$("track");
      let i = t.length;
      for (; i--; )
        (e === t[i] || e === t[i].track) && this.el().removeChild(t[i]);
    }
  }
  /**
   * Gets available media playback quality metrics as specified by the W3C's Media
   * Playback Quality API.
   *
   * @see [Spec]{@link https://wicg.github.io/media-playback-quality}
   *
   * @return {Object}
   *         An object with supported media playback quality metrics
   */
  getVideoPlaybackQuality() {
    if (typeof this.el().getVideoPlaybackQuality == "function")
      return this.el().getVideoPlaybackQuality();
    const e = {};
    return typeof this.el().webkitDroppedFrameCount < "u" && typeof this.el().webkitDecodedFrameCount < "u" && (e.droppedVideoFrames = this.el().webkitDroppedFrameCount, e.totalVideoFrames = this.el().webkitDecodedFrameCount), me.performance && (e.creationTime = me.performance.now()), e;
  }
}
hl(ze, "TEST_VID", function() {
  if (!Pa())
    return;
  const n = Be.createElement("video"), e = Be.createElement("track");
  return e.kind = "captions", e.srclang = "en", e.label = "English", n.appendChild(e), n;
});
ze.isSupported = function() {
  try {
    ze.TEST_VID.volume = 0.5;
  } catch {
    return !1;
  }
  return !!(ze.TEST_VID && ze.TEST_VID.canPlayType);
};
ze.canPlayType = function(n) {
  return ze.TEST_VID.canPlayType(n);
};
ze.canPlaySource = function(n, e) {
  return ze.canPlayType(n.type);
};
ze.canControlVolume = function() {
  try {
    const n = ze.TEST_VID.volume;
    ze.TEST_VID.volume = n / 2 + 0.1;
    const e = n !== ze.TEST_VID.volume;
    return e && Gt ? (me.setTimeout(() => {
      ze && ze.prototype && (ze.prototype.featuresVolumeControl = n !== ze.TEST_VID.volume);
    }), !1) : e;
  } catch {
    return !1;
  }
};
ze.canMuteVolume = function() {
  try {
    const n = ze.TEST_VID.muted;
    return ze.TEST_VID.muted = !n, ze.TEST_VID.muted ? Da(ze.TEST_VID, "muted", "muted") : vl(ze.TEST_VID, "muted", "muted"), n !== ze.TEST_VID.muted;
  } catch {
    return !1;
  }
};
ze.canControlPlaybackRate = function() {
  if (ai && _i && pl < 58)
    return !1;
  try {
    const n = ze.TEST_VID.playbackRate;
    return ze.TEST_VID.playbackRate = n / 2 + 0.1, n !== ze.TEST_VID.playbackRate;
  } catch {
    return !1;
  }
};
ze.canOverrideAttributes = function() {
  try {
    const n = () => {
    };
    Object.defineProperty(Be.createElement("video"), "src", {
      get: n,
      set: n
    }), Object.defineProperty(Be.createElement("audio"), "src", {
      get: n,
      set: n
    }), Object.defineProperty(Be.createElement("video"), "innerHTML", {
      get: n,
      set: n
    }), Object.defineProperty(Be.createElement("audio"), "innerHTML", {
      get: n,
      set: n
    });
  } catch {
    return !1;
  }
  return !0;
};
ze.supportsNativeTextTracks = function() {
  return bl || Gt && _i;
};
ze.supportsNativeVideoTracks = function() {
  return !!(ze.TEST_VID && ze.TEST_VID.videoTracks);
};
ze.supportsNativeAudioTracks = function() {
  return !!(ze.TEST_VID && ze.TEST_VID.audioTracks);
};
ze.Events = ["loadstart", "suspend", "abort", "error", "emptied", "stalled", "loadedmetadata", "loadeddata", "canplay", "canplaythrough", "playing", "waiting", "seeking", "seeked", "ended", "durationchange", "timeupdate", "progress", "play", "pause", "ratechange", "resize", "volumechange"];
[["featuresMuteControl", "canMuteVolume"], ["featuresPlaybackRate", "canControlPlaybackRate"], ["featuresSourceset", "canOverrideAttributes"], ["featuresNativeTextTracks", "supportsNativeTextTracks"], ["featuresNativeVideoTracks", "supportsNativeVideoTracks"], ["featuresNativeAudioTracks", "supportsNativeAudioTracks"]].forEach(function([n, e]) {
  hl(ze.prototype, n, () => ze[e](), !0);
});
ze.prototype.featuresVolumeControl = ze.canControlVolume();
ze.prototype.movingMediaElementInDOM = !Gt;
ze.prototype.featuresFullscreenResize = !0;
ze.prototype.featuresProgressEvents = !0;
ze.prototype.featuresTimeupdateEvents = !0;
ze.prototype.featuresVideoFrameCallback = !!(ze.TEST_VID && ze.TEST_VID.requestVideoFrameCallback);
ze.disposeMediaElement = function(n) {
  if (n) {
    for (n.parentNode && n.parentNode.removeChild(n); n.hasChildNodes(); )
      n.removeChild(n.firstChild);
    n.removeAttribute("src"), typeof n.load == "function" && (function() {
      try {
        n.load();
      } catch {
      }
    })();
  }
};
ze.resetMediaElement = function(n) {
  if (!n)
    return;
  const e = n.querySelectorAll("source");
  let t = e.length;
  for (; t--; )
    n.removeChild(e[t]);
  n.removeAttribute("src"), typeof n.load == "function" && (function() {
    try {
      n.load();
    } catch {
    }
  })();
};
[
  /**
   * Get the value of `muted` from the media element. `muted` indicates
   * that the volume for the media should be set to silent. This does not actually change
   * the `volume` attribute.
   *
   * @method Html5#muted
   * @return {boolean}
   *         - True if the value of `volume` should be ignored and the audio set to silent.
   *         - False if the value of `volume` should be used.
   *
   * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-muted}
   */
  "muted",
  /**
   * Get the value of `defaultMuted` from the media element. `defaultMuted` indicates
   * whether the media should start muted or not. Only changes the default state of the
   * media. `muted` and `defaultMuted` can have different values. {@link Html5#muted} indicates the
   * current state.
   *
   * @method Html5#defaultMuted
   * @return {boolean}
   *         - The value of `defaultMuted` from the media element.
   *         - True indicates that the media should start muted.
   *         - False indicates that the media should not start muted
   *
   * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-defaultmuted}
   */
  "defaultMuted",
  /**
   * Get the value of `autoplay` from the media element. `autoplay` indicates
   * that the media should start to play as soon as the page is ready.
   *
   * @method Html5#autoplay
   * @return {boolean}
   *         - The value of `autoplay` from the media element.
   *         - True indicates that the media should start as soon as the page loads.
   *         - False indicates that the media should not start as soon as the page loads.
   *
   * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#attr-media-autoplay}
   */
  "autoplay",
  /**
   * Get the value of `controls` from the media element. `controls` indicates
   * whether the native media controls should be shown or hidden.
   *
   * @method Html5#controls
   * @return {boolean}
   *         - The value of `controls` from the media element.
   *         - True indicates that native controls should be showing.
   *         - False indicates that native controls should be hidden.
   *
   * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#attr-media-controls}
   */
  "controls",
  /**
   * Get the value of `loop` from the media element. `loop` indicates
   * that the media should return to the start of the media and continue playing once
   * it reaches the end.
   *
   * @method Html5#loop
   * @return {boolean}
   *         - The value of `loop` from the media element.
   *         - True indicates that playback should seek back to start once
   *           the end of a media is reached.
   *         - False indicates that playback should not loop back to the start when the
   *           end of the media is reached.
   *
   * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#attr-media-loop}
   */
  "loop",
  /**
   * Get the value of `playsinline` from the media element. `playsinline` indicates
   * to the browser that non-fullscreen playback is preferred when fullscreen
   * playback is the native default, such as in iOS Safari.
   *
   * @method Html5#playsinline
   * @return {boolean}
   *         - The value of `playsinline` from the media element.
   *         - True indicates that the media should play inline.
   *         - False indicates that the media should not play inline.
   *
   * @see [Spec]{@link https://html.spec.whatwg.org/#attr-video-playsinline}
   */
  "playsinline"
].forEach(function(n) {
  ze.prototype[n] = function() {
    return this.el_[n] || this.el_.hasAttribute(n);
  };
});
[
  /**
   * Set the value of `muted` on the media element. `muted` indicates that the current
   * audio level should be silent.
   *
   * @method Html5#setMuted
   * @param {boolean} muted
   *        - True if the audio should be set to silent
   *        - False otherwise
   *
   * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-muted}
   */
  "muted",
  /**
   * Set the value of `defaultMuted` on the media element. `defaultMuted` indicates that the current
   * audio level should be silent, but will only effect the muted level on initial playback..
   *
   * @method Html5.prototype.setDefaultMuted
   * @param {boolean} defaultMuted
   *        - True if the audio should be set to silent
   *        - False otherwise
   *
   * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-defaultmuted}
   */
  "defaultMuted",
  /**
   * Set the value of `autoplay` on the media element. `autoplay` indicates
   * that the media should start to play as soon as the page is ready.
   *
   * @method Html5#setAutoplay
   * @param {boolean} autoplay
   *         - True indicates that the media should start as soon as the page loads.
   *         - False indicates that the media should not start as soon as the page loads.
   *
   * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#attr-media-autoplay}
   */
  "autoplay",
  /**
   * Set the value of `loop` on the media element. `loop` indicates
   * that the media should return to the start of the media and continue playing once
   * it reaches the end.
   *
   * @method Html5#setLoop
   * @param {boolean} loop
   *         - True indicates that playback should seek back to start once
   *           the end of a media is reached.
   *         - False indicates that playback should not loop back to the start when the
   *           end of the media is reached.
   *
   * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#attr-media-loop}
   */
  "loop",
  /**
   * Set the value of `playsinline` from the media element. `playsinline` indicates
   * to the browser that non-fullscreen playback is preferred when fullscreen
   * playback is the native default, such as in iOS Safari.
   *
   * @method Html5#setPlaysinline
   * @param {boolean} playsinline
   *         - True indicates that the media should play inline.
   *         - False indicates that the media should not play inline.
   *
   * @see [Spec]{@link https://html.spec.whatwg.org/#attr-video-playsinline}
   */
  "playsinline"
].forEach(function(n) {
  ze.prototype["set" + Rt(n)] = function(e) {
    this.el_[n] = e, e ? this.el_.setAttribute(n, n) : this.el_.removeAttribute(n);
  };
});
[
  /**
   * Get the value of `paused` from the media element. `paused` indicates whether the media element
   * is currently paused or not.
   *
   * @method Html5#paused
   * @return {boolean}
   *         The value of `paused` from the media element.
   *
   * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-paused}
   */
  "paused",
  /**
   * Get the value of `currentTime` from the media element. `currentTime` indicates
   * the current second that the media is at in playback.
   *
   * @method Html5#currentTime
   * @return {number}
   *         The value of `currentTime` from the media element.
   *
   * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-currenttime}
   */
  "currentTime",
  /**
   * Get the value of `buffered` from the media element. `buffered` is a `TimeRange`
   * object that represents the parts of the media that are already downloaded and
   * available for playback.
   *
   * @method Html5#buffered
   * @return {TimeRange}
   *         The value of `buffered` from the media element.
   *
   * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-buffered}
   */
  "buffered",
  /**
   * Get the value of `volume` from the media element. `volume` indicates
   * the current playback volume of audio for a media. `volume` will be a value from 0
   * (silent) to 1 (loudest and default).
   *
   * @method Html5#volume
   * @return {number}
   *         The value of `volume` from the media element. Value will be between 0-1.
   *
   * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-a-volume}
   */
  "volume",
  /**
   * Get the value of `poster` from the media element. `poster` indicates
   * that the url of an image file that can/will be shown when no media data is available.
   *
   * @method Html5#poster
   * @return {string}
   *         The value of `poster` from the media element. Value will be a url to an
   *         image.
   *
   * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#attr-video-poster}
   */
  "poster",
  /**
   * Get the value of `preload` from the media element. `preload` indicates
   * what should download before the media is interacted with. It can have the following
   * values:
   * - none: nothing should be downloaded
   * - metadata: poster and the first few frames of the media may be downloaded to get
   *   media dimensions and other metadata
   * - auto: allow the media and metadata for the media to be downloaded before
   *    interaction
   *
   * @method Html5#preload
   * @return {string}
   *         The value of `preload` from the media element. Will be 'none', 'metadata',
   *         or 'auto'.
   *
   * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#attr-media-preload}
   */
  "preload",
  /**
   * Get the value of the `error` from the media element. `error` indicates any
   * MediaError that may have occurred during playback. If error returns null there is no
   * current error.
   *
   * @method Html5#error
   * @return {MediaError|null}
   *         The value of `error` from the media element. Will be `MediaError` if there
   *         is a current error and null otherwise.
   *
   * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-error}
   */
  "error",
  /**
   * Get the value of `seeking` from the media element. `seeking` indicates whether the
   * media is currently seeking to a new position or not.
   *
   * @method Html5#seeking
   * @return {boolean}
   *         - The value of `seeking` from the media element.
   *         - True indicates that the media is currently seeking to a new position.
   *         - False indicates that the media is not seeking to a new position at this time.
   *
   * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-seeking}
   */
  "seeking",
  /**
   * Get the value of `seekable` from the media element. `seekable` returns a
   * `TimeRange` object indicating ranges of time that can currently be `seeked` to.
   *
   * @method Html5#seekable
   * @return {TimeRange}
   *         The value of `seekable` from the media element. A `TimeRange` object
   *         indicating the current ranges of time that can be seeked to.
   *
   * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-seekable}
   */
  "seekable",
  /**
   * Get the value of `ended` from the media element. `ended` indicates whether
   * the media has reached the end or not.
   *
   * @method Html5#ended
   * @return {boolean}
   *         - The value of `ended` from the media element.
   *         - True indicates that the media has ended.
   *         - False indicates that the media has not ended.
   *
   * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-ended}
   */
  "ended",
  /**
   * Get the value of `playbackRate` from the media element. `playbackRate` indicates
   * the rate at which the media is currently playing back. Examples:
   *   - if playbackRate is set to 2, media will play twice as fast.
   *   - if playbackRate is set to 0.5, media will play half as fast.
   *
   * @method Html5#playbackRate
   * @return {number}
   *         The value of `playbackRate` from the media element. A number indicating
   *         the current playback speed of the media, where 1 is normal speed.
   *
   * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-playbackrate}
   */
  "playbackRate",
  /**
   * Get the value of `defaultPlaybackRate` from the media element. `defaultPlaybackRate` indicates
   * the rate at which the media is currently playing back. This value will not indicate the current
   * `playbackRate` after playback has started, use {@link Html5#playbackRate} for that.
   *
   * Examples:
   *   - if defaultPlaybackRate is set to 2, media will play twice as fast.
   *   - if defaultPlaybackRate is set to 0.5, media will play half as fast.
   *
   * @method Html5.prototype.defaultPlaybackRate
   * @return {number}
   *         The value of `defaultPlaybackRate` from the media element. A number indicating
   *         the current playback speed of the media, where 1 is normal speed.
   *
   * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-playbackrate}
   */
  "defaultPlaybackRate",
  /**
   * Get the value of 'disablePictureInPicture' from the video element.
   *
   * @method Html5#disablePictureInPicture
   * @return {boolean} value
   *         - The value of `disablePictureInPicture` from the video element.
   *         - True indicates that the video can't be played in Picture-In-Picture mode
   *         - False indicates that the video can be played in Picture-In-Picture mode
   *
   * @see [Spec]{@link https://w3c.github.io/picture-in-picture/#disable-pip}
   */
  "disablePictureInPicture",
  /**
   * Get the value of `played` from the media element. `played` returns a `TimeRange`
   * object representing points in the media timeline that have been played.
   *
   * @method Html5#played
   * @return {TimeRange}
   *         The value of `played` from the media element. A `TimeRange` object indicating
   *         the ranges of time that have been played.
   *
   * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-played}
   */
  "played",
  /**
   * Get the value of `networkState` from the media element. `networkState` indicates
   * the current network state. It returns an enumeration from the following list:
   * - 0: NETWORK_EMPTY
   * - 1: NETWORK_IDLE
   * - 2: NETWORK_LOADING
   * - 3: NETWORK_NO_SOURCE
   *
   * @method Html5#networkState
   * @return {number}
   *         The value of `networkState` from the media element. This will be a number
   *         from the list in the description.
   *
   * @see [Spec] {@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-networkstate}
   */
  "networkState",
  /**
   * Get the value of `readyState` from the media element. `readyState` indicates
   * the current state of the media element. It returns an enumeration from the
   * following list:
   * - 0: HAVE_NOTHING
   * - 1: HAVE_METADATA
   * - 2: HAVE_CURRENT_DATA
   * - 3: HAVE_FUTURE_DATA
   * - 4: HAVE_ENOUGH_DATA
   *
   * @method Html5#readyState
   * @return {number}
   *         The value of `readyState` from the media element. This will be a number
   *         from the list in the description.
   *
   * @see [Spec] {@link https://www.w3.org/TR/html5/embedded-content-0.html#ready-states}
   */
  "readyState",
  /**
   * Get the value of `videoWidth` from the video element. `videoWidth` indicates
   * the current width of the video in css pixels.
   *
   * @method Html5#videoWidth
   * @return {number}
   *         The value of `videoWidth` from the video element. This will be a number
   *         in css pixels.
   *
   * @see [Spec] {@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-video-videowidth}
   */
  "videoWidth",
  /**
   * Get the value of `videoHeight` from the video element. `videoHeight` indicates
   * the current height of the video in css pixels.
   *
   * @method Html5#videoHeight
   * @return {number}
   *         The value of `videoHeight` from the video element. This will be a number
   *         in css pixels.
   *
   * @see [Spec] {@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-video-videowidth}
   */
  "videoHeight",
  /**
   * Get the value of `crossOrigin` from the media element. `crossOrigin` indicates
   * to the browser that should sent the cookies along with the requests for the
   * different assets/playlists
   *
   * @method Html5#crossOrigin
   * @return {string}
   *         - anonymous indicates that the media should not sent cookies.
   *         - use-credentials indicates that the media should sent cookies along the requests.
   *
   * @see [Spec]{@link https://html.spec.whatwg.org/#attr-media-crossorigin}
   */
  "crossOrigin"
].forEach(function(n) {
  ze.prototype[n] = function() {
    return this.el_[n];
  };
});
[
  /**
   * Set the value of `volume` on the media element. `volume` indicates the current
   * audio level as a percentage in decimal form. This means that 1 is 100%, 0.5 is 50%, and
   * so on.
   *
   * @method Html5#setVolume
   * @param {number} percentAsDecimal
   *        The volume percent as a decimal. Valid range is from 0-1.
   *
   * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-a-volume}
   */
  "volume",
  /**
   * Set the value of `src` on the media element. `src` indicates the current
   * {@link Tech~SourceObject} for the media.
   *
   * @method Html5#setSrc
   * @param {Tech~SourceObject} src
   *        The source object to set as the current source.
   *
   * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-src}
   */
  "src",
  /**
   * Set the value of `poster` on the media element. `poster` is the url to
   * an image file that can/will be shown when no media data is available.
   *
   * @method Html5#setPoster
   * @param {string} poster
   *        The url to an image that should be used as the `poster` for the media
   *        element.
   *
   * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#attr-media-poster}
   */
  "poster",
  /**
   * Set the value of `preload` on the media element. `preload` indicates
   * what should download before the media is interacted with. It can have the following
   * values:
   * - none: nothing should be downloaded
   * - metadata: poster and the first few frames of the media may be downloaded to get
   *   media dimensions and other metadata
   * - auto: allow the media and metadata for the media to be downloaded before
   *    interaction
   *
   * @method Html5#setPreload
   * @param {string} preload
   *         The value of `preload` to set on the media element. Must be 'none', 'metadata',
   *         or 'auto'.
   *
   * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#attr-media-preload}
   */
  "preload",
  /**
   * Set the value of `playbackRate` on the media element. `playbackRate` indicates
   * the rate at which the media should play back. Examples:
   *   - if playbackRate is set to 2, media will play twice as fast.
   *   - if playbackRate is set to 0.5, media will play half as fast.
   *
   * @method Html5#setPlaybackRate
   * @return {number}
   *         The value of `playbackRate` from the media element. A number indicating
   *         the current playback speed of the media, where 1 is normal speed.
   *
   * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-playbackrate}
   */
  "playbackRate",
  /**
   * Set the value of `defaultPlaybackRate` on the media element. `defaultPlaybackRate` indicates
   * the rate at which the media should play back upon initial startup. Changing this value
   * after a video has started will do nothing. Instead you should used {@link Html5#setPlaybackRate}.
   *
   * Example Values:
   *   - if playbackRate is set to 2, media will play twice as fast.
   *   - if playbackRate is set to 0.5, media will play half as fast.
   *
   * @method Html5.prototype.setDefaultPlaybackRate
   * @return {number}
   *         The value of `defaultPlaybackRate` from the media element. A number indicating
   *         the current playback speed of the media, where 1 is normal speed.
   *
   * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-defaultplaybackrate}
   */
  "defaultPlaybackRate",
  /**
   * Prevents the browser from suggesting a Picture-in-Picture context menu
   * or to request Picture-in-Picture automatically in some cases.
   *
   * @method Html5#setDisablePictureInPicture
   * @param {boolean} value
   *         The true value will disable Picture-in-Picture mode.
   *
   * @see [Spec]{@link https://w3c.github.io/picture-in-picture/#disable-pip}
   */
  "disablePictureInPicture",
  /**
   * Set the value of `crossOrigin` from the media element. `crossOrigin` indicates
   * to the browser that should sent the cookies along with the requests for the
   * different assets/playlists
   *
   * @method Html5#setCrossOrigin
   * @param {string} crossOrigin
   *         - anonymous indicates that the media should not sent cookies.
   *         - use-credentials indicates that the media should sent cookies along the requests.
   *
   * @see [Spec]{@link https://html.spec.whatwg.org/#attr-media-crossorigin}
   */
  "crossOrigin"
].forEach(function(n) {
  ze.prototype["set" + Rt(n)] = function(e) {
    this.el_[n] = e;
  };
});
[
  /**
   * A wrapper around the media elements `pause` function. This will call the `HTML5`
   * media elements `pause` function.
   *
   * @method Html5#pause
   * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-pause}
   */
  "pause",
  /**
   * A wrapper around the media elements `load` function. This will call the `HTML5`s
   * media element `load` function.
   *
   * @method Html5#load
   * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-load}
   */
  "load",
  /**
   * A wrapper around the media elements `play` function. This will call the `HTML5`s
   * media element `play` function.
   *
   * @method Html5#play
   * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-play}
   */
  "play"
].forEach(function(n) {
  ze.prototype[n] = function() {
    return this.el_[n]();
  };
});
tt.withSourceHandlers(ze);
ze.nativeSourceHandler = {};
ze.nativeSourceHandler.canPlayType = function(n) {
  try {
    return ze.TEST_VID.canPlayType(n);
  } catch {
    return "";
  }
};
ze.nativeSourceHandler.canHandleSource = function(n, e) {
  if (n.type)
    return ze.nativeSourceHandler.canPlayType(n.type);
  if (n.src) {
    const t = o0(n.src);
    return ze.nativeSourceHandler.canPlayType(`video/${t}`);
  }
  return "";
};
ze.nativeSourceHandler.handleSource = function(n, e, t) {
  e.setSrc(n.src);
};
ze.nativeSourceHandler.dispose = function() {
};
ze.registerSourceHandler(ze.nativeSourceHandler);
tt.registerTech("Html5", ze);
const NS = [
  /**
   * Fired while the user agent is downloading media data.
   *
   * @event Player#progress
   * @type {Event}
   */
  /**
   * Retrigger the `progress` event that was triggered by the {@link Tech}.
   *
   * @private
   * @method Player#handleTechProgress_
   * @fires Player#progress
   * @listens Tech#progress
   */
  "progress",
  /**
   * Fires when the loading of an audio/video is aborted.
   *
   * @event Player#abort
   * @type {Event}
   */
  /**
   * Retrigger the `abort` event that was triggered by the {@link Tech}.
   *
   * @private
   * @method Player#handleTechAbort_
   * @fires Player#abort
   * @listens Tech#abort
   */
  "abort",
  /**
   * Fires when the browser is intentionally not getting media data.
   *
   * @event Player#suspend
   * @type {Event}
   */
  /**
   * Retrigger the `suspend` event that was triggered by the {@link Tech}.
   *
   * @private
   * @method Player#handleTechSuspend_
   * @fires Player#suspend
   * @listens Tech#suspend
   */
  "suspend",
  /**
   * Fires when the current playlist is empty.
   *
   * @event Player#emptied
   * @type {Event}
   */
  /**
   * Retrigger the `emptied` event that was triggered by the {@link Tech}.
   *
   * @private
   * @method Player#handleTechEmptied_
   * @fires Player#emptied
   * @listens Tech#emptied
   */
  "emptied",
  /**
   * Fires when the browser is trying to get media data, but data is not available.
   *
   * @event Player#stalled
   * @type {Event}
   */
  /**
   * Retrigger the `stalled` event that was triggered by the {@link Tech}.
   *
   * @private
   * @method Player#handleTechStalled_
   * @fires Player#stalled
   * @listens Tech#stalled
   */
  "stalled",
  /**
   * Fires when the browser has loaded meta data for the audio/video.
   *
   * @event Player#loadedmetadata
   * @type {Event}
   */
  /**
   * Retrigger the `loadedmetadata` event that was triggered by the {@link Tech}.
   *
   * @private
   * @method Player#handleTechLoadedmetadata_
   * @fires Player#loadedmetadata
   * @listens Tech#loadedmetadata
   */
  "loadedmetadata",
  /**
   * Fires when the browser has loaded the current frame of the audio/video.
   *
   * @event Player#loadeddata
   * @type {event}
   */
  /**
   * Retrigger the `loadeddata` event that was triggered by the {@link Tech}.
   *
   * @private
   * @method Player#handleTechLoaddeddata_
   * @fires Player#loadeddata
   * @listens Tech#loadeddata
   */
  "loadeddata",
  /**
   * Fires when the current playback position has changed.
   *
   * @event Player#timeupdate
   * @type {event}
   */
  /**
   * Retrigger the `timeupdate` event that was triggered by the {@link Tech}.
   *
   * @private
   * @method Player#handleTechTimeUpdate_
   * @fires Player#timeupdate
   * @listens Tech#timeupdate
   */
  "timeupdate",
  /**
   * Fires when the video's intrinsic dimensions change
   *
   * @event Player#resize
   * @type {event}
   */
  /**
   * Retrigger the `resize` event that was triggered by the {@link Tech}.
   *
   * @private
   * @method Player#handleTechResize_
   * @fires Player#resize
   * @listens Tech#resize
   */
  "resize",
  /**
   * Fires when the volume has been changed
   *
   * @event Player#volumechange
   * @type {event}
   */
  /**
   * Retrigger the `volumechange` event that was triggered by the {@link Tech}.
   *
   * @private
   * @method Player#handleTechVolumechange_
   * @fires Player#volumechange
   * @listens Tech#volumechange
   */
  "volumechange",
  /**
   * Fires when the text track has been changed
   *
   * @event Player#texttrackchange
   * @type {event}
   */
  /**
   * Retrigger the `texttrackchange` event that was triggered by the {@link Tech}.
   *
   * @private
   * @method Player#handleTechTexttrackchange_
   * @fires Player#texttrackchange
   * @listens Tech#texttrackchange
   */
  "texttrackchange"
], Pp = {
  canplay: "CanPlay",
  canplaythrough: "CanPlayThrough",
  playing: "Playing",
  seeked: "Seeked"
}, Tm = ["tiny", "xsmall", "small", "medium", "large", "xlarge", "huge"], Xu = {};
Tm.forEach((n) => {
  const e = n.charAt(0) === "x" ? `x-${n.substring(1)}` : n;
  Xu[n] = `vjs-layout-${e}`;
});
const t9 = {
  tiny: 210,
  xsmall: 320,
  small: 425,
  medium: 768,
  large: 1440,
  xlarge: 2560,
  huge: 1 / 0
};
class dt extends Pe {
  /**
   * Create an instance of this class.
   *
   * @param {Element} tag
   *        The original video DOM element used for configuring options.
   *
   * @param {Object} [options]
   *        Object of option names and values.
   *
   * @param {PlayerReadyCallback} [ready]
   *        Ready callback function.
   */
  constructor(e, t, i) {
    if (e.id = e.id || t.id || `vjs_video_${Mn()}`, t = Object.assign(dt.getTagSettings(e), t), t.initChildren = !1, t.createEl = !1, t.evented = !1, t.reportTouchActivity = !1, !t.language) {
      const s = e.closest("[lang]");
      s && (t.language = s.getAttribute("lang"));
    }
    if (super(null, t, i), this.boundDocumentFullscreenChange_ = (s) => this.documentFullscreenChange_(s), this.boundFullWindowOnEscKey_ = (s) => this.fullWindowOnEscKey(s), this.boundUpdateStyleEl_ = (s) => this.updateStyleEl_(s), this.boundApplyInitTime_ = (s) => this.applyInitTime_(s), this.boundUpdateCurrentBreakpoint_ = (s) => this.updateCurrentBreakpoint_(s), this.boundHandleTechClick_ = (s) => this.handleTechClick_(s), this.boundHandleTechDoubleClick_ = (s) => this.handleTechDoubleClick_(s), this.boundHandleTechTouchStart_ = (s) => this.handleTechTouchStart_(s), this.boundHandleTechTouchMove_ = (s) => this.handleTechTouchMove_(s), this.boundHandleTechTouchEnd_ = (s) => this.handleTechTouchEnd_(s), this.boundHandleTechTap_ = (s) => this.handleTechTap_(s), this.boundUpdatePlayerHeightOnAudioOnlyMode_ = (s) => this.updatePlayerHeightOnAudioOnlyMode_(s), this.isFullscreen_ = !1, this.log = xD(this.id_), this.fsApi_ = cc, this.isPosterFromTech_ = !1, this.queuedCallbacks_ = [], this.isReady_ = !1, this.hasStarted_ = !1, this.userActive_ = !1, this.debugEnabled_ = !1, this.audioOnlyMode_ = !1, this.audioPosterMode_ = !1, this.audioOnlyCache_ = {
      controlBarHeight: null,
      playerHeight: null,
      hiddenChildren: []
    }, !this.options_ || !this.options_.techOrder || !this.options_.techOrder.length)
      throw new Error("No techOrder specified. Did you overwrite videojs.options instead of just changing the properties you want to override?");
    if (this.tag = e, this.tagAttributes = e && Ki(e), this.language(this.options_.language), t.languages) {
      const s = {};
      Object.getOwnPropertyNames(t.languages).forEach(function(o) {
        s[o.toLowerCase()] = t.languages[o];
      }), this.languages_ = s;
    } else
      this.languages_ = dt.prototype.options_.languages;
    this.resetCache_(), this.poster_ = t.poster || "", this.controls_ = !!t.controls, e.controls = !1, e.removeAttribute("controls"), this.changingSrc_ = !1, this.playCallbacks_ = [], this.playTerminatedQueue_ = [], e.hasAttribute("autoplay") ? this.autoplay(!0) : this.autoplay(this.options_.autoplay), t.plugins && Object.keys(t.plugins).forEach((s) => {
      if (typeof this[s] != "function")
        throw new Error(`plugin "${s}" does not exist`);
    }), this.scrubbing_ = !1, this.el_ = this.createEl(), n0(this, {
      eventBusKey: "el_"
    }), this.fsApi_.requestFullscreen && (En(Be, this.fsApi_.fullscreenchange, this.boundDocumentFullscreenChange_), this.on(this.fsApi_.fullscreenchange, this.boundDocumentFullscreenChange_)), this.fluid_ && this.on(["playerreset", "resize"], this.boundUpdateStyleEl_);
    const r = yt(this.options_);
    if (t.plugins && Object.keys(t.plugins).forEach((s) => {
      this[s](t.plugins[s]);
    }), t.debug && this.debug(!0), this.options_.playerOptions = r, this.middleware_ = [], this.playbackRates(t.playbackRates), t.experimentalSvgIcons) {
      const o = new me.DOMParser().parseFromString(EO, "image/svg+xml");
      if (o.querySelector("parsererror"))
        at.warn("Failed to load SVG Icons. Falling back to Font Icons."), this.options_.experimentalSvgIcons = null;
      else {
        const c = o.documentElement;
        c.style.display = "none", this.el_.appendChild(c), this.addClass("vjs-svg-icons-enabled");
      }
    }
    this.initChildren(), this.isAudio(e.nodeName.toLowerCase() === "audio"), this.controls() ? this.addClass("vjs-controls-enabled") : this.addClass("vjs-controls-disabled"), this.el_.setAttribute("role", "region"), this.isAudio() ? this.el_.setAttribute("aria-label", this.localize("Audio Player")) : this.el_.setAttribute("aria-label", this.localize("Video Player")), this.isAudio() && this.addClass("vjs-audio"), t.spatialNavigation && t.spatialNavigation.enabled && (this.spatialNavigation = new DO(this), this.addClass("vjs-spatial-navigation-enabled")), Qs && this.addClass("vjs-touch-enabled"), Gt || this.addClass("vjs-workinghover"), dt.players[this.id_] = this;
    const a = dm.split(".")[0];
    this.addClass(`vjs-v${a}`), this.userActive(!0), this.reportUserActivity(), this.one("play", (s) => this.listenForUserActivity_(s)), this.on("keydown", (s) => this.handleKeyDown(s)), this.on("languagechange", (s) => this.handleLanguagechange(s)), this.breakpoints(this.options_.breakpoints), this.responsive(this.options_.responsive), this.on("ready", () => {
      this.audioPosterMode(this.options_.audioPosterMode), this.audioOnlyMode(this.options_.audioOnlyMode);
    });
  }
  /**
   * Destroys the video player and does any necessary cleanup.
   *
   * This is especially helpful if you are dynamically adding and removing videos
   * to/from the DOM.
   *
   * @fires Player#dispose
   */
  dispose() {
    this.trigger("dispose"), this.off("dispose"), Xt(Be, this.fsApi_.fullscreenchange, this.boundDocumentFullscreenChange_), Xt(Be, "keydown", this.boundFullWindowOnEscKey_), this.styleEl_ && this.styleEl_.parentNode && (this.styleEl_.parentNode.removeChild(this.styleEl_), this.styleEl_ = null), dt.players[this.id_] = null, this.tag && this.tag.player && (this.tag.player = null), this.el_ && this.el_.player && (this.el_.player = null), this.tech_ && (this.tech_.dispose(), this.isPosterFromTech_ = !1, this.poster_ = ""), this.playerElIngest_ && (this.playerElIngest_ = null), this.tag && (this.tag = null), xO(this), on.names.forEach((e) => {
      const t = on[e], i = this[t.getterName]();
      i && i.off && i.off();
    }), super.dispose({
      restoreEl: this.options_.restoreEl
    });
  }
  /**
   * Create the `Player`'s DOM element.
   *
   * @return {Element}
   *         The DOM element that gets created.
   */
  createEl() {
    let e = this.tag, t, i = this.playerElIngest_ = e.parentNode && e.parentNode.hasAttribute && e.parentNode.hasAttribute("data-vjs-player");
    const r = this.tag.tagName.toLowerCase() === "video-js";
    i ? t = this.el_ = e.parentNode : r || (t = this.el_ = super.createEl("div"));
    const a = Ki(e);
    if (r) {
      for (t = this.el_ = e, e = this.tag = Be.createElement("video"); t.children.length; )
        e.appendChild(t.firstChild);
      Os(t, "video-js") || Rr(t, "video-js"), t.appendChild(e), i = this.playerElIngest_ = t, Object.keys(t).forEach((u) => {
        try {
          e[u] = t[u];
        } catch {
        }
      });
    }
    e.setAttribute("tabindex", "-1"), a.tabindex = "-1", _i && ml && (e.setAttribute("role", "application"), a.role = "application"), e.removeAttribute("width"), e.removeAttribute("height"), "width" in a && delete a.width, "height" in a && delete a.height, Object.getOwnPropertyNames(a).forEach(function(u) {
      r && u === "class" || t.setAttribute(u, a[u]), r && e.setAttribute(u, a[u]);
    }), e.playerId = e.id, e.id += "_html5_api", e.className = "vjs-tech", e.player = t.player = this, this.addClass("vjs-paused");
    const s = ["IS_SMART_TV", "IS_TIZEN", "IS_WEBOS", "IS_ANDROID", "IS_IPAD", "IS_IPHONE", "IS_CHROMECAST_RECEIVER"].filter((u) => AD[u]).map((u) => "vjs-device-" + u.substring(3).toLowerCase().replace(/\_/g, "-"));
    if (this.addClass(...s), me.VIDEOJS_NO_DYNAMIC_STYLE !== !0) {
      this.styleEl_ = VD("vjs-styles-dimensions");
      const u = ir(".vjs-styles-defaults"), c = ir("head");
      c.insertBefore(this.styleEl_, u ? u.nextSibling : c.firstChild);
    }
    this.fill_ = !1, this.fluid_ = !1, this.width(this.options_.width), this.height(this.options_.height), this.fill(this.options_.fill), this.fluid(this.options_.fluid), this.aspectRatio(this.options_.aspectRatio), this.crossOrigin(this.options_.crossOrigin || this.options_.crossorigin);
    const o = e.getElementsByTagName("a");
    for (let u = 0; u < o.length; u++) {
      const c = o.item(u);
      Rr(c, "vjs-hidden"), c.setAttribute("hidden", "hidden");
    }
    return e.initNetworkState_ = e.networkState, e.parentNode && !i && e.parentNode.insertBefore(t, e), hm(e, t), this.children_.unshift(e), this.el_.setAttribute("lang", this.language_), this.el_.setAttribute("translate", "no"), this.el_ = t, t;
  }
  /**
   * Get or set the `Player`'s crossOrigin option. For the HTML5 player, this
   * sets the `crossOrigin` property on the `<video>` tag to control the CORS
   * behavior.
   *
   * @see [Video Element Attributes]{@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/video#attr-crossorigin}
   *
   * @param {string|null} [value]
   *        The value to set the `Player`'s crossOrigin to. If an argument is
   *        given, must be one of `'anonymous'` or `'use-credentials'`, or 'null'.
   *
   * @return {string|null|undefined}
   *         - The current crossOrigin value of the `Player` when getting.
   *         - undefined when setting
   */
  crossOrigin(e) {
    if (typeof e > "u")
      return this.techGet_("crossOrigin");
    if (e !== null && e !== "anonymous" && e !== "use-credentials") {
      at.warn(`crossOrigin must be null,  "anonymous" or "use-credentials", given "${e}"`);
      return;
    }
    this.techCall_("setCrossOrigin", e), this.posterImage && this.posterImage.crossOrigin(e);
  }
  /**
   * A getter/setter for the `Player`'s width. Returns the player's configured value.
   * To get the current width use `currentWidth()`.
   *
   * @param {number|string} [value]
   *        CSS value to set the `Player`'s width to.
   *
   * @return {number|undefined}
   *         - The current width of the `Player` when getting.
   *         - Nothing when setting
   */
  width(e) {
    return this.dimension("width", e);
  }
  /**
   * A getter/setter for the `Player`'s height. Returns the player's configured value.
   * To get the current height use `currentheight()`.
   *
   * @param {number|string} [value]
   *        CSS value to set the `Player`'s height to.
   *
   * @return {number|undefined}
   *         - The current height of the `Player` when getting.
   *         - Nothing when setting
   */
  height(e) {
    return this.dimension("height", e);
  }
  /**
   * A getter/setter for the `Player`'s width & height.
   *
   * @param {string} dimension
   *        This string can be:
   *        - 'width'
   *        - 'height'
   *
   * @param {number|string} [value]
   *        Value for dimension specified in the first argument.
   *
   * @return {number}
   *         The dimension arguments value when getting (width/height).
   */
  dimension(e, t) {
    const i = e + "_";
    if (t === void 0)
      return this[i] || 0;
    if (t === "" || t === "auto") {
      this[i] = void 0, this.updateStyleEl_();
      return;
    }
    const r = parseFloat(t);
    if (isNaN(r)) {
      at.error(`Improper value "${t}" supplied for for ${e}`);
      return;
    }
    this[i] = r, this.updateStyleEl_();
  }
  /**
   * A getter/setter/toggler for the vjs-fluid `className` on the `Player`.
   *
   * Turning this on will turn off fill mode.
   *
   * @param {boolean} [bool]
   *        - A value of true adds the class.
   *        - A value of false removes the class.
   *        - No value will be a getter.
   *
   * @return {boolean|undefined}
   *         - The value of fluid when getting.
   *         - `undefined` when setting.
   */
  fluid(e) {
    if (e === void 0)
      return !!this.fluid_;
    this.fluid_ = !!e, Oi(this) && this.off(["playerreset", "resize"], this.boundUpdateStyleEl_), e ? (this.addClass("vjs-fluid"), this.fill(!1), ZR(this, () => {
      this.on(["playerreset", "resize"], this.boundUpdateStyleEl_);
    })) : this.removeClass("vjs-fluid"), this.updateStyleEl_();
  }
  /**
   * A getter/setter/toggler for the vjs-fill `className` on the `Player`.
   *
   * Turning this on will turn off fluid mode.
   *
   * @param {boolean} [bool]
   *        - A value of true adds the class.
   *        - A value of false removes the class.
   *        - No value will be a getter.
   *
   * @return {boolean|undefined}
   *         - The value of fluid when getting.
   *         - `undefined` when setting.
   */
  fill(e) {
    if (e === void 0)
      return !!this.fill_;
    this.fill_ = !!e, e ? (this.addClass("vjs-fill"), this.fluid(!1)) : this.removeClass("vjs-fill");
  }
  /**
   * Get/Set the aspect ratio
   *
   * @param {string} [ratio]
   *        Aspect ratio for player
   *
   * @return {string|undefined}
   *         returns the current aspect ratio when getting
   */
  /**
   * A getter/setter for the `Player`'s aspect ratio.
   *
   * @param {string} [ratio]
   *        The value to set the `Player`'s aspect ratio to.
   *
   * @return {string|undefined}
   *         - The current aspect ratio of the `Player` when getting.
   *         - undefined when setting
   */
  aspectRatio(e) {
    if (e === void 0)
      return this.aspectRatio_;
    if (!/^\d+\:\d+$/.test(e))
      throw new Error("Improper value supplied for aspect ratio. The format should be width:height, for example 16:9.");
    this.aspectRatio_ = e, this.fluid(!0), this.updateStyleEl_();
  }
  /**
   * Update styles of the `Player` element (height, width and aspect ratio).
   *
   * @private
   * @listens Tech#loadedmetadata
   */
  updateStyleEl_() {
    if (me.VIDEOJS_NO_DYNAMIC_STYLE === !0) {
      const o = typeof this.width_ == "number" ? this.width_ : this.options_.width, u = typeof this.height_ == "number" ? this.height_ : this.options_.height, c = this.tech_ && this.tech_.el();
      c && (o >= 0 && (c.width = o), u >= 0 && (c.height = u));
      return;
    }
    let e, t, i, r;
    this.aspectRatio_ !== void 0 && this.aspectRatio_ !== "auto" ? i = this.aspectRatio_ : this.videoWidth() > 0 ? i = this.videoWidth() + ":" + this.videoHeight() : i = "16:9";
    const a = i.split(":"), s = a[1] / a[0];
    this.width_ !== void 0 ? e = this.width_ : this.height_ !== void 0 ? e = this.height_ / s : e = this.videoWidth() || 300, this.height_ !== void 0 ? t = this.height_ : t = e * s, /^[^a-zA-Z]/.test(this.id()) ? r = "dimensions-" + this.id() : r = this.id() + "-dimensions", this.addClass(r), HD(this.styleEl_, `
      .${r} {
        width: ${e}px;
        height: ${t}px;
      }

      .${r}.vjs-fluid:not(.vjs-audio-only-mode) {
        padding-top: ${s * 100}%;
      }
    `);
  }
  /**
   * Load/Create an instance of playback {@link Tech} including element
   * and API methods. Then append the `Tech` element in `Player` as a child.
   *
   * @param {string} techName
   *        name of the playback technology
   *
   * @param {string} source
   *        video source
   *
   * @private
   */
  loadTech_(e, t) {
    this.tech_ && this.unloadTech_();
    const i = Rt(e), r = e.charAt(0).toLowerCase() + e.slice(1);
    i !== "Html5" && this.tag && (tt.getTech("Html5").disposeMediaElement(this.tag), this.tag.player = null, this.tag = null), this.techName_ = i, this.isReady_ = !1;
    let a = this.autoplay();
    (typeof this.autoplay() == "string" || this.autoplay() === !0 && this.options_.normalizeAutoplay) && (a = !1);
    const s = {
      source: t,
      autoplay: a,
      nativeControlsForTouch: this.options_.nativeControlsForTouch,
      playerId: this.id(),
      techId: `${this.id()}_${r}_api`,
      playsinline: this.options_.playsinline,
      preload: this.options_.preload,
      loop: this.options_.loop,
      disablePictureInPicture: this.options_.disablePictureInPicture,
      muted: this.options_.muted,
      poster: this.poster(),
      language: this.language(),
      playerElIngest: this.playerElIngest_ || !1,
      "vtt.js": this.options_["vtt.js"],
      canOverridePoster: !!this.options_.techCanOverridePoster,
      enableSourceset: this.options_.enableSourceset
    };
    on.names.forEach((u) => {
      const c = on[u];
      s[c.getterName] = this[c.privateName];
    }), Object.assign(s, this.options_[i]), Object.assign(s, this.options_[r]), Object.assign(s, this.options_[e.toLowerCase()]), this.tag && (s.tag = this.tag), t && t.src === this.cache_.src && this.cache_.currentTime > 0 && (s.startTime = this.cache_.currentTime);
    const o = tt.getTech(e);
    if (!o)
      throw new Error(`No Tech named '${i}' exists! '${i}' should be registered using videojs.registerTech()'`);
    this.tech_ = new o(s), this.tech_.ready(_t(this, this.handleTechReady_), !0), vm.jsonToTextTracks(this.textTracksJson_ || [], this.tech_), NS.forEach((u) => {
      this.on(this.tech_, u, (c) => this[`handleTech${Rt(u)}_`](c));
    }), Object.keys(Pp).forEach((u) => {
      this.on(this.tech_, u, (c) => {
        if (this.tech_.playbackRate() === 0 && this.tech_.seeking()) {
          this.queuedCallbacks_.push({
            callback: this[`handleTech${Pp[u]}_`].bind(this),
            event: c
          });
          return;
        }
        this[`handleTech${Pp[u]}_`](c);
      });
    }), this.on(this.tech_, "loadstart", (u) => this.handleTechLoadStart_(u)), this.on(this.tech_, "sourceset", (u) => this.handleTechSourceset_(u)), this.on(this.tech_, "waiting", (u) => this.handleTechWaiting_(u)), this.on(this.tech_, "ended", (u) => this.handleTechEnded_(u)), this.on(this.tech_, "seeking", (u) => this.handleTechSeeking_(u)), this.on(this.tech_, "play", (u) => this.handleTechPlay_(u)), this.on(this.tech_, "pause", (u) => this.handleTechPause_(u)), this.on(this.tech_, "durationchange", (u) => this.handleTechDurationChange_(u)), this.on(this.tech_, "fullscreenchange", (u, c) => this.handleTechFullscreenChange_(u, c)), this.on(this.tech_, "fullscreenerror", (u, c) => this.handleTechFullscreenError_(u, c)), this.on(this.tech_, "enterpictureinpicture", (u) => this.handleTechEnterPictureInPicture_(u)), this.on(this.tech_, "leavepictureinpicture", (u) => this.handleTechLeavePictureInPicture_(u)), this.on(this.tech_, "error", (u) => this.handleTechError_(u)), this.on(this.tech_, "posterchange", (u) => this.handleTechPosterChange_(u)), this.on(this.tech_, "textdata", (u) => this.handleTechTextData_(u)), this.on(this.tech_, "ratechange", (u) => this.handleTechRateChange_(u)), this.on(this.tech_, "loadedmetadata", this.boundUpdateStyleEl_), this.usingNativeControls(this.techGet_("controls")), this.controls() && !this.usingNativeControls() && this.addTechControlsListeners_(), this.tech_.el().parentNode !== this.el() && (i !== "Html5" || !this.tag) && hm(this.tech_.el(), this.el()), this.tag && (this.tag.player = null, this.tag = null);
  }
  /**
   * Unload and dispose of the current playback {@link Tech}.
   *
   * @private
   */
  unloadTech_() {
    on.names.forEach((e) => {
      const t = on[e];
      this[t.privateName] = this[t.getterName]();
    }), this.textTracksJson_ = vm.textTracksToJson(this.tech_), this.isReady_ = !1, this.tech_.dispose(), this.tech_ = !1, this.isPosterFromTech_ && (this.poster_ = "", this.trigger("posterchange")), this.isPosterFromTech_ = !1;
  }
  /**
   * Return a reference to the current {@link Tech}.
   * It will print a warning by default about the danger of using the tech directly
   * but any argument that is passed in will silence the warning.
   *
   * @param {*} [safety]
   *        Anything passed in to silence the warning
   *
   * @return {Tech}
   *         The Tech
   */
  tech(e) {
    return e === void 0 && at.warn(`Using the tech directly can be dangerous. I hope you know what you're doing.
See https://github.com/videojs/video.js/issues/2617 for more info.
`), this.tech_;
  }
  /**
   * An object that contains Video.js version.
   *
   * @typedef {Object} PlayerVersion
   *
   * @property {string} 'video.js' - Video.js version
   */
  /**
   * Returns an object with Video.js version.
   *
   * @return {PlayerVersion}
   *          An object with Video.js version.
   */
  version() {
    return {
      "video.js": dm
    };
  }
  /**
   * Set up click and touch listeners for the playback element
   *
   * - On desktops: a click on the video itself will toggle playback
   * - On mobile devices: a click on the video toggles controls
   *   which is done by toggling the user state between active and
   *   inactive
   * - A tap can signal that a user has become active or has become inactive
   *   e.g. a quick tap on an iPhone movie should reveal the controls. Another
   *   quick tap should hide them again (signaling the user is in an inactive
   *   viewing state)
   * - In addition to this, we still want the user to be considered inactive after
   *   a few seconds of inactivity.
   *
   * > Note: the only part of iOS interaction we can't mimic with this setup
   * is a touch and hold on the video element counting as activity in order to
   * keep the controls showing, but that shouldn't be an issue. A touch and hold
   * on any controls will still keep the user active
   *
   * @private
   */
  addTechControlsListeners_() {
    this.removeTechControlsListeners_(), this.on(this.tech_, "click", this.boundHandleTechClick_), this.on(this.tech_, "dblclick", this.boundHandleTechDoubleClick_), this.on(this.tech_, "touchstart", this.boundHandleTechTouchStart_), this.on(this.tech_, "touchmove", this.boundHandleTechTouchMove_), this.on(this.tech_, "touchend", this.boundHandleTechTouchEnd_), this.on(this.tech_, "tap", this.boundHandleTechTap_);
  }
  /**
   * Remove the listeners used for click and tap controls. This is needed for
   * toggling to controls disabled, where a tap/touch should do nothing.
   *
   * @private
   */
  removeTechControlsListeners_() {
    this.off(this.tech_, "tap", this.boundHandleTechTap_), this.off(this.tech_, "touchstart", this.boundHandleTechTouchStart_), this.off(this.tech_, "touchmove", this.boundHandleTechTouchMove_), this.off(this.tech_, "touchend", this.boundHandleTechTouchEnd_), this.off(this.tech_, "click", this.boundHandleTechClick_), this.off(this.tech_, "dblclick", this.boundHandleTechDoubleClick_);
  }
  /**
   * Player waits for the tech to be ready
   *
   * @private
   */
  handleTechReady_() {
    this.triggerReady(), this.cache_.volume && this.techCall_("setVolume", this.cache_.volume), this.handleTechPosterChange_(), this.handleTechDurationChange_();
  }
  /**
   * Retrigger the `loadstart` event that was triggered by the {@link Tech}.
   *
   * @fires Player#loadstart
   * @listens Tech#loadstart
   * @private
   */
  handleTechLoadStart_() {
    this.removeClass("vjs-ended", "vjs-seeking"), this.error(null), this.handleTechDurationChange_(), this.paused() ? (this.hasStarted(!1), this.trigger("loadstart")) : this.trigger("loadstart"), this.manualAutoplay_(this.autoplay() === !0 && this.options_.normalizeAutoplay ? "play" : this.autoplay());
  }
  /**
   * Handle autoplay string values, rather than the typical boolean
   * values that should be handled by the tech. Note that this is not
   * part of any specification. Valid values and what they do can be
   * found on the autoplay getter at Player#autoplay()
   */
  manualAutoplay_(e) {
    if (!this.tech_ || typeof e != "string")
      return;
    const t = () => {
      const r = this.muted();
      this.muted(!0);
      const a = () => {
        this.muted(r);
      };
      this.playTerminatedQueue_.push(a);
      const s = this.play();
      if (Ps(s))
        return s.catch((o) => {
          throw a(), new Error(`Rejection at manualAutoplay. Restoring muted value. ${o || ""}`);
        });
    };
    let i;
    if (e === "any" && !this.muted() ? (i = this.play(), Ps(i) && (i = i.catch(t))) : e === "muted" && !this.muted() ? i = t() : i = this.play(), !!Ps(i))
      return i.then(() => {
        this.trigger({
          type: "autoplay-success",
          autoplay: e
        });
      }).catch(() => {
        this.trigger({
          type: "autoplay-failure",
          autoplay: e
        });
      });
  }
  /**
   * Update the internal source caches so that we return the correct source from
   * `src()`, `currentSource()`, and `currentSources()`.
   *
   * > Note: `currentSources` will not be updated if the source that is passed in exists
   *         in the current `currentSources` cache.
   *
   *
   * @param {Tech~SourceObject} srcObj
   *        A string or object source to update our caches to.
   */
  updateSourceCaches_(e = "") {
    let t = e, i = "";
    typeof t != "string" && (t = e.src, i = e.type), this.cache_.source = this.cache_.source || {}, this.cache_.sources = this.cache_.sources || [], t && !i && (i = wO(this, t)), this.cache_.source = yt({}, e, {
      src: t,
      type: i
    });
    const r = this.cache_.sources.filter((u) => u.src && u.src === t), a = [], s = this.$$("source"), o = [];
    for (let u = 0; u < s.length; u++) {
      const c = Ki(s[u]);
      a.push(c), c.src && c.src === t && o.push(c.src);
    }
    o.length && !r.length ? this.cache_.sources = a : r.length || (this.cache_.sources = [this.cache_.source]), this.cache_.src = t;
  }
  /**
   * *EXPERIMENTAL* Fired when the source is set or changed on the {@link Tech}
   * causing the media element to reload.
   *
   * It will fire for the initial source and each subsequent source.
   * This event is a custom event from Video.js and is triggered by the {@link Tech}.
   *
   * The event object for this event contains a `src` property that will contain the source
   * that was available when the event was triggered. This is generally only necessary if Video.js
   * is switching techs while the source was being changed.
   *
   * It is also fired when `load` is called on the player (or media element)
   * because the {@link https://html.spec.whatwg.org/multipage/media.html#dom-media-load|specification for `load`}
   * says that the resource selection algorithm needs to be aborted and restarted.
   * In this case, it is very likely that the `src` property will be set to the
   * empty string `""` to indicate we do not know what the source will be but
   * that it is changing.
   *
   * *This event is currently still experimental and may change in minor releases.*
   * __To use this, pass `enableSourceset` option to the player.__
   *
   * @event Player#sourceset
   * @type {Event}
   * @prop {string} src
   *                The source url available when the `sourceset` was triggered.
   *                It will be an empty string if we cannot know what the source is
   *                but know that the source will change.
   */
  /**
   * Retrigger the `sourceset` event that was triggered by the {@link Tech}.
   *
   * @fires Player#sourceset
   * @listens Tech#sourceset
   * @private
   */
  handleTechSourceset_(e) {
    if (!this.changingSrc_) {
      let t = (a) => this.updateSourceCaches_(a);
      const i = this.currentSource().src, r = e.src;
      i && !/^blob:/.test(i) && /^blob:/.test(r) && (!this.lastSource_ || this.lastSource_.tech !== r && this.lastSource_.player !== i) && (t = () => {
      }), t(r), e.src || this.tech_.any(["sourceset", "loadstart"], (a) => {
        if (a.type === "sourceset")
          return;
        const s = this.techGet_("currentSrc");
        this.lastSource_.tech = s, this.updateSourceCaches_(s);
      });
    }
    this.lastSource_ = {
      player: this.currentSource().src,
      tech: e.src
    }, this.trigger({
      src: e.src,
      type: "sourceset"
    });
  }
  /**
   * Add/remove the vjs-has-started class
   *
   *
   * @param {boolean} request
   *        - true: adds the class
   *        - false: remove the class
   *
   * @return {boolean}
   *         the boolean value of hasStarted_
   */
  hasStarted(e) {
    if (e === void 0)
      return this.hasStarted_;
    e !== this.hasStarted_ && (this.hasStarted_ = e, this.hasStarted_ ? this.addClass("vjs-has-started") : this.removeClass("vjs-has-started"));
  }
  /**
   * Fired whenever the media begins or resumes playback
   *
   * @see [Spec]{@link https://html.spec.whatwg.org/multipage/embedded-content.html#dom-media-play}
   * @fires Player#play
   * @listens Tech#play
   * @private
   */
  handleTechPlay_() {
    this.removeClass("vjs-ended", "vjs-paused"), this.addClass("vjs-playing"), this.hasStarted(!0), this.trigger("play");
  }
  /**
   * Retrigger the `ratechange` event that was triggered by the {@link Tech}.
   *
   * If there were any events queued while the playback rate was zero, fire
   * those events now.
   *
   * @private
   * @method Player#handleTechRateChange_
   * @fires Player#ratechange
   * @listens Tech#ratechange
   */
  handleTechRateChange_() {
    this.tech_.playbackRate() > 0 && this.cache_.lastPlaybackRate === 0 && (this.queuedCallbacks_.forEach((e) => e.callback(e.event)), this.queuedCallbacks_ = []), this.cache_.lastPlaybackRate = this.tech_.playbackRate(), this.trigger("ratechange");
  }
  /**
   * Retrigger the `waiting` event that was triggered by the {@link Tech}.
   *
   * @fires Player#waiting
   * @listens Tech#waiting
   * @private
   */
  handleTechWaiting_() {
    this.addClass("vjs-waiting"), this.trigger("waiting");
    const e = this.currentTime(), t = () => {
      e !== this.currentTime() && (this.removeClass("vjs-waiting"), this.off("timeupdate", t));
    };
    this.on("timeupdate", t);
  }
  /**
   * Retrigger the `canplay` event that was triggered by the {@link Tech}.
   * > Note: This is not consistent between browsers. See #1351
   *
   * @fires Player#canplay
   * @listens Tech#canplay
   * @private
   */
  handleTechCanPlay_() {
    this.removeClass("vjs-waiting"), this.trigger("canplay");
  }
  /**
   * Retrigger the `canplaythrough` event that was triggered by the {@link Tech}.
   *
   * @fires Player#canplaythrough
   * @listens Tech#canplaythrough
   * @private
   */
  handleTechCanPlayThrough_() {
    this.removeClass("vjs-waiting"), this.trigger("canplaythrough");
  }
  /**
   * Retrigger the `playing` event that was triggered by the {@link Tech}.
   *
   * @fires Player#playing
   * @listens Tech#playing
   * @private
   */
  handleTechPlaying_() {
    this.removeClass("vjs-waiting"), this.trigger("playing");
  }
  /**
   * Retrigger the `seeking` event that was triggered by the {@link Tech}.
   *
   * @fires Player#seeking
   * @listens Tech#seeking
   * @private
   */
  handleTechSeeking_() {
    this.addClass("vjs-seeking"), this.trigger("seeking");
  }
  /**
   * Retrigger the `seeked` event that was triggered by the {@link Tech}.
   *
   * @fires Player#seeked
   * @listens Tech#seeked
   * @private
   */
  handleTechSeeked_() {
    this.removeClass("vjs-seeking", "vjs-ended"), this.trigger("seeked");
  }
  /**
   * Retrigger the `pause` event that was triggered by the {@link Tech}.
   *
   * @fires Player#pause
   * @listens Tech#pause
   * @private
   */
  handleTechPause_() {
    this.removeClass("vjs-playing"), this.addClass("vjs-paused"), this.trigger("pause");
  }
  /**
   * Retrigger the `ended` event that was triggered by the {@link Tech}.
   *
   * @fires Player#ended
   * @listens Tech#ended
   * @private
   */
  handleTechEnded_() {
    this.addClass("vjs-ended"), this.removeClass("vjs-waiting"), this.options_.loop ? (this.currentTime(0), this.play()) : this.paused() || this.pause(), this.trigger("ended");
  }
  /**
   * Fired when the duration of the media resource is first known or changed
   *
   * @listens Tech#durationchange
   * @private
   */
  handleTechDurationChange_() {
    this.duration(this.techGet_("duration"));
  }
  /**
   * Handle a click on the media element to play/pause
   *
   * @param {Event} event
   *        the event that caused this function to trigger
   *
   * @listens Tech#click
   * @private
   */
  handleTechClick_(e) {
    this.controls_ && (this.options_ === void 0 || this.options_.userActions === void 0 || this.options_.userActions.click === void 0 || this.options_.userActions.click !== !1) && (this.options_ !== void 0 && this.options_.userActions !== void 0 && typeof this.options_.userActions.click == "function" ? this.options_.userActions.click.call(this, e) : this.paused() ? mi(this.play()) : this.pause());
  }
  /**
   * Handle a double-click on the media element to enter/exit fullscreen,
   * or exit documentPictureInPicture mode
   *
   * @param {Event} event
   *        the event that caused this function to trigger
   *
   * @listens Tech#dblclick
   * @private
   */
  handleTechDoubleClick_(e) {
    if (!this.controls_)
      return;
    Array.prototype.some.call(this.$$(".vjs-control-bar, .vjs-modal-dialog"), (i) => i.contains(e.target)) || (this.options_ === void 0 || this.options_.userActions === void 0 || this.options_.userActions.doubleClick === void 0 || this.options_.userActions.doubleClick !== !1) && (this.options_ !== void 0 && this.options_.userActions !== void 0 && typeof this.options_.userActions.doubleClick == "function" ? this.options_.userActions.doubleClick.call(this, e) : this.isInPictureInPicture() && !Be.pictureInPictureElement ? this.exitPictureInPicture() : this.isFullscreen() ? this.exitFullscreen() : this.requestFullscreen());
  }
  /**
   * Handle a tap on the media element. It will toggle the user
   * activity state, which hides and shows the controls.
   *
   * @listens Tech#tap
   * @private
   */
  handleTechTap_() {
    this.userActive(!this.userActive());
  }
  /**
   * Handle touch to start
   *
   * @listens Tech#touchstart
   * @private
   */
  handleTechTouchStart_() {
    this.userWasActive = this.userActive();
  }
  /**
   * Handle touch to move
   *
   * @listens Tech#touchmove
   * @private
   */
  handleTechTouchMove_() {
    this.userWasActive && this.reportUserActivity();
  }
  /**
   * Handle touch to end
   *
   * @param {Event} event
   *        the touchend event that triggered
   *        this function
   *
   * @listens Tech#touchend
   * @private
   */
  handleTechTouchEnd_(e) {
    e.cancelable && e.preventDefault();
  }
  /**
   * @private
   */
  toggleFullscreenClass_() {
    this.isFullscreen() ? this.addClass("vjs-fullscreen") : this.removeClass("vjs-fullscreen");
  }
  /**
   * when the document fschange event triggers it calls this
   */
  documentFullscreenChange_(e) {
    const t = e.target.player;
    if (t && t !== this)
      return;
    const i = this.el();
    let r = Be[this.fsApi_.fullscreenElement] === i;
    !r && i.matches && (r = i.matches(":" + this.fsApi_.fullscreen)), this.isFullscreen(r);
  }
  /**
   * Handle Tech Fullscreen Change
   *
   * @param {Event} event
   *        the fullscreenchange event that triggered this function
   *
   * @param {Object} data
   *        the data that was sent with the event
   *
   * @private
   * @listens Tech#fullscreenchange
   * @fires Player#fullscreenchange
   */
  handleTechFullscreenChange_(e, t) {
    t && (t.nativeIOSFullscreen && (this.addClass("vjs-ios-native-fs"), this.tech_.one("webkitendfullscreen", () => {
      this.removeClass("vjs-ios-native-fs");
    })), this.isFullscreen(t.isFullscreen));
  }
  handleTechFullscreenError_(e, t) {
    this.trigger("fullscreenerror", t);
  }
  /**
   * @private
   */
  togglePictureInPictureClass_() {
    this.isInPictureInPicture() ? this.addClass("vjs-picture-in-picture") : this.removeClass("vjs-picture-in-picture");
  }
  /**
   * Handle Tech Enter Picture-in-Picture.
   *
   * @param {Event} event
   *        the enterpictureinpicture event that triggered this function
   *
   * @private
   * @listens Tech#enterpictureinpicture
   */
  handleTechEnterPictureInPicture_(e) {
    this.isInPictureInPicture(!0);
  }
  /**
   * Handle Tech Leave Picture-in-Picture.
   *
   * @param {Event} event
   *        the leavepictureinpicture event that triggered this function
   *
   * @private
   * @listens Tech#leavepictureinpicture
   */
  handleTechLeavePictureInPicture_(e) {
    this.isInPictureInPicture(!1);
  }
  /**
   * Fires when an error occurred during the loading of an audio/video.
   *
   * @private
   * @listens Tech#error
   */
  handleTechError_() {
    const e = this.tech_.error();
    e && this.error(e);
  }
  /**
   * Retrigger the `textdata` event that was triggered by the {@link Tech}.
   *
   * @fires Player#textdata
   * @listens Tech#textdata
   * @private
   */
  handleTechTextData_() {
    let e = null;
    arguments.length > 1 && (e = arguments[1]), this.trigger("textdata", e);
  }
  /**
   * Get object for cached values.
   *
   * @return {Object}
   *         get the current object cache
   */
  getCache() {
    return this.cache_;
  }
  /**
   * Resets the internal cache object.
   *
   * Using this function outside the player constructor or reset method may
   * have unintended side-effects.
   *
   * @private
   */
  resetCache_() {
    this.cache_ = {
      // Right now, the currentTime is not _really_ cached because it is always
      // retrieved from the tech (see: currentTime). However, for completeness,
      // we set it to zero here to ensure that if we do start actually caching
      // it, we reset it along with everything else.
      currentTime: 0,
      initTime: 0,
      inactivityTimeout: this.options_.inactivityTimeout,
      duration: NaN,
      lastVolume: 1,
      lastPlaybackRate: this.defaultPlaybackRate(),
      media: null,
      src: "",
      source: {},
      sources: [],
      playbackRates: [],
      volume: 1
    };
  }
  /**
   * Pass values to the playback tech
   *
   * @param {string} [method]
   *        the method to call
   *
   * @param {Object} [arg]
   *        the argument to pass
   *
   * @private
   */
  techCall_(e, t) {
    this.ready(function() {
      if (e in yO)
        return gO(this.middleware_, this.tech_, e, t);
      if (e in E_)
        return w_(this.middleware_, this.tech_, e, t);
      try {
        this.tech_ && this.tech_[e](t);
      } catch (i) {
        throw at(i), i;
      }
    }, !0);
  }
  /**
   * Mediate attempt to call playback tech method
   * and return the value of the method called.
   *
   * @param {string} method
   *        Tech method
   *
   * @return {*}
   *         Value returned by the tech method called, undefined if tech
   *         is not ready or tech method is not present
   *
   * @private
   */
  techGet_(e) {
    if (!(!this.tech_ || !this.tech_.isReady_)) {
      if (e in bO)
        return mO(this.middleware_, this.tech_, e);
      if (e in E_)
        return w_(this.middleware_, this.tech_, e);
      try {
        return this.tech_[e]();
      } catch (t) {
        throw this.tech_[e] === void 0 ? (at(`Video.js: ${e} method not defined for ${this.techName_} playback technology.`, t), t) : t.name === "TypeError" ? (at(`Video.js: ${e} unavailable on ${this.techName_} playback technology element.`, t), this.tech_.isReady_ = !1, t) : (at(t), t);
      }
    }
  }
  /**
   * Attempt to begin playback at the first opportunity.
   *
   * @return {Promise|undefined}
   *         Returns a promise if the browser supports Promises (or one
   *         was passed in as an option). This promise will be resolved on
   *         the return value of play. If this is undefined it will fulfill the
   *         promise chain otherwise the promise chain will be fulfilled when
   *         the promise from play is fulfilled.
   */
  play() {
    return new Promise((e) => {
      this.play_(e);
    });
  }
  /**
   * The actual logic for play, takes a callback that will be resolved on the
   * return value of play. This allows us to resolve to the play promise if there
   * is one on modern browsers.
   *
   * @private
   * @param {Function} [callback]
   *        The callback that should be called when the techs play is actually called
   */
  play_(e = mi) {
    this.playCallbacks_.push(e);
    const t = !!(!this.changingSrc_ && (this.src() || this.currentSrc())), i = !!(bl || Gt);
    if (this.waitToPlay_ && (this.off(["ready", "loadstart"], this.waitToPlay_), this.waitToPlay_ = null), !this.isReady_ || !t) {
      this.waitToPlay_ = (s) => {
        this.play_();
      }, this.one(["ready", "loadstart"], this.waitToPlay_), !t && i && this.load();
      return;
    }
    const r = this.techGet_("play");
    i && this.hasClass("vjs-ended") && this.resetProgressBar_(), r === null ? this.runPlayTerminatedQueue_() : this.runPlayCallbacks_(r);
  }
  /**
   * These functions will be run when if play is terminated. If play
   * runPlayCallbacks_ is run these function will not be run. This allows us
   * to differentiate between a terminated play and an actual call to play.
   */
  runPlayTerminatedQueue_() {
    const e = this.playTerminatedQueue_.slice(0);
    this.playTerminatedQueue_ = [], e.forEach(function(t) {
      t();
    });
  }
  /**
   * When a callback to play is delayed we have to run these
   * callbacks when play is actually called on the tech. This function
   * runs the callbacks that were delayed and accepts the return value
   * from the tech.
   *
   * @param {undefined|Promise} val
   *        The return value from the tech.
   */
  runPlayCallbacks_(e) {
    const t = this.playCallbacks_.slice(0);
    this.playCallbacks_ = [], this.playTerminatedQueue_ = [], t.forEach(function(i) {
      i(e);
    });
  }
  /**
   * Pause the video playback
   */
  pause() {
    this.techCall_("pause");
  }
  /**
   * Check if the player is paused or has yet to play
   *
   * @return {boolean}
   *         - false: if the media is currently playing
   *         - true: if media is not currently playing
   */
  paused() {
    return this.techGet_("paused") !== !1;
  }
  /**
   * Get a TimeRange object representing the current ranges of time that the user
   * has played.
   *
   * @return {TimeRange}
   *         A time range object that represents all the increments of time that have
   *         been played.
   */
  played() {
    return this.techGet_("played") || ii(0, 0);
  }
  /**
   * Sets or returns whether or not the user is "scrubbing". Scrubbing is
   * when the user has clicked the progress bar handle and is
   * dragging it along the progress bar.
   *
   * @param {boolean} [isScrubbing]
   *        whether the user is or is not scrubbing
   *
   * @return {boolean|undefined}
   *         - The value of scrubbing when getting
   *         - Nothing when setting
   */
  scrubbing(e) {
    if (typeof e > "u")
      return this.scrubbing_;
    this.scrubbing_ = !!e, this.techCall_("setScrubbing", this.scrubbing_), e ? this.addClass("vjs-scrubbing") : this.removeClass("vjs-scrubbing");
  }
  /**
   * Get or set the current time (in seconds)
   *
   * @param {number|string} [seconds]
   *        The time to seek to in seconds
   *
   * @return {number|undefined}
   *         - the current time in seconds when getting
   *         - Nothing when setting
   */
  currentTime(e) {
    if (e === void 0)
      return this.cache_.currentTime = this.techGet_("currentTime") || 0, this.cache_.currentTime;
    if (e < 0 && (e = 0), !this.isReady_ || this.changingSrc_ || !this.tech_ || !this.tech_.isReady_) {
      this.cache_.initTime = e, this.off("canplay", this.boundApplyInitTime_), this.one("canplay", this.boundApplyInitTime_);
      return;
    }
    this.techCall_("setCurrentTime", e), this.cache_.initTime = 0, isFinite(e) && (this.cache_.currentTime = Number(e));
  }
  /**
   * Apply the value of initTime stored in cache as currentTime.
   *
   * @private
   */
  applyInitTime_() {
    this.currentTime(this.cache_.initTime);
  }
  /**
   * Normally gets the length in time of the video in seconds;
   * in all but the rarest use cases an argument will NOT be passed to the method
   *
   * > **NOTE**: The video must have started loading before the duration can be
   * known, and depending on preload behaviour may not be known until the video starts
   * playing.
   *
   * @fires Player#durationchange
   *
   * @param {number} [seconds]
   *        The duration of the video to set in seconds
   *
   * @return {number|undefined}
   *         - The duration of the video in seconds when getting
   *         - Nothing when setting
   */
  duration(e) {
    if (e === void 0)
      return this.cache_.duration !== void 0 ? this.cache_.duration : NaN;
    e = parseFloat(e), e < 0 && (e = 1 / 0), e !== this.cache_.duration && (this.cache_.duration = e, e === 1 / 0 ? this.addClass("vjs-live") : this.removeClass("vjs-live"), isNaN(e) || this.trigger("durationchange"));
  }
  /**
   * Calculates how much time is left in the video. Not part
   * of the native video API.
   *
   * @return {number}
   *         The time remaining in seconds
   */
  remainingTime() {
    return this.duration() - this.currentTime();
  }
  /**
   * A remaining time function that is intended to be used when
   * the time is to be displayed directly to the user.
   *
   * @return {number}
   *         The rounded time remaining in seconds
   */
  remainingTimeDisplay() {
    return Math.floor(this.duration()) - Math.floor(this.currentTime());
  }
  //
  // Kind of like an array of portions of the video that have been downloaded.
  /**
   * Get a TimeRange object with an array of the times of the video
   * that have been downloaded. If you just want the percent of the
   * video that's been downloaded, use bufferedPercent.
   *
   * @see [Buffered Spec]{@link http://dev.w3.org/html5/spec/video.html#dom-media-buffered}
   *
   * @return {TimeRange}
   *         A mock {@link TimeRanges} object (following HTML spec)
   */
  buffered() {
    let e = this.techGet_("buffered");
    return (!e || !e.length) && (e = ii(0, 0)), e;
  }
  /**
   * Get the TimeRanges of the media that are currently available
   * for seeking to.
   *
   * @see [Seekable Spec]{@link https://html.spec.whatwg.org/multipage/media.html#dom-media-seekable}
   *
   * @return {TimeRange}
   *         A mock {@link TimeRanges} object (following HTML spec)
   */
  seekable() {
    let e = this.techGet_("seekable");
    return (!e || !e.length) && (e = ii(0, 0)), e;
  }
  /**
   * Returns whether the player is in the "seeking" state.
   *
   * @return {boolean} True if the player is in the seeking state, false if not.
   */
  seeking() {
    return this.techGet_("seeking");
  }
  /**
   * Returns whether the player is in the "ended" state.
   *
   * @return {boolean} True if the player is in the ended state, false if not.
   */
  ended() {
    return this.techGet_("ended");
  }
  /**
   * Returns the current state of network activity for the element, from
   * the codes in the list below.
   * - NETWORK_EMPTY (numeric value 0)
   *   The element has not yet been initialised. All attributes are in
   *   their initial states.
   * - NETWORK_IDLE (numeric value 1)
   *   The element's resource selection algorithm is active and has
   *   selected a resource, but it is not actually using the network at
   *   this time.
   * - NETWORK_LOADING (numeric value 2)
   *   The user agent is actively trying to download data.
   * - NETWORK_NO_SOURCE (numeric value 3)
   *   The element's resource selection algorithm is active, but it has
   *   not yet found a resource to use.
   *
   * @see https://html.spec.whatwg.org/multipage/embedded-content.html#network-states
   * @return {number} the current network activity state
   */
  networkState() {
    return this.techGet_("networkState");
  }
  /**
   * Returns a value that expresses the current state of the element
   * with respect to rendering the current playback position, from the
   * codes in the list below.
   * - HAVE_NOTHING (numeric value 0)
   *   No information regarding the media resource is available.
   * - HAVE_METADATA (numeric value 1)
   *   Enough of the resource has been obtained that the duration of the
   *   resource is available.
   * - HAVE_CURRENT_DATA (numeric value 2)
   *   Data for the immediate current playback position is available.
   * - HAVE_FUTURE_DATA (numeric value 3)
   *   Data for the immediate current playback position is available, as
   *   well as enough data for the user agent to advance the current
   *   playback position in the direction of playback.
   * - HAVE_ENOUGH_DATA (numeric value 4)
   *   The user agent estimates that enough data is available for
   *   playback to proceed uninterrupted.
   *
   * @see https://html.spec.whatwg.org/multipage/embedded-content.html#dom-media-readystate
   * @return {number} the current playback rendering state
   */
  readyState() {
    return this.techGet_("readyState");
  }
  /**
   * Get the percent (as a decimal) of the video that's been downloaded.
   * This method is not a part of the native HTML video API.
   *
   * @return {number}
   *         A decimal between 0 and 1 representing the percent
   *         that is buffered 0 being 0% and 1 being 100%
   */
  bufferedPercent() {
    return JD(this.buffered(), this.duration());
  }
  /**
   * Get the ending time of the last buffered time range
   * This is used in the progress bar to encapsulate all time ranges.
   *
   * @return {number}
   *         The end of the last buffered time range
   */
  bufferedEnd() {
    const e = this.buffered(), t = this.duration();
    let i = e.end(e.length - 1);
    return i > t && (i = t), i;
  }
  /**
   * Get or set the current volume of the media
   *
   * @param  {number} [percentAsDecimal]
   *         The new volume as a decimal percent:
   *         - 0 is muted/0%/off
   *         - 1.0 is 100%/full
   *         - 0.5 is half volume or 50%
   *
   * @return {number|undefined}
   *         The current volume as a percent when getting
   */
  volume(e) {
    let t;
    if (e !== void 0) {
      t = Math.max(0, Math.min(1, e)), this.cache_.volume = t, this.techCall_("setVolume", t), t > 0 && this.lastVolume_(t);
      return;
    }
    return t = parseFloat(this.techGet_("volume")), isNaN(t) ? 1 : t;
  }
  /**
   * Get the current muted state, or turn mute on or off
   *
   * @param {boolean} [muted]
   *        - true to mute
   *        - false to unmute
   *
   * @return {boolean|undefined}
   *         - true if mute is on and getting
   *         - false if mute is off and getting
   *         - nothing if setting
   */
  muted(e) {
    if (e !== void 0) {
      this.techCall_("setMuted", e);
      return;
    }
    return this.techGet_("muted") || !1;
  }
  /**
   * Get the current defaultMuted state, or turn defaultMuted on or off. defaultMuted
   * indicates the state of muted on initial playback.
   *
   * ```js
   *   var myPlayer = videojs('some-player-id');
   *
   *   myPlayer.src("http://www.example.com/path/to/video.mp4");
   *
   *   // get, should be false
   *   console.log(myPlayer.defaultMuted());
   *   // set to true
   *   myPlayer.defaultMuted(true);
   *   // get should be true
   *   console.log(myPlayer.defaultMuted());
   * ```
   *
   * @param {boolean} [defaultMuted]
   *        - true to mute
   *        - false to unmute
   *
   * @return {boolean|undefined}
   *         - true if defaultMuted is on and getting
   *         - false if defaultMuted is off and getting
   *         - Nothing when setting
   */
  defaultMuted(e) {
    return e !== void 0 && this.techCall_("setDefaultMuted", e), this.techGet_("defaultMuted") || !1;
  }
  /**
   * Get the last volume, or set it
   *
   * @param  {number} [percentAsDecimal]
   *         The new last volume as a decimal percent:
   *         - 0 is muted/0%/off
   *         - 1.0 is 100%/full
   *         - 0.5 is half volume or 50%
   *
   * @return {number|undefined}
   *         - The current value of lastVolume as a percent when getting
   *         - Nothing when setting
   *
   * @private
   */
  lastVolume_(e) {
    if (e !== void 0 && e !== 0) {
      this.cache_.lastVolume = e;
      return;
    }
    return this.cache_.lastVolume;
  }
  /**
   * Check if current tech can support native fullscreen
   * (e.g. with built in controls like iOS)
   *
   * @return {boolean}
   *         if native fullscreen is supported
   */
  supportsFullScreen() {
    return this.techGet_("supportsFullScreen") || !1;
  }
  /**
   * Check if the player is in fullscreen mode or tell the player that it
   * is or is not in fullscreen mode.
   *
   * > NOTE: As of the latest HTML5 spec, isFullscreen is no longer an official
   * property and instead document.fullscreenElement is used. But isFullscreen is
   * still a valuable property for internal player workings.
   *
   * @param  {boolean} [isFS]
   *         Set the players current fullscreen state
   *
   * @return {boolean|undefined}
   *         - true if fullscreen is on and getting
   *         - false if fullscreen is off and getting
   *         - Nothing when setting
   */
  isFullscreen(e) {
    if (e !== void 0) {
      const t = this.isFullscreen_;
      this.isFullscreen_ = !!e, this.isFullscreen_ !== t && this.fsApi_.prefixed && this.trigger("fullscreenchange"), this.toggleFullscreenClass_();
      return;
    }
    return this.isFullscreen_;
  }
  /**
   * Increase the size of the video to full screen
   * In some browsers, full screen is not supported natively, so it enters
   * "full window mode", where the video fills the browser window.
   * In browsers and devices that support native full screen, sometimes the
   * browser's default controls will be shown, and not the Video.js custom skin.
   * This includes most mobile devices (iOS, Android) and older versions of
   * Safari.
   *
   * @param  {Object} [fullscreenOptions]
   *         Override the player fullscreen options
   *
   * @fires Player#fullscreenchange
   */
  requestFullscreen(e) {
    this.isInPictureInPicture() && this.exitPictureInPicture();
    const t = this;
    return new Promise((i, r) => {
      function a() {
        t.off("fullscreenerror", o), t.off("fullscreenchange", s);
      }
      function s() {
        a(), i();
      }
      function o(c, l) {
        a(), r(l);
      }
      t.one("fullscreenchange", s), t.one("fullscreenerror", o);
      const u = t.requestFullscreenHelper_(e);
      u && (u.then(a, a), u.then(i, r));
    });
  }
  requestFullscreenHelper_(e) {
    let t;
    if (this.fsApi_.prefixed || (t = this.options_.fullscreen && this.options_.fullscreen.options || {}, e !== void 0 && (t = e)), this.fsApi_.requestFullscreen) {
      const i = this.el_[this.fsApi_.requestFullscreen](t);
      return i && i.then(() => this.isFullscreen(!0), () => this.isFullscreen(!1)), i;
    } else this.tech_.supportsFullScreen() && !this.options_.preferFullWindow ? this.techCall_("enterFullScreen") : this.enterFullWindow();
  }
  /**
   * Return the video to its normal size after having been in full screen mode
   *
   * @fires Player#fullscreenchange
   */
  exitFullscreen() {
    const e = this;
    return new Promise((t, i) => {
      function r() {
        e.off("fullscreenerror", s), e.off("fullscreenchange", a);
      }
      function a() {
        r(), t();
      }
      function s(u, c) {
        r(), i(c);
      }
      e.one("fullscreenchange", a), e.one("fullscreenerror", s);
      const o = e.exitFullscreenHelper_();
      o && (o.then(r, r), o.then(t, i));
    });
  }
  exitFullscreenHelper_() {
    if (this.fsApi_.requestFullscreen) {
      const e = Be[this.fsApi_.exitFullscreen]();
      return e && mi(e.then(() => this.isFullscreen(!1))), e;
    } else this.tech_.supportsFullScreen() && !this.options_.preferFullWindow ? this.techCall_("exitFullScreen") : this.exitFullWindow();
  }
  /**
   * When fullscreen isn't supported we can stretch the
   * video container to as wide as the browser will let us.
   *
   * @fires Player#enterFullWindow
   */
  enterFullWindow() {
    this.isFullscreen(!0), this.isFullWindow = !0, this.docOrigOverflow = Be.documentElement.style.overflow, En(Be, "keydown", this.boundFullWindowOnEscKey_), Be.documentElement.style.overflow = "hidden", Rr(Be.body, "vjs-full-window"), this.trigger("enterFullWindow");
  }
  /**
   * Check for call to either exit full window or
   * full screen on ESC key
   *
   * @param {string} event
   *        Event to check for key press
   */
  fullWindowOnEscKey(e) {
    e.key === "Escape" && this.isFullscreen() === !0 && (this.isFullWindow ? this.exitFullWindow() : this.exitFullscreen());
  }
  /**
   * Exit full window
   *
   * @fires Player#exitFullWindow
   */
  exitFullWindow() {
    this.isFullscreen(!1), this.isFullWindow = !1, Xt(Be, "keydown", this.boundFullWindowOnEscKey_), Be.documentElement.style.overflow = this.docOrigOverflow, yl(Be.body, "vjs-full-window"), this.trigger("exitFullWindow");
  }
  /**
   * Get or set disable Picture-in-Picture mode.
   *
   * @param {boolean} [value]
   *                  - true will disable Picture-in-Picture mode
   *                  - false will enable Picture-in-Picture mode
   */
  disablePictureInPicture(e) {
    if (e === void 0)
      return this.techGet_("disablePictureInPicture");
    this.techCall_("setDisablePictureInPicture", e), this.options_.disablePictureInPicture = e, this.trigger("disablepictureinpicturechanged");
  }
  /**
   * Check if the player is in Picture-in-Picture mode or tell the player that it
   * is or is not in Picture-in-Picture mode.
   *
   * @param  {boolean} [isPiP]
   *         Set the players current Picture-in-Picture state
   *
   * @return {boolean|undefined}
   *         - true if Picture-in-Picture is on and getting
   *         - false if Picture-in-Picture is off and getting
   *         - nothing if setting
   */
  isInPictureInPicture(e) {
    if (e !== void 0) {
      this.isInPictureInPicture_ = !!e, this.togglePictureInPictureClass_();
      return;
    }
    return !!this.isInPictureInPicture_;
  }
  /**
   * Create a floating video window always on top of other windows so that users may
   * continue consuming media while they interact with other content sites, or
   * applications on their device.
   *
   * This can use document picture-in-picture or element picture in picture
   *
   * Set `enableDocumentPictureInPicture` to `true` to use docPiP on a supported browser
   * Else set `disablePictureInPicture` to `false` to disable elPiP on a supported browser
   *
   *
   * @see [Spec]{@link https://w3c.github.io/picture-in-picture/}
   * @see [Spec]{@link https://wicg.github.io/document-picture-in-picture/}
   *
   * @fires Player#enterpictureinpicture
   *
   * @return {Promise}
   *         A promise with a Picture-in-Picture window.
   */
  requestPictureInPicture() {
    if (this.options_.enableDocumentPictureInPicture && me.documentPictureInPicture) {
      const e = Be.createElement(this.el().tagName);
      return e.classList = this.el().classList, e.classList.add("vjs-pip-container"), this.posterImage && e.appendChild(this.posterImage.el().cloneNode(!0)), this.titleBar && e.appendChild(this.titleBar.el().cloneNode(!0)), e.appendChild(Ye("p", {
        className: "vjs-pip-text"
      }, {}, this.localize("Playing in picture-in-picture"))), me.documentPictureInPicture.requestWindow({
        // The aspect ratio won't be correct, Chrome bug https://crbug.com/1407629
        width: this.videoWidth(),
        height: this.videoHeight()
      }).then((t) => (jD(t), this.el_.parentNode.insertBefore(e, this.el_), t.document.body.appendChild(this.el_), t.document.body.classList.add("vjs-pip-window"), this.player_.isInPictureInPicture(!0), this.player_.trigger({
        type: "enterpictureinpicture",
        pipWindow: t
      }), t.addEventListener("pagehide", (i) => {
        const r = i.target.querySelector(".video-js");
        e.parentNode.replaceChild(r, e), this.player_.isInPictureInPicture(!1), this.player_.trigger("leavepictureinpicture");
      }), t));
    }
    return "pictureInPictureEnabled" in Be && this.disablePictureInPicture() === !1 ? this.techGet_("requestPictureInPicture") : Promise.reject("No PiP mode is available");
  }
  /**
   * Exit Picture-in-Picture mode.
   *
   * @see [Spec]{@link https://wicg.github.io/picture-in-picture}
   *
   * @fires Player#leavepictureinpicture
   *
   * @return {Promise}
   *         A promise.
   */
  exitPictureInPicture() {
    if (me.documentPictureInPicture && me.documentPictureInPicture.window)
      return me.documentPictureInPicture.window.close(), Promise.resolve();
    if ("pictureInPictureEnabled" in Be)
      return Be.exitPictureInPicture();
  }
  /**
   * Called when this Player has focus and a key gets pressed down, or when
   * any Component of this player receives a key press that it doesn't handle.
   * This allows player-wide hotkeys (either as defined below, or optionally
   * by an external function).
   *
   * @param {KeyboardEvent} event
   *        The `keydown` event that caused this function to be called.
   *
   * @listens keydown
   */
  handleKeyDown(e) {
    const {
      userActions: t
    } = this.options_;
    !t || !t.hotkeys || ((r) => {
      const a = r.tagName.toLowerCase();
      if (r.isContentEditable)
        return !0;
      const s = ["button", "checkbox", "hidden", "radio", "reset", "submit"];
      return a === "input" ? s.indexOf(r.type) === -1 : ["textarea"].indexOf(a) !== -1;
    })(this.el_.ownerDocument.activeElement) || (typeof t.hotkeys == "function" ? t.hotkeys.call(this, e) : this.handleHotkeys(e));
  }
  /**
   * Called when this Player receives a hotkey keydown event.
   * Supported player-wide hotkeys are:
   *
   *   f          - toggle fullscreen
   *   m          - toggle mute
   *   k or Space - toggle play/pause
   *
   * @param {Event} event
   *        The `keydown` event that caused this function to be called.
   */
  handleHotkeys(e) {
    const t = this.options_.userActions ? this.options_.userActions.hotkeys : {}, {
      fullscreenKey: i = (s) => e.key.toLowerCase() === "f",
      muteKey: r = (s) => e.key.toLowerCase() === "m",
      playPauseKey: a = (s) => e.key.toLowerCase() === "k" || e.key.toLowerCase() === " "
    } = t;
    if (i.call(this, e)) {
      e.preventDefault(), e.stopPropagation();
      const s = Pe.getComponent("FullscreenToggle");
      Be[this.fsApi_.fullscreenEnabled] !== !1 && s.prototype.handleClick.call(this, e);
    } else r.call(this, e) ? (e.preventDefault(), e.stopPropagation(), Pe.getComponent("MuteToggle").prototype.handleClick.call(this, e)) : a.call(this, e) && (e.preventDefault(), e.stopPropagation(), Pe.getComponent("PlayToggle").prototype.handleClick.call(this, e));
  }
  /**
   * Check whether the player can play a given mimetype
   *
   * @see https://www.w3.org/TR/2011/WD-html5-20110113/video.html#dom-navigator-canplaytype
   *
   * @param {string} type
   *        The mimetype to check
   *
   * @return {string}
   *         'probably', 'maybe', or '' (empty string)
   */
  canPlayType(e) {
    let t;
    for (let i = 0, r = this.options_.techOrder; i < r.length; i++) {
      const a = r[i];
      let s = tt.getTech(a);
      if (s || (s = Pe.getComponent(a)), !s) {
        at.error(`The "${a}" tech is undefined. Skipped browser support check for that tech.`);
        continue;
      }
      if (s.isSupported() && (t = s.canPlayType(e), t))
        return t;
    }
    return "";
  }
  /**
   * Select source based on tech-order or source-order
   * Uses source-order selection if `options.sourceOrder` is truthy. Otherwise,
   * defaults to tech-order selection
   *
   * @param {Array} sources
   *        The sources for a media asset
   *
   * @return {Object|boolean}
   *         Object of source and tech order or false
   */
  selectSource(e) {
    const t = this.options_.techOrder.map((o) => [o, tt.getTech(o)]).filter(([o, u]) => u ? u.isSupported() : (at.error(`The "${o}" tech is undefined. Skipped browser support check for that tech.`), !1)), i = function(o, u, c) {
      let l;
      return o.some((h) => u.some((f) => {
        if (l = c(h, f), l)
          return !0;
      })), l;
    };
    let r;
    const a = (o) => (u, c) => o(c, u), s = ([o, u], c) => {
      if (u.canPlaySource(c, this.options_[o.toLowerCase()]))
        return {
          source: c,
          tech: o
        };
    };
    return this.options_.sourceOrder ? r = i(e, t, a(s)) : r = i(t, e, s), r || !1;
  }
  /**
   * Executes source setting and getting logic
   *
   * @param {Tech~SourceObject|Tech~SourceObject[]|string} [source]
   *        A SourceObject, an array of SourceObjects, or a string referencing
   *        a URL to a media source. It is _highly recommended_ that an object
   *        or array of objects is used here, so that source selection
   *        algorithms can take the `type` into account.
   *
   *        If not provided, this method acts as a getter.
   * @param {boolean} [isRetry]
   *        Indicates whether this is being called internally as a result of a retry
   *
   * @return {string|undefined}
   *         If the `source` argument is missing, returns the current source
   *         URL. Otherwise, returns nothing/undefined.
   */
  handleSrc_(e, t) {
    if (typeof e > "u")
      return this.cache_.src || "";
    this.resetRetryOnError_ && this.resetRetryOnError_();
    const i = aS(e);
    if (!i.length) {
      this.setTimeout(function() {
        this.error({
          code: 4,
          message: this.options_.notSupportedMessage
        });
      }, 0);
      return;
    }
    if (this.changingSrc_ = !0, t || (this.cache_.sources = i), this.updateSourceCaches_(i[0]), hO(this, i[0], (r, a) => {
      if (this.middleware_ = a, t || (this.cache_.sources = i), this.updateSourceCaches_(r), this.src_(r)) {
        if (i.length > 1)
          return this.handleSrc_(i.slice(1));
        this.changingSrc_ = !1, this.setTimeout(function() {
          this.error({
            code: 4,
            message: this.options_.notSupportedMessage
          });
        }, 0), this.triggerReady();
        return;
      }
      pO(a, this.tech_);
    }), i.length > 1) {
      const r = () => {
        this.error(null), this.handleSrc_(i.slice(1), !0);
      }, a = () => {
        this.off("error", r);
      };
      this.one("error", r), this.one("playing", a), this.resetRetryOnError_ = () => {
        this.off("error", r), this.off("playing", a);
      };
    }
  }
  /**
   * Get or set the video source.
   *
   * @param {Tech~SourceObject|Tech~SourceObject[]|string} [source]
   *        A SourceObject, an array of SourceObjects, or a string referencing
   *        a URL to a media source. It is _highly recommended_ that an object
   *        or array of objects is used here, so that source selection
   *        algorithms can take the `type` into account.
   *
   *        If not provided, this method acts as a getter.
   *
   * @return {string|undefined}
   *         If the `source` argument is missing, returns the current source
   *         URL. Otherwise, returns nothing/undefined.
   */
  src(e) {
    return this.handleSrc_(e, !1);
  }
  /**
   * Set the source object on the tech, returns a boolean that indicates whether
   * there is a tech that can play the source or not
   *
   * @param {Tech~SourceObject} source
   *        The source object to set on the Tech
   *
   * @return {boolean}
   *         - True if there is no Tech to playback this source
   *         - False otherwise
   *
   * @private
   */
  src_(e) {
    const t = this.selectSource([e]);
    return t ? KD(t.tech, this.techName_) ? (this.ready(function() {
      this.tech_.constructor.prototype.hasOwnProperty("setSource") ? this.techCall_("setSource", e) : this.techCall_("src", e.src), this.changingSrc_ = !1;
    }, !0), !1) : (this.changingSrc_ = !0, this.loadTech_(t.tech, t.source), this.tech_.ready(() => {
      this.changingSrc_ = !1;
    }), !1) : !0;
  }
  /**
   * Add a <source> element to the <video> element.
   *
   * @param {string} srcUrl
   *        The URL of the video source.
   *
   * @param {string} [mimeType]
   *        The MIME type of the video source. Optional but recommended.
   *
   * @return {boolean}
   *         Returns true if the source element was successfully added, false otherwise.
   */
  addSourceElement(e, t) {
    return this.tech_ ? this.tech_.addSourceElement(e, t) : !1;
  }
  /**
   * Remove a <source> element from the <video> element by its URL.
   *
   * @param {string} srcUrl
   *        The URL of the source to remove.
   *
   * @return {boolean}
   *         Returns true if the source element was successfully removed, false otherwise.
   */
  removeSourceElement(e) {
    return this.tech_ ? this.tech_.removeSourceElement(e) : !1;
  }
  /**
   * Begin loading the src data.
   */
  load() {
    if (this.tech_ && this.tech_.vhs) {
      this.src(this.currentSource());
      return;
    }
    this.techCall_("load");
  }
  /**
   * Reset the player. Loads the first tech in the techOrder,
   * removes all the text tracks in the existing `tech`,
   * and calls `reset` on the `tech`.
   */
  reset() {
    if (this.paused())
      this.doReset_();
    else {
      const e = this.play();
      mi(e.then(() => this.doReset_()));
    }
  }
  doReset_() {
    this.tech_ && this.tech_.clearTracks("text"), this.removeClass("vjs-playing"), this.addClass("vjs-paused"), this.resetCache_(), this.poster(""), this.loadTech_(this.options_.techOrder[0], null), this.techCall_("reset"), this.resetControlBarUI_(), this.error(null), this.titleBar && this.titleBar.update({
      title: void 0,
      description: void 0
    }), Oi(this) && this.trigger("playerreset");
  }
  /**
   * Reset Control Bar's UI by calling sub-methods that reset
   * all of Control Bar's components
   */
  resetControlBarUI_() {
    this.resetProgressBar_(), this.resetPlaybackRate_(), this.resetVolumeBar_();
  }
  /**
   * Reset tech's progress so progress bar is reset in the UI
   */
  resetProgressBar_() {
    this.currentTime(0);
    const {
      currentTimeDisplay: e,
      durationDisplay: t,
      progressControl: i,
      remainingTimeDisplay: r
    } = this.controlBar || {}, {
      seekBar: a
    } = i || {};
    e && e.updateContent(), t && t.updateContent(), r && r.updateContent(), a && (a.update(), a.loadProgressBar && a.loadProgressBar.update());
  }
  /**
   * Reset Playback ratio
   */
  resetPlaybackRate_() {
    this.playbackRate(this.defaultPlaybackRate()), this.handleTechRateChange_();
  }
  /**
   * Reset Volume bar
   */
  resetVolumeBar_() {
    this.volume(1), this.trigger("volumechange");
  }
  /**
   * Returns all of the current source objects.
   *
   * @return {Tech~SourceObject[]}
   *         The current source objects
   */
  currentSources() {
    const e = this.currentSource(), t = [];
    return Object.keys(e).length !== 0 && t.push(e), this.cache_.sources || t;
  }
  /**
   * Returns the current source object.
   *
   * @return {Tech~SourceObject}
   *         The current source object
   */
  currentSource() {
    return this.cache_.source || {};
  }
  /**
   * Returns the fully qualified URL of the current source value e.g. http://mysite.com/video.mp4
   * Can be used in conjunction with `currentType` to assist in rebuilding the current source object.
   *
   * @return {string}
   *         The current source
   */
  currentSrc() {
    return this.currentSource() && this.currentSource().src || "";
  }
  /**
   * Get the current source type e.g. video/mp4
   * This can allow you rebuild the current source object so that you could load the same
   * source and tech later
   *
   * @return {string}
   *         The source MIME type
   */
  currentType() {
    return this.currentSource() && this.currentSource().type || "";
  }
  /**
   * Get or set the preload attribute
   *
   * @param {'none'|'auto'|'metadata'} [value]
   *        Preload mode to pass to tech
   *
   * @return {string|undefined}
   *         - The preload attribute value when getting
   *         - Nothing when setting
   */
  preload(e) {
    if (e !== void 0) {
      this.techCall_("setPreload", e), this.options_.preload = e;
      return;
    }
    return this.techGet_("preload");
  }
  /**
   * Get or set the autoplay option. When this is a boolean it will
   * modify the attribute on the tech. When this is a string the attribute on
   * the tech will be removed and `Player` will handle autoplay on loadstarts.
   *
   * @param {boolean|'play'|'muted'|'any'} [value]
   *        - true: autoplay using the browser behavior
   *        - false: do not autoplay
   *        - 'play': call play() on every loadstart
   *        - 'muted': call muted() then play() on every loadstart
   *        - 'any': call play() on every loadstart. if that fails call muted() then play().
   *        - *: values other than those listed here will be set `autoplay` to true
   *
   * @return {boolean|string|undefined}
   *         - The current value of autoplay when getting
   *         - Nothing when setting
   */
  autoplay(e) {
    if (e === void 0)
      return this.options_.autoplay || !1;
    let t;
    typeof e == "string" && /(any|play|muted)/.test(e) || e === !0 && this.options_.normalizeAutoplay ? (this.options_.autoplay = e, this.manualAutoplay_(typeof e == "string" ? e : "play"), t = !1) : e ? this.options_.autoplay = !0 : this.options_.autoplay = !1, t = typeof t > "u" ? this.options_.autoplay : t, this.tech_ && this.techCall_("setAutoplay", t);
  }
  /**
   * Set or unset the playsinline attribute.
   * Playsinline tells the browser that non-fullscreen playback is preferred.
   *
   * @param {boolean} [value]
   *        - true means that we should try to play inline by default
   *        - false means that we should use the browser's default playback mode,
   *          which in most cases is inline. iOS Safari is a notable exception
   *          and plays fullscreen by default.
   *
   * @return {string|undefined}
   *         - the current value of playsinline
   *         - Nothing when setting
   *
   * @see [Spec]{@link https://html.spec.whatwg.org/#attr-video-playsinline}
   */
  playsinline(e) {
    return e !== void 0 && (this.techCall_("setPlaysinline", e), this.options_.playsinline = e), this.techGet_("playsinline");
  }
  /**
   * Get or set the loop attribute on the video element.
   *
   * @param {boolean} [value]
   *        - true means that we should loop the video
   *        - false means that we should not loop the video
   *
   * @return {boolean|undefined}
   *         - The current value of loop when getting
   *         - Nothing when setting
   */
  loop(e) {
    if (e !== void 0) {
      this.techCall_("setLoop", e), this.options_.loop = e;
      return;
    }
    return this.techGet_("loop");
  }
  /**
   * Get or set the poster image source url
   *
   * @fires Player#posterchange
   *
   * @param {string} [src]
   *        Poster image source URL
   *
   * @return {string|undefined}
   *         - The current value of poster when getting
   *         - Nothing when setting
   */
  poster(e) {
    if (e === void 0)
      return this.poster_;
    e || (e = ""), e !== this.poster_ && (this.poster_ = e, this.techCall_("setPoster", e), this.isPosterFromTech_ = !1, this.trigger("posterchange"));
  }
  /**
   * Some techs (e.g. YouTube) can provide a poster source in an
   * asynchronous way. We want the poster component to use this
   * poster source so that it covers up the tech's controls.
   * (YouTube's play button). However we only want to use this
   * source if the player user hasn't set a poster through
   * the normal APIs.
   *
   * @fires Player#posterchange
   * @listens Tech#posterchange
   * @private
   */
  handleTechPosterChange_() {
    if ((!this.poster_ || this.options_.techCanOverridePoster) && this.tech_ && this.tech_.poster) {
      const e = this.tech_.poster() || "";
      e !== this.poster_ && (this.poster_ = e, this.isPosterFromTech_ = !0, this.trigger("posterchange"));
    }
  }
  /**
   * Get or set whether or not the controls are showing.
   *
   * @fires Player#controlsenabled
   *
   * @param {boolean} [bool]
   *        - true to turn controls on
   *        - false to turn controls off
   *
   * @return {boolean|undefined}
   *         - The current value of controls when getting
   *         - Nothing when setting
   */
  controls(e) {
    if (e === void 0)
      return !!this.controls_;
    e = !!e, this.controls_ !== e && (this.controls_ = e, this.usingNativeControls() && this.techCall_("setControls", e), this.controls_ ? (this.removeClass("vjs-controls-disabled"), this.addClass("vjs-controls-enabled"), this.trigger("controlsenabled"), this.usingNativeControls() || this.addTechControlsListeners_()) : (this.removeClass("vjs-controls-enabled"), this.addClass("vjs-controls-disabled"), this.trigger("controlsdisabled"), this.usingNativeControls() || this.removeTechControlsListeners_()));
  }
  /**
   * Toggle native controls on/off. Native controls are the controls built into
   * devices (e.g. default iPhone controls) or other techs
   * (e.g. Vimeo Controls)
   * **This should only be set by the current tech, because only the tech knows
   * if it can support native controls**
   *
   * @fires Player#usingnativecontrols
   * @fires Player#usingcustomcontrols
   *
   * @param {boolean} [bool]
   *        - true to turn native controls on
   *        - false to turn native controls off
   *
   * @return {boolean|undefined}
   *         - The current value of native controls when getting
   *         - Nothing when setting
   */
  usingNativeControls(e) {
    if (e === void 0)
      return !!this.usingNativeControls_;
    e = !!e, this.usingNativeControls_ !== e && (this.usingNativeControls_ = e, this.usingNativeControls_ ? (this.addClass("vjs-using-native-controls"), this.trigger("usingnativecontrols")) : (this.removeClass("vjs-using-native-controls"), this.trigger("usingcustomcontrols")));
  }
  /**
   * Set or get the current MediaError
   *
   * @fires Player#error
   *
   * @param  {MediaError|string|number} [err]
   *         A MediaError or a string/number to be turned
   *         into a MediaError
   *
   * @return {MediaError|null|undefined}
   *         - The current MediaError when getting (or null)
   *         - Nothing when setting
   */
  error(e) {
    if (e === void 0)
      return this.error_ || null;
    if (nr("beforeerror").forEach((t) => {
      const i = t(this, e);
      if (!(xi(i) && !Array.isArray(i) || typeof i == "string" || typeof i == "number" || i === null)) {
        this.log.error("please return a value that MediaError expects in beforeerror hooks");
        return;
      }
      e = i;
    }), this.options_.suppressNotSupportedError && e && e.code === 4) {
      const t = function() {
        this.error(e);
      };
      this.options_.suppressNotSupportedError = !1, this.any(["click", "touchstart"], t), this.one("loadstart", function() {
        this.off(["click", "touchstart"], t);
      });
      return;
    }
    if (e === null) {
      this.error_ = null, this.removeClass("vjs-error"), this.errorDisplay && this.errorDisplay.close();
      return;
    }
    this.error_ = new It(e), this.addClass("vjs-error"), at.error(`(CODE:${this.error_.code} ${It.errorTypes[this.error_.code]})`, this.error_.message, this.error_), this.trigger("error"), nr("error").forEach((t) => t(this, this.error_));
  }
  /**
   * Report user activity
   *
   * @param {Object} event
   *        Event object
   */
  reportUserActivity(e) {
    this.userActivity_ = !0;
  }
  /**
   * Get/set if user is active
   *
   * @fires Player#useractive
   * @fires Player#userinactive
   *
   * @param {boolean} [bool]
   *        - true if the user is active
   *        - false if the user is inactive
   *
   * @return {boolean|undefined}
   *         - The current value of userActive when getting
   *         - Nothing when setting
   */
  userActive(e) {
    if (e === void 0)
      return this.userActive_;
    if (e = !!e, e !== this.userActive_) {
      if (this.userActive_ = e, this.userActive_) {
        this.userActivity_ = !0, this.removeClass("vjs-user-inactive"), this.addClass("vjs-user-active"), this.trigger("useractive");
        return;
      }
      this.tech_ && this.tech_.one("mousemove", function(t) {
        t.stopPropagation(), t.preventDefault();
      }), this.userActivity_ = !1, this.removeClass("vjs-user-active"), this.addClass("vjs-user-inactive"), this.trigger("userinactive");
    }
  }
  /**
   * Listen for user activity based on timeout value
   *
   * @private
   */
  listenForUserActivity_() {
    let e, t, i;
    const r = _t(this, this.reportUserActivity), a = function(h) {
      (h.screenX !== t || h.screenY !== i) && (t = h.screenX, i = h.screenY, r());
    }, s = function() {
      r(), this.clearInterval(e), e = this.setInterval(r, 250);
    }, o = function(h) {
      r(), this.clearInterval(e);
    };
    this.on("mousedown", s), this.on("mousemove", a), this.on("mouseup", o), this.on("mouseleave", o);
    const u = this.getChild("controlBar");
    u && !Gt && !ai && (u.on("mouseenter", function(h) {
      this.player().options_.inactivityTimeout !== 0 && (this.player().cache_.inactivityTimeout = this.player().options_.inactivityTimeout), this.player().options_.inactivityTimeout = 0;
    }), u.on("mouseleave", function(h) {
      this.player().options_.inactivityTimeout = this.player().cache_.inactivityTimeout;
    })), this.on("keydown", r), this.on("keyup", r);
    let c;
    const l = function() {
      if (!this.userActivity_)
        return;
      this.userActivity_ = !1, this.userActive(!0), this.clearTimeout(c);
      const h = this.options_.inactivityTimeout;
      h <= 0 || (c = this.setTimeout(function() {
        this.userActivity_ || this.userActive(!1);
      }, h));
    };
    this.setInterval(l, 250);
  }
  /**
   * Gets or sets the current playback rate. A playback rate of
   * 1.0 represents normal speed and 0.5 would indicate half-speed
   * playback, for instance.
   *
   * @see https://html.spec.whatwg.org/multipage/embedded-content.html#dom-media-playbackrate
   *
   * @param {number} [rate]
   *       New playback rate to set.
   *
   * @return {number|undefined}
   *         - The current playback rate when getting or 1.0
   *         - Nothing when setting
   */
  playbackRate(e) {
    if (e !== void 0) {
      this.techCall_("setPlaybackRate", e);
      return;
    }
    return this.tech_ && this.tech_.featuresPlaybackRate ? this.cache_.lastPlaybackRate || this.techGet_("playbackRate") : 1;
  }
  /**
   * Gets or sets the current default playback rate. A default playback rate of
   * 1.0 represents normal speed and 0.5 would indicate half-speed playback, for instance.
   * defaultPlaybackRate will only represent what the initial playbackRate of a video was, not
   * not the current playbackRate.
   *
   * @see https://html.spec.whatwg.org/multipage/embedded-content.html#dom-media-defaultplaybackrate
   *
   * @param {number} [rate]
   *       New default playback rate to set.
   *
   * @return {number|undefined}
   *         - The default playback rate when getting or 1.0
   *         - Nothing when setting
   */
  defaultPlaybackRate(e) {
    return e !== void 0 ? this.techCall_("setDefaultPlaybackRate", e) : this.tech_ && this.tech_.featuresPlaybackRate ? this.techGet_("defaultPlaybackRate") : 1;
  }
  /**
   * Gets or sets the audio flag
   *
   * @param {boolean} [bool]
   *        - true signals that this is an audio player
   *        - false signals that this is not an audio player
   *
   * @return {boolean|undefined}
   *         - The current value of isAudio when getting
   *         - Nothing when setting
   */
  isAudio(e) {
    if (e !== void 0) {
      this.isAudio_ = !!e;
      return;
    }
    return !!this.isAudio_;
  }
  updatePlayerHeightOnAudioOnlyMode_() {
    const e = this.getChild("ControlBar");
    !e || this.audioOnlyCache_.controlBarHeight === e.currentHeight() || (this.audioOnlyCache_.controlBarHeight = e.currentHeight(), this.height(this.audioOnlyCache_.controlBarHeight));
  }
  enableAudioOnlyUI_() {
    this.addClass("vjs-audio-only-mode");
    const e = this.children(), t = this.getChild("ControlBar"), i = t && t.currentHeight();
    e.forEach((r) => {
      r !== t && r.el_ && !r.hasClass("vjs-hidden") && (r.hide(), this.audioOnlyCache_.hiddenChildren.push(r));
    }), this.audioOnlyCache_.playerHeight = this.currentHeight(), this.audioOnlyCache_.controlBarHeight = i, this.on("playerresize", this.boundUpdatePlayerHeightOnAudioOnlyMode_), this.height(i), this.trigger("audioonlymodechange");
  }
  disableAudioOnlyUI_() {
    this.removeClass("vjs-audio-only-mode"), this.off("playerresize", this.boundUpdatePlayerHeightOnAudioOnlyMode_), this.audioOnlyCache_.hiddenChildren.forEach((e) => e.show()), this.height(this.audioOnlyCache_.playerHeight), this.trigger("audioonlymodechange");
  }
  /**
   * Get the current audioOnlyMode state or set audioOnlyMode to true or false.
   *
   * Setting this to `true` will hide all player components except the control bar,
   * as well as control bar components needed only for video.
   *
   * @param {boolean} [value]
   *         The value to set audioOnlyMode to.
   *
   * @return {Promise|boolean}
   *        A Promise is returned when setting the state, and a boolean when getting
   *        the present state
   */
  audioOnlyMode(e) {
    if (typeof e != "boolean" || e === this.audioOnlyMode_)
      return this.audioOnlyMode_;
    if (this.audioOnlyMode_ = e, e) {
      const t = [];
      return this.isInPictureInPicture() && t.push(this.exitPictureInPicture()), this.isFullscreen() && t.push(this.exitFullscreen()), this.audioPosterMode() && t.push(this.audioPosterMode(!1)), Promise.all(t).then(() => this.enableAudioOnlyUI_());
    }
    return Promise.resolve().then(() => this.disableAudioOnlyUI_());
  }
  enablePosterModeUI_() {
    (this.tech_ && this.tech_).hide(), this.addClass("vjs-audio-poster-mode"), this.trigger("audiopostermodechange");
  }
  disablePosterModeUI_() {
    (this.tech_ && this.tech_).show(), this.removeClass("vjs-audio-poster-mode"), this.trigger("audiopostermodechange");
  }
  /**
   * Get the current audioPosterMode state or set audioPosterMode to true or false
   *
   * @param {boolean} [value]
   *         The value to set audioPosterMode to.
   *
   * @return {Promise|boolean}
   *         A Promise is returned when setting the state, and a boolean when getting
   *        the present state
   */
  audioPosterMode(e) {
    return typeof e != "boolean" || e === this.audioPosterMode_ ? this.audioPosterMode_ : (this.audioPosterMode_ = e, e ? this.audioOnlyMode() ? this.audioOnlyMode(!1).then(() => {
      this.enablePosterModeUI_();
    }) : Promise.resolve().then(() => {
      this.enablePosterModeUI_();
    }) : Promise.resolve().then(() => {
      this.disablePosterModeUI_();
    }));
  }
  /**
   * A helper method for adding a {@link TextTrack} to our
   * {@link TextTrackList}.
   *
   * In addition to the W3C settings we allow adding additional info through options.
   *
   * @see http://www.w3.org/html/wg/drafts/html/master/embedded-content-0.html#dom-media-addtexttrack
   *
   * @param {string} [kind]
   *        the kind of TextTrack you are adding
   *
   * @param {string} [label]
   *        the label to give the TextTrack label
   *
   * @param {string} [language]
   *        the language to set on the TextTrack
   *
   * @return {TextTrack|undefined}
   *         the TextTrack that was added or undefined
   *         if there is no tech
   */
  addTextTrack(e, t, i) {
    if (this.tech_)
      return this.tech_.addTextTrack(e, t, i);
  }
  /**
   * Create a remote {@link TextTrack} and an {@link HTMLTrackElement}.
   *
   * @param {Object} options
   *        Options to pass to {@link HTMLTrackElement} during creation. See
   *        {@link HTMLTrackElement} for object properties that you should use.
   *
   * @param {boolean} [manualCleanup=false] if set to true, the TextTrack will not be removed
   *                                        from the TextTrackList and HtmlTrackElementList
   *                                        after a source change
   *
   * @return {HtmlTrackElement}
   *         the HTMLTrackElement that was created and added
   *         to the HtmlTrackElementList and the remote
   *         TextTrackList
   *
   */
  addRemoteTextTrack(e, t) {
    if (this.tech_)
      return this.tech_.addRemoteTextTrack(e, t);
  }
  /**
   * Remove a remote {@link TextTrack} from the respective
   * {@link TextTrackList} and {@link HtmlTrackElementList}.
   *
   * @param {Object} track
   *        Remote {@link TextTrack} to remove
   *
   * @return {undefined}
   *         does not return anything
   */
  removeRemoteTextTrack(e = {}) {
    let {
      track: t
    } = e;
    if (t || (t = e), this.tech_)
      return this.tech_.removeRemoteTextTrack(t);
  }
  /**
   * Gets available media playback quality metrics as specified by the W3C's Media
   * Playback Quality API.
   *
   * @see [Spec]{@link https://wicg.github.io/media-playback-quality}
   *
   * @return {Object|undefined}
   *         An object with supported media playback quality metrics or undefined if there
   *         is no tech or the tech does not support it.
   */
  getVideoPlaybackQuality() {
    return this.techGet_("getVideoPlaybackQuality");
  }
  /**
   * Get video width
   *
   * @return {number}
   *         current video width
   */
  videoWidth() {
    return this.tech_ && this.tech_.videoWidth && this.tech_.videoWidth() || 0;
  }
  /**
   * Get video height
   *
   * @return {number}
   *         current video height
   */
  videoHeight() {
    return this.tech_ && this.tech_.videoHeight && this.tech_.videoHeight() || 0;
  }
  /**
   * Set or get the player's language code.
   *
   * Changing the language will trigger
   * [languagechange]{@link Player#event:languagechange}
   * which Components can use to update control text.
   * ClickableComponent will update its control text by default on
   * [languagechange]{@link Player#event:languagechange}.
   *
   * @fires Player#languagechange
   *
   * @param {string} [code]
   *        the language code to set the player to
   *
   * @return {string|undefined}
   *         - The current language code when getting
   *         - Nothing when setting
   */
  language(e) {
    if (e === void 0)
      return this.language_;
    this.language_ !== String(e).toLowerCase() && (this.language_ = String(e).toLowerCase(), Oi(this) && this.trigger("languagechange"));
  }
  /**
   * Get the player's language dictionary
   * Merge every time, because a newly added plugin might call videojs.addLanguage() at any time
   * Languages specified directly in the player options have precedence
   *
   * @return {Array}
   *         An array of of supported languages
   */
  languages() {
    return yt(dt.prototype.options_.languages, this.languages_);
  }
  /**
   * returns a JavaScript object representing the current track
   * information. **DOES not return it as JSON**
   *
   * @return {Object}
   *         Object representing the current of track info
   */
  toJSON() {
    const e = yt(this.options_), t = e.tracks;
    e.tracks = [];
    for (let i = 0; i < t.length; i++) {
      let r = t[i];
      r = yt(r), r.player = void 0, e.tracks[i] = r;
    }
    return e;
  }
  /**
   * Creates a simple modal dialog (an instance of the {@link ModalDialog}
   * component) that immediately overlays the player with arbitrary
   * content and removes itself when closed.
   *
   * @param {string|Function|Element|Array|null} content
   *        Same as {@link ModalDialog#content}'s param of the same name.
   *        The most straight-forward usage is to provide a string or DOM
   *        element.
   *
   * @param {Object} [options]
   *        Extra options which will be passed on to the {@link ModalDialog}.
   *
   * @return {ModalDialog}
   *         the {@link ModalDialog} that was created
   */
  createModal(e, t) {
    t = t || {}, t.content = e || "";
    const i = new Ma(this, t);
    return this.addChild(i), i.on("dispose", () => {
      this.removeChild(i);
    }), i.open(), i;
  }
  /**
   * Change breakpoint classes when the player resizes.
   *
   * @private
   */
  updateCurrentBreakpoint_() {
    if (!this.responsive())
      return;
    const e = this.currentBreakpoint(), t = this.currentWidth();
    for (let i = 0; i < Tm.length; i++) {
      const r = Tm[i], a = this.breakpoints_[r];
      if (t <= a) {
        if (e === r)
          return;
        e && this.removeClass(Xu[e]), this.addClass(Xu[r]), this.breakpoint_ = r;
        break;
      }
    }
  }
  /**
   * Removes the current breakpoint.
   *
   * @private
   */
  removeCurrentBreakpoint_() {
    const e = this.currentBreakpointClass();
    this.breakpoint_ = "", e && this.removeClass(e);
  }
  /**
   * Get or set breakpoints on the player.
   *
   * Calling this method with an object or `true` will remove any previous
   * custom breakpoints and start from the defaults again.
   *
   * @param  {Object|boolean} [breakpoints]
   *         If an object is given, it can be used to provide custom
   *         breakpoints. If `true` is given, will set default breakpoints.
   *         If this argument is not given, will simply return the current
   *         breakpoints.
   *
   * @param  {number} [breakpoints.tiny]
   *         The maximum width for the "vjs-layout-tiny" class.
   *
   * @param  {number} [breakpoints.xsmall]
   *         The maximum width for the "vjs-layout-x-small" class.
   *
   * @param  {number} [breakpoints.small]
   *         The maximum width for the "vjs-layout-small" class.
   *
   * @param  {number} [breakpoints.medium]
   *         The maximum width for the "vjs-layout-medium" class.
   *
   * @param  {number} [breakpoints.large]
   *         The maximum width for the "vjs-layout-large" class.
   *
   * @param  {number} [breakpoints.xlarge]
   *         The maximum width for the "vjs-layout-x-large" class.
   *
   * @param  {number} [breakpoints.huge]
   *         The maximum width for the "vjs-layout-huge" class.
   *
   * @return {Object}
   *         An object mapping breakpoint names to maximum width values.
   */
  breakpoints(e) {
    return e === void 0 ? Object.assign(this.breakpoints_) : (this.breakpoint_ = "", this.breakpoints_ = Object.assign({}, t9, e), this.updateCurrentBreakpoint_(), Object.assign(this.breakpoints_));
  }
  /**
   * Get or set a flag indicating whether or not this player should adjust
   * its UI based on its dimensions.
   *
   * @param  {boolean} [value]
   *         Should be `true` if the player should adjust its UI based on its
   *         dimensions; otherwise, should be `false`.
   *
   * @return {boolean|undefined}
   *         Will be `true` if this player should adjust its UI based on its
   *         dimensions; otherwise, will be `false`.
   *         Nothing if setting
   */
  responsive(e) {
    if (e === void 0)
      return this.responsive_;
    e = !!e;
    const t = this.responsive_;
    if (e !== t)
      return this.responsive_ = e, e ? (this.on("playerresize", this.boundUpdateCurrentBreakpoint_), this.updateCurrentBreakpoint_()) : (this.off("playerresize", this.boundUpdateCurrentBreakpoint_), this.removeCurrentBreakpoint_()), e;
  }
  /**
   * Get current breakpoint name, if any.
   *
   * @return {string}
   *         If there is currently a breakpoint set, returns a the key from the
   *         breakpoints object matching it. Otherwise, returns an empty string.
   */
  currentBreakpoint() {
    return this.breakpoint_;
  }
  /**
   * Get the current breakpoint class name.
   *
   * @return {string}
   *         The matching class name (e.g. `"vjs-layout-tiny"` or
   *         `"vjs-layout-large"`) for the current breakpoint. Empty string if
   *         there is no current breakpoint.
   */
  currentBreakpointClass() {
    return Xu[this.breakpoint_] || "";
  }
  /**
   * An object that describes a single piece of media.
   *
   * Properties that are not part of this type description will be retained; so,
   * this can be viewed as a generic metadata storage mechanism as well.
   *
   * @see      {@link https://wicg.github.io/mediasession/#the-mediametadata-interface}
   * @typedef  {Object} Player~MediaObject
   *
   * @property {string} [album]
   *           Unused, except if this object is passed to the `MediaSession`
   *           API.
   *
   * @property {string} [artist]
   *           Unused, except if this object is passed to the `MediaSession`
   *           API.
   *
   * @property {Object[]} [artwork]
   *           Unused, except if this object is passed to the `MediaSession`
   *           API. If not specified, will be populated via the `poster`, if
   *           available.
   *
   * @property {string} [poster]
   *           URL to an image that will display before playback.
   *
   * @property {Tech~SourceObject|Tech~SourceObject[]|string} [src]
   *           A single source object, an array of source objects, or a string
   *           referencing a URL to a media source. It is _highly recommended_
   *           that an object or array of objects is used here, so that source
   *           selection algorithms can take the `type` into account.
   *
   * @property {string} [title]
   *           Unused, except if this object is passed to the `MediaSession`
   *           API.
   *
   * @property {Object[]} [textTracks]
   *           An array of objects to be used to create text tracks, following
   *           the {@link https://www.w3.org/TR/html50/embedded-content-0.html#the-track-element|native track element format}.
   *           For ease of removal, these will be created as "remote" text
   *           tracks and set to automatically clean up on source changes.
   *
   *           These objects may have properties like `src`, `kind`, `label`,
   *           and `language`, see {@link Tech#createRemoteTextTrack}.
   */
  /**
   * Populate the player using a {@link Player~MediaObject|MediaObject}.
   *
   * @param  {Player~MediaObject} media
   *         A media object.
   *
   * @param  {Function} ready
   *         A callback to be called when the player is ready.
   */
  loadMedia(e, t) {
    if (!e || typeof e != "object")
      return;
    const i = this.crossOrigin();
    this.reset(), this.cache_.media = yt(e);
    const {
      artist: r,
      artwork: a,
      description: s,
      poster: o,
      src: u,
      textTracks: c,
      title: l
    } = this.cache_.media;
    !a && o && (this.cache_.media.artwork = [{
      src: o,
      type: vc(o)
    }]), i && this.crossOrigin(i), u && this.src(u), o && this.poster(o), Array.isArray(c) && c.forEach((h) => this.addRemoteTextTrack(h, !1)), this.titleBar && this.titleBar.update({
      title: l,
      description: s || r || ""
    }), this.ready(t);
  }
  /**
   * Get a clone of the current {@link Player~MediaObject} for this player.
   *
   * If the `loadMedia` method has not been used, will attempt to return a
   * {@link Player~MediaObject} based on the current state of the player.
   *
   * @return {Player~MediaObject}
   */
  getMedia() {
    if (!this.cache_.media) {
      const e = this.poster(), t = this.currentSources(), i = Array.prototype.map.call(this.remoteTextTracks(), (a) => ({
        kind: a.kind,
        label: a.label,
        language: a.language,
        src: a.src
      })), r = {
        src: t,
        textTracks: i
      };
      return e && (r.poster = e, r.artwork = [{
        src: r.poster,
        type: vc(r.poster)
      }]), r;
    }
    return yt(this.cache_.media);
  }
  /**
   * Gets tag settings
   *
   * @param {Element} tag
   *        The player tag
   *
   * @return {Object}
   *         An object containing all of the settings
   *         for a player tag
   */
  static getTagSettings(e) {
    const t = {
      sources: [],
      tracks: []
    }, i = Ki(e), r = i["data-setup"];
    if (Os(e, "vjs-fill") && (i.fill = !0), Os(e, "vjs-fluid") && (i.fluid = !0), r !== null)
      try {
        Object.assign(i, JSON.parse(r || "{}"));
      } catch (a) {
        at.error("data-setup", a);
      }
    if (Object.assign(t, i), e.hasChildNodes()) {
      const a = e.childNodes;
      for (let s = 0, o = a.length; s < o; s++) {
        const u = a[s], c = u.nodeName.toLowerCase();
        c === "source" ? t.sources.push(Ki(u)) : c === "track" && t.tracks.push(Ki(u));
      }
    }
    return t;
  }
  /**
   * Set debug mode to enable/disable logs at info level.
   *
   * @param {boolean} enabled
   * @fires Player#debugon
   * @fires Player#debugoff
   * @return {boolean|undefined}
   */
  debug(e) {
    if (e === void 0)
      return this.debugEnabled_;
    e ? (this.trigger("debugon"), this.previousLogLevel_ = this.log.level, this.log.level("debug"), this.debugEnabled_ = !0) : (this.trigger("debugoff"), this.log.level(this.previousLogLevel_), this.previousLogLevel_ = void 0, this.debugEnabled_ = !1);
  }
  /**
   * Set or get current playback rates.
   * Takes an array and updates the playback rates menu with the new items.
   * Pass in an empty array to hide the menu.
   * Values other than arrays are ignored.
   *
   * @fires Player#playbackrateschange
   * @param {number[]} [newRates]
   *                   The new rates that the playback rates menu should update to.
   *                   An empty array will hide the menu
   * @return {number[]} When used as a getter will return the current playback rates
   */
  playbackRates(e) {
    if (e === void 0)
      return this.cache_.playbackRates;
    Array.isArray(e) && e.every((t) => typeof t == "number") && (this.cache_.playbackRates = e, this.trigger("playbackrateschange"));
  }
  /**
   * Reports whether or not a player has a plugin available.
   *
   * This does not report whether or not the plugin has ever been initialized
   * on this player. For that, [usingPlugin]{@link Player#usingPlugin}.
   *
   * @method hasPlugin
   * @param  {string}  name
   *         The name of a plugin.
   *
   * @return {boolean}
   *         Whether or not this player has the requested plugin available.
   */
  /**
   * Reports whether or not a player is using a plugin by name.
   *
   * For basic plugins, this only reports whether the plugin has _ever_ been
   * initialized on this player.
   *
   * @method Player#usingPlugin
   * @param  {string} name
   *         The name of a plugin.
   *
   * @return {boolean}
   *         Whether or not this player is using the requested plugin.
   */
}
dt.prototype.videoTracks = () => {
};
dt.prototype.audioTracks = () => {
};
dt.prototype.textTracks = () => {
};
dt.prototype.remoteTextTracks = () => {
};
dt.prototype.remoteTextTrackEls = () => {
};
on.names.forEach(function(n) {
  const e = on[n];
  dt.prototype[e.getterName] = function() {
    return this.tech_ ? this.tech_[e.getterName]() : (this[e.privateName] = this[e.privateName] || new e.ListClass(), this[e.privateName]);
  };
});
dt.prototype.crossorigin = dt.prototype.crossOrigin;
dt.players = {};
const vs = me.navigator;
dt.prototype.options_ = {
  // Default order of fallback technology
  techOrder: tt.defaultTechOrder_,
  html5: {},
  // enable sourceset by default
  enableSourceset: !0,
  // default inactivity timeout
  inactivityTimeout: 2e3,
  // default playback rates
  playbackRates: [],
  // Add playback rate selection by adding rates
  // 'playbackRates': [0.5, 1, 1.5, 2],
  liveui: !1,
  // Included control sets
  children: ["mediaLoader", "posterImage", "titleBar", "textTrackDisplay", "loadingSpinner", "bigPlayButton", "liveTracker", "controlBar", "errorDisplay", "textTrackSettings", "resizeManager"],
  language: vs && (vs.languages && vs.languages[0] || vs.userLanguage || vs.language) || "en",
  // locales and their language translations
  languages: {},
  // Default message to show when a video cannot be played.
  notSupportedMessage: "No compatible source was found for this media.",
  normalizeAutoplay: !1,
  fullscreen: {
    options: {
      navigationUI: "hide"
    }
  },
  breakpoints: {},
  responsive: !1,
  audioOnlyMode: !1,
  audioPosterMode: !1,
  spatialNavigation: {
    enabled: !1,
    horizontalSeek: !1
  },
  // Default smooth seeking to false
  enableSmoothSeeking: !1,
  disableSeekWhileScrubbingOnMobile: !1,
  disableSeekWhileScrubbingOnSTV: !1
};
NS.forEach(function(n) {
  dt.prototype[`handleTech${Rt(n)}_`] = function() {
    return this.trigger(n);
  };
});
Pe.registerComponent("Player", dt);
const xc = "plugin", da = "activePlugins_", na = {}, _c = (n) => na.hasOwnProperty(n), Ku = (n) => _c(n) ? na[n] : void 0, MS = (n, e) => {
  n[da] = n[da] || {}, n[da][e] = !0;
}, Tc = (n, e, t) => {
  const i = (t ? "before" : "") + "pluginsetup";
  n.trigger(i, e), n.trigger(i + ":" + e.name, e);
}, n9 = function(n, e) {
  const t = function() {
    Tc(this, {
      name: n,
      plugin: e,
      instance: null
    }, !0);
    const i = e.apply(this, arguments);
    return MS(this, n), Tc(this, {
      name: n,
      plugin: e,
      instance: i
    }), i;
  };
  return Object.keys(e).forEach(function(i) {
    t[i] = e[i];
  }), t;
}, j_ = (n, e) => (e.prototype.name = n, function(...t) {
  Tc(this, {
    name: n,
    plugin: e,
    instance: null
  }, !0);
  const i = new e(this, ...t);
  return this[n] = () => i, Tc(this, i.getEventHash()), i;
});
class mn {
  /**
   * Creates an instance of this class.
   *
   * Sub-classes should call `super` to ensure plugins are properly initialized.
   *
   * @param {Player} player
   *        A Video.js player instance.
   */
  constructor(e) {
    if (this.constructor === mn)
      throw new Error("Plugin must be sub-classed; not directly instantiated.");
    this.player = e, this.log || (this.log = this.player.log.createLogger(this.name)), n0(this), delete this.trigger, XD(this, this.constructor.defaultState), MS(e, this.name), this.dispose = this.dispose.bind(this), e.on("dispose", this.dispose);
  }
  /**
   * Get the version of the plugin that was set on <pluginName>.VERSION
   */
  version() {
    return this.constructor.VERSION;
  }
  /**
   * Each event triggered by plugins includes a hash of additional data with
   * conventional properties.
   *
   * This returns that object or mutates an existing hash.
   *
   * @param   {Object} [hash={}]
   *          An object to be used as event an event hash.
   *
   * @return {PluginEventHash}
   *          An event hash object with provided properties mixed-in.
   */
  getEventHash(e = {}) {
    return e.name = this.name, e.plugin = this.constructor, e.instance = this, e;
  }
  /**
   * Triggers an event on the plugin object and overrides
   * {@link module:evented~EventedMixin.trigger|EventedMixin.trigger}.
   *
   * @param   {string|Object} event
   *          An event type or an object with a type property.
   *
   * @param   {Object} [hash={}]
   *          Additional data hash to merge with a
   *          {@link PluginEventHash|PluginEventHash}.
   *
   * @return {boolean}
   *          Whether or not default was prevented.
   */
  trigger(e, t = {}) {
    return Na(this.eventBusEl_, e, this.getEventHash(t));
  }
  /**
   * Handles "statechanged" events on the plugin. No-op by default, override by
   * subclassing.
   *
   * @abstract
   * @param    {Event} e
   *           An event object provided by a "statechanged" event.
   *
   * @param    {Object} e.changes
   *           An object describing changes that occurred with the "statechanged"
   *           event.
   */
  handleStateChanged(e) {
  }
  /**
   * Disposes a plugin.
   *
   * Subclasses can override this if they want, but for the sake of safety,
   * it's probably best to subscribe the "dispose" event.
   *
   * @fires Plugin#dispose
   */
  dispose() {
    const {
      name: e,
      player: t
    } = this;
    this.trigger("dispose"), this.off(), t.off("dispose", this.dispose), t[da][e] = !1, this.player = this.state = null, t[e] = j_(e, na[e]);
  }
  /**
   * Determines if a plugin is a basic plugin (i.e. not a sub-class of `Plugin`).
   *
   * @param   {string|Function} plugin
   *          If a string, matches the name of a plugin. If a function, will be
   *          tested directly.
   *
   * @return {boolean}
   *          Whether or not a plugin is a basic plugin.
   */
  static isBasic(e) {
    const t = typeof e == "string" ? Ku(e) : e;
    return typeof t == "function" && !mn.prototype.isPrototypeOf(t.prototype);
  }
  /**
   * Register a Video.js plugin.
   *
   * @param   {string} name
   *          The name of the plugin to be registered. Must be a string and
   *          must not match an existing plugin or a method on the `Player`
   *          prototype.
   *
   * @param   {typeof Plugin|Function} plugin
   *          A sub-class of `Plugin` or a function for basic plugins.
   *
   * @return {typeof Plugin|Function}
   *          For advanced plugins, a factory function for that plugin. For
   *          basic plugins, a wrapper function that initializes the plugin.
   */
  static registerPlugin(e, t) {
    if (typeof e != "string")
      throw new Error(`Illegal plugin name, "${e}", must be a string, was ${typeof e}.`);
    if (_c(e))
      at.warn(`A plugin named "${e}" already exists. You may want to avoid re-registering plugins!`);
    else if (dt.prototype.hasOwnProperty(e))
      throw new Error(`Illegal plugin name, "${e}", cannot share a name with an existing player method!`);
    if (typeof t != "function")
      throw new Error(`Illegal plugin for "${e}", must be a function, was ${typeof t}.`);
    return na[e] = t, e !== xc && (mn.isBasic(t) ? dt.prototype[e] = n9(e, t) : dt.prototype[e] = j_(e, t)), t;
  }
  /**
   * De-register a Video.js plugin.
   *
   * @param  {string} name
   *         The name of the plugin to be de-registered. Must be a string that
   *         matches an existing plugin.
   *
   * @throws {Error}
   *         If an attempt is made to de-register the base plugin.
   */
  static deregisterPlugin(e) {
    if (e === xc)
      throw new Error("Cannot de-register base plugin.");
    _c(e) && (delete na[e], delete dt.prototype[e]);
  }
  /**
   * Gets an object containing multiple Video.js plugins.
   *
   * @param   {Array} [names]
   *          If provided, should be an array of plugin names. Defaults to _all_
   *          plugin names.
   *
   * @return {Object|undefined}
   *          An object containing plugin(s) associated with their name(s) or
   *          `undefined` if no matching plugins exist).
   */
  static getPlugins(e = Object.keys(na)) {
    let t;
    return e.forEach((i) => {
      const r = Ku(i);
      r && (t = t || {}, t[i] = r);
    }), t;
  }
  /**
   * Gets a plugin's version, if available
   *
   * @param   {string} name
   *          The name of a plugin.
   *
   * @return {string}
   *          The plugin's version or an empty string.
   */
  static getPluginVersion(e) {
    const t = Ku(e);
    return t && t.VERSION || "";
  }
}
mn.getPlugin = Ku;
mn.BASE_PLUGIN_NAME = xc;
mn.registerPlugin(xc, mn);
dt.prototype.usingPlugin = function(n) {
  return !!this[da] && this[da][n] === !0;
};
dt.prototype.hasPlugin = function(n) {
  return !!_c(n);
};
function i9(n, e) {
  let t = !1;
  return function(...i) {
    return t || at.warn(n), t = !0, e.apply(this, i);
  };
}
function si(n, e, t, i) {
  return i9(`${e} is deprecated and will be removed in ${n}.0; please use ${t} instead.`, i);
}
var r9 = {
  NetworkBadStatus: "networkbadstatus",
  NetworkRequestFailed: "networkrequestfailed",
  NetworkRequestAborted: "networkrequestaborted",
  NetworkRequestTimeout: "networkrequesttimeout",
  NetworkBodyParserFailed: "networkbodyparserfailed",
  StreamingHlsPlaylistParserError: "streaminghlsplaylistparsererror",
  StreamingDashManifestParserError: "streamingdashmanifestparsererror",
  StreamingContentSteeringParserError: "streamingcontentsteeringparsererror",
  StreamingVttParserError: "streamingvttparsererror",
  StreamingFailedToSelectNextSegment: "streamingfailedtoselectnextsegment",
  StreamingFailedToDecryptSegment: "streamingfailedtodecryptsegment",
  StreamingFailedToTransmuxSegment: "streamingfailedtotransmuxsegment",
  StreamingFailedToAppendSegment: "streamingfailedtoappendsegment",
  StreamingCodecsChangeError: "streamingcodecschangeerror"
};
const BS = (n) => n.indexOf("#") === 0 ? n.slice(1) : n;
function ke(n, e, t) {
  let i = ke.getPlayer(n);
  if (i)
    return e && at.warn(`Player "${n}" is already initialised. Options will not be applied.`), t && i.ready(t), i;
  const r = typeof n == "string" ? ir("#" + BS(n)) : n;
  if (!Fa(r))
    throw new TypeError("The element or ID supplied is not valid. (videojs)");
  const s = ("getRootNode" in r ? r.getRootNode() instanceof me.ShadowRoot : !1) ? r.getRootNode() : r.ownerDocument.body;
  (!r.ownerDocument.defaultView || !s.contains(r)) && at.warn("The element supplied is not included in the DOM"), e = e || {}, e.restoreEl === !0 && (e.restoreEl = (r.parentNode && r.parentNode.hasAttribute && r.parentNode.hasAttribute("data-vjs-player") ? r.parentNode : r).cloneNode(!0)), nr("beforesetup").forEach((u) => {
    const c = u(r, yt(e));
    if (!xi(c) || Array.isArray(c)) {
      at.error("please return an object in beforesetup hooks");
      return;
    }
    e = yt(e, c);
  });
  const o = Pe.getComponent("Player");
  return i = new o(r, e, t), nr("setup").forEach((u) => u(i)), i;
}
ke.hooks_ = ki;
ke.hooks = nr;
ke.hook = MR;
ke.hookOnce = BR;
ke.removeHook = vD;
if (me.VIDEOJS_NO_DYNAMIC_STYLE !== !0 && Pa()) {
  let n = ir(".vjs-styles-defaults");
  if (!n) {
    n = VD("vjs-styles-defaults");
    const e = ir("head");
    e && e.insertBefore(n, e.firstChild), HD(n, `
      .video-js {
        width: 300px;
        height: 150px;
      }

      .vjs-fluid:not(.vjs-audio-only-mode) {
        padding-top: 56.25%
      }
    `);
  }
}
mm(1, ke);
ke.VERSION = dm;
ke.options = dt.prototype.options_;
ke.getPlayers = () => dt.players;
ke.getPlayer = (n) => {
  const e = dt.players;
  let t;
  if (typeof n == "string") {
    const i = BS(n), r = e[i];
    if (r)
      return r;
    t = ir("#" + i);
  } else
    t = n;
  if (Fa(t)) {
    const {
      player: i,
      playerId: r
    } = t;
    if (i || e[r])
      return i || e[r];
  }
};
ke.getAllPlayers = () => (
  // Disposed players leave a key with a `null` value, so we need to make sure
  // we filter those out.
  Object.keys(dt.players).map((n) => dt.players[n]).filter(Boolean)
);
ke.players = dt.players;
ke.getComponent = Pe.getComponent;
ke.registerComponent = (n, e) => (tt.isTech(e) && at.warn(`The ${n} tech was registered as a component. It should instead be registered using videojs.registerTech(name, tech)`), Pe.registerComponent.call(Pe, n, e));
ke.getTech = tt.getTech;
ke.registerTech = tt.registerTech;
ke.use = fO;
Object.defineProperty(ke, "middleware", {
  value: {},
  writeable: !1,
  enumerable: !0
});
Object.defineProperty(ke.middleware, "TERMINATOR", {
  value: yc,
  writeable: !1,
  enumerable: !0
});
ke.browser = AD;
ke.obj = WR;
ke.mergeOptions = si(9, "videojs.mergeOptions", "videojs.obj.merge", yt);
ke.defineLazyProperty = si(9, "videojs.defineLazyProperty", "videojs.obj.defineLazyProperty", hl);
ke.bind = si(9, "videojs.bind", "native Function.prototype.bind", _t);
ke.registerPlugin = mn.registerPlugin;
ke.deregisterPlugin = mn.deregisterPlugin;
ke.plugin = (n, e) => (at.warn("videojs.plugin() is deprecated; use videojs.registerPlugin() instead"), mn.registerPlugin(n, e));
ke.getPlugins = mn.getPlugins;
ke.getPlugin = mn.getPlugin;
ke.getPluginVersion = mn.getPluginVersion;
ke.addLanguage = function(n, e) {
  return n = ("" + n).toLowerCase(), ke.options.languages = yt(ke.options.languages, {
    [n]: e
  }), ke.options.languages[n];
};
ke.log = at;
ke.createLogger = xD;
ke.time = iO;
ke.createTimeRange = si(9, "videojs.createTimeRange", "videojs.time.createTimeRanges", ii);
ke.createTimeRanges = si(9, "videojs.createTimeRanges", "videojs.time.createTimeRanges", ii);
ke.formatTime = si(9, "videojs.formatTime", "videojs.time.formatTime", Nr);
ke.setFormatTime = si(9, "videojs.setFormatTime", "videojs.time.setFormatTime", QD);
ke.resetFormatTime = si(9, "videojs.resetFormatTime", "videojs.time.resetFormatTime", ZD);
ke.parseUrl = si(9, "videojs.parseUrl", "videojs.url.parseUrl", s0);
ke.isCrossOrigin = si(9, "videojs.isCrossOrigin", "videojs.url.isCrossOrigin", Dl);
ke.EventTarget = Dn;
ke.any = t0;
ke.on = En;
ke.one = wl;
ke.off = Xt;
ke.trigger = Na;
ke.xhr = aD;
ke.TrackList = Mr;
ke.TextTrack = mo;
ke.TextTrackList = r0;
ke.AudioTrack = iS;
ke.AudioTrackList = eS;
ke.VideoTrack = rS;
ke.VideoTrackList = tS;
["isEl", "isTextNode", "createEl", "hasClass", "addClass", "removeClass", "toggleClass", "setAttributes", "getAttributes", "emptyEl", "appendContent", "insertContent"].forEach((n) => {
  ke[n] = function() {
    return at.warn(`videojs.${n}() is deprecated; use videojs.dom.${n}() instead`), qD[n].apply(null, arguments);
  };
});
ke.computedStyle = si(9, "videojs.computedStyle", "videojs.dom.computedStyle", Ca);
ke.dom = qD;
ke.fn = QR;
ke.num = OO;
ke.str = tO;
ke.url = lO;
ke.Error = r9;
/*! @name videojs-contrib-quality-levels @version 4.1.0 @license Apache-2.0 */
class a9 {
  /**
   * Creates a QualityLevel
   *
   * @param {Representation|Object} representation The representation of the quality level
   * @param {string}   representation.id        Unique id of the QualityLevel
   * @param {number=}  representation.width     Resolution width of the QualityLevel
   * @param {number=}  representation.height    Resolution height of the QualityLevel
   * @param {number}   representation.bandwidth Bitrate of the QualityLevel
   * @param {number=}  representation.frameRate Frame-rate of the QualityLevel
   * @param {Function} representation.enabled   Callback to enable/disable QualityLevel
   */
  constructor(e) {
    let t = this;
    return t.id = e.id, t.label = t.id, t.width = e.width, t.height = e.height, t.bitrate = e.bandwidth, t.frameRate = e.frameRate, t.enabled_ = e.enabled, Object.defineProperty(t, "enabled", {
      /**
       * Get whether the QualityLevel is enabled.
       *
       * @return {boolean} True if the QualityLevel is enabled.
       */
      get() {
        return t.enabled_();
      },
      /**
       * Enable or disable the QualityLevel.
       *
       * @param {boolean} enable true to enable QualityLevel, false to disable.
       */
      set(i) {
        t.enabled_(i);
      }
    }), t;
  }
}
class wc extends ke.EventTarget {
  /**
   * Creates a QualityLevelList.
   */
  constructor() {
    super();
    let e = this;
    return e.levels_ = [], e.selectedIndex_ = -1, Object.defineProperty(e, "selectedIndex", {
      get() {
        return e.selectedIndex_;
      }
    }), Object.defineProperty(e, "length", {
      get() {
        return e.levels_.length;
      }
    }), e[Symbol.iterator] = () => e.levels_.values(), e;
  }
  /**
   * Adds a quality level to the list.
   *
   * @param {Representation|Object} representation The representation of the quality level
   * @param {string}   representation.id        Unique id of the QualityLevel
   * @param {number=}  representation.width     Resolution width of the QualityLevel
   * @param {number=}  representation.height    Resolution height of the QualityLevel
   * @param {number}   representation.bandwidth Bitrate of the QualityLevel
   * @param {number=}  representation.frameRate Frame-rate of the QualityLevel
   * @param {Function} representation.enabled   Callback to enable/disable QualityLevel
   * @return {QualityLevel} the QualityLevel added to the list
   * @method addQualityLevel
   */
  addQualityLevel(e) {
    let t = this.getQualityLevelById(e.id);
    if (t)
      return t;
    const i = this.levels_.length;
    return t = new a9(e), "" + i in this || Object.defineProperty(this, i, {
      get() {
        return this.levels_[i];
      }
    }), this.levels_.push(t), this.trigger({
      qualityLevel: t,
      type: "addqualitylevel"
    }), t;
  }
  /**
   * Removes a quality level from the list.
   *
   * @param {QualityLevel} qualityLevel The QualityLevel to remove from the list.
   * @return {QualityLevel|null} the QualityLevel removed or null if nothing removed
   * @method removeQualityLevel
   */
  removeQualityLevel(e) {
    let t = null;
    for (let i = 0, r = this.length; i < r; i++)
      if (this[i] === e) {
        t = this.levels_.splice(i, 1)[0], this.selectedIndex_ === i ? this.selectedIndex_ = -1 : this.selectedIndex_ > i && this.selectedIndex_--;
        break;
      }
    return t && this.trigger({
      qualityLevel: e,
      type: "removequalitylevel"
    }), t;
  }
  /**
   * Searches for a QualityLevel with the given id.
   *
   * @param {string} id The id of the QualityLevel to find.
   * @return {QualityLevel|null} The QualityLevel with id, or null if not found.
   * @method getQualityLevelById
   */
  getQualityLevelById(e) {
    for (let t = 0, i = this.length; t < i; t++) {
      const r = this[t];
      if (r.id === e)
        return r;
    }
    return null;
  }
  /**
   * Resets the list of QualityLevels to empty
   *
   * @method dispose
   */
  dispose() {
    this.selectedIndex_ = -1, this.levels_.length = 0;
  }
}
wc.prototype.allowedEvents_ = {
  change: "change",
  addqualitylevel: "addqualitylevel",
  removequalitylevel: "removequalitylevel"
};
for (const n in wc.prototype.allowedEvents_)
  wc.prototype["on" + n] = null;
var jS = "4.1.0";
const s9 = function(n, e) {
  const t = n.qualityLevels, i = new wc(), r = function() {
    i.dispose(), n.qualityLevels = t, n.off("dispose", r);
  };
  return n.on("dispose", r), n.qualityLevels = () => i, n.qualityLevels.VERSION = jS, i;
}, qS = function(n) {
  return s9(this, ke.obj.merge({}, n));
};
ke.registerPlugin("qualityLevels", qS);
qS.VERSION = jS;
/*! @name @videojs/http-streaming @version 3.17.2 @license Apache-2.0 */
const hn = XI, Ec = (n, e) => e && e.responseURL && n !== e.responseURL ? e.responseURL : n, jn = (n) => ke.log.debug ? ke.log.debug.bind(ke, "VHS:", `${n} >`) : function() {
};
function ft(...n) {
  const e = ke.obj || ke;
  return (e.merge || e.mergeOptions).apply(e, n);
}
function Vt(...n) {
  const e = ke.time || ke;
  return (e.createTimeRanges || e.createTimeRanges).apply(e, n);
}
function o9(n) {
  if (n.length === 0)
    return "Buffered Ranges are empty";
  let e = `Buffered Ranges: 
`;
  for (let t = 0; t < n.length; t++) {
    const i = n.start(t), r = n.end(t);
    e += `${i} --> ${r}. Duration (${r - i})
`;
  }
  return e;
}
const gi = 1 / 30, bi = gi * 3, WS = function(n, e) {
  const t = [];
  let i;
  if (n && n.length)
    for (i = 0; i < n.length; i++)
      e(n.start(i), n.end(i)) && t.push([n.start(i), n.end(i)]);
  return Vt(t);
}, ia = function(n, e) {
  return WS(n, function(t, i) {
    return t - bi <= e && i + bi >= e;
  });
}, _u = function(n, e) {
  return WS(n, function(t) {
    return t - gi >= e;
  });
}, u9 = function(n) {
  if (n.length < 2)
    return Vt();
  const e = [];
  for (let t = 1; t < n.length; t++) {
    const i = n.end(t - 1), r = n.start(t);
    e.push([i, r]);
  }
  return Vt(e);
}, c9 = function(n, e) {
  let t = null, i = null, r = 0;
  const a = [], s = [];
  if (!n || !n.length || !e || !e.length)
    return Vt();
  let o = n.length;
  for (; o--; )
    a.push({
      time: n.start(o),
      type: "start"
    }), a.push({
      time: n.end(o),
      type: "end"
    });
  for (o = e.length; o--; )
    a.push({
      time: e.start(o),
      type: "start"
    }), a.push({
      time: e.end(o),
      type: "end"
    });
  for (a.sort(function(u, c) {
    return u.time - c.time;
  }), o = 0; o < a.length; o++)
    a[o].type === "start" ? (r++, r === 2 && (t = a[o].time)) : a[o].type === "end" && (r--, r === 1 && (i = a[o].time)), t !== null && i !== null && (s.push([t, i]), t = null, i = null);
  return Vt(s);
}, VS = (n) => {
  const e = [];
  if (!n || !n.length)
    return "";
  for (let t = 0; t < n.length; t++)
    e.push(n.start(t) + " => " + n.end(t));
  return e.join(", ");
}, l9 = function(n, e, t = 1) {
  return ((n.length ? n.end(n.length - 1) : 0) - e) / t;
}, kr = (n) => {
  const e = [];
  for (let t = 0; t < n.length; t++)
    e.push({
      start: n.start(t),
      end: n.end(t)
    });
  return e;
}, d9 = function(n, e) {
  if (n === e)
    return !1;
  if (!n && e || !e && n || n.length !== e.length)
    return !0;
  for (let t = 0; t < n.length; t++)
    if (n.start(t) !== e.start(t) || n.end(t) !== e.end(t))
      return !0;
  return !1;
}, Fp = function(n) {
  if (!(!n || !n.length || !n.end))
    return n.end(n.length - 1);
}, w0 = function(n, e) {
  let t = 0;
  if (!n || !n.length)
    return t;
  for (let i = 0; i < n.length; i++) {
    const r = n.start(i), a = n.end(i);
    if (!(e > a)) {
      if (e > r && e <= a) {
        t += a - e;
        continue;
      }
      t += a - r;
    }
  }
  return t;
}, E0 = (n, e) => {
  if (!e.preload)
    return e.duration;
  let t = 0;
  return (e.parts || []).forEach(function(i) {
    t += i.duration;
  }), (e.preloadHints || []).forEach(function(i) {
    i.type === "PART" && (t += n.partTargetDuration);
  }), t;
}, wm = (n) => (n.segments || []).reduce((e, t, i) => (t.parts ? t.parts.forEach(function(r, a) {
  e.push({
    duration: r.duration,
    segmentIndex: i,
    partIndex: a,
    part: r,
    segment: t
  });
}) : e.push({
  duration: t.duration,
  segmentIndex: i,
  partIndex: null,
  segment: t,
  part: null
}), e), []), HS = (n) => {
  const e = n.segments && n.segments.length && n.segments[n.segments.length - 1];
  return e && e.parts || [];
}, zS = ({
  preloadSegment: n
}) => {
  if (!n)
    return;
  const {
    parts: e,
    preloadHints: t
  } = n;
  let i = (t || []).reduce((r, a) => r + (a.type === "PART" ? 1 : 0), 0);
  return i += e && e.length ? e.length : 0, i;
}, $S = (n, e) => {
  if (e.endList)
    return 0;
  if (n && n.suggestedPresentationDelay)
    return n.suggestedPresentationDelay;
  const t = HS(e).length > 0;
  return t && e.serverControl && e.serverControl.partHoldBack ? e.serverControl.partHoldBack : t && e.partTargetDuration ? e.partTargetDuration * 3 : e.serverControl && e.serverControl.holdBack ? e.serverControl.holdBack : e.targetDuration ? e.targetDuration * 3 : 0;
}, f9 = function(n, e) {
  let t = 0, i = e - n.mediaSequence, r = n.segments[i];
  if (r) {
    if (typeof r.start < "u")
      return {
        result: r.start,
        precise: !0
      };
    if (typeof r.end < "u")
      return {
        result: r.end - r.duration,
        precise: !0
      };
  }
  for (; i--; ) {
    if (r = n.segments[i], typeof r.end < "u")
      return {
        result: t + r.end,
        precise: !0
      };
    if (t += E0(n, r), typeof r.start < "u")
      return {
        result: t + r.start,
        precise: !0
      };
  }
  return {
    result: t,
    precise: !1
  };
}, h9 = function(n, e) {
  let t = 0, i, r = e - n.mediaSequence;
  for (; r < n.segments.length; r++) {
    if (i = n.segments[r], typeof i.start < "u")
      return {
        result: i.start - t,
        precise: !0
      };
    if (t += E0(n, i), typeof i.end < "u")
      return {
        result: i.end - t,
        precise: !0
      };
  }
  return {
    result: -1,
    precise: !1
  };
}, GS = function(n, e, t) {
  if (typeof e > "u" && (e = n.mediaSequence + n.segments.length), e < n.mediaSequence)
    return 0;
  const i = f9(n, e);
  if (i.precise)
    return i.result;
  const r = h9(n, e);
  return r.precise ? r.result : i.result + t;
}, XS = function(n, e, t) {
  if (!n)
    return 0;
  if (typeof t != "number" && (t = 0), typeof e > "u") {
    if (n.totalDuration)
      return n.totalDuration;
    if (!n.endList)
      return me.Infinity;
  }
  return GS(n, e, t);
}, Fs = function({
  defaultDuration: n,
  durationList: e,
  startIndex: t,
  endIndex: i
}) {
  let r = 0;
  if (t > i && ([t, i] = [i, t]), t < 0) {
    for (let a = t; a < Math.min(0, i); a++)
      r += n;
    t = 0;
  }
  for (let a = t; a < i; a++)
    r += e[a].duration;
  return r;
}, KS = function(n, e, t, i) {
  if (!n || !n.segments)
    return null;
  if (n.endList)
    return XS(n);
  if (e === null)
    return null;
  e = e || 0;
  let r = GS(n, n.mediaSequence + n.segments.length, e);
  return t && (i = typeof i == "number" ? i : $S(null, n), r -= i), Math.max(0, r);
}, p9 = function(n, e, t) {
  const r = e || 0;
  let a = KS(n, e, !0, t);
  return a === null ? Vt() : (a < r && (a = r), Vt(r, a));
}, m9 = function({
  playlist: n,
  currentTime: e,
  startingSegmentIndex: t,
  startingPartIndex: i,
  startTime: r,
  exactManifestTimings: a
}) {
  let s = e - r;
  const o = wm(n);
  let u = 0;
  for (let c = 0; c < o.length; c++) {
    const l = o[c];
    if (t === l.segmentIndex && !(typeof i == "number" && typeof l.partIndex == "number" && i !== l.partIndex)) {
      u = c;
      break;
    }
  }
  if (s < 0) {
    if (u > 0)
      for (let c = u - 1; c >= 0; c--) {
        const l = o[c];
        if (s += l.duration, a) {
          if (s < 0)
            continue;
        } else if (s + gi <= 0)
          continue;
        return {
          partIndex: l.partIndex,
          segmentIndex: l.segmentIndex,
          startTime: r - Fs({
            defaultDuration: n.targetDuration,
            durationList: o,
            startIndex: u,
            endIndex: c
          })
        };
      }
    return {
      partIndex: o[0] && o[0].partIndex || null,
      segmentIndex: o[0] && o[0].segmentIndex || 0,
      startTime: e
    };
  }
  if (u < 0) {
    for (let c = u; c < 0; c++)
      if (s -= n.targetDuration, s < 0)
        return {
          partIndex: o[0] && o[0].partIndex || null,
          segmentIndex: o[0] && o[0].segmentIndex || 0,
          startTime: e
        };
    u = 0;
  }
  for (let c = u; c < o.length; c++) {
    const l = o[c];
    s -= l.duration;
    const h = l.duration > gi, f = s === 0, d = h && s + gi >= 0;
    if (!((f || d) && c !== o.length - 1)) {
      if (a) {
        if (s > 0)
          continue;
      } else if (s - gi >= 0)
        continue;
      return {
        partIndex: l.partIndex,
        segmentIndex: l.segmentIndex,
        startTime: r + Fs({
          defaultDuration: n.targetDuration,
          durationList: o,
          startIndex: u,
          endIndex: c
        })
      };
    }
  }
  return {
    segmentIndex: o[o.length - 1].segmentIndex,
    partIndex: o[o.length - 1].partIndex,
    startTime: e
  };
}, YS = function(n) {
  return n.excludeUntil && n.excludeUntil > Date.now();
}, D0 = function(n) {
  return n.excludeUntil && n.excludeUntil === 1 / 0;
}, Al = function(n) {
  const e = YS(n);
  return !n.disabled && !e;
}, g9 = function(n) {
  return n.disabled;
}, b9 = function(n) {
  for (let e = 0; e < n.segments.length; e++)
    if (n.segments[e].key)
      return !0;
  return !1;
}, QS = function(n, e) {
  return e.attributes && e.attributes[n];
}, y9 = function(n, e, t, i = 0) {
  return QS("BANDWIDTH", t) ? (n * t.attributes.BANDWIDTH - i * 8) / e : NaN;
}, Em = (n, e) => {
  if (n.playlists.length === 1)
    return !0;
  const t = e.attributes.BANDWIDTH || Number.MAX_VALUE;
  return n.playlists.filter((i) => Al(i) ? (i.attributes.BANDWIDTH || 0) < t : !1).length === 0;
}, S0 = (n, e) => !n && !e || !n && e || n && !e ? !1 : !!(n === e || n.id && e.id && n.id === e.id || n.resolvedUri && e.resolvedUri && n.resolvedUri === e.resolvedUri || n.uri && e.uri && n.uri === e.uri), q_ = function(n, e) {
  const t = n && n.mediaGroups && n.mediaGroups.AUDIO || {};
  let i = !1;
  for (const r in t) {
    for (const a in t[r])
      if (i = e(t[r][a]), i)
        break;
    if (i)
      break;
  }
  return !!i;
}, vo = (n) => {
  if (!n || !n.playlists || !n.playlists.length)
    return q_(n, (t) => t.playlists && t.playlists.length || t.uri);
  for (let e = 0; e < n.playlists.length; e++) {
    const t = n.playlists[e], i = t.attributes && t.attributes.CODECS;
    if (!(i && i.split(",").every((a) => oD(a)) || q_(n, (a) => S0(t, a))))
      return !1;
  }
  return !0;
};
var pn = {
  liveEdgeDelay: $S,
  duration: XS,
  seekable: p9,
  getMediaInfoForTime: m9,
  isEnabled: Al,
  isDisabled: g9,
  isExcluded: YS,
  isIncompatible: D0,
  playlistEnd: KS,
  isAes: b9,
  hasAttribute: QS,
  estimateSegmentRequestTime: y9,
  isLowestEnabledRendition: Em,
  isAudioOnly: vo,
  playlistMatch: S0,
  segmentDurationWithParts: E0
};
const {
  log: ZS
} = ke, fa = (n, e) => `${n}-${e}`, JS = (n, e, t) => `placeholder-uri-${n}-${e}-${t}`, v9 = ({
  onwarn: n,
  oninfo: e,
  manifestString: t,
  customTagParsers: i = [],
  customTagMappers: r = [],
  llhls: a
}) => {
  const s = new nU();
  n && s.on("warn", n), e && s.on("info", e), i.forEach((c) => s.addParser(c)), r.forEach((c) => s.addTagMapper(c)), s.push(t), s.end();
  const o = s.manifest;
  if (a || (["preloadSegment", "skip", "serverControl", "renditionReports", "partInf", "partTargetDuration"].forEach(function(c) {
    o.hasOwnProperty(c) && delete o[c];
  }), o.segments && o.segments.forEach(function(c) {
    ["parts", "preloadHints"].forEach(function(l) {
      c.hasOwnProperty(l) && delete c[l];
    });
  })), !o.targetDuration) {
    let c = 10;
    o.segments && o.segments.length && (c = o.segments.reduce((l, h) => Math.max(l, h.duration), 0)), n && n({
      message: `manifest has no targetDuration defaulting to ${c}`
    }), o.targetDuration = c;
  }
  const u = HS(o);
  if (u.length && !o.partTargetDuration) {
    const c = u.reduce((l, h) => Math.max(l, h.duration), 0);
    n && (n({
      message: `manifest has no partTargetDuration defaulting to ${c}`
    }), ZS.error("LL-HLS manifest has parts but lacks required #EXT-X-PART-INF:PART-TARGET value. See https://datatracker.ietf.org/doc/html/draft-pantos-hls-rfc8216bis-09#section-4.4.3.7. Playback is not guaranteed.")), o.partTargetDuration = c;
  }
  return o;
}, qa = (n, e) => {
  n.mediaGroups && ["AUDIO", "SUBTITLES"].forEach((t) => {
    if (n.mediaGroups[t])
      for (const i in n.mediaGroups[t])
        for (const r in n.mediaGroups[t][i]) {
          const a = n.mediaGroups[t][i][r];
          e(a, t, i, r);
        }
  });
}, e3 = ({
  playlist: n,
  uri: e,
  id: t
}) => {
  n.id = t, n.playlistErrors_ = 0, e && (n.uri = e), n.attributes = n.attributes || {};
}, x9 = (n) => {
  let e = n.playlists.length;
  for (; e--; ) {
    const t = n.playlists[e];
    e3({
      playlist: t,
      id: fa(e, t.uri)
    }), t.resolvedUri = hn(n.uri, t.uri), n.playlists[t.id] = t, n.playlists[t.uri] = t, t.attributes.BANDWIDTH || ZS.warn("Invalid playlist STREAM-INF detected. Missing BANDWIDTH attribute.");
  }
}, _9 = (n) => {
  qa(n, (e) => {
    e.uri && (e.resolvedUri = hn(n.uri, e.uri));
  });
}, T9 = (n, e) => {
  const t = fa(0, e), i = {
    mediaGroups: {
      AUDIO: {},
      VIDEO: {},
      "CLOSED-CAPTIONS": {},
      SUBTITLES: {}
    },
    uri: me.location.href,
    resolvedUri: me.location.href,
    playlists: [{
      uri: e,
      id: t,
      resolvedUri: e,
      // m3u8-parser does not attach an attributes property to media playlists so make
      // sure that the property is attached to avoid undefined reference errors
      attributes: {}
    }]
  };
  return i.playlists[t] = i.playlists[0], i.playlists[e] = i.playlists[0], i;
}, t3 = (n, e, t = JS) => {
  n.uri = e;
  for (let r = 0; r < n.playlists.length; r++)
    if (!n.playlists[r].uri) {
      const a = `placeholder-uri-${r}`;
      n.playlists[r].uri = a;
    }
  const i = vo(n);
  qa(n, (r, a, s, o) => {
    if (!r.playlists || !r.playlists.length) {
      if (i && a === "AUDIO" && !r.uri)
        for (let u = 0; u < n.playlists.length; u++) {
          const c = n.playlists[u];
          if (c.attributes && c.attributes.AUDIO && c.attributes.AUDIO === s)
            return;
        }
      r.playlists = [Lt({}, r)];
    }
    r.playlists.forEach(function(u, c) {
      const l = t(a, s, o, u), h = fa(c, l);
      u.uri ? u.resolvedUri = u.resolvedUri || hn(n.uri, u.uri) : (u.uri = c === 0 ? l : h, u.resolvedUri = u.uri), u.id = u.id || h, u.attributes = u.attributes || {}, n.playlists[u.id] = u, n.playlists[u.uri] = u;
    });
  }), x9(n), _9(n);
};
class W_ {
  constructor() {
    this.offset_ = null, this.pendingDateRanges_ = /* @__PURE__ */ new Map(), this.processedDateRanges_ = /* @__PURE__ */ new Map();
  }
  setOffset(e = []) {
    if (this.offset_ !== null || !e.length)
      return;
    const [t] = e;
    t.programDateTime !== void 0 && (this.offset_ = t.programDateTime / 1e3);
  }
  setPendingDateRanges(e = []) {
    if (!e.length)
      return;
    const [t] = e, i = t.startDate.getTime();
    this.trimProcessedDateRanges_(i), this.pendingDateRanges_ = e.reduce((r, a) => (r.set(a.id, a), r), /* @__PURE__ */ new Map());
  }
  processDateRange(e) {
    this.pendingDateRanges_.delete(e.id), this.processedDateRanges_.set(e.id, e);
  }
  getDateRangesToProcess() {
    if (this.offset_ === null)
      return [];
    const e = {}, t = [];
    this.pendingDateRanges_.forEach((i, r) => {
      if (!this.processedDateRanges_.has(r) && (i.startTime = i.startDate.getTime() / 1e3 - this.offset_, i.processDateRange = () => this.processDateRange(i), t.push(i), !!i.class))
        if (e[i.class]) {
          const a = e[i.class].push(i);
          i.classListIndex = a - 1;
        } else
          e[i.class] = [i], i.classListIndex = 0;
    });
    for (const i of t) {
      const r = e[i.class] || [];
      i.endDate ? i.endTime = i.endDate.getTime() / 1e3 - this.offset_ : i.endOnNext && r[i.classListIndex + 1] ? i.endTime = r[i.classListIndex + 1].startTime : i.duration ? i.endTime = i.startTime + i.duration : i.plannedDuration ? i.endTime = i.startTime + i.plannedDuration : i.endTime = i.startTime;
    }
    return t;
  }
  trimProcessedDateRanges_(e) {
    new Map(this.processedDateRanges_).forEach((i, r) => {
      i.startDate.getTime() < e && this.processedDateRanges_.delete(r);
    });
  }
}
const n3 = 22, Pr = ({
  requestType: n,
  request: e,
  error: t,
  parseFailure: i
}) => {
  const r = e.status < 200 || e.status > 299, a = e.status >= 400 && e.status <= 499, s = {
    uri: e.uri,
    requestType: n
  }, o = r && !a || i;
  if (t && a)
    s.error = Lt({}, t), s.errorType = ke.Error.NetworkRequestFailed;
  else if (e.aborted)
    s.errorType = ke.Error.NetworkRequestAborted;
  else if (e.timedout)
    s.errorType = ke.Error.NetworkRequestTimeout;
  else if (o) {
    const u = i ? ke.Error.NetworkBodyParserFailed : ke.Error.NetworkBadStatus;
    s.errorType = u, s.status = e.status, s.headers = e.headers;
  }
  return s;
}, w9 = jn("CodecUtils"), i3 = function(n) {
  const e = n.attributes || {};
  if (e.CODECS)
    return hi(e.CODECS);
}, r3 = (n, e) => {
  const t = e.attributes || {};
  return n && n.mediaGroups && n.mediaGroups.AUDIO && t.AUDIO && n.mediaGroups.AUDIO[t.AUDIO];
}, E9 = (n, e) => {
  if (!r3(n, e))
    return !0;
  const t = e.attributes || {}, i = n.mediaGroups.AUDIO[t.AUDIO];
  for (const r in i)
    if (!i[r].uri && !i[r].playlists)
      return !0;
  return !1;
}, eo = function(n) {
  const e = {};
  return n.forEach(({
    mediaType: t,
    type: i,
    details: r
  }) => {
    e[t] = e[t] || [], e[t].push(sD(`${i}${r}`));
  }), Object.keys(e).forEach(function(t) {
    if (e[t].length > 1) {
      w9(`multiple ${t} codecs found as attributes: ${e[t].join(", ")}. Setting playlist codecs to null so that we wait for mux.js to probe segments for real codecs.`), e[t] = null;
      return;
    }
    e[t] = e[t][0];
  }), e;
}, V_ = function(n) {
  let e = 0;
  return n.audio && e++, n.video && e++, e;
}, Ns = function(n, e) {
  const t = e.attributes || {}, i = eo(i3(e) || []);
  if (r3(n, e) && !i.audio && !E9(n, e)) {
    const r = eo(rU(n, t.AUDIO) || []);
    r.audio && (i.audio = r.audio);
  }
  return i;
}, {
  EventTarget: D9
} = ke, S9 = (n, e) => {
  if (e.endList || !e.serverControl)
    return n;
  const t = {};
  if (e.serverControl.canBlockReload) {
    const {
      preloadSegment: i
    } = e;
    let r = e.mediaSequence + e.segments.length;
    if (i) {
      const a = i.parts || [], s = zS(e) - 1;
      s > -1 && s !== a.length - 1 && (t._HLS_part = s), (s > -1 || a.length) && r--;
    }
    t._HLS_msn = r;
  }
  if (e.serverControl && e.serverControl.canSkipUntil && (t._HLS_skip = e.serverControl.canSkipDateranges ? "v2" : "YES"), Object.keys(t).length) {
    const i = new me.URL(n);
    ["_HLS_skip", "_HLS_msn", "_HLS_part"].forEach(function(r) {
      t.hasOwnProperty(r) && i.searchParams.set(r, t[r]);
    }), n = i.toString();
  }
  return n;
}, C9 = (n, e) => {
  if (!n)
    return e;
  const t = ft(n, e);
  if (n.preloadHints && !e.preloadHints && delete t.preloadHints, n.parts && !e.parts)
    delete t.parts;
  else if (n.parts && e.parts)
    for (let i = 0; i < e.parts.length; i++)
      n.parts && n.parts[i] && (t.parts[i] = ft(n.parts[i], e.parts[i]));
  return !n.skipped && e.skipped && (t.skipped = !1), n.preload && !e.preload && (t.preload = !1), t;
}, A9 = (n, e, t) => {
  const i = n.slice(), r = e.slice();
  t = t || 0;
  const a = [];
  let s;
  for (let o = 0; o < r.length; o++) {
    const u = i[o + t], c = r[o];
    u ? (s = u.map || s, a.push(C9(u, c))) : (s && !c.map && (c.map = s), a.push(c));
  }
  return a;
}, a3 = (n, e) => {
  !n.resolvedUri && n.uri && (n.resolvedUri = hn(e, n.uri)), n.key && !n.key.resolvedUri && (n.key.resolvedUri = hn(e, n.key.uri)), n.map && !n.map.resolvedUri && (n.map.resolvedUri = hn(e, n.map.uri)), n.map && n.map.key && !n.map.key.resolvedUri && (n.map.key.resolvedUri = hn(e, n.map.key.uri)), n.parts && n.parts.length && n.parts.forEach((t) => {
    t.resolvedUri || (t.resolvedUri = hn(e, t.uri));
  }), n.preloadHints && n.preloadHints.length && n.preloadHints.forEach((t) => {
    t.resolvedUri || (t.resolvedUri = hn(e, t.uri));
  });
}, s3 = function(n) {
  const e = n.segments || [], t = n.preloadSegment;
  if (t && t.parts && t.parts.length) {
    if (t.preloadHints) {
      for (let i = 0; i < t.preloadHints.length; i++)
        if (t.preloadHints[i].type === "MAP")
          return e;
    }
    t.duration = n.targetDuration, t.preload = !0, e.push(t);
  }
  return e;
}, o3 = (n, e) => n === e || n.segments && e.segments && n.segments.length === e.segments.length && n.endList === e.endList && n.mediaSequence === e.mediaSequence && n.preloadSegment === e.preloadSegment, Dm = (n, e, t = o3) => {
  const i = ft(n, {}), r = i.playlists[e.id];
  if (!r || t(r, e))
    return null;
  e.segments = s3(e);
  const a = ft(r, e);
  if (a.preloadSegment && !e.preloadSegment && delete a.preloadSegment, r.segments) {
    if (e.skip) {
      e.segments = e.segments || [];
      for (let s = 0; s < e.skip.skippedSegments; s++)
        e.segments.unshift({
          skipped: !0
        });
    }
    a.segments = A9(r.segments, e.segments, e.mediaSequence - r.mediaSequence);
  }
  a.segments.forEach((s) => {
    a3(s, a.resolvedUri);
  });
  for (let s = 0; s < i.playlists.length; s++)
    i.playlists[s].id === e.id && (i.playlists[s] = a);
  return i.playlists[e.id] = a, i.playlists[e.uri] = a, qa(n, (s, o, u, c) => {
    if (s.playlists)
      for (let l = 0; l < s.playlists.length; l++)
        e.id === s.playlists[l].id && (s.playlists[l] = a);
  }), i;
}, Sm = (n, e) => {
  const t = n.segments || [], i = t[t.length - 1], r = i && i.parts && i.parts[i.parts.length - 1], a = r && r.duration || i && i.duration;
  return e && a ? a * 1e3 : (n.partTargetDuration || n.targetDuration || 10) * 500;
}, H_ = (n, e, t) => {
  if (!n)
    return;
  const i = [];
  return n.forEach((r) => {
    if (!r.attributes)
      return;
    const {
      BANDWIDTH: a,
      RESOLUTION: s,
      CODECS: o
    } = r.attributes;
    i.push({
      id: r.id,
      bandwidth: a,
      resolution: s,
      codecs: o
    });
  }), {
    type: e,
    isLive: t,
    renditions: i
  };
};
class ra extends D9 {
  constructor(e, t, i = {}) {
    if (super(), !e)
      throw new Error("A non-empty playlist URL or object is required");
    this.logger_ = jn("PlaylistLoader");
    const {
      withCredentials: r = !1
    } = i;
    this.src = e, this.vhs_ = t, this.withCredentials = r, this.addDateRangesToTextTrack_ = i.addDateRangesToTextTrack;
    const a = t.options_;
    this.customTagParsers = a && a.customTagParsers || [], this.customTagMappers = a && a.customTagMappers || [], this.llhls = a && a.llhls, this.dateRangesStorage_ = new W_(), this.state = "HAVE_NOTHING", this.handleMediaupdatetimeout_ = this.handleMediaupdatetimeout_.bind(this), this.on("mediaupdatetimeout", this.handleMediaupdatetimeout_), this.on("loadedplaylist", this.handleLoadedPlaylist_.bind(this));
  }
  handleLoadedPlaylist_() {
    const e = this.media();
    if (!e)
      return;
    this.dateRangesStorage_.setOffset(e.segments), this.dateRangesStorage_.setPendingDateRanges(e.dateRanges);
    const t = this.dateRangesStorage_.getDateRangesToProcess();
    !t.length || !this.addDateRangesToTextTrack_ || this.addDateRangesToTextTrack_(t);
  }
  handleMediaupdatetimeout_() {
    if (this.state !== "HAVE_METADATA")
      return;
    const e = this.media();
    let t = hn(this.main.uri, e.uri);
    this.llhls && (t = S9(t, e)), this.state = "HAVE_CURRENT_METADATA", this.request = this.vhs_.xhr({
      uri: t,
      withCredentials: this.withCredentials,
      requestType: "hls-playlist"
    }, (i, r) => {
      if (this.request) {
        if (i)
          return this.playlistRequestError(this.request, this.media(), "HAVE_METADATA");
        this.haveMetadata({
          playlistString: this.request.responseText,
          url: this.media().uri,
          id: this.media().id
        });
      }
    });
  }
  playlistRequestError(e, t, i) {
    const {
      uri: r,
      id: a
    } = t;
    this.request = null, i && (this.state = i), this.error = {
      playlist: this.main.playlists[a],
      status: e.status,
      message: `HLS playlist request error at URL: ${r}.`,
      responseText: e.responseText,
      code: e.status >= 500 ? 4 : 2,
      metadata: Pr({
        requestType: e.requestType,
        request: e,
        error: e.error
      })
    }, this.trigger("error");
  }
  parseManifest_({
    url: e,
    manifestString: t
  }) {
    try {
      const i = v9({
        onwarn: ({
          message: r
        }) => this.logger_(`m3u8-parser warn for ${e}: ${r}`),
        oninfo: ({
          message: r
        }) => this.logger_(`m3u8-parser info for ${e}: ${r}`),
        manifestString: t,
        customTagParsers: this.customTagParsers,
        customTagMappers: this.customTagMappers,
        llhls: this.llhls
      });
      return !i.playlists || !i.playlists.length || this.excludeAudioOnlyVariants(i.playlists), i;
    } catch (i) {
      this.error = i, this.error.metadata = {
        errorType: ke.Error.StreamingHlsPlaylistParserError,
        error: i
      };
    }
  }
  excludeAudioOnlyVariants(e) {
    const t = (i) => {
      const r = i.attributes || {}, {
        width: a,
        height: s
      } = r.RESOLUTION || {};
      if (a && s)
        return !0;
      const o = i3(i) || [];
      return !!eo(o).video;
    };
    e.some(t) && e.forEach((i) => {
      t(i) || (i.excludeUntil = 1 / 0);
    });
  }
  /**
   * Update the playlist loader's state in response to a new or updated playlist.
   *
   * @param {string} [playlistString]
   *        Playlist string (if playlistObject is not provided)
   * @param {Object} [playlistObject]
   *        Playlist object (if playlistString is not provided)
   * @param {string} url
   *        URL of playlist
   * @param {string} id
   *        ID to use for playlist
   */
  haveMetadata({
    playlistString: e,
    playlistObject: t,
    url: i,
    id: r
  }) {
    this.request = null, this.state = "HAVE_METADATA";
    const a = {
      playlistInfo: {
        type: "media",
        uri: i
      }
    };
    this.trigger({
      type: "playlistparsestart",
      metadata: a
    });
    const s = t || this.parseManifest_({
      url: i,
      manifestString: e
    });
    s.lastRequest = Date.now(), e3({
      playlist: s,
      uri: i,
      id: r
    });
    const o = Dm(this.main, s);
    this.targetDuration = s.partTargetDuration || s.targetDuration, this.pendingMedia_ = null, o ? (this.main = o, this.media_ = this.main.playlists[r]) : this.trigger("playlistunchanged"), this.updateMediaUpdateTimeout_(Sm(this.media(), !!o)), a.parsedPlaylist = H_(this.main.playlists, a.playlistInfo.type, !this.media_.endList), this.trigger({
      type: "playlistparsecomplete",
      metadata: a
    }), this.trigger("loadedplaylist");
  }
  /**
    * Abort any outstanding work and clean up.
    */
  dispose() {
    this.trigger("dispose"), this.stopRequest(), me.clearTimeout(this.mediaUpdateTimeout), me.clearTimeout(this.finalRenditionTimeout), this.dateRangesStorage_ = new W_(), this.off();
  }
  stopRequest() {
    if (this.request) {
      const e = this.request;
      this.request = null, e.onreadystatechange = null, e.abort();
    }
  }
  /**
    * When called without any arguments, returns the currently
    * active media playlist. When called with a single argument,
    * triggers the playlist loader to asynchronously switch to the
    * specified media playlist. Calling this method while the
    * loader is in the HAVE_NOTHING causes an error to be emitted
    * but otherwise has no effect.
    *
    * @param {Object=} playlist the parsed media playlist
    * object to switch to
    * @param {boolean=} shouldDelay whether we should delay the request by half target duration
    *
    * @return {Playlist} the current loaded media
    */
  media(e, t) {
    if (!e)
      return this.media_;
    if (this.state === "HAVE_NOTHING")
      throw new Error("Cannot switch media playlist from " + this.state);
    if (typeof e == "string") {
      if (!this.main.playlists[e])
        throw new Error("Unknown playlist URI: " + e);
      e = this.main.playlists[e];
    }
    if (me.clearTimeout(this.finalRenditionTimeout), t) {
      const o = (e.partTargetDuration || e.targetDuration) / 2 * 1e3 || 5e3;
      this.finalRenditionTimeout = me.setTimeout(this.media.bind(this, e, !1), o);
      return;
    }
    const i = this.state, r = !this.media_ || e.id !== this.media_.id, a = this.main.playlists[e.id];
    if (a && a.endList || // handle the case of a playlist object (e.g., if using vhs-json with a resolved
    // media playlist or, for the case of demuxed audio, a resolved audio media group)
    e.endList && e.segments.length) {
      this.request && (this.request.onreadystatechange = null, this.request.abort(), this.request = null), this.state = "HAVE_METADATA", this.media_ = e, r && (this.trigger("mediachanging"), i === "HAVE_MAIN_MANIFEST" ? this.trigger("loadedmetadata") : this.trigger("mediachange"));
      return;
    }
    if (this.updateMediaUpdateTimeout_(Sm(e, !0)), !r)
      return;
    if (this.state = "SWITCHING_MEDIA", this.request) {
      if (e.resolvedUri === this.request.url)
        return;
      this.request.onreadystatechange = null, this.request.abort(), this.request = null;
    }
    this.media_ && this.trigger("mediachanging"), this.pendingMedia_ = e;
    const s = {
      playlistInfo: {
        type: "media",
        uri: e.uri
      }
    };
    this.trigger({
      type: "playlistrequeststart",
      metadata: s
    }), this.request = this.vhs_.xhr({
      uri: e.resolvedUri,
      withCredentials: this.withCredentials,
      requestType: "hls-playlist"
    }, (o, u) => {
      if (this.request) {
        if (e.lastRequest = Date.now(), e.resolvedUri = Ec(e.resolvedUri, u), o)
          return this.playlistRequestError(this.request, e, i);
        this.trigger({
          type: "playlistrequestcomplete",
          metadata: s
        }), this.haveMetadata({
          playlistString: u.responseText,
          url: e.uri,
          id: e.id
        }), i === "HAVE_MAIN_MANIFEST" ? this.trigger("loadedmetadata") : this.trigger("mediachange");
      }
    });
  }
  /**
   * pause loading of the playlist
   */
  pause() {
    this.mediaUpdateTimeout && (me.clearTimeout(this.mediaUpdateTimeout), this.mediaUpdateTimeout = null), this.stopRequest(), this.state === "HAVE_NOTHING" && (this.started = !1), this.state === "SWITCHING_MEDIA" ? this.media_ ? this.state = "HAVE_METADATA" : this.state = "HAVE_MAIN_MANIFEST" : this.state === "HAVE_CURRENT_METADATA" && (this.state = "HAVE_METADATA");
  }
  /**
   * start loading of the playlist
   */
  load(e) {
    this.mediaUpdateTimeout && (me.clearTimeout(this.mediaUpdateTimeout), this.mediaUpdateTimeout = null);
    const t = this.media();
    if (e) {
      const i = t ? (t.partTargetDuration || t.targetDuration) / 2 * 1e3 : 5e3;
      this.mediaUpdateTimeout = me.setTimeout(() => {
        this.mediaUpdateTimeout = null, this.load();
      }, i);
      return;
    }
    if (!this.started) {
      this.start();
      return;
    }
    t && !t.endList ? this.trigger("mediaupdatetimeout") : this.trigger("loadedplaylist");
  }
  updateMediaUpdateTimeout_(e) {
    this.mediaUpdateTimeout && (me.clearTimeout(this.mediaUpdateTimeout), this.mediaUpdateTimeout = null), !(!this.media() || this.media().endList) && (this.mediaUpdateTimeout = me.setTimeout(() => {
      this.mediaUpdateTimeout = null, this.trigger("mediaupdatetimeout"), this.updateMediaUpdateTimeout_(e);
    }, e));
  }
  /**
   * start loading of the playlist
   */
  start() {
    if (this.started = !0, typeof this.src == "object") {
      this.src.uri || (this.src.uri = me.location.href), this.src.resolvedUri = this.src.uri, setTimeout(() => {
        this.setupInitialPlaylist(this.src);
      }, 0);
      return;
    }
    const e = {
      playlistInfo: {
        type: "multivariant",
        uri: this.src
      }
    };
    this.trigger({
      type: "playlistrequeststart",
      metadata: e
    }), this.request = this.vhs_.xhr({
      uri: this.src,
      withCredentials: this.withCredentials,
      requestType: "hls-playlist"
    }, (t, i) => {
      if (!this.request)
        return;
      if (this.request = null, t)
        return this.error = {
          status: i.status,
          message: `HLS playlist request error at URL: ${this.src}.`,
          responseText: i.responseText,
          // MEDIA_ERR_NETWORK
          code: 2,
          metadata: Pr({
            requestType: i.requestType,
            request: i,
            error: t
          })
        }, this.state === "HAVE_NOTHING" && (this.started = !1), this.trigger("error");
      this.trigger({
        type: "playlistrequestcomplete",
        metadata: e
      }), this.src = Ec(this.src, i), this.trigger({
        type: "playlistparsestart",
        metadata: e
      });
      const r = this.parseManifest_({
        manifestString: i.responseText,
        url: this.src
      });
      e.parsedPlaylist = H_(r.playlists, e.playlistInfo.type, !1), this.trigger({
        type: "playlistparsecomplete",
        metadata: e
      }), this.setupInitialPlaylist(r);
    });
  }
  srcUri() {
    return typeof this.src == "string" ? this.src : this.src.uri;
  }
  /**
   * Given a manifest object that's either a main or media playlist, trigger the proper
   * events and set the state of the playlist loader.
   *
   * If the manifest object represents a main playlist, `loadedplaylist` will be
   * triggered to allow listeners to select a playlist. If none is selected, the loader
   * will default to the first one in the playlists array.
   *
   * If the manifest object represents a media playlist, `loadedplaylist` will be
   * triggered followed by `loadedmetadata`, as the only available playlist is loaded.
   *
   * In the case of a media playlist, a main playlist object wrapper with one playlist
   * will be created so that all logic can handle playlists in the same fashion (as an
   * assumed manifest object schema).
   *
   * @param {Object} manifest
   *        The parsed manifest object
   */
  setupInitialPlaylist(e) {
    if (this.state = "HAVE_MAIN_MANIFEST", e.playlists) {
      this.main = e, t3(this.main, this.srcUri()), e.playlists.forEach((i) => {
        i.segments = s3(i), i.segments.forEach((r) => {
          a3(r, i.resolvedUri);
        });
      }), this.trigger("loadedplaylist"), this.request || this.media(this.main.playlists[0]);
      return;
    }
    const t = this.srcUri() || me.location.href;
    this.main = T9(e, t), this.haveMetadata({
      playlistObject: e,
      url: t,
      id: this.main.playlists[0].id
    }), this.trigger("loadedmetadata");
  }
  /**
   * Updates or deletes a preexisting pathway clone.
   * Ensures that all playlists related to the old pathway clone are
   * either updated or deleted.
   *
   * @param {Object} clone On update, the pathway clone object for the newly updated pathway clone.
   *        On delete, the old pathway clone object to be deleted.
   * @param {boolean} isUpdate True if the pathway is to be updated,
   *        false if it is meant to be deleted.
   */
  updateOrDeleteClone(e, t) {
    const i = this.main, r = e.ID;
    let a = i.playlists.length;
    for (; a--; ) {
      const s = i.playlists[a];
      if (s.attributes["PATHWAY-ID"] === r) {
        const o = s.resolvedUri, u = s.id;
        if (t) {
          const c = this.createCloneURI_(s.resolvedUri, e), l = fa(r, c), h = this.createCloneAttributes_(r, s.attributes), f = this.createClonePlaylist_(s, l, e, h);
          i.playlists[a] = f, i.playlists[l] = f, i.playlists[c] = f;
        } else
          i.playlists.splice(a, 1);
        delete i.playlists[u], delete i.playlists[o];
      }
    }
    this.updateOrDeleteCloneMedia(e, t);
  }
  /**
   * Updates or deletes media data based on the pathway clone object.
   * Due to the complexity of the media groups and playlists, in all cases
   * we remove all of the old media groups and playlists.
   * On updates, we then create new media groups and playlists based on the
   * new pathway clone object.
   *
   * @param {Object} clone The pathway clone object for the newly updated pathway clone.
   * @param {boolean} isUpdate True if the pathway is to be updated,
   *        false if it is meant to be deleted.
   */
  updateOrDeleteCloneMedia(e, t) {
    const i = this.main, r = e.ID;
    ["AUDIO", "SUBTITLES", "CLOSED-CAPTIONS"].forEach((a) => {
      if (!(!i.mediaGroups[a] || !i.mediaGroups[a][r])) {
        for (const s in i.mediaGroups[a])
          if (s === r) {
            for (const o in i.mediaGroups[a][s])
              i.mediaGroups[a][s][o].playlists.forEach((c, l) => {
                const h = i.playlists[c.id], f = h.id, d = h.resolvedUri;
                delete i.playlists[f], delete i.playlists[d];
              });
            delete i.mediaGroups[a][s];
          }
      }
    }), t && this.createClonedMediaGroups_(e);
  }
  /**
   * Given a pathway clone object, clones all necessary playlists.
   *
   * @param {Object} clone The pathway clone object.
   * @param {Object} basePlaylist The original playlist to clone from.
   */
  addClonePathway(e, t = {}) {
    const i = this.main, r = i.playlists.length, a = this.createCloneURI_(t.resolvedUri, e), s = fa(e.ID, a), o = this.createCloneAttributes_(e.ID, t.attributes), u = this.createClonePlaylist_(t, s, e, o);
    i.playlists[r] = u, i.playlists[s] = u, i.playlists[a] = u, this.createClonedMediaGroups_(e);
  }
  /**
   * Given a pathway clone object we create clones of all media.
   * In this function, all necessary information and updated playlists
   * are added to the `mediaGroup` object.
   * Playlists are also added to the `playlists` array so the media groups
   * will be properly linked.
   *
   * @param {Object} clone The pathway clone object.
   */
  createClonedMediaGroups_(e) {
    const t = e.ID, i = e["BASE-ID"], r = this.main;
    ["AUDIO", "SUBTITLES", "CLOSED-CAPTIONS"].forEach((a) => {
      if (!(!r.mediaGroups[a] || r.mediaGroups[a][t]))
        for (const s in r.mediaGroups[a]) {
          if (s === i)
            r.mediaGroups[a][t] = {};
          else
            continue;
          for (const o in r.mediaGroups[a][s]) {
            const u = r.mediaGroups[a][s][o];
            r.mediaGroups[a][t][o] = Lt({}, u);
            const c = r.mediaGroups[a][t][o], l = this.createCloneURI_(u.resolvedUri, e);
            c.resolvedUri = l, c.uri = l, c.playlists = [], u.playlists.forEach((h, f) => {
              const d = r.playlists[h.id], y = JS(a, t, o), m = fa(t, y);
              if (d && !r.playlists[m]) {
                const b = this.createClonePlaylist_(d, m, e), p = b.resolvedUri;
                r.playlists[m] = b, r.playlists[p] = b;
              }
              c.playlists[f] = this.createClonePlaylist_(h, m, e);
            });
          }
        }
    });
  }
  /**
   * Using the original playlist to be cloned, and the pathway clone object
   * information, we create a new playlist.
   *
   * @param {Object} basePlaylist  The original playlist to be cloned from.
   * @param {string} id The desired id of the newly cloned playlist.
   * @param {Object} clone The pathway clone object.
   * @param {Object} attributes An optional object to populate the `attributes` property in the playlist.
   *
   * @return {Object} The combined cloned playlist.
   */
  createClonePlaylist_(e, t, i, r) {
    const a = this.createCloneURI_(e.resolvedUri, i), s = {
      resolvedUri: a,
      uri: a,
      id: t
    };
    return e.segments && (s.segments = []), r && (s.attributes = r), ft(e, s);
  }
  /**
   * Generates an updated URI for a cloned pathway based on the original
   * pathway's URI and the paramaters from the pathway clone object in the
   * content steering server response.
   *
   * @param {string} baseUri URI to be updated in the cloned pathway.
   * @param {Object} clone The pathway clone object.
   *
   * @return {string} The updated URI for the cloned pathway.
   */
  createCloneURI_(e, t) {
    const i = new URL(e);
    i.hostname = t["URI-REPLACEMENT"].HOST;
    const r = t["URI-REPLACEMENT"].PARAMS;
    for (const a of Object.keys(r))
      i.searchParams.set(a, r[a]);
    return i.href;
  }
  /**
   * Helper function to create the attributes needed for the new clone.
   * This mainly adds the necessary media attributes.
   *
   * @param {string} id The pathway clone object ID.
   * @param {Object} oldAttributes The old attributes to compare to.
   * @return {Object} The new attributes to add to the playlist.
   */
  createCloneAttributes_(e, t) {
    const i = {
      "PATHWAY-ID": e
    };
    return ["AUDIO", "SUBTITLES", "CLOSED-CAPTIONS"].forEach((r) => {
      t[r] && (i[r] = e);
    }), i;
  }
  /**
   * Returns the key ID set from a playlist
   *
   * @param {playlist} playlist to fetch the key ID set from.
   * @return a Set of 32 digit hex strings that represent the unique keyIds for that playlist.
   */
  getKeyIdSet(e) {
    const t = /* @__PURE__ */ new Set();
    if (!e || !e.contentProtection)
      return t;
    for (const i in e.contentProtection)
      if (e.contentProtection[i] && e.contentProtection[i].attributes && e.contentProtection[i].attributes.keyId) {
        const r = e.contentProtection[i].attributes.keyId;
        t.add(r.toLowerCase());
      }
    return t;
  }
}
const Cm = function(n, e, t, i) {
  const r = n.responseType === "arraybuffer" ? n.response : n.responseText;
  !e && r && (n.responseTime = Date.now(), n.roundTripTime = n.responseTime - n.requestTime, n.bytesReceived = r.byteLength || r.length, n.bandwidth || (n.bandwidth = Math.floor(n.bytesReceived / n.roundTripTime * 8 * 1e3))), t.headers && (n.responseHeaders = t.headers), e && e.code === "ETIMEDOUT" && (n.timedout = !0), !e && !n.aborted && t.statusCode !== 200 && t.statusCode !== 206 && t.statusCode !== 0 && (e = new Error("XHR Failed with a response of: " + (n && (r || n.responseText)))), i(e, n);
}, k9 = (n, e) => {
  if (!n || !n.size)
    return;
  let t = e;
  return n.forEach((i) => {
    t = i(t);
  }), t;
}, I9 = (n, e, t, i) => {
  !n || !n.size || n.forEach((r) => {
    r(e, t, i);
  });
}, u3 = function() {
  const n = function e(t, i) {
    t = ft({
      timeout: 45e3
    }, t);
    const r = e.beforeRequest || ke.Vhs.xhr.beforeRequest, a = e._requestCallbackSet || ke.Vhs.xhr._requestCallbackSet || /* @__PURE__ */ new Set(), s = e._responseCallbackSet || ke.Vhs.xhr._responseCallbackSet;
    r && typeof r == "function" && (ke.log.warn("beforeRequest is deprecated, use onRequest instead."), a.add(r));
    const o = ke.Vhs.xhr.original === !0 ? ke.xhr : ke.Vhs.xhr, u = k9(a, t);
    a.delete(r);
    const c = o(u || t, function(h, f) {
      return I9(s, c, h, f), Cm(c, h, f, i);
    }), l = c.abort;
    return c.abort = function() {
      return c.aborted = !0, l.apply(c, arguments);
    }, c.uri = t.uri, c.requestType = t.requestType, c.requestTime = Date.now(), c;
  };
  return n.original = !0, n;
}, U9 = function(n) {
  let e;
  const t = n.offset;
  return typeof n.offset == "bigint" || typeof n.length == "bigint" ? e = me.BigInt(n.offset) + me.BigInt(n.length) - me.BigInt(1) : e = n.offset + n.length - 1, "bytes=" + t + "-" + e;
}, Am = function(n) {
  const e = {};
  return n.byterange && (e.Range = U9(n.byterange)), e;
}, R9 = function(n, e) {
  return n.start(e) + "-" + n.end(e);
}, O9 = function(n, e) {
  const t = n.toString(16);
  return "00".substring(0, 2 - t.length) + t + (e % 2 ? " " : "");
}, L9 = function(n) {
  return n >= 32 && n < 126 ? String.fromCharCode(n) : ".";
}, c3 = function(n) {
  const e = {};
  return Object.keys(n).forEach((t) => {
    const i = n[t];
    cD(i) ? e[t] = {
      bytes: i.buffer,
      byteOffset: i.byteOffset,
      byteLength: i.byteLength
    } : e[t] = i;
  }), e;
}, Dc = function(n) {
  const e = n.byterange || {
    length: 1 / 0,
    offset: 0
  };
  return [e.length, e.offset, n.resolvedUri].join(",");
}, l3 = function(n) {
  return n.resolvedUri;
}, d3 = (n) => {
  const e = Array.prototype.slice.call(n), t = 16;
  let i = "", r, a;
  for (let s = 0; s < e.length / t; s++)
    r = e.slice(s * t, s * t + t).map(O9).join(""), a = e.slice(s * t, s * t + t).map(L9).join(""), i += r + " " + a + `
`;
  return i;
}, P9 = ({
  bytes: n
}) => d3(n), F9 = (n) => {
  let e = "", t;
  for (t = 0; t < n.length; t++)
    e += R9(n, t) + " ";
  return e;
};
var N9 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  createTransferableMessage: c3,
  initSegmentId: Dc,
  segmentKeyId: l3,
  hexDump: d3,
  tagDump: P9,
  textRanges: F9
});
const f3 = 0.25, M9 = (n, e) => {
  if (!e.dateTimeObject)
    return null;
  const t = e.videoTimingInfo.transmuxerPrependedSeconds, r = e.videoTimingInfo.transmuxedPresentationStart + t, a = n - r;
  return new Date(e.dateTimeObject.getTime() + a * 1e3);
}, B9 = (n) => n.transmuxedPresentationEnd - n.transmuxedPresentationStart - n.transmuxerPrependedSeconds, j9 = (n, e) => {
  let t;
  try {
    t = new Date(n);
  } catch {
    return null;
  }
  if (!e || !e.segments || e.segments.length === 0)
    return null;
  let i = e.segments[0];
  if (t < new Date(i.dateTimeObject))
    return null;
  for (let u = 0; u < e.segments.length - 1; u++) {
    i = e.segments[u];
    const c = new Date(e.segments[u + 1].dateTimeObject);
    if (t < c)
      break;
  }
  const r = e.segments[e.segments.length - 1], a = r.dateTimeObject, s = r.videoTimingInfo ? B9(r.videoTimingInfo) : r.duration + r.duration * f3, o = new Date(a.getTime() + s * 1e3);
  return t > o ? null : (t > new Date(a) && (i = r), {
    segment: i,
    estimatedStart: i.videoTimingInfo ? i.videoTimingInfo.transmuxedPresentationStart : pn.duration(e, e.mediaSequence + e.segments.indexOf(i)),
    // Although, given that all segments have accurate date time objects, the segment
    // selected should be accurate, unless the video has been transmuxed at some point
    // (determined by the presence of the videoTimingInfo object), the segment's "player
    // time" (the start time in the player) can't be considered accurate.
    type: i.videoTimingInfo ? "accurate" : "estimate"
  });
}, q9 = (n, e) => {
  if (!e || !e.segments || e.segments.length === 0)
    return null;
  let t = 0, i;
  for (let a = 0; a < e.segments.length && (i = e.segments[a], t = i.videoTimingInfo ? i.videoTimingInfo.transmuxedPresentationEnd : t + i.duration, !(n <= t)); a++)
    ;
  const r = e.segments[e.segments.length - 1];
  if (r.videoTimingInfo && r.videoTimingInfo.transmuxedPresentationEnd < n)
    return null;
  if (n > t) {
    if (n > t + r.duration * f3)
      return null;
    i = r;
  }
  return {
    segment: i,
    estimatedStart: i.videoTimingInfo ? i.videoTimingInfo.transmuxedPresentationStart : t - i.duration,
    // Because videoTimingInfo is only set after transmux, it is the only way to get
    // accurate timing values.
    type: i.videoTimingInfo ? "accurate" : "estimate"
  };
}, W9 = (n, e) => {
  let t, i;
  try {
    t = new Date(n), i = new Date(e);
  } catch {
  }
  const r = t.getTime();
  return (i.getTime() - r) / 1e3;
}, V9 = (n) => {
  if (!n.segments || n.segments.length === 0)
    return !1;
  for (let e = 0; e < n.segments.length; e++)
    if (!n.segments[e].dateTimeObject)
      return !1;
  return !0;
}, H9 = ({
  playlist: n,
  time: e = void 0,
  callback: t
}) => {
  if (!t)
    throw new Error("getProgramTime: callback must be provided");
  if (!n || e === void 0)
    return t({
      message: "getProgramTime: playlist and time must be provided"
    });
  const i = q9(e, n);
  if (!i)
    return t({
      message: "valid programTime was not found"
    });
  if (i.type === "estimate")
    return t({
      message: "Accurate programTime could not be determined. Please seek to e.seekTime and try again",
      seekTime: i.estimatedStart
    });
  const r = {
    mediaSeconds: e
  }, a = M9(e, i.segment);
  return a && (r.programDateTime = a.toISOString()), t(null, r);
}, h3 = ({
  programTime: n,
  playlist: e,
  retryCount: t = 2,
  seekTo: i,
  pauseAfterSeek: r = !0,
  tech: a,
  callback: s
}) => {
  if (!s)
    throw new Error("seekToProgramTime: callback must be provided");
  if (typeof n > "u" || !e || !i)
    return s({
      message: "seekToProgramTime: programTime, seekTo and playlist must be provided"
    });
  if (!e.endList && !a.hasStarted_)
    return s({
      message: "player must be playing a live stream to start buffering"
    });
  if (!V9(e))
    return s({
      message: "programDateTime tags must be provided in the manifest " + e.resolvedUri
    });
  const o = j9(n, e);
  if (!o)
    return s({
      message: `${n} was not found in the stream`
    });
  const u = o.segment, c = W9(u.dateTimeObject, n);
  if (o.type === "estimate") {
    if (t === 0)
      return s({
        message: `${n} is not buffered yet. Try again`
      });
    i(o.estimatedStart + c), a.one("seeked", () => {
      h3({
        programTime: n,
        playlist: e,
        retryCount: t - 1,
        seekTo: i,
        pauseAfterSeek: r,
        tech: a,
        callback: s
      });
    });
    return;
  }
  const l = u.start + c, h = () => s(null, a.currentTime());
  a.one("seeked", h), r && a.pause(), i(l);
}, Np = (n, e) => {
  if (n.readyState === 4)
    return e();
}, z9 = (n, e, t, i) => {
  let r = [], a, s = !1;
  const o = function(h, f, d, y) {
    return f.abort(), s = !0, t(h, f, d, y);
  }, u = function(h, f) {
    if (s)
      return;
    if (h)
      return h.metadata = Pr({
        requestType: i,
        request: f,
        error: h
      }), o(h, f, "", r);
    const d = f.responseText.substring(r && r.byteLength || 0, f.responseText.length);
    if (r = pU(r, lD(d, !0)), a = a || ws(r), r.length < 10 || a && r.length < a + 2)
      return Np(f, () => o(h, f, "", r));
    const y = Yg(r);
    return y === "ts" && r.length < 188 ? Np(f, () => o(h, f, "", r)) : !y && r.length < 376 ? Np(f, () => o(h, f, "", r)) : o(null, f, y, r);
  }, l = e({
    uri: n,
    beforeSend(h) {
      h.overrideMimeType("text/plain; charset=x-user-defined"), h.addEventListener("progress", function({
        total: f,
        loaded: d
      }) {
        return Cm(h, null, {
          statusCode: h.status
        }, u);
      });
    }
  }, function(h, f) {
    return Cm(l, h, f, u);
  });
  return l;
}, {
  EventTarget: $9
} = ke, z_ = function(n, e) {
  if (!o3(n, e) || n.sidx && e.sidx && (n.sidx.offset !== e.sidx.offset || n.sidx.length !== e.sidx.length))
    return !1;
  if (!n.sidx && e.sidx || n.sidx && !e.sidx || n.segments && !e.segments || !n.segments && e.segments)
    return !1;
  if (!n.segments && !e.segments)
    return !0;
  for (let t = 0; t < n.segments.length; t++) {
    const i = n.segments[t], r = e.segments[t];
    if (i.uri !== r.uri)
      return !1;
    if (!i.byterange && !r.byterange)
      continue;
    const a = i.byterange, s = r.byterange;
    if (a && !s || !a && s || a.offset !== s.offset || a.length !== s.length)
      return !1;
  }
  return !0;
}, G9 = (n, e, t, i) => {
  const r = i.attributes.NAME || t;
  return `placeholder-uri-${n}-${e}-${r}`;
}, X9 = ({
  mainXml: n,
  srcUrl: e,
  clientOffset: t,
  sidxMapping: i,
  previousManifest: r
}) => {
  const a = gR(n, {
    manifestUri: e,
    clientOffset: t,
    sidxMapping: i,
    previousManifest: r
  });
  return t3(a, e, G9), a;
}, K9 = (n, e) => {
  qa(n, (t, i, r, a) => {
    (!e.mediaGroups[i][r] || !(a in e.mediaGroups[i][r])) && delete n.mediaGroups[i][r][a];
  });
}, Y9 = (n, e, t) => {
  let i = !0, r = ft(n, {
    // These are top level properties that can be updated
    duration: e.duration,
    minimumUpdatePeriod: e.minimumUpdatePeriod,
    timelineStarts: e.timelineStarts
  });
  for (let a = 0; a < e.playlists.length; a++) {
    const s = e.playlists[a];
    if (s.sidx) {
      const u = dl(s.sidx);
      t && t[u] && t[u].sidx && Gg(s, t[u].sidx, s.sidx.resolvedUri);
    }
    const o = Dm(r, s, z_);
    o && (r = o, i = !1);
  }
  return qa(e, (a, s, o, u) => {
    if (a.playlists && a.playlists.length) {
      const c = a.playlists[0].id, l = Dm(r, a.playlists[0], z_);
      l && (r = l, u in r.mediaGroups[s][o] || (r.mediaGroups[s][o][u] = a), r.mediaGroups[s][o][u].playlists[0] = r.playlists[c], i = !1);
    }
  }), K9(r, e), e.minimumUpdatePeriod !== n.minimumUpdatePeriod && (i = !1), i ? null : r;
}, Q9 = (n, e) => (!n.map && !e.map || !!(n.map && e.map && n.map.byterange.offset === e.map.byterange.offset && n.map.byterange.length === e.map.byterange.length)) && n.uri === e.uri && n.byterange.offset === e.byterange.offset && n.byterange.length === e.byterange.length, $_ = (n, e) => {
  const t = {};
  for (const i in n) {
    const a = n[i].sidx;
    if (a) {
      const s = dl(a);
      if (!e[s])
        break;
      const o = e[s].sidxInfo;
      Q9(o, a) && (t[s] = e[s]);
    }
  }
  return t;
}, Z9 = (n, e) => {
  let i = $_(n.playlists, e);
  return qa(n, (r, a, s, o) => {
    if (r.playlists && r.playlists.length) {
      const u = r.playlists;
      i = ft(i, $_(u, e));
    }
  }), i;
};
class km extends $9 {
  // DashPlaylistLoader must accept either a src url or a playlist because subsequent
  // playlist loader setups from media groups will expect to be able to pass a playlist
  // (since there aren't external URLs to media playlists with DASH)
  constructor(e, t, i = {}, r) {
    super(), this.isPaused_ = !0, this.mainPlaylistLoader_ = r || this, r || (this.isMain_ = !0);
    const {
      withCredentials: a = !1
    } = i;
    if (this.vhs_ = t, this.withCredentials = a, this.addMetadataToTextTrack = i.addMetadataToTextTrack, !e)
      throw new Error("A non-empty playlist URL or object is required");
    this.on("minimumUpdatePeriod", () => {
      this.refreshXml_();
    }), this.on("mediaupdatetimeout", () => {
      this.refreshMedia_(this.media().id);
    }), this.state = "HAVE_NOTHING", this.loadedPlaylists_ = {}, this.logger_ = jn("DashPlaylistLoader"), this.isMain_ ? (this.mainPlaylistLoader_.srcUrl = e, this.mainPlaylistLoader_.sidxMapping_ = {}) : this.childPlaylist_ = e;
  }
  get isPaused() {
    return this.isPaused_;
  }
  requestErrored_(e, t, i) {
    if (!this.request)
      return !0;
    if (this.request = null, e)
      return this.error = typeof e == "object" && !(e instanceof Error) ? e : {
        status: t.status,
        message: "DASH request error at URL: " + t.uri,
        response: t.response,
        // MEDIA_ERR_NETWORK
        code: 2,
        metadata: e.metadata
      }, i && (this.state = i), this.trigger("error"), !0;
  }
  /**
   * Verify that the container of the sidx segment can be parsed
   * and if it can, get and parse that segment.
   */
  addSidxSegments_(e, t, i) {
    const r = e.sidx && dl(e.sidx);
    if (!e.sidx || !r || this.mainPlaylistLoader_.sidxMapping_[r]) {
      me.clearTimeout(this.mediaRequest_), this.mediaRequest_ = me.setTimeout(() => i(!1), 0);
      return;
    }
    const a = Ec(e.sidx.resolvedUri), s = (u, c) => {
      if (this.requestErrored_(u, c, t))
        return;
      const l = this.mainPlaylistLoader_.sidxMapping_, {
        requestType: h
      } = c;
      let f;
      try {
        f = _R(Ke(c.response).subarray(8));
      } catch (d) {
        d.metadata = Pr({
          requestType: h,
          request: c,
          parseFailure: !0
        }), this.requestErrored_(d, c, t);
        return;
      }
      return l[r] = {
        sidxInfo: e.sidx,
        sidx: f
      }, Gg(e, f, e.sidx.resolvedUri), i(!0);
    }, o = "dash-sidx";
    this.request = z9(a, this.vhs_.xhr, (u, c, l, h) => {
      if (u)
        return s(u, c);
      if (!l || l !== "mp4") {
        const y = l || "unknown";
        return s({
          status: c.status,
          message: `Unsupported ${y} container type for sidx segment at URL: ${a}`,
          // response is just bytes in this case
          // but we really don't want to return that.
          response: "",
          playlist: e,
          internal: !0,
          playlistExclusionDuration: 1 / 0,
          // MEDIA_ERR_NETWORK
          code: 2
        }, c);
      }
      const {
        offset: f,
        length: d
      } = e.sidx.byterange;
      if (h.length >= d + f)
        return s(u, {
          response: h.subarray(f, f + d),
          status: c.status,
          uri: c.uri
        });
      this.request = this.vhs_.xhr({
        uri: a,
        responseType: "arraybuffer",
        requestType: "dash-sidx",
        headers: Am({
          byterange: e.sidx.byterange
        })
      }, s);
    }, o);
  }
  dispose() {
    this.isPaused_ = !0, this.trigger("dispose"), this.stopRequest(), this.loadedPlaylists_ = {}, me.clearTimeout(this.minimumUpdatePeriodTimeout_), me.clearTimeout(this.mediaRequest_), me.clearTimeout(this.mediaUpdateTimeout), this.mediaUpdateTimeout = null, this.mediaRequest_ = null, this.minimumUpdatePeriodTimeout_ = null, this.mainPlaylistLoader_.createMupOnMedia_ && (this.off("loadedmetadata", this.mainPlaylistLoader_.createMupOnMedia_), this.mainPlaylistLoader_.createMupOnMedia_ = null), this.off();
  }
  hasPendingRequest() {
    return this.request || this.mediaRequest_;
  }
  stopRequest() {
    if (this.request) {
      const e = this.request;
      this.request = null, e.onreadystatechange = null, e.abort();
    }
  }
  media(e) {
    if (!e)
      return this.media_;
    if (this.state === "HAVE_NOTHING")
      throw new Error("Cannot switch media playlist from " + this.state);
    const t = this.state;
    if (typeof e == "string") {
      if (!this.mainPlaylistLoader_.main.playlists[e])
        throw new Error("Unknown playlist URI: " + e);
      e = this.mainPlaylistLoader_.main.playlists[e];
    }
    const i = !this.media_ || e.id !== this.media_.id;
    if (i && this.loadedPlaylists_[e.id] && this.loadedPlaylists_[e.id].endList) {
      this.state = "HAVE_METADATA", this.media_ = e, i && (this.trigger("mediachanging"), this.trigger("mediachange"));
      return;
    }
    i && (this.media_ && this.trigger("mediachanging"), this.addSidxSegments_(e, t, (r) => {
      this.haveMetadata({
        startingState: t,
        playlist: e
      });
    }));
  }
  haveMetadata({
    startingState: e,
    playlist: t
  }) {
    this.state = "HAVE_METADATA", this.loadedPlaylists_[t.id] = t, me.clearTimeout(this.mediaRequest_), this.mediaRequest_ = null, this.refreshMedia_(t.id), e === "HAVE_MAIN_MANIFEST" ? this.trigger("loadedmetadata") : this.trigger("mediachange");
  }
  pause() {
    this.isPaused_ = !0, this.mainPlaylistLoader_.createMupOnMedia_ && (this.off("loadedmetadata", this.mainPlaylistLoader_.createMupOnMedia_), this.mainPlaylistLoader_.createMupOnMedia_ = null), this.stopRequest(), me.clearTimeout(this.mediaUpdateTimeout), this.mediaUpdateTimeout = null, this.isMain_ && (me.clearTimeout(this.mainPlaylistLoader_.minimumUpdatePeriodTimeout_), this.mainPlaylistLoader_.minimumUpdatePeriodTimeout_ = null), this.state === "HAVE_NOTHING" && (this.started = !1);
  }
  load(e) {
    this.isPaused_ = !1, me.clearTimeout(this.mediaUpdateTimeout), this.mediaUpdateTimeout = null;
    const t = this.media();
    if (e) {
      const i = t ? t.targetDuration / 2 * 1e3 : 5e3;
      this.mediaUpdateTimeout = me.setTimeout(() => this.load(), i);
      return;
    }
    if (!this.started) {
      this.start();
      return;
    }
    t && !t.endList ? (this.isMain_ && !this.minimumUpdatePeriodTimeout_ && (this.trigger("minimumUpdatePeriod"), this.updateMinimumUpdatePeriodTimeout_()), this.trigger("mediaupdatetimeout")) : this.trigger("loadedplaylist");
  }
  start() {
    if (this.started = !0, !this.isMain_) {
      me.clearTimeout(this.mediaRequest_), this.mediaRequest_ = me.setTimeout(() => this.haveMain_(), 0);
      return;
    }
    this.requestMain_((e, t) => {
      this.haveMain_(), !this.hasPendingRequest() && !this.media_ && this.media(this.mainPlaylistLoader_.main.playlists[0]);
    });
  }
  requestMain_(e) {
    const t = {
      manifestInfo: {
        uri: this.mainPlaylistLoader_.srcUrl
      }
    };
    this.trigger({
      type: "manifestrequeststart",
      metadata: t
    }), this.request = this.vhs_.xhr({
      uri: this.mainPlaylistLoader_.srcUrl,
      withCredentials: this.withCredentials,
      requestType: "dash-manifest"
    }, (i, r) => {
      if (i) {
        const {
          requestType: s
        } = r;
        i.metadata = Pr({
          requestType: s,
          request: r,
          error: i
        });
      }
      if (this.requestErrored_(i, r)) {
        this.state === "HAVE_NOTHING" && (this.started = !1);
        return;
      }
      this.trigger({
        type: "manifestrequestcomplete",
        metadata: t
      });
      const a = r.responseText !== this.mainPlaylistLoader_.mainXml_;
      if (this.mainPlaylistLoader_.mainXml_ = r.responseText, r.responseHeaders && r.responseHeaders.date ? this.mainLoaded_ = Date.parse(r.responseHeaders.date) : this.mainLoaded_ = Date.now(), this.mainPlaylistLoader_.srcUrl = Ec(this.mainPlaylistLoader_.srcUrl, r), a) {
        this.handleMain_(), this.syncClientServerClock_(() => e(r, a));
        return;
      }
      return e(r, a);
    });
  }
  /**
   * Parses the main xml for UTCTiming node to sync the client clock to the server
   * clock. If the UTCTiming node requires a HEAD or GET request, that request is made.
   *
   * @param {Function} done
   *        Function to call when clock sync has completed
   */
  syncClientServerClock_(e) {
    const t = bR(this.mainPlaylistLoader_.mainXml_);
    if (t === null)
      return this.mainPlaylistLoader_.clientOffset_ = this.mainLoaded_ - Date.now(), e();
    if (t.method === "DIRECT")
      return this.mainPlaylistLoader_.clientOffset_ = t.value - Date.now(), e();
    this.request = this.vhs_.xhr({
      uri: hn(this.mainPlaylistLoader_.srcUrl, t.value),
      method: t.method,
      withCredentials: this.withCredentials,
      requestType: "dash-clock-sync"
    }, (i, r) => {
      if (!this.request)
        return;
      if (i) {
        const {
          requestType: s
        } = r;
        return this.error.metadata = Pr({
          requestType: s,
          request: r,
          error: i
        }), this.mainPlaylistLoader_.clientOffset_ = this.mainLoaded_ - Date.now(), e();
      }
      let a;
      t.method === "HEAD" ? !r.responseHeaders || !r.responseHeaders.date ? a = this.mainLoaded_ : a = Date.parse(r.responseHeaders.date) : a = Date.parse(r.responseText), this.mainPlaylistLoader_.clientOffset_ = a - Date.now(), e();
    });
  }
  haveMain_() {
    this.state = "HAVE_MAIN_MANIFEST", this.isMain_ ? this.trigger("loadedplaylist") : this.media_ || this.media(this.childPlaylist_);
  }
  handleMain_() {
    me.clearTimeout(this.mediaRequest_), this.mediaRequest_ = null;
    const e = this.mainPlaylistLoader_.main, t = {
      manifestInfo: {
        uri: this.mainPlaylistLoader_.srcUrl
      }
    };
    this.trigger({
      type: "manifestparsestart",
      metadata: t
    });
    let i;
    try {
      i = X9({
        mainXml: this.mainPlaylistLoader_.mainXml_,
        srcUrl: this.mainPlaylistLoader_.srcUrl,
        clientOffset: this.mainPlaylistLoader_.clientOffset_,
        sidxMapping: this.mainPlaylistLoader_.sidxMapping_,
        previousManifest: e
      });
    } catch (a) {
      this.error = a, this.error.metadata = {
        errorType: ke.Error.StreamingDashManifestParserError,
        error: a
      }, this.trigger("error");
    }
    e && (i = Y9(e, i, this.mainPlaylistLoader_.sidxMapping_)), this.mainPlaylistLoader_.main = i || e;
    const r = this.mainPlaylistLoader_.main.locations && this.mainPlaylistLoader_.main.locations[0];
    if (r && r !== this.mainPlaylistLoader_.srcUrl && (this.mainPlaylistLoader_.srcUrl = r), (!e || i && i.minimumUpdatePeriod !== e.minimumUpdatePeriod) && this.updateMinimumUpdatePeriodTimeout_(), this.addEventStreamToMetadataTrack_(i), i) {
      const {
        duration: a,
        endList: s
      } = i, o = [];
      i.playlists.forEach((c) => {
        o.push({
          id: c.id,
          bandwidth: c.attributes.BANDWIDTH,
          resolution: c.attributes.RESOLUTION,
          codecs: c.attributes.CODECS
        });
      });
      const u = {
        duration: a,
        isLive: !s,
        renditions: o
      };
      t.parsedManifest = u, this.trigger({
        type: "manifestparsecomplete",
        metadata: t
      });
    }
    return !!i;
  }
  updateMinimumUpdatePeriodTimeout_() {
    const e = this.mainPlaylistLoader_;
    e.createMupOnMedia_ && (e.off("loadedmetadata", e.createMupOnMedia_), e.createMupOnMedia_ = null), e.minimumUpdatePeriodTimeout_ && (me.clearTimeout(e.minimumUpdatePeriodTimeout_), e.minimumUpdatePeriodTimeout_ = null);
    let t = e.main && e.main.minimumUpdatePeriod;
    if (t === 0 && (e.media() ? t = e.media().targetDuration * 1e3 : (e.createMupOnMedia_ = e.updateMinimumUpdatePeriodTimeout_, e.one("loadedmetadata", e.createMupOnMedia_))), typeof t != "number" || t <= 0) {
      t < 0 && this.logger_(`found invalid minimumUpdatePeriod of ${t}, not setting a timeout`);
      return;
    }
    this.createMUPTimeout_(t);
  }
  createMUPTimeout_(e) {
    const t = this.mainPlaylistLoader_;
    t.minimumUpdatePeriodTimeout_ = me.setTimeout(() => {
      t.minimumUpdatePeriodTimeout_ = null, t.trigger("minimumUpdatePeriod"), t.createMUPTimeout_(e);
    }, e);
  }
  /**
   * Sends request to refresh the main xml and updates the parsed main manifest
   */
  refreshXml_() {
    this.requestMain_((e, t) => {
      t && (this.media_ && (this.media_ = this.mainPlaylistLoader_.main.playlists[this.media_.id]), this.mainPlaylistLoader_.sidxMapping_ = Z9(this.mainPlaylistLoader_.main, this.mainPlaylistLoader_.sidxMapping_), this.addSidxSegments_(this.media(), this.state, (i) => {
        this.refreshMedia_(this.media().id);
      }));
    });
  }
  /**
   * Refreshes the media playlist by re-parsing the main xml and updating playlist
   * references. If this is an alternate loader, the updated parsed manifest is retrieved
   * from the main loader.
   */
  refreshMedia_(e) {
    if (!e)
      throw new Error("refreshMedia_ must take a media id");
    this.media_ && this.isMain_ && this.handleMain_();
    const t = this.mainPlaylistLoader_.main.playlists, i = !this.media_ || this.media_ !== t[e];
    if (i ? this.media_ = t[e] : this.trigger("playlistunchanged"), !this.mediaUpdateTimeout) {
      const r = () => {
        this.media().endList || (this.mediaUpdateTimeout = me.setTimeout(() => {
          this.trigger("mediaupdatetimeout"), r();
        }, Sm(this.media(), !!i)));
      };
      r();
    }
    this.trigger("loadedplaylist");
  }
  /**
   * Takes eventstream data from a parsed DASH manifest and adds it to the metadata text track.
   *
   * @param {manifest} newMain the newly parsed manifest
   */
  addEventStreamToMetadataTrack_(e) {
    if (e && this.mainPlaylistLoader_.main.eventStream) {
      const t = this.mainPlaylistLoader_.main.eventStream.map((i) => ({
        cueTime: i.start,
        frames: [{
          data: i.messageData
        }]
      }));
      this.addMetadataToTextTrack("EventStream", t, this.mainPlaylistLoader_.main.duration);
    }
  }
  /**
   * Returns the key ID set from a playlist
   *
   * @param {playlist} playlist to fetch the key ID set from.
   * @return a Set of 32 digit hex strings that represent the unique keyIds for that playlist.
   */
  getKeyIdSet(e) {
    if (e.contentProtection) {
      const t = /* @__PURE__ */ new Set();
      for (const i in e.contentProtection) {
        const r = e.contentProtection[i].attributes["cenc:default_KID"];
        r && t.add(r.replace(/-/g, "").toLowerCase());
      }
      return t;
    }
  }
}
var qt = {
  GOAL_BUFFER_LENGTH: 30,
  MAX_GOAL_BUFFER_LENGTH: 60,
  BACK_BUFFER_LENGTH: 30,
  GOAL_BUFFER_LENGTH_RATE: 1,
  // 0.5 MB/s
  INITIAL_BANDWIDTH: 4194304,
  // A fudge factor to apply to advertised playlist bitrates to account for
  // temporary flucations in client bandwidth
  BANDWIDTH_VARIANCE: 1.2,
  // How much of the buffer must be filled before we consider upswitching
  BUFFER_LOW_WATER_LINE: 0,
  MAX_BUFFER_LOW_WATER_LINE: 30,
  // TODO: Remove this when experimentalBufferBasedABR is removed
  EXPERIMENTAL_MAX_BUFFER_LOW_WATER_LINE: 16,
  BUFFER_LOW_WATER_LINE_RATE: 1,
  // If the buffer is greater than the high water line, we won't switch down
  BUFFER_HIGH_WATER_LINE: 30
};
const J9 = (n) => {
  const e = new Uint8Array(new ArrayBuffer(n.length));
  for (let t = 0; t < n.length; t++)
    e[t] = n.charCodeAt(t);
  return e.buffer;
}, p3 = function(n) {
  return n.on = n.addEventListener, n.off = n.removeEventListener, n;
}, eL = function(n) {
  try {
    return URL.createObjectURL(new Blob([n], {
      type: "application/javascript"
    }));
  } catch {
    const t = new BlobBuilder();
    return t.append(n), URL.createObjectURL(t.getBlob());
  }
}, m3 = function(n) {
  return function() {
    const e = eL(n), t = p3(new Worker(e));
    t.objURL = e;
    const i = t.terminate;
    return t.on = t.addEventListener, t.off = t.removeEventListener, t.terminate = function() {
      return URL.revokeObjectURL(e), i.call(this);
    }, t;
  };
}, g3 = function(n) {
  return `var browserWorkerPolyFill = ${p3.toString()};
browserWorkerPolyFill(self);
` + n;
}, b3 = function(n) {
  return n.toString().replace(/^function.+?{/, "").slice(0, -1);
}, tL = g3(b3(function() {
  var n = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {}, e = function() {
    this.init = function() {
      var w = {};
      this.on = function(A, O) {
        w[A] || (w[A] = []), w[A] = w[A].concat(O);
      }, this.off = function(A, O) {
        var R;
        return w[A] ? (R = w[A].indexOf(O), w[A] = w[A].slice(), w[A].splice(R, 1), R > -1) : !1;
      }, this.trigger = function(A) {
        var O, R, V, X;
        if (O = w[A], !!O)
          if (arguments.length === 2)
            for (V = O.length, R = 0; R < V; ++R)
              O[R].call(this, arguments[1]);
          else {
            for (X = [], R = arguments.length, R = 1; R < arguments.length; ++R)
              X.push(arguments[R]);
            for (V = O.length, R = 0; R < V; ++R)
              O[R].apply(this, X);
          }
      }, this.dispose = function() {
        w = {};
      };
    };
  };
  e.prototype.pipe = function(w) {
    return this.on("data", function(A) {
      w.push(A);
    }), this.on("done", function(A) {
      w.flush(A);
    }), this.on("partialdone", function(A) {
      w.partialFlush(A);
    }), this.on("endedtimeline", function(A) {
      w.endTimeline(A);
    }), this.on("reset", function(A) {
      w.reset(A);
    }), w;
  }, e.prototype.push = function(w) {
    this.trigger("data", w);
  }, e.prototype.flush = function(w) {
    this.trigger("done", w);
  }, e.prototype.partialFlush = function(w) {
    this.trigger("partialdone", w);
  }, e.prototype.endTimeline = function(w) {
    this.trigger("endedtimeline", w);
  }, e.prototype.reset = function(w) {
    this.trigger("reset", w);
  };
  var t = e, i = Math.pow(2, 32), r = function(w) {
    var A = new DataView(w.buffer, w.byteOffset, w.byteLength), O;
    return A.getBigUint64 ? (O = A.getBigUint64(0), O < Number.MAX_SAFE_INTEGER ? Number(O) : O) : A.getUint32(0) * i + A.getUint32(4);
  }, a = {
    getUint64: r,
    MAX_UINT32: i
  }, s = a.MAX_UINT32, o, u, c, l, h, f, d, y, m, b, p, g, v, _, x, T, E, U, D, L, j, C, k, I, $, W, B, z, q, Y, H, K, ie, ge, pe, ce;
  (function() {
    var w;
    if (k = {
      avc1: [],
      // codingname
      avcC: [],
      btrt: [],
      dinf: [],
      dref: [],
      esds: [],
      ftyp: [],
      hdlr: [],
      mdat: [],
      mdhd: [],
      mdia: [],
      mfhd: [],
      minf: [],
      moof: [],
      moov: [],
      mp4a: [],
      // codingname
      mvex: [],
      mvhd: [],
      pasp: [],
      sdtp: [],
      smhd: [],
      stbl: [],
      stco: [],
      stsc: [],
      stsd: [],
      stsz: [],
      stts: [],
      styp: [],
      tfdt: [],
      tfhd: [],
      traf: [],
      trak: [],
      trun: [],
      trex: [],
      tkhd: [],
      vmhd: []
    }, !(typeof Uint8Array > "u")) {
      for (w in k)
        k.hasOwnProperty(w) && (k[w] = [w.charCodeAt(0), w.charCodeAt(1), w.charCodeAt(2), w.charCodeAt(3)]);
      I = new Uint8Array([105, 115, 111, 109]), W = new Uint8Array([97, 118, 99, 49]), $ = new Uint8Array([0, 0, 0, 1]), B = new Uint8Array([
        0,
        // version 0
        0,
        0,
        0,
        // flags
        0,
        0,
        0,
        0,
        // pre_defined
        118,
        105,
        100,
        101,
        // handler_type: 'vide'
        0,
        0,
        0,
        0,
        // reserved
        0,
        0,
        0,
        0,
        // reserved
        0,
        0,
        0,
        0,
        // reserved
        86,
        105,
        100,
        101,
        111,
        72,
        97,
        110,
        100,
        108,
        101,
        114,
        0
        // name: 'VideoHandler'
      ]), z = new Uint8Array([
        0,
        // version 0
        0,
        0,
        0,
        // flags
        0,
        0,
        0,
        0,
        // pre_defined
        115,
        111,
        117,
        110,
        // handler_type: 'soun'
        0,
        0,
        0,
        0,
        // reserved
        0,
        0,
        0,
        0,
        // reserved
        0,
        0,
        0,
        0,
        // reserved
        83,
        111,
        117,
        110,
        100,
        72,
        97,
        110,
        100,
        108,
        101,
        114,
        0
        // name: 'SoundHandler'
      ]), q = {
        video: B,
        audio: z
      }, K = new Uint8Array([
        0,
        // version 0
        0,
        0,
        0,
        // flags
        0,
        0,
        0,
        1,
        // entry_count
        0,
        0,
        0,
        12,
        // entry_size
        117,
        114,
        108,
        32,
        // 'url' type
        0,
        // version 0
        0,
        0,
        1
        // entry_flags
      ]), H = new Uint8Array([
        0,
        // version
        0,
        0,
        0,
        // flags
        0,
        0,
        // balance, 0 means centered
        0,
        0
        // reserved
      ]), ie = new Uint8Array([
        0,
        // version
        0,
        0,
        0,
        // flags
        0,
        0,
        0,
        0
        // entry_count
      ]), ge = ie, pe = new Uint8Array([
        0,
        // version
        0,
        0,
        0,
        // flags
        0,
        0,
        0,
        0,
        // sample_size
        0,
        0,
        0,
        0
        // sample_count
      ]), ce = ie, Y = new Uint8Array([
        0,
        // version
        0,
        0,
        1,
        // flags
        0,
        0,
        // graphicsmode
        0,
        0,
        0,
        0,
        0,
        0
        // opcolor
      ]);
    }
  })(), o = function(w) {
    var A = [], O = 0, R, V, X;
    for (R = 1; R < arguments.length; R++)
      A.push(arguments[R]);
    for (R = A.length; R--; )
      O += A[R].byteLength;
    for (V = new Uint8Array(O + 8), X = new DataView(V.buffer, V.byteOffset, V.byteLength), X.setUint32(0, V.byteLength), V.set(w, 4), R = 0, O = 8; R < A.length; R++)
      V.set(A[R], O), O += A[R].byteLength;
    return V;
  }, u = function() {
    return o(k.dinf, o(k.dref, K));
  }, c = function(w) {
    return o(k.esds, new Uint8Array([
      0,
      // version
      0,
      0,
      0,
      // flags
      // ES_Descriptor
      3,
      // tag, ES_DescrTag
      25,
      // length
      0,
      0,
      // ES_ID
      0,
      // streamDependenceFlag, URL_flag, reserved, streamPriority
      // DecoderConfigDescriptor
      4,
      // tag, DecoderConfigDescrTag
      17,
      // length
      64,
      // object type
      21,
      // streamType
      0,
      6,
      0,
      // bufferSizeDB
      0,
      0,
      218,
      192,
      // maxBitrate
      0,
      0,
      218,
      192,
      // avgBitrate
      // DecoderSpecificInfo
      5,
      // tag, DecoderSpecificInfoTag
      2,
      // length
      // ISO/IEC 14496-3, AudioSpecificConfig
      // for samplingFrequencyIndex see ISO/IEC 13818-7:2006, 8.1.3.2.2, Table 35
      w.audioobjecttype << 3 | w.samplingfrequencyindex >>> 1,
      w.samplingfrequencyindex << 7 | w.channelcount << 3,
      6,
      1,
      2
      // GASpecificConfig
    ]));
  }, l = function() {
    return o(k.ftyp, I, $, I, W);
  }, T = function(w) {
    return o(k.hdlr, q[w]);
  }, h = function(w) {
    return o(k.mdat, w);
  }, x = function(w) {
    var A = new Uint8Array([
      0,
      // version 0
      0,
      0,
      0,
      // flags
      0,
      0,
      0,
      2,
      // creation_time
      0,
      0,
      0,
      3,
      // modification_time
      0,
      1,
      95,
      144,
      // timescale, 90,000 "ticks" per second
      w.duration >>> 24 & 255,
      w.duration >>> 16 & 255,
      w.duration >>> 8 & 255,
      w.duration & 255,
      // duration
      85,
      196,
      // 'und' language (undetermined)
      0,
      0
    ]);
    return w.samplerate && (A[12] = w.samplerate >>> 24 & 255, A[13] = w.samplerate >>> 16 & 255, A[14] = w.samplerate >>> 8 & 255, A[15] = w.samplerate & 255), o(k.mdhd, A);
  }, _ = function(w) {
    return o(k.mdia, x(w), T(w.type), d(w));
  }, f = function(w) {
    return o(k.mfhd, new Uint8Array([
      0,
      0,
      0,
      0,
      // flags
      (w & 4278190080) >> 24,
      (w & 16711680) >> 16,
      (w & 65280) >> 8,
      w & 255
      // sequence_number
    ]));
  }, d = function(w) {
    return o(k.minf, w.type === "video" ? o(k.vmhd, Y) : o(k.smhd, H), u(), U(w));
  }, y = function(w, A) {
    for (var O = [], R = A.length; R--; )
      O[R] = L(A[R]);
    return o.apply(null, [k.moof, f(w)].concat(O));
  }, m = function(w) {
    for (var A = w.length, O = []; A--; )
      O[A] = g(w[A]);
    return o.apply(null, [k.moov, p(4294967295)].concat(O).concat(b(w)));
  }, b = function(w) {
    for (var A = w.length, O = []; A--; )
      O[A] = j(w[A]);
    return o.apply(null, [k.mvex].concat(O));
  }, p = function(w) {
    var A = new Uint8Array([
      0,
      // version 0
      0,
      0,
      0,
      // flags
      0,
      0,
      0,
      1,
      // creation_time
      0,
      0,
      0,
      2,
      // modification_time
      0,
      1,
      95,
      144,
      // timescale, 90,000 "ticks" per second
      (w & 4278190080) >> 24,
      (w & 16711680) >> 16,
      (w & 65280) >> 8,
      w & 255,
      // duration
      0,
      1,
      0,
      0,
      // 1.0 rate
      1,
      0,
      // 1.0 volume
      0,
      0,
      // reserved
      0,
      0,
      0,
      0,
      // reserved
      0,
      0,
      0,
      0,
      // reserved
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      64,
      0,
      0,
      0,
      // transformation: unity matrix
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      // pre_defined
      255,
      255,
      255,
      255
      // next_track_ID
    ]);
    return o(k.mvhd, A);
  }, E = function(w) {
    var A = w.samples || [], O = new Uint8Array(4 + A.length), R, V;
    for (V = 0; V < A.length; V++)
      R = A[V].flags, O[V + 4] = R.dependsOn << 4 | R.isDependedOn << 2 | R.hasRedundancy;
    return o(k.sdtp, O);
  }, U = function(w) {
    return o(k.stbl, D(w), o(k.stts, ce), o(k.stsc, ge), o(k.stsz, pe), o(k.stco, ie));
  }, (function() {
    var w, A;
    D = function(O) {
      return o(k.stsd, new Uint8Array([
        0,
        // version 0
        0,
        0,
        0,
        // flags
        0,
        0,
        0,
        1
      ]), O.type === "video" ? w(O) : A(O));
    }, w = function(O) {
      var R = O.sps || [], V = O.pps || [], X = [], re = [], ue, be;
      for (ue = 0; ue < R.length; ue++)
        X.push((R[ue].byteLength & 65280) >>> 8), X.push(R[ue].byteLength & 255), X = X.concat(Array.prototype.slice.call(R[ue]));
      for (ue = 0; ue < V.length; ue++)
        re.push((V[ue].byteLength & 65280) >>> 8), re.push(V[ue].byteLength & 255), re = re.concat(Array.prototype.slice.call(V[ue]));
      if (be = [k.avc1, new Uint8Array([
        0,
        0,
        0,
        0,
        0,
        0,
        // reserved
        0,
        1,
        // data_reference_index
        0,
        0,
        // pre_defined
        0,
        0,
        // reserved
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        // pre_defined
        (O.width & 65280) >> 8,
        O.width & 255,
        // width
        (O.height & 65280) >> 8,
        O.height & 255,
        // height
        0,
        72,
        0,
        0,
        // horizresolution
        0,
        72,
        0,
        0,
        // vertresolution
        0,
        0,
        0,
        0,
        // reserved
        0,
        1,
        // frame_count
        19,
        118,
        105,
        100,
        101,
        111,
        106,
        115,
        45,
        99,
        111,
        110,
        116,
        114,
        105,
        98,
        45,
        104,
        108,
        115,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        // compressorname
        0,
        24,
        // depth = 24
        17,
        17
        // pre_defined = -1
      ]), o(k.avcC, new Uint8Array([
        1,
        // configurationVersion
        O.profileIdc,
        // AVCProfileIndication
        O.profileCompatibility,
        // profile_compatibility
        O.levelIdc,
        // AVCLevelIndication
        255
        // lengthSizeMinusOne, hard-coded to 4 bytes
      ].concat(
        [R.length],
        // numOfSequenceParameterSets
        X,
        // "SPS"
        [V.length],
        // numOfPictureParameterSets
        re
        // "PPS"
      ))), o(k.btrt, new Uint8Array([
        0,
        28,
        156,
        128,
        // bufferSizeDB
        0,
        45,
        198,
        192,
        // maxBitrate
        0,
        45,
        198,
        192
        // avgBitrate
      ]))], O.sarRatio) {
        var _e = O.sarRatio[0], Ae = O.sarRatio[1];
        be.push(o(k.pasp, new Uint8Array([(_e & 4278190080) >> 24, (_e & 16711680) >> 16, (_e & 65280) >> 8, _e & 255, (Ae & 4278190080) >> 24, (Ae & 16711680) >> 16, (Ae & 65280) >> 8, Ae & 255])));
      }
      return o.apply(null, be);
    }, A = function(O) {
      return o(k.mp4a, new Uint8Array([
        // SampleEntry, ISO/IEC 14496-12
        0,
        0,
        0,
        0,
        0,
        0,
        // reserved
        0,
        1,
        // data_reference_index
        // AudioSampleEntry, ISO/IEC 14496-12
        0,
        0,
        0,
        0,
        // reserved
        0,
        0,
        0,
        0,
        // reserved
        (O.channelcount & 65280) >> 8,
        O.channelcount & 255,
        // channelcount
        (O.samplesize & 65280) >> 8,
        O.samplesize & 255,
        // samplesize
        0,
        0,
        // pre_defined
        0,
        0,
        // reserved
        (O.samplerate & 65280) >> 8,
        O.samplerate & 255,
        0,
        0
        // samplerate, 16.16
        // MP4AudioSampleEntry, ISO/IEC 14496-14
      ]), c(O));
    };
  })(), v = function(w) {
    var A = new Uint8Array([
      0,
      // version 0
      0,
      0,
      7,
      // flags
      0,
      0,
      0,
      0,
      // creation_time
      0,
      0,
      0,
      0,
      // modification_time
      (w.id & 4278190080) >> 24,
      (w.id & 16711680) >> 16,
      (w.id & 65280) >> 8,
      w.id & 255,
      // track_ID
      0,
      0,
      0,
      0,
      // reserved
      (w.duration & 4278190080) >> 24,
      (w.duration & 16711680) >> 16,
      (w.duration & 65280) >> 8,
      w.duration & 255,
      // duration
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      // reserved
      0,
      0,
      // layer
      0,
      0,
      // alternate_group
      1,
      0,
      // non-audio track volume
      0,
      0,
      // reserved
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      64,
      0,
      0,
      0,
      // transformation: unity matrix
      (w.width & 65280) >> 8,
      w.width & 255,
      0,
      0,
      // width
      (w.height & 65280) >> 8,
      w.height & 255,
      0,
      0
      // height
    ]);
    return o(k.tkhd, A);
  }, L = function(w) {
    var A, O, R, V, X, re, ue;
    return A = o(k.tfhd, new Uint8Array([
      0,
      // version 0
      0,
      0,
      58,
      // flags
      (w.id & 4278190080) >> 24,
      (w.id & 16711680) >> 16,
      (w.id & 65280) >> 8,
      w.id & 255,
      // track_ID
      0,
      0,
      0,
      1,
      // sample_description_index
      0,
      0,
      0,
      0,
      // default_sample_duration
      0,
      0,
      0,
      0,
      // default_sample_size
      0,
      0,
      0,
      0
      // default_sample_flags
    ])), re = Math.floor(w.baseMediaDecodeTime / s), ue = Math.floor(w.baseMediaDecodeTime % s), O = o(k.tfdt, new Uint8Array([
      1,
      // version 1
      0,
      0,
      0,
      // flags
      // baseMediaDecodeTime
      re >>> 24 & 255,
      re >>> 16 & 255,
      re >>> 8 & 255,
      re & 255,
      ue >>> 24 & 255,
      ue >>> 16 & 255,
      ue >>> 8 & 255,
      ue & 255
    ])), X = 92, w.type === "audio" ? (R = C(w, X), o(k.traf, A, O, R)) : (V = E(w), R = C(w, V.length + X), o(k.traf, A, O, R, V));
  }, g = function(w) {
    return w.duration = w.duration || 4294967295, o(k.trak, v(w), _(w));
  }, j = function(w) {
    var A = new Uint8Array([
      0,
      // version 0
      0,
      0,
      0,
      // flags
      (w.id & 4278190080) >> 24,
      (w.id & 16711680) >> 16,
      (w.id & 65280) >> 8,
      w.id & 255,
      // track_ID
      0,
      0,
      0,
      1,
      // default_sample_description_index
      0,
      0,
      0,
      0,
      // default_sample_duration
      0,
      0,
      0,
      0,
      // default_sample_size
      0,
      1,
      0,
      1
      // default_sample_flags
    ]);
    return w.type !== "video" && (A[A.length - 1] = 0), o(k.trex, A);
  }, (function() {
    var w, A, O;
    O = function(R, V) {
      var X = 0, re = 0, ue = 0, be = 0;
      return R.length && (R[0].duration !== void 0 && (X = 1), R[0].size !== void 0 && (re = 2), R[0].flags !== void 0 && (ue = 4), R[0].compositionTimeOffset !== void 0 && (be = 8)), [
        0,
        // version 0
        0,
        X | re | ue | be,
        1,
        // flags
        (R.length & 4278190080) >>> 24,
        (R.length & 16711680) >>> 16,
        (R.length & 65280) >>> 8,
        R.length & 255,
        // sample_count
        (V & 4278190080) >>> 24,
        (V & 16711680) >>> 16,
        (V & 65280) >>> 8,
        V & 255
        // data_offset
      ];
    }, A = function(R, V) {
      var X, re, ue, be, _e, Ae;
      for (be = R.samples || [], V += 20 + 16 * be.length, ue = O(be, V), re = new Uint8Array(ue.length + be.length * 16), re.set(ue), X = ue.length, Ae = 0; Ae < be.length; Ae++)
        _e = be[Ae], re[X++] = (_e.duration & 4278190080) >>> 24, re[X++] = (_e.duration & 16711680) >>> 16, re[X++] = (_e.duration & 65280) >>> 8, re[X++] = _e.duration & 255, re[X++] = (_e.size & 4278190080) >>> 24, re[X++] = (_e.size & 16711680) >>> 16, re[X++] = (_e.size & 65280) >>> 8, re[X++] = _e.size & 255, re[X++] = _e.flags.isLeading << 2 | _e.flags.dependsOn, re[X++] = _e.flags.isDependedOn << 6 | _e.flags.hasRedundancy << 4 | _e.flags.paddingValue << 1 | _e.flags.isNonSyncSample, re[X++] = _e.flags.degradationPriority & 61440, re[X++] = _e.flags.degradationPriority & 15, re[X++] = (_e.compositionTimeOffset & 4278190080) >>> 24, re[X++] = (_e.compositionTimeOffset & 16711680) >>> 16, re[X++] = (_e.compositionTimeOffset & 65280) >>> 8, re[X++] = _e.compositionTimeOffset & 255;
      return o(k.trun, re);
    }, w = function(R, V) {
      var X, re, ue, be, _e, Ae;
      for (be = R.samples || [], V += 20 + 8 * be.length, ue = O(be, V), X = new Uint8Array(ue.length + be.length * 8), X.set(ue), re = ue.length, Ae = 0; Ae < be.length; Ae++)
        _e = be[Ae], X[re++] = (_e.duration & 4278190080) >>> 24, X[re++] = (_e.duration & 16711680) >>> 16, X[re++] = (_e.duration & 65280) >>> 8, X[re++] = _e.duration & 255, X[re++] = (_e.size & 4278190080) >>> 24, X[re++] = (_e.size & 16711680) >>> 16, X[re++] = (_e.size & 65280) >>> 8, X[re++] = _e.size & 255;
      return o(k.trun, X);
    }, C = function(R, V) {
      return R.type === "audio" ? w(R, V) : A(R, V);
    };
  })();
  var oe = {
    ftyp: l,
    mdat: h,
    moof: y,
    moov: m,
    initSegment: function(w) {
      var A = l(), O = m(w), R;
      return R = new Uint8Array(A.byteLength + O.byteLength), R.set(A), R.set(O, A.byteLength), R;
    }
  }, De = function(w) {
    var A, O, R = [], V = [];
    for (V.byteLength = 0, V.nalCount = 0, V.duration = 0, R.byteLength = 0, A = 0; A < w.length; A++)
      O = w[A], O.nalUnitType === "access_unit_delimiter_rbsp" ? (R.length && (R.duration = O.dts - R.dts, V.byteLength += R.byteLength, V.nalCount += R.length, V.duration += R.duration, V.push(R)), R = [O], R.byteLength = O.data.byteLength, R.pts = O.pts, R.dts = O.dts) : (O.nalUnitType === "slice_layer_without_partitioning_rbsp_idr" && (R.keyFrame = !0), R.duration = O.dts - R.dts, R.byteLength += O.data.byteLength, R.push(O));
    return V.length && (!R.duration || R.duration <= 0) && (R.duration = V[V.length - 1].duration), V.byteLength += R.byteLength, V.nalCount += R.length, V.duration += R.duration, V.push(R), V;
  }, Re = function(w) {
    var A, O, R = [], V = [];
    for (R.byteLength = 0, R.nalCount = 0, R.duration = 0, R.pts = w[0].pts, R.dts = w[0].dts, V.byteLength = 0, V.nalCount = 0, V.duration = 0, V.pts = w[0].pts, V.dts = w[0].dts, A = 0; A < w.length; A++)
      O = w[A], O.keyFrame ? (R.length && (V.push(R), V.byteLength += R.byteLength, V.nalCount += R.nalCount, V.duration += R.duration), R = [O], R.nalCount = O.length, R.byteLength = O.byteLength, R.pts = O.pts, R.dts = O.dts, R.duration = O.duration) : (R.duration += O.duration, R.nalCount += O.length, R.byteLength += O.byteLength, R.push(O));
    return V.length && R.duration <= 0 && (R.duration = V[V.length - 1].duration), V.byteLength += R.byteLength, V.nalCount += R.nalCount, V.duration += R.duration, V.push(R), V;
  }, Me = function(w) {
    var A;
    return !w[0][0].keyFrame && w.length > 1 && (A = w.shift(), w.byteLength -= A.byteLength, w.nalCount -= A.nalCount, w[0][0].dts = A.dts, w[0][0].pts = A.pts, w[0][0].duration += A.duration), w;
  }, F = function() {
    return {
      size: 0,
      flags: {
        isLeading: 0,
        dependsOn: 1,
        isDependedOn: 0,
        hasRedundancy: 0,
        degradationPriority: 0,
        isNonSyncSample: 1
      }
    };
  }, P = function(w, A) {
    var O = F();
    return O.dataOffset = A, O.compositionTimeOffset = w.pts - w.dts, O.duration = w.duration, O.size = 4 * w.length, O.size += w.byteLength, w.keyFrame && (O.flags.dependsOn = 2, O.flags.isNonSyncSample = 0), O;
  }, ne = function(w, A) {
    var O, R, V, X, re, ue = A || 0, be = [];
    for (O = 0; O < w.length; O++)
      for (X = w[O], R = 0; R < X.length; R++)
        re = X[R], V = P(re, ue), ue += V.size, be.push(V);
    return be;
  }, S = function(w) {
    var A, O, R, V, X, re, ue = 0, be = w.byteLength, _e = w.nalCount, Ae = be + 4 * _e, Oe = new Uint8Array(Ae), We = new DataView(Oe.buffer);
    for (A = 0; A < w.length; A++)
      for (V = w[A], O = 0; O < V.length; O++)
        for (X = V[O], R = 0; R < X.length; R++)
          re = X[R], We.setUint32(ue, re.data.byteLength), ue += 4, Oe.set(re.data, ue), ue += re.data.byteLength;
    return Oe;
  }, he = function(w, A) {
    var O, R = A || 0, V = [];
    return O = P(w, R), V.push(O), V;
  }, ae = function(w) {
    var A, O, R = 0, V = w.byteLength, X = w.length, re = V + 4 * X, ue = new Uint8Array(re), be = new DataView(ue.buffer);
    for (A = 0; A < w.length; A++)
      O = w[A], be.setUint32(R, O.data.byteLength), R += 4, ue.set(O.data, R), R += O.data.byteLength;
    return ue;
  }, te = {
    groupNalsIntoFrames: De,
    groupFramesIntoGops: Re,
    extendFirstKeyFrame: Me,
    generateSampleTable: ne,
    concatenateNalData: S,
    generateSampleTableForFrame: he,
    concatenateNalDataForFrame: ae
  }, ee = [33, 16, 5, 32, 164, 27], ve = [33, 65, 108, 84, 1, 2, 4, 8, 168, 2, 4, 8, 17, 191, 252], Ee = function(w) {
    for (var A = []; w--; )
      A.push(0);
    return A;
  }, Se = function(w) {
    return Object.keys(w).reduce(function(A, O) {
      return A[O] = new Uint8Array(w[O].reduce(function(R, V) {
        return R.concat(V);
      }, [])), A;
    }, {});
  }, xe, le = function() {
    if (!xe) {
      var w = {
        96e3: [ee, [227, 64], Ee(154), [56]],
        88200: [ee, [231], Ee(170), [56]],
        64e3: [ee, [248, 192], Ee(240), [56]],
        48e3: [ee, [255, 192], Ee(268), [55, 148, 128], Ee(54), [112]],
        44100: [ee, [255, 192], Ee(268), [55, 163, 128], Ee(84), [112]],
        32e3: [ee, [255, 192], Ee(268), [55, 234], Ee(226), [112]],
        24e3: [ee, [255, 192], Ee(268), [55, 255, 128], Ee(268), [111, 112], Ee(126), [224]],
        16e3: [ee, [255, 192], Ee(268), [55, 255, 128], Ee(268), [111, 255], Ee(269), [223, 108], Ee(195), [1, 192]],
        12e3: [ve, Ee(268), [3, 127, 248], Ee(268), [6, 255, 240], Ee(268), [13, 255, 224], Ee(268), [27, 253, 128], Ee(259), [56]],
        11025: [ve, Ee(268), [3, 127, 248], Ee(268), [6, 255, 240], Ee(268), [13, 255, 224], Ee(268), [27, 255, 192], Ee(268), [55, 175, 128], Ee(108), [112]],
        8e3: [ve, Ee(268), [3, 121, 16], Ee(47), [7]]
      };
      xe = Se(w);
    }
    return xe;
  }, ye = 9e4, we, Ue, Q, M, N, Z, de;
  we = function(w) {
    return w * ye;
  }, Ue = function(w, A) {
    return w * A;
  }, Q = function(w) {
    return w / ye;
  }, M = function(w, A) {
    return w / A;
  }, N = function(w, A) {
    return we(M(w, A));
  }, Z = function(w, A) {
    return Ue(Q(w), A);
  }, de = function(w, A, O) {
    return Q(O ? w : w - A);
  };
  var Te = {
    ONE_SECOND_IN_TS: ye,
    secondsToVideoTs: we,
    secondsToAudioTs: Ue,
    videoTsToSeconds: Q,
    audioTsToSeconds: M,
    audioTsToVideoTs: N,
    videoTsToAudioTs: Z,
    metadataTsToSeconds: de
  }, Ie = le, je = Te, Ze = function(w) {
    var A, O, R = 0;
    for (A = 0; A < w.length; A++)
      O = w[A], R += O.data.byteLength;
    return R;
  }, Qe = function(w, A, O, R) {
    var V, X = 0, re = 0, ue = 0, be = 0, _e, Ae, Oe;
    if (A.length && (V = je.audioTsToVideoTs(w.baseMediaDecodeTime, w.samplerate), X = Math.ceil(je.ONE_SECOND_IN_TS / (w.samplerate / 1024)), O && R && (re = V - Math.max(O, R), ue = Math.floor(re / X), be = ue * X), !(ue < 1 || be > je.ONE_SECOND_IN_TS / 2))) {
      for (_e = Ie()[w.samplerate], _e || (_e = A[0].data), Ae = 0; Ae < ue; Ae++)
        Oe = A[0], A.splice(0, 0, {
          data: _e,
          dts: Oe.dts - X,
          pts: Oe.pts - X
        });
      return w.baseMediaDecodeTime -= Math.floor(je.videoTsToAudioTs(be, w.samplerate)), be;
    }
  }, ot = function(w, A, O) {
    return A.minSegmentDts >= O ? w : (A.minSegmentDts = 1 / 0, w.filter(function(R) {
      return R.dts >= O ? (A.minSegmentDts = Math.min(A.minSegmentDts, R.dts), A.minSegmentPts = A.minSegmentDts, !0) : !1;
    }));
  }, rt = function(w) {
    var A, O, R = [];
    for (A = 0; A < w.length; A++)
      O = w[A], R.push({
        size: O.data.byteLength,
        duration: 1024
        // For AAC audio, all samples contain 1024 samples
      });
    return R;
  }, Bi = function(w) {
    var A, O, R = 0, V = new Uint8Array(Ze(w));
    for (A = 0; A < w.length; A++)
      O = w[A], V.set(O.data, R), R += O.data.byteLength;
    return V;
  }, oi = {
    prefixWithSilence: Qe,
    trimAdtsFramesByEarliestDts: ot,
    generateSampleTable: rt,
    concatenateFrameData: Bi
  }, ui = Te.ONE_SECOND_IN_TS, G = function(w, A) {
    typeof A.pts == "number" && (w.timelineStartInfo.pts === void 0 && (w.timelineStartInfo.pts = A.pts), w.minSegmentPts === void 0 ? w.minSegmentPts = A.pts : w.minSegmentPts = Math.min(w.minSegmentPts, A.pts), w.maxSegmentPts === void 0 ? w.maxSegmentPts = A.pts : w.maxSegmentPts = Math.max(w.maxSegmentPts, A.pts)), typeof A.dts == "number" && (w.timelineStartInfo.dts === void 0 && (w.timelineStartInfo.dts = A.dts), w.minSegmentDts === void 0 ? w.minSegmentDts = A.dts : w.minSegmentDts = Math.min(w.minSegmentDts, A.dts), w.maxSegmentDts === void 0 ? w.maxSegmentDts = A.dts : w.maxSegmentDts = Math.max(w.maxSegmentDts, A.dts));
  }, J = function(w) {
    delete w.minSegmentDts, delete w.maxSegmentDts, delete w.minSegmentPts, delete w.maxSegmentPts;
  }, fe = function(w, A) {
    var O, R, V = w.minSegmentDts;
    return A || (V -= w.timelineStartInfo.dts), O = w.timelineStartInfo.baseMediaDecodeTime, O += V, O = Math.max(0, O), w.type === "audio" && (R = w.samplerate / ui, O *= R, O = Math.floor(O)), O;
  }, Ce = {
    clearDtsInfo: J,
    calculateTrackBaseMediaDecodeTime: fe,
    collectDtsInfo: G
  }, Ne = 4, Ve = 128, ut = function(w) {
    for (var A = 0, O = {
      payloadType: -1,
      payloadSize: 0
    }, R = 0, V = 0; A < w.byteLength && w[A] !== Ve; ) {
      for (; w[A] === 255; )
        R += 255, A++;
      for (R += w[A++]; w[A] === 255; )
        V += 255, A++;
      if (V += w[A++], !O.payload && R === Ne) {
        var X = String.fromCharCode(w[A + 3], w[A + 4], w[A + 5], w[A + 6]);
        if (X === "GA94") {
          O.payloadType = R, O.payloadSize = V, O.payload = w.subarray(A, A + V);
          break;
        } else
          O.payload = void 0;
      }
      A += V, R = 0, V = 0;
    }
    return O;
  }, mt = function(w) {
    return w.payload[0] !== 181 || (w.payload[1] << 8 | w.payload[2]) !== 49 || String.fromCharCode(w.payload[3], w.payload[4], w.payload[5], w.payload[6]) !== "GA94" || w.payload[7] !== 3 ? null : w.payload.subarray(8, w.payload.length - 1);
  }, Jt = function(w, A) {
    var O = [], R, V, X, re;
    if (!(A[0] & 64))
      return O;
    for (V = A[0] & 31, R = 0; R < V; R++)
      X = R * 3, re = {
        type: A[X + 2] & 3,
        pts: w
      }, A[X + 2] & 4 && (re.ccData = A[X + 3] << 8 | A[X + 4], O.push(re));
    return O;
  }, qn = function(w) {
    for (var A = w.byteLength, O = [], R = 1, V, X; R < A - 2; )
      w[R] === 0 && w[R + 1] === 0 && w[R + 2] === 3 ? (O.push(R + 2), R += 2) : R++;
    if (O.length === 0)
      return w;
    V = A - O.length, X = new Uint8Array(V);
    var re = 0;
    for (R = 0; R < V; re++, R++)
      re === O[0] && (re++, O.shift()), X[R] = w[re];
    return X;
  }, An = {
    parseSei: ut,
    parseUserData: mt,
    parseCaptionPackets: Jt,
    discardEmulationPreventionBytes: qn,
    USER_DATA_REGISTERED_ITU_T_T35: Ne
  }, Wn = t, kn = An, Ut = function(w) {
    w = w || {}, Ut.prototype.init.call(this), this.parse708captions_ = typeof w.parse708captions == "boolean" ? w.parse708captions : !0, this.captionPackets_ = [], this.ccStreams_ = [
      new Dt(0, 0),
      // eslint-disable-line no-use-before-define
      new Dt(0, 1),
      // eslint-disable-line no-use-before-define
      new Dt(1, 0),
      // eslint-disable-line no-use-before-define
      new Dt(1, 1)
      // eslint-disable-line no-use-before-define
    ], this.parse708captions_ && (this.cc708Stream_ = new lt({
      captionServices: w.captionServices
    })), this.reset(), this.ccStreams_.forEach(function(A) {
      A.on("data", this.trigger.bind(this, "data")), A.on("partialdone", this.trigger.bind(this, "partialdone")), A.on("done", this.trigger.bind(this, "done"));
    }, this), this.parse708captions_ && (this.cc708Stream_.on("data", this.trigger.bind(this, "data")), this.cc708Stream_.on("partialdone", this.trigger.bind(this, "partialdone")), this.cc708Stream_.on("done", this.trigger.bind(this, "done")));
  };
  Ut.prototype = new Wn(), Ut.prototype.push = function(w) {
    var A, O, R;
    if (w.nalUnitType === "sei_rbsp" && (A = kn.parseSei(w.escapedRBSP), !!A.payload && A.payloadType === kn.USER_DATA_REGISTERED_ITU_T_T35 && (O = kn.parseUserData(A), !!O))) {
      if (w.dts < this.latestDts_) {
        this.ignoreNextEqualDts_ = !0;
        return;
      } else if (w.dts === this.latestDts_ && this.ignoreNextEqualDts_) {
        this.numSameDts_--, this.numSameDts_ || (this.ignoreNextEqualDts_ = !1);
        return;
      }
      R = kn.parseCaptionPackets(w.pts, O), this.captionPackets_ = this.captionPackets_.concat(R), this.latestDts_ !== w.dts && (this.numSameDts_ = 0), this.numSameDts_++, this.latestDts_ = w.dts;
    }
  }, Ut.prototype.flushCCStreams = function(w) {
    this.ccStreams_.forEach(function(A) {
      return w === "flush" ? A.flush() : A.partialFlush();
    }, this);
  }, Ut.prototype.flushStream = function(w) {
    if (!this.captionPackets_.length) {
      this.flushCCStreams(w);
      return;
    }
    this.captionPackets_.forEach(function(A, O) {
      A.presortIndex = O;
    }), this.captionPackets_.sort(function(A, O) {
      return A.pts === O.pts ? A.presortIndex - O.presortIndex : A.pts - O.pts;
    }), this.captionPackets_.forEach(function(A) {
      A.type < 2 ? this.dispatchCea608Packet(A) : this.dispatchCea708Packet(A);
    }, this), this.captionPackets_.length = 0, this.flushCCStreams(w);
  }, Ut.prototype.flush = function() {
    return this.flushStream("flush");
  }, Ut.prototype.partialFlush = function() {
    return this.flushStream("partialFlush");
  }, Ut.prototype.reset = function() {
    this.latestDts_ = null, this.ignoreNextEqualDts_ = !1, this.numSameDts_ = 0, this.activeCea608Channel_ = [null, null], this.ccStreams_.forEach(function(w) {
      w.reset();
    });
  }, Ut.prototype.dispatchCea608Packet = function(w) {
    this.setsTextOrXDSActive(w) ? this.activeCea608Channel_[w.type] = null : this.setsChannel1Active(w) ? this.activeCea608Channel_[w.type] = 0 : this.setsChannel2Active(w) && (this.activeCea608Channel_[w.type] = 1), this.activeCea608Channel_[w.type] !== null && this.ccStreams_[(w.type << 1) + this.activeCea608Channel_[w.type]].push(w);
  }, Ut.prototype.setsChannel1Active = function(w) {
    return (w.ccData & 30720) === 4096;
  }, Ut.prototype.setsChannel2Active = function(w) {
    return (w.ccData & 30720) === 6144;
  }, Ut.prototype.setsTextOrXDSActive = function(w) {
    return (w.ccData & 28928) === 256 || (w.ccData & 30974) === 4138 || (w.ccData & 30974) === 6186;
  }, Ut.prototype.dispatchCea708Packet = function(w) {
    this.parse708captions_ && this.cc708Stream_.push(w);
  };
  var In = {
    127: 9834,
    // 
    4128: 32,
    // Transparent Space
    4129: 160,
    // Nob-breaking Transparent Space
    4133: 8230,
    // 
    4138: 352,
    // 
    4140: 338,
    // 
    4144: 9608,
    // 
    4145: 8216,
    // 
    4146: 8217,
    // 
    4147: 8220,
    // 
    4148: 8221,
    // 
    4149: 8226,
    // 
    4153: 8482,
    // 
    4154: 353,
    // 
    4156: 339,
    // 
    4157: 8480,
    // 
    4159: 376,
    // 
    4214: 8539,
    // 
    4215: 8540,
    // 
    4216: 8541,
    // 
    4217: 8542,
    // 
    4218: 9168,
    // 
    4219: 9124,
    // 
    4220: 9123,
    // 
    4221: 9135,
    // 
    4222: 9126,
    // 
    4223: 9121,
    // 
    4256: 12600
    //  (CC char)
  }, wi = function(w) {
    var A = In[w] || w;
    return w & 4096 && w === A ? "" : String.fromCharCode(A);
  }, ci = function(w) {
    return 32 <= w && w <= 127 || 160 <= w && w <= 255;
  }, xt = function(w) {
    this.windowNum = w, this.reset();
  };
  xt.prototype.reset = function() {
    this.clearText(), this.pendingNewLine = !1, this.winAttr = {}, this.penAttr = {}, this.penLoc = {}, this.penColor = {}, this.visible = 0, this.rowLock = 0, this.columnLock = 0, this.priority = 0, this.relativePositioning = 0, this.anchorVertical = 0, this.anchorHorizontal = 0, this.anchorPoint = 0, this.rowCount = 1, this.virtualRowCount = this.rowCount + 1, this.columnCount = 41, this.windowStyle = 0, this.penStyle = 0;
  }, xt.prototype.getText = function() {
    return this.rows.join(`
`);
  }, xt.prototype.clearText = function() {
    this.rows = [""], this.rowIdx = 0;
  }, xt.prototype.newLine = function(w) {
    for (this.rows.length >= this.virtualRowCount && typeof this.beforeRowOverflow == "function" && this.beforeRowOverflow(w), this.rows.length > 0 && (this.rows.push(""), this.rowIdx++); this.rows.length > this.virtualRowCount; )
      this.rows.shift(), this.rowIdx--;
  }, xt.prototype.isEmpty = function() {
    return this.rows.length === 0 ? !0 : this.rows.length === 1 ? this.rows[0] === "" : !1;
  }, xt.prototype.addText = function(w) {
    this.rows[this.rowIdx] += w;
  }, xt.prototype.backspace = function() {
    if (!this.isEmpty()) {
      var w = this.rows[this.rowIdx];
      this.rows[this.rowIdx] = w.substr(0, w.length - 1);
    }
  };
  var dr = function(w, A, O) {
    this.serviceNum = w, this.text = "", this.currentWindow = new xt(-1), this.windows = [], this.stream = O, typeof A == "string" && this.createTextDecoder(A);
  };
  dr.prototype.init = function(w, A) {
    this.startPts = w;
    for (var O = 0; O < 8; O++)
      this.windows[O] = new xt(O), typeof A == "function" && (this.windows[O].beforeRowOverflow = A);
  }, dr.prototype.setCurrentWindow = function(w) {
    this.currentWindow = this.windows[w];
  }, dr.prototype.createTextDecoder = function(w) {
    if (typeof TextDecoder > "u")
      this.stream.trigger("log", {
        level: "warn",
        message: "The `encoding` option is unsupported without TextDecoder support"
      });
    else
      try {
        this.textDecoder_ = new TextDecoder(w);
      } catch (A) {
        this.stream.trigger("log", {
          level: "warn",
          message: "TextDecoder could not be created with " + w + " encoding. " + A
        });
      }
  };
  var lt = function(w) {
    w = w || {}, lt.prototype.init.call(this);
    var A = this, O = w.captionServices || {}, R = {}, V;
    Object.keys(O).forEach((X) => {
      V = O[X], /^SERVICE/.test(X) && (R[X] = V.encoding);
    }), this.serviceEncodings = R, this.current708Packet = null, this.services = {}, this.push = function(X) {
      X.type === 3 ? (A.new708Packet(), A.add708Bytes(X)) : (A.current708Packet === null && A.new708Packet(), A.add708Bytes(X));
    };
  };
  lt.prototype = new Wn(), lt.prototype.new708Packet = function() {
    this.current708Packet !== null && this.push708Packet(), this.current708Packet = {
      data: [],
      ptsVals: []
    };
  }, lt.prototype.add708Bytes = function(w) {
    var A = w.ccData, O = A >>> 8, R = A & 255;
    this.current708Packet.ptsVals.push(w.pts), this.current708Packet.data.push(O), this.current708Packet.data.push(R);
  }, lt.prototype.push708Packet = function() {
    var w = this.current708Packet, A = w.data, O = null, R = null, V = 0, X = A[V++];
    for (w.seq = X >> 6, w.sizeCode = X & 63; V < A.length; V++)
      X = A[V++], O = X >> 5, R = X & 31, O === 7 && R > 0 && (X = A[V++], O = X), this.pushServiceBlock(O, V, R), R > 0 && (V += R - 1);
  }, lt.prototype.pushServiceBlock = function(w, A, O) {
    var R, V = A, X = this.current708Packet.data, re = this.services[w];
    for (re || (re = this.initService(w, V)); V < A + O && V < X.length; V++)
      R = X[V], ci(R) ? V = this.handleText(V, re) : R === 24 ? V = this.multiByteCharacter(V, re) : R === 16 ? V = this.extendedCommands(V, re) : 128 <= R && R <= 135 ? V = this.setCurrentWindow(V, re) : 152 <= R && R <= 159 ? V = this.defineWindow(V, re) : R === 136 ? V = this.clearWindows(V, re) : R === 140 ? V = this.deleteWindows(V, re) : R === 137 ? V = this.displayWindows(V, re) : R === 138 ? V = this.hideWindows(V, re) : R === 139 ? V = this.toggleWindows(V, re) : R === 151 ? V = this.setWindowAttributes(V, re) : R === 144 ? V = this.setPenAttributes(V, re) : R === 145 ? V = this.setPenColor(V, re) : R === 146 ? V = this.setPenLocation(V, re) : R === 143 ? re = this.reset(V, re) : R === 8 ? re.currentWindow.backspace() : R === 12 ? re.currentWindow.clearText() : R === 13 ? re.currentWindow.pendingNewLine = !0 : R === 14 ? re.currentWindow.clearText() : R === 141 && V++;
  }, lt.prototype.extendedCommands = function(w, A) {
    var O = this.current708Packet.data, R = O[++w];
    return ci(R) && (w = this.handleText(w, A, {
      isExtended: !0
    })), w;
  }, lt.prototype.getPts = function(w) {
    return this.current708Packet.ptsVals[Math.floor(w / 2)];
  }, lt.prototype.initService = function(w, A) {
    var R = "SERVICE" + w, O = this, R, V;
    return R in this.serviceEncodings && (V = this.serviceEncodings[R]), this.services[w] = new dr(w, V, O), this.services[w].init(this.getPts(A), function(X) {
      O.flushDisplayed(X, O.services[w]);
    }), this.services[w];
  }, lt.prototype.handleText = function(w, A, O) {
    var R = O && O.isExtended, V = O && O.isMultiByte, X = this.current708Packet.data, re = R ? 4096 : 0, ue = X[w], be = X[w + 1], _e = A.currentWindow, Ae, Oe;
    function We(Fe) {
      return Fe.map((Xe) => ("0" + (Xe & 255).toString(16)).slice(-2)).join("");
    }
    if (V ? (Oe = [ue, be], w++) : Oe = [ue], A.textDecoder_ && !R)
      Ae = A.textDecoder_.decode(new Uint8Array(Oe));
    else if (V) {
      const Fe = We(Oe);
      Ae = String.fromCharCode(parseInt(Fe, 16));
    } else
      Ae = wi(re | ue);
    return _e.pendingNewLine && !_e.isEmpty() && _e.newLine(this.getPts(w)), _e.pendingNewLine = !1, _e.addText(Ae), w;
  }, lt.prototype.multiByteCharacter = function(w, A) {
    var O = this.current708Packet.data, R = O[w + 1], V = O[w + 2];
    return ci(R) && ci(V) && (w = this.handleText(++w, A, {
      isMultiByte: !0
    })), w;
  }, lt.prototype.setCurrentWindow = function(w, A) {
    var O = this.current708Packet.data, R = O[w], V = R & 7;
    return A.setCurrentWindow(V), w;
  }, lt.prototype.defineWindow = function(w, A) {
    var O = this.current708Packet.data, R = O[w], V = R & 7;
    A.setCurrentWindow(V);
    var X = A.currentWindow;
    return R = O[++w], X.visible = (R & 32) >> 5, X.rowLock = (R & 16) >> 4, X.columnLock = (R & 8) >> 3, X.priority = R & 7, R = O[++w], X.relativePositioning = (R & 128) >> 7, X.anchorVertical = R & 127, R = O[++w], X.anchorHorizontal = R, R = O[++w], X.anchorPoint = (R & 240) >> 4, X.rowCount = R & 15, R = O[++w], X.columnCount = R & 63, R = O[++w], X.windowStyle = (R & 56) >> 3, X.penStyle = R & 7, X.virtualRowCount = X.rowCount + 1, w;
  }, lt.prototype.setWindowAttributes = function(w, A) {
    var O = this.current708Packet.data, R = O[w], V = A.currentWindow.winAttr;
    return R = O[++w], V.fillOpacity = (R & 192) >> 6, V.fillRed = (R & 48) >> 4, V.fillGreen = (R & 12) >> 2, V.fillBlue = R & 3, R = O[++w], V.borderType = (R & 192) >> 6, V.borderRed = (R & 48) >> 4, V.borderGreen = (R & 12) >> 2, V.borderBlue = R & 3, R = O[++w], V.borderType += (R & 128) >> 5, V.wordWrap = (R & 64) >> 6, V.printDirection = (R & 48) >> 4, V.scrollDirection = (R & 12) >> 2, V.justify = R & 3, R = O[++w], V.effectSpeed = (R & 240) >> 4, V.effectDirection = (R & 12) >> 2, V.displayEffect = R & 3, w;
  }, lt.prototype.flushDisplayed = function(w, A) {
    for (var O = [], R = 0; R < 8; R++)
      A.windows[R].visible && !A.windows[R].isEmpty() && O.push(A.windows[R].getText());
    A.endPts = w, A.text = O.join(`

`), this.pushCaption(A), A.startPts = w;
  }, lt.prototype.pushCaption = function(w) {
    w.text !== "" && (this.trigger("data", {
      startPts: w.startPts,
      endPts: w.endPts,
      text: w.text,
      stream: "cc708_" + w.serviceNum
    }), w.text = "", w.startPts = w.endPts);
  }, lt.prototype.displayWindows = function(w, A) {
    var O = this.current708Packet.data, R = O[++w], V = this.getPts(w);
    this.flushDisplayed(V, A);
    for (var X = 0; X < 8; X++)
      R & 1 << X && (A.windows[X].visible = 1);
    return w;
  }, lt.prototype.hideWindows = function(w, A) {
    var O = this.current708Packet.data, R = O[++w], V = this.getPts(w);
    this.flushDisplayed(V, A);
    for (var X = 0; X < 8; X++)
      R & 1 << X && (A.windows[X].visible = 0);
    return w;
  }, lt.prototype.toggleWindows = function(w, A) {
    var O = this.current708Packet.data, R = O[++w], V = this.getPts(w);
    this.flushDisplayed(V, A);
    for (var X = 0; X < 8; X++)
      R & 1 << X && (A.windows[X].visible ^= 1);
    return w;
  }, lt.prototype.clearWindows = function(w, A) {
    var O = this.current708Packet.data, R = O[++w], V = this.getPts(w);
    this.flushDisplayed(V, A);
    for (var X = 0; X < 8; X++)
      R & 1 << X && A.windows[X].clearText();
    return w;
  }, lt.prototype.deleteWindows = function(w, A) {
    var O = this.current708Packet.data, R = O[++w], V = this.getPts(w);
    this.flushDisplayed(V, A);
    for (var X = 0; X < 8; X++)
      R & 1 << X && A.windows[X].reset();
    return w;
  }, lt.prototype.setPenAttributes = function(w, A) {
    var O = this.current708Packet.data, R = O[w], V = A.currentWindow.penAttr;
    return R = O[++w], V.textTag = (R & 240) >> 4, V.offset = (R & 12) >> 2, V.penSize = R & 3, R = O[++w], V.italics = (R & 128) >> 7, V.underline = (R & 64) >> 6, V.edgeType = (R & 56) >> 3, V.fontStyle = R & 7, w;
  }, lt.prototype.setPenColor = function(w, A) {
    var O = this.current708Packet.data, R = O[w], V = A.currentWindow.penColor;
    return R = O[++w], V.fgOpacity = (R & 192) >> 6, V.fgRed = (R & 48) >> 4, V.fgGreen = (R & 12) >> 2, V.fgBlue = R & 3, R = O[++w], V.bgOpacity = (R & 192) >> 6, V.bgRed = (R & 48) >> 4, V.bgGreen = (R & 12) >> 2, V.bgBlue = R & 3, R = O[++w], V.edgeRed = (R & 48) >> 4, V.edgeGreen = (R & 12) >> 2, V.edgeBlue = R & 3, w;
  }, lt.prototype.setPenLocation = function(w, A) {
    var O = this.current708Packet.data, R = O[w], V = A.currentWindow.penLoc;
    return A.currentWindow.pendingNewLine = !0, R = O[++w], V.row = R & 15, R = O[++w], V.column = R & 63, w;
  }, lt.prototype.reset = function(w, A) {
    var O = this.getPts(w);
    return this.flushDisplayed(O, A), this.initService(A.serviceNum, w);
  };
  var _o = {
    42: 225,
    // 
    92: 233,
    // 
    94: 237,
    // 
    95: 243,
    // 
    96: 250,
    // 
    123: 231,
    // 
    124: 247,
    // 
    125: 209,
    // 
    126: 241,
    // 
    127: 9608,
    // 
    304: 174,
    // 
    305: 176,
    // 
    306: 189,
    // 
    307: 191,
    // 
    308: 8482,
    // 
    309: 162,
    // 
    310: 163,
    // 
    311: 9834,
    // 
    312: 224,
    // 
    313: 160,
    //
    314: 232,
    // 
    315: 226,
    // 
    316: 234,
    // 
    317: 238,
    // 
    318: 244,
    // 
    319: 251,
    // 
    544: 193,
    // 
    545: 201,
    // 
    546: 211,
    // 
    547: 218,
    // 
    548: 220,
    // 
    549: 252,
    // 
    550: 8216,
    // 
    551: 161,
    // 
    552: 42,
    // *
    553: 39,
    // '
    554: 8212,
    // 
    555: 169,
    // 
    556: 8480,
    // 
    557: 8226,
    // 
    558: 8220,
    // 
    559: 8221,
    // 
    560: 192,
    // 
    561: 194,
    // 
    562: 199,
    // 
    563: 200,
    // 
    564: 202,
    // 
    565: 203,
    // 
    566: 235,
    // 
    567: 206,
    // 
    568: 207,
    // 
    569: 239,
    // 
    570: 212,
    // 
    571: 217,
    // 
    572: 249,
    // 
    573: 219,
    // 
    574: 171,
    // 
    575: 187,
    // 
    800: 195,
    // 
    801: 227,
    // 
    802: 205,
    // 
    803: 204,
    // 
    804: 236,
    // 
    805: 210,
    // 
    806: 242,
    // 
    807: 213,
    // 
    808: 245,
    // 
    809: 123,
    // {
    810: 125,
    // }
    811: 92,
    // \
    812: 94,
    // ^
    813: 95,
    // _
    814: 124,
    // |
    815: 126,
    // ~
    816: 196,
    // 
    817: 228,
    // 
    818: 214,
    // 
    819: 246,
    // 
    820: 223,
    // 
    821: 165,
    // 
    822: 164,
    // 
    823: 9474,
    // 
    824: 197,
    // 
    825: 229,
    // 
    826: 216,
    // 
    827: 248,
    // 
    828: 9484,
    // 
    829: 9488,
    // 
    830: 9492,
    // 
    831: 9496
    // 
  }, To = function(w) {
    return w === null ? "" : (w = _o[w] || w, String.fromCharCode(w));
  }, wo = 14, cC = [4352, 4384, 4608, 4640, 5376, 5408, 5632, 5664, 5888, 5920, 4096, 4864, 4896, 5120, 5152], fr = function() {
    for (var w = [], A = wo + 1; A--; )
      w.push({
        text: "",
        indent: 0,
        offset: 0
      });
    return w;
  }, Dt = function(w, A) {
    Dt.prototype.init.call(this), this.field_ = w || 0, this.dataChannel_ = A || 0, this.name_ = "CC" + ((this.field_ << 1 | this.dataChannel_) + 1), this.setConstants(), this.reset(), this.push = function(O) {
      var R, V, X, re, ue;
      if (R = O.ccData & 32639, R === this.lastControlCode_) {
        this.lastControlCode_ = null;
        return;
      }
      if ((R & 61440) === 4096 ? this.lastControlCode_ = R : R !== this.PADDING_ && (this.lastControlCode_ = null), X = R >>> 8, re = R & 255, R !== this.PADDING_)
        if (R === this.RESUME_CAPTION_LOADING_)
          this.mode_ = "popOn";
        else if (R === this.END_OF_CAPTION_)
          this.mode_ = "popOn", this.clearFormatting(O.pts), this.flushDisplayed(O.pts), V = this.displayed_, this.displayed_ = this.nonDisplayed_, this.nonDisplayed_ = V, this.startPts_ = O.pts;
        else if (R === this.ROLL_UP_2_ROWS_)
          this.rollUpRows_ = 2, this.setRollUp(O.pts);
        else if (R === this.ROLL_UP_3_ROWS_)
          this.rollUpRows_ = 3, this.setRollUp(O.pts);
        else if (R === this.ROLL_UP_4_ROWS_)
          this.rollUpRows_ = 4, this.setRollUp(O.pts);
        else if (R === this.CARRIAGE_RETURN_)
          this.clearFormatting(O.pts), this.flushDisplayed(O.pts), this.shiftRowsUp_(), this.startPts_ = O.pts;
        else if (R === this.BACKSPACE_)
          this.mode_ === "popOn" ? this.nonDisplayed_[this.row_].text = this.nonDisplayed_[this.row_].text.slice(0, -1) : this.displayed_[this.row_].text = this.displayed_[this.row_].text.slice(0, -1);
        else if (R === this.ERASE_DISPLAYED_MEMORY_)
          this.flushDisplayed(O.pts), this.displayed_ = fr();
        else if (R === this.ERASE_NON_DISPLAYED_MEMORY_)
          this.nonDisplayed_ = fr();
        else if (R === this.RESUME_DIRECT_CAPTIONING_)
          this.mode_ !== "paintOn" && (this.flushDisplayed(O.pts), this.displayed_ = fr()), this.mode_ = "paintOn", this.startPts_ = O.pts;
        else if (this.isSpecialCharacter(X, re))
          X = (X & 3) << 8, ue = To(X | re), this[this.mode_](O.pts, ue), this.column_++;
        else if (this.isExtCharacter(X, re))
          this.mode_ === "popOn" ? this.nonDisplayed_[this.row_].text = this.nonDisplayed_[this.row_].text.slice(0, -1) : this.displayed_[this.row_].text = this.displayed_[this.row_].text.slice(0, -1), X = (X & 3) << 8, ue = To(X | re), this[this.mode_](O.pts, ue), this.column_++;
        else if (this.isMidRowCode(X, re))
          this.clearFormatting(O.pts), this[this.mode_](O.pts, " "), this.column_++, (re & 14) === 14 && this.addFormatting(O.pts, ["i"]), (re & 1) === 1 && this.addFormatting(O.pts, ["u"]);
        else if (this.isOffsetControlCode(X, re)) {
          const _e = re & 3;
          this.nonDisplayed_[this.row_].offset = _e, this.column_ += _e;
        } else if (this.isPAC(X, re)) {
          var be = cC.indexOf(R & 7968);
          if (this.mode_ === "rollUp" && (be - this.rollUpRows_ + 1 < 0 && (be = this.rollUpRows_ - 1), this.setRollUp(O.pts, be)), be !== this.row_ && be >= 0 && be <= 14 && (this.clearFormatting(O.pts), this.row_ = be), re & 1 && this.formatting_.indexOf("u") === -1 && this.addFormatting(O.pts, ["u"]), (R & 16) === 16) {
            const _e = (R & 14) >> 1;
            this.column_ = _e * 4, this.nonDisplayed_[this.row_].indent += _e;
          }
          this.isColorPAC(re) && (re & 14) === 14 && this.addFormatting(O.pts, ["i"]);
        } else this.isNormalChar(X) && (re === 0 && (re = null), ue = To(X), ue += To(re), this[this.mode_](O.pts, ue), this.column_ += ue.length);
    };
  };
  Dt.prototype = new Wn(), Dt.prototype.flushDisplayed = function(w) {
    const A = (R) => {
      this.trigger("log", {
        level: "warn",
        message: "Skipping a malformed 608 caption at index " + R + "."
      });
    }, O = [];
    this.displayed_.forEach((R, V) => {
      if (R && R.text && R.text.length) {
        try {
          R.text = R.text.trim();
        } catch {
          A(V);
        }
        R.text.length && O.push({
          // The text to be displayed in the caption from this specific row, with whitespace removed.
          text: R.text,
          // Value between 1 and 15 representing the PAC row used to calculate line height.
          line: V + 1,
          // A number representing the indent position by percentage (CEA-608 PAC indent code).
          // The value will be a number between 10 and 80. Offset is used to add an aditional
          // value to the position if necessary.
          position: 10 + Math.min(70, R.indent * 10) + R.offset * 2.5
        });
      } else R == null && A(V);
    }), O.length && this.trigger("data", {
      startPts: this.startPts_,
      endPts: w,
      content: O,
      stream: this.name_
    });
  }, Dt.prototype.reset = function() {
    this.mode_ = "popOn", this.topRow_ = 0, this.startPts_ = 0, this.displayed_ = fr(), this.nonDisplayed_ = fr(), this.lastControlCode_ = null, this.column_ = 0, this.row_ = wo, this.rollUpRows_ = 2, this.formatting_ = [];
  }, Dt.prototype.setConstants = function() {
    this.dataChannel_ === 0 ? (this.BASE_ = 16, this.EXT_ = 17, this.CONTROL_ = (20 | this.field_) << 8, this.OFFSET_ = 23) : this.dataChannel_ === 1 && (this.BASE_ = 24, this.EXT_ = 25, this.CONTROL_ = (28 | this.field_) << 8, this.OFFSET_ = 31), this.PADDING_ = 0, this.RESUME_CAPTION_LOADING_ = this.CONTROL_ | 32, this.END_OF_CAPTION_ = this.CONTROL_ | 47, this.ROLL_UP_2_ROWS_ = this.CONTROL_ | 37, this.ROLL_UP_3_ROWS_ = this.CONTROL_ | 38, this.ROLL_UP_4_ROWS_ = this.CONTROL_ | 39, this.CARRIAGE_RETURN_ = this.CONTROL_ | 45, this.RESUME_DIRECT_CAPTIONING_ = this.CONTROL_ | 41, this.BACKSPACE_ = this.CONTROL_ | 33, this.ERASE_DISPLAYED_MEMORY_ = this.CONTROL_ | 44, this.ERASE_NON_DISPLAYED_MEMORY_ = this.CONTROL_ | 46;
  }, Dt.prototype.isSpecialCharacter = function(w, A) {
    return w === this.EXT_ && A >= 48 && A <= 63;
  }, Dt.prototype.isExtCharacter = function(w, A) {
    return (w === this.EXT_ + 1 || w === this.EXT_ + 2) && A >= 32 && A <= 63;
  }, Dt.prototype.isMidRowCode = function(w, A) {
    return w === this.EXT_ && A >= 32 && A <= 47;
  }, Dt.prototype.isOffsetControlCode = function(w, A) {
    return w === this.OFFSET_ && A >= 33 && A <= 35;
  }, Dt.prototype.isPAC = function(w, A) {
    return w >= this.BASE_ && w < this.BASE_ + 8 && A >= 64 && A <= 127;
  }, Dt.prototype.isColorPAC = function(w) {
    return w >= 64 && w <= 79 || w >= 96 && w <= 127;
  }, Dt.prototype.isNormalChar = function(w) {
    return w >= 32 && w <= 127;
  }, Dt.prototype.setRollUp = function(w, A) {
    if (this.mode_ !== "rollUp" && (this.row_ = wo, this.mode_ = "rollUp", this.flushDisplayed(w), this.nonDisplayed_ = fr(), this.displayed_ = fr()), A !== void 0 && A !== this.row_)
      for (var O = 0; O < this.rollUpRows_; O++)
        this.displayed_[A - O] = this.displayed_[this.row_ - O], this.displayed_[this.row_ - O] = {
          text: "",
          indent: 0,
          offset: 0
        };
    A === void 0 && (A = this.row_), this.topRow_ = A - this.rollUpRows_ + 1;
  }, Dt.prototype.addFormatting = function(w, A) {
    this.formatting_ = this.formatting_.concat(A);
    var O = A.reduce(function(R, V) {
      return R + "<" + V + ">";
    }, "");
    this[this.mode_](w, O);
  }, Dt.prototype.clearFormatting = function(w) {
    if (this.formatting_.length) {
      var A = this.formatting_.reverse().reduce(function(O, R) {
        return O + "</" + R + ">";
      }, "");
      this.formatting_ = [], this[this.mode_](w, A);
    }
  }, Dt.prototype.popOn = function(w, A) {
    var O = this.nonDisplayed_[this.row_].text;
    O += A, this.nonDisplayed_[this.row_].text = O;
  }, Dt.prototype.rollUp = function(w, A) {
    var O = this.displayed_[this.row_].text;
    O += A, this.displayed_[this.row_].text = O;
  }, Dt.prototype.shiftRowsUp_ = function() {
    var w;
    for (w = 0; w < this.topRow_; w++)
      this.displayed_[w] = {
        text: "",
        indent: 0,
        offset: 0
      };
    for (w = this.row_ + 1; w < wo + 1; w++)
      this.displayed_[w] = {
        text: "",
        indent: 0,
        offset: 0
      };
    for (w = this.topRow_; w < this.row_; w++)
      this.displayed_[w] = this.displayed_[w + 1];
    this.displayed_[this.row_] = {
      text: "",
      indent: 0,
      offset: 0
    };
  }, Dt.prototype.paintOn = function(w, A) {
    var O = this.displayed_[this.row_].text;
    O += A, this.displayed_[this.row_].text = O;
  };
  var U0 = {
    CaptionStream: Ut,
    Cea608Stream: Dt,
    Cea708Stream: lt
  }, Eo = {
    H264_STREAM_TYPE: 27,
    ADTS_STREAM_TYPE: 15,
    METADATA_STREAM_TYPE: 21
  }, lC = t, dC = 8589934592, fC = 4294967296, R0 = "shared", kl = function(w, A) {
    var O = 1;
    for (w > A && (O = -1); Math.abs(A - w) > fC; )
      w += O * dC;
    return w;
  }, Il = function(w) {
    var A, O;
    Il.prototype.init.call(this), this.type_ = w || R0, this.push = function(R) {
      if (R.type === "metadata") {
        this.trigger("data", R);
        return;
      }
      this.type_ !== R0 && R.type !== this.type_ || (O === void 0 && (O = R.dts), R.dts = kl(R.dts, O), R.pts = kl(R.pts, O), A = R.dts, this.trigger("data", R));
    }, this.flush = function() {
      O = A, this.trigger("done");
    }, this.endTimeline = function() {
      this.flush(), this.trigger("endedtimeline");
    }, this.discontinuity = function() {
      O = void 0, A = void 0;
    }, this.reset = function() {
      this.discontinuity(), this.trigger("reset");
    };
  };
  Il.prototype = new lC();
  var O0 = {
    TimestampRolloverStream: Il,
    handleRollover: kl
  }, hC = (w, A, O) => {
    if (!w)
      return -1;
    for (var R = O; R < w.length; R++)
      if (w[R] === A)
        return R;
    return -1;
  }, pC = {
    typedArrayIndexOf: hC
  }, Do = pC.typedArrayIndexOf, So = {
    // UTF-16BE encoded Unicode, without BOM, terminated with \0\0
    Utf8: 3
    // UTF-8 encoded Unicode, terminated with \0
  }, L0 = function(w, A, O) {
    var R, V = "";
    for (R = A; R < O; R++)
      V += "%" + ("00" + w[R].toString(16)).slice(-2);
    return V;
  }, Wa = function(w, A, O) {
    return decodeURIComponent(L0(w, A, O));
  }, Va = function(w, A, O) {
    return unescape(L0(w, A, O));
  }, Ha = function(w) {
    return w[0] << 21 | w[1] << 14 | w[2] << 7 | w[3];
  }, za = {
    APIC: function(w) {
      var A = 1, O, R, V = "-->";
      w.data[0] === So.Utf8 && (O = Do(w.data, 0, A), !(O < 0) && (w.mimeType = Va(w.data, A, O), A = O + 1, w.pictureType = w.data[A], A++, R = Do(w.data, 0, A), !(R < 0) && (w.description = Wa(w.data, A, R), A = R + 1, w.mimeType === V ? w.url = Va(w.data, A, w.data.length) : w.pictureData = w.data.subarray(A, w.data.length))));
    },
    "T*": function(w) {
      w.data[0] === So.Utf8 && (w.value = Wa(w.data, 1, w.data.length).replace(/\0*$/, ""), w.values = w.value.split("\0"));
    },
    TXXX: function(w) {
      var A;
      w.data[0] === So.Utf8 && (A = Do(w.data, 0, 1), A !== -1 && (w.description = Wa(w.data, 1, A), w.value = Wa(w.data, A + 1, w.data.length).replace(/\0*$/, ""), w.data = w.value));
    },
    "W*": function(w) {
      w.url = Va(w.data, 0, w.data.length).replace(/\0.*$/, "");
    },
    WXXX: function(w) {
      var A;
      w.data[0] === So.Utf8 && (A = Do(w.data, 0, 1), A !== -1 && (w.description = Wa(w.data, 1, A), w.url = Va(w.data, A + 1, w.data.length).replace(/\0.*$/, "")));
    },
    PRIV: function(w) {
      var A;
      for (A = 0; A < w.data.length; A++)
        if (w.data[A] === 0) {
          w.owner = Va(w.data, 0, A);
          break;
        }
      w.privateData = w.data.subarray(A + 1), w.data = w.privateData;
    }
  }, mC = function(w) {
    var A, O, R = 10, V = 0, X = [];
    if (!(w.length < 10 || w[0] !== 73 || w[1] !== 68 || w[2] !== 51)) {
      V = Ha(w.subarray(6, 10)), V += 10;
      var re = w[5] & 64;
      re && (R += 4, R += Ha(w.subarray(10, 14)), V -= Ha(w.subarray(16, 20)));
      do {
        if (A = Ha(w.subarray(R + 4, R + 8)), A < 1)
          break;
        O = String.fromCharCode(w[R], w[R + 1], w[R + 2], w[R + 3]);
        var ue = {
          id: O,
          data: w.subarray(R + 10, R + A + 10)
        };
        ue.key = ue.id, za[ue.id] ? za[ue.id](ue) : ue.id[0] === "T" ? za["T*"](ue) : ue.id[0] === "W" && za["W*"](ue), X.push(ue), R += 10, R += A;
      } while (R < V);
      return X;
    }
  }, P0 = {
    parseId3Frames: mC,
    parseSyncSafeInteger: Ha,
    frameParsers: za
  }, gC = t, bC = Eo, ji = P0, Co;
  Co = function(w) {
    var A = {
      // the bytes of the program-level descriptor field in MP2T
      // see ISO/IEC 13818-1:2013 (E), section 2.6 "Program and
      // program element descriptors"
      descriptor: w && w.descriptor
    }, O = 0, R = [], V = 0, X;
    if (Co.prototype.init.call(this), this.dispatchType = bC.METADATA_STREAM_TYPE.toString(16), A.descriptor)
      for (X = 0; X < A.descriptor.length; X++)
        this.dispatchType += ("00" + A.descriptor[X].toString(16)).slice(-2);
    this.push = function(re) {
      var ue, be, _e, Ae, Oe, We;
      if (re.type === "timed-metadata") {
        if (re.dataAlignmentIndicator && (V = 0, R.length = 0), R.length === 0 && (re.data.length < 10 || re.data[0] !== 73 || re.data[1] !== 68 || re.data[2] !== 51)) {
          this.trigger("log", {
            level: "warn",
            message: "Skipping unrecognized metadata packet"
          });
          return;
        }
        if (R.push(re), V += re.data.byteLength, R.length === 1 && (O = ji.parseSyncSafeInteger(re.data.subarray(6, 10)), O += 10), !(V < O)) {
          for (ue = {
            data: new Uint8Array(O),
            frames: [],
            pts: R[0].pts,
            dts: R[0].dts
          }, Oe = 0; Oe < O; )
            ue.data.set(R[0].data.subarray(0, O - Oe), Oe), Oe += R[0].data.byteLength, V -= R[0].data.byteLength, R.shift();
          be = 10, ue.data[5] & 64 && (be += 4, be += ji.parseSyncSafeInteger(ue.data.subarray(10, 14)), O -= ji.parseSyncSafeInteger(ue.data.subarray(16, 20)));
          do {
            if (_e = ji.parseSyncSafeInteger(ue.data.subarray(be + 4, be + 8)), _e < 1) {
              this.trigger("log", {
                level: "warn",
                message: "Malformed ID3 frame encountered. Skipping remaining metadata parsing."
              });
              break;
            }
            if (We = String.fromCharCode(ue.data[be], ue.data[be + 1], ue.data[be + 2], ue.data[be + 3]), Ae = {
              id: We,
              data: ue.data.subarray(be + 10, be + _e + 10)
            }, Ae.key = Ae.id, ji.frameParsers[Ae.id] ? ji.frameParsers[Ae.id](Ae) : Ae.id[0] === "T" ? ji.frameParsers["T*"](Ae) : Ae.id[0] === "W" && ji.frameParsers["W*"](Ae), Ae.owner === "com.apple.streaming.transportStreamTimestamp") {
              var Fe = Ae.data, Xe = (Fe[3] & 1) << 30 | Fe[4] << 22 | Fe[5] << 14 | Fe[6] << 6 | Fe[7] >>> 2;
              Xe *= 4, Xe += Fe[7] & 3, Ae.timeStamp = Xe, ue.pts === void 0 && ue.dts === void 0 && (ue.pts = Ae.timeStamp, ue.dts = Ae.timeStamp), this.trigger("timestamp", Ae);
            }
            ue.frames.push(Ae), be += 10, be += _e;
          } while (be < O);
          this.trigger("data", ue);
        }
      }
    };
  }, Co.prototype = new gC();
  var yC = Co, Ul = t, Rl = U0, Vn = Eo, vC = O0.TimestampRolloverStream, Ao, $a, ko, Gr = 188, Ol = 71;
  Ao = function() {
    var w = new Uint8Array(Gr), A = 0;
    Ao.prototype.init.call(this), this.push = function(O) {
      var R = 0, V = Gr, X;
      for (A ? (X = new Uint8Array(O.byteLength + A), X.set(w.subarray(0, A)), X.set(O, A), A = 0) : X = O; V < X.byteLength; ) {
        if (X[R] === Ol && X[V] === Ol) {
          this.trigger("data", X.subarray(R, V)), R += Gr, V += Gr;
          continue;
        }
        R++, V++;
      }
      R < X.byteLength && (w.set(X.subarray(R), 0), A = X.byteLength - R);
    }, this.flush = function() {
      A === Gr && w[0] === Ol && (this.trigger("data", w), A = 0), this.trigger("done");
    }, this.endTimeline = function() {
      this.flush(), this.trigger("endedtimeline");
    }, this.reset = function() {
      A = 0, this.trigger("reset");
    };
  }, Ao.prototype = new Ul(), $a = function() {
    var w, A, O, R;
    $a.prototype.init.call(this), R = this, this.packetsWaitingForPmt = [], this.programMapTable = void 0, w = function(V, X) {
      var re = 0;
      X.payloadUnitStartIndicator && (re += V[re] + 1), X.type === "pat" ? A(V.subarray(re), X) : O(V.subarray(re), X);
    }, A = function(V, X) {
      X.section_number = V[7], X.last_section_number = V[8], R.pmtPid = (V[10] & 31) << 8 | V[11], X.pmtPid = R.pmtPid;
    }, O = function(V, X) {
      var re, ue, be, _e;
      if (V[5] & 1) {
        for (R.programMapTable = {
          video: null,
          audio: null,
          "timed-metadata": {}
        }, re = (V[1] & 15) << 8 | V[2], ue = 3 + re - 4, be = (V[10] & 15) << 8 | V[11], _e = 12 + be; _e < ue; ) {
          var Ae = V[_e], Oe = (V[_e + 1] & 31) << 8 | V[_e + 2];
          Ae === Vn.H264_STREAM_TYPE && R.programMapTable.video === null ? R.programMapTable.video = Oe : Ae === Vn.ADTS_STREAM_TYPE && R.programMapTable.audio === null ? R.programMapTable.audio = Oe : Ae === Vn.METADATA_STREAM_TYPE && (R.programMapTable["timed-metadata"][Oe] = Ae), _e += ((V[_e + 3] & 15) << 8 | V[_e + 4]) + 5;
        }
        X.programMapTable = R.programMapTable;
      }
    }, this.push = function(V) {
      var X = {}, re = 4;
      if (X.payloadUnitStartIndicator = !!(V[1] & 64), X.pid = V[1] & 31, X.pid <<= 8, X.pid |= V[2], (V[3] & 48) >>> 4 > 1 && (re += V[re] + 1), X.pid === 0)
        X.type = "pat", w(V.subarray(re), X), this.trigger("data", X);
      else if (X.pid === this.pmtPid)
        for (X.type = "pmt", w(V.subarray(re), X), this.trigger("data", X); this.packetsWaitingForPmt.length; )
          this.processPes_.apply(this, this.packetsWaitingForPmt.shift());
      else this.programMapTable === void 0 ? this.packetsWaitingForPmt.push([V, re, X]) : this.processPes_(V, re, X);
    }, this.processPes_ = function(V, X, re) {
      re.pid === this.programMapTable.video ? re.streamType = Vn.H264_STREAM_TYPE : re.pid === this.programMapTable.audio ? re.streamType = Vn.ADTS_STREAM_TYPE : re.streamType = this.programMapTable["timed-metadata"][re.pid], re.type = "pes", re.data = V.subarray(X), this.trigger("data", re);
    };
  }, $a.prototype = new Ul(), $a.STREAM_TYPES = {
    h264: 27,
    adts: 15
  }, ko = function() {
    var w = this, A = !1, O = {
      data: [],
      size: 0
    }, R = {
      data: [],
      size: 0
    }, V = {
      data: [],
      size: 0
    }, X, re = function(be, _e) {
      var Ae;
      const Oe = be[0] << 16 | be[1] << 8 | be[2];
      _e.data = new Uint8Array(), Oe === 1 && (_e.packetLength = 6 + (be[4] << 8 | be[5]), _e.dataAlignmentIndicator = (be[6] & 4) !== 0, Ae = be[7], Ae & 192 && (_e.pts = (be[9] & 14) << 27 | (be[10] & 255) << 20 | (be[11] & 254) << 12 | (be[12] & 255) << 5 | (be[13] & 254) >>> 3, _e.pts *= 4, _e.pts += (be[13] & 6) >>> 1, _e.dts = _e.pts, Ae & 64 && (_e.dts = (be[14] & 14) << 27 | (be[15] & 255) << 20 | (be[16] & 254) << 12 | (be[17] & 255) << 5 | (be[18] & 254) >>> 3, _e.dts *= 4, _e.dts += (be[18] & 6) >>> 1)), _e.data = be.subarray(9 + be[8]));
    }, ue = function(be, _e, Ae) {
      var Oe = new Uint8Array(be.size), We = {
        type: _e
      }, Fe = 0, Xe = 0, nt = !1, jt;
      if (!(!be.data.length || be.size < 9)) {
        for (We.trackId = be.data[0].pid, Fe = 0; Fe < be.data.length; Fe++)
          jt = be.data[Fe], Oe.set(jt.data, Xe), Xe += jt.data.byteLength;
        re(Oe, We), nt = _e === "video" || We.packetLength <= be.size, (Ae || nt) && (be.size = 0, be.data.length = 0), nt && w.trigger("data", We);
      }
    };
    ko.prototype.init.call(this), this.push = function(be) {
      ({
        pat: function() {
        },
        pes: function() {
          var _e, Ae;
          switch (be.streamType) {
            case Vn.H264_STREAM_TYPE:
              _e = O, Ae = "video";
              break;
            case Vn.ADTS_STREAM_TYPE:
              _e = R, Ae = "audio";
              break;
            case Vn.METADATA_STREAM_TYPE:
              _e = V, Ae = "timed-metadata";
              break;
            default:
              return;
          }
          be.payloadUnitStartIndicator && ue(_e, Ae, !0), _e.data.push(be), _e.size += be.data.byteLength;
        },
        pmt: function() {
          var _e = {
            type: "metadata",
            tracks: []
          };
          X = be.programMapTable, X.video !== null && _e.tracks.push({
            timelineStartInfo: {
              baseMediaDecodeTime: 0
            },
            id: +X.video,
            codec: "avc",
            type: "video"
          }), X.audio !== null && _e.tracks.push({
            timelineStartInfo: {
              baseMediaDecodeTime: 0
            },
            id: +X.audio,
            codec: "adts",
            type: "audio"
          }), A = !0, w.trigger("data", _e);
        }
      })[be.type]();
    }, this.reset = function() {
      O.size = 0, O.data.length = 0, R.size = 0, R.data.length = 0, this.trigger("reset");
    }, this.flushStreams_ = function() {
      ue(O, "video"), ue(R, "audio"), ue(V, "timed-metadata");
    }, this.flush = function() {
      if (!A && X) {
        var be = {
          type: "metadata",
          tracks: []
        };
        X.video !== null && be.tracks.push({
          timelineStartInfo: {
            baseMediaDecodeTime: 0
          },
          id: +X.video,
          codec: "avc",
          type: "video"
        }), X.audio !== null && be.tracks.push({
          timelineStartInfo: {
            baseMediaDecodeTime: 0
          },
          id: +X.audio,
          codec: "adts",
          type: "audio"
        }), w.trigger("data", be);
      }
      A = !1, this.flushStreams_(), this.trigger("done");
    };
  }, ko.prototype = new Ul();
  var F0 = {
    PAT_PID: 0,
    MP2T_PACKET_LENGTH: Gr,
    TransportPacketStream: Ao,
    TransportParseStream: $a,
    ElementaryStream: ko,
    TimestampRolloverStream: vC,
    CaptionStream: Rl.CaptionStream,
    Cea608Stream: Rl.Cea608Stream,
    Cea708Stream: Rl.Cea708Stream,
    MetadataStream: yC
  };
  for (var Ll in Vn)
    Vn.hasOwnProperty(Ll) && (F0[Ll] = Vn[Ll]);
  var xC = F0, _C = t, TC = Te.ONE_SECOND_IN_TS, Io, N0 = [96e3, 88200, 64e3, 48e3, 44100, 32e3, 24e3, 22050, 16e3, 12e3, 11025, 8e3, 7350];
  Io = function(w) {
    var A, O = 0;
    Io.prototype.init.call(this), this.skipWarn_ = function(R, V) {
      this.trigger("log", {
        level: "warn",
        message: `adts skiping bytes ${R} to ${V} in frame ${O} outside syncword`
      });
    }, this.push = function(R) {
      var V = 0, X, re, ue, be, _e;
      if (w || (O = 0), R.type === "audio") {
        A && A.length ? (ue = A, A = new Uint8Array(ue.byteLength + R.data.byteLength), A.set(ue), A.set(R.data, ue.byteLength)) : A = R.data;
        for (var Ae; V + 7 < A.length; ) {
          if (A[V] !== 255 || (A[V + 1] & 246) !== 240) {
            typeof Ae != "number" && (Ae = V), V++;
            continue;
          }
          if (typeof Ae == "number" && (this.skipWarn_(Ae, V), Ae = null), re = (~A[V + 1] & 1) * 2, X = (A[V + 3] & 3) << 11 | A[V + 4] << 3 | (A[V + 5] & 224) >> 5, be = ((A[V + 6] & 3) + 1) * 1024, _e = be * TC / N0[(A[V + 2] & 60) >>> 2], A.byteLength - V < X)
            break;
          this.trigger("data", {
            pts: R.pts + O * _e,
            dts: R.dts + O * _e,
            sampleCount: be,
            audioobjecttype: (A[V + 2] >>> 6 & 3) + 1,
            channelcount: (A[V + 2] & 1) << 2 | (A[V + 3] & 192) >>> 6,
            samplerate: N0[(A[V + 2] & 60) >>> 2],
            samplingfrequencyindex: (A[V + 2] & 60) >>> 2,
            // assume ISO/IEC 14496-12 AudioSampleEntry default of 16
            samplesize: 16,
            // data is the frame without it's header
            data: A.subarray(V + 7 + re, V + X)
          }), O++, V += X;
        }
        typeof Ae == "number" && (this.skipWarn_(Ae, V), Ae = null), A = A.subarray(V);
      }
    }, this.flush = function() {
      O = 0, this.trigger("done");
    }, this.reset = function() {
      A = void 0, this.trigger("reset");
    }, this.endTimeline = function() {
      A = void 0, this.trigger("endedtimeline");
    };
  }, Io.prototype = new _C();
  var wC = Io, M0;
  M0 = function(w) {
    var A = w.byteLength, O = 0, R = 0;
    this.length = function() {
      return 8 * A;
    }, this.bitsAvailable = function() {
      return 8 * A + R;
    }, this.loadWord = function() {
      var V = w.byteLength - A, X = new Uint8Array(4), re = Math.min(4, A);
      if (re === 0)
        throw new Error("no bytes available");
      X.set(w.subarray(V, V + re)), O = new DataView(X.buffer).getUint32(0), R = re * 8, A -= re;
    }, this.skipBits = function(V) {
      var X;
      R > V ? (O <<= V, R -= V) : (V -= R, X = Math.floor(V / 8), V -= X * 8, A -= X, this.loadWord(), O <<= V, R -= V);
    }, this.readBits = function(V) {
      var X = Math.min(R, V), re = O >>> 32 - X;
      return R -= X, R > 0 ? O <<= X : A > 0 && this.loadWord(), X = V - X, X > 0 ? re << X | this.readBits(X) : re;
    }, this.skipLeadingZeros = function() {
      var V;
      for (V = 0; V < R; ++V)
        if ((O & 2147483648 >>> V) !== 0)
          return O <<= V, R -= V, V;
      return this.loadWord(), V + this.skipLeadingZeros();
    }, this.skipUnsignedExpGolomb = function() {
      this.skipBits(1 + this.skipLeadingZeros());
    }, this.skipExpGolomb = function() {
      this.skipBits(1 + this.skipLeadingZeros());
    }, this.readUnsignedExpGolomb = function() {
      var V = this.skipLeadingZeros();
      return this.readBits(V + 1) - 1;
    }, this.readExpGolomb = function() {
      var V = this.readUnsignedExpGolomb();
      return 1 & V ? 1 + V >>> 1 : -1 * (V >>> 1);
    }, this.readBoolean = function() {
      return this.readBits(1) === 1;
    }, this.readUnsignedByte = function() {
      return this.readBits(8);
    }, this.loadWord();
  };
  var EC = M0, B0 = t, DC = EC, Uo, Ro, j0;
  Ro = function() {
    var w = 0, A, O;
    Ro.prototype.init.call(this), this.push = function(R) {
      var V;
      O ? (V = new Uint8Array(O.byteLength + R.data.byteLength), V.set(O), V.set(R.data, O.byteLength), O = V) : O = R.data;
      for (var X = O.byteLength; w < X - 3; w++)
        if (O[w + 2] === 1) {
          A = w + 5;
          break;
        }
      for (; A < X; )
        switch (O[A]) {
          case 0:
            if (O[A - 1] !== 0) {
              A += 2;
              break;
            } else if (O[A - 2] !== 0) {
              A++;
              break;
            }
            w + 3 !== A - 2 && this.trigger("data", O.subarray(w + 3, A - 2));
            do
              A++;
            while (O[A] !== 1 && A < X);
            w = A - 2, A += 3;
            break;
          case 1:
            if (O[A - 1] !== 0 || O[A - 2] !== 0) {
              A += 3;
              break;
            }
            this.trigger("data", O.subarray(w + 3, A - 2)), w = A - 2, A += 3;
            break;
          default:
            A += 3;
            break;
        }
      O = O.subarray(w), A -= w, w = 0;
    }, this.reset = function() {
      O = null, w = 0, this.trigger("reset");
    }, this.flush = function() {
      O && O.byteLength > 3 && this.trigger("data", O.subarray(w + 3)), O = null, w = 0, this.trigger("done");
    }, this.endTimeline = function() {
      this.flush(), this.trigger("endedtimeline");
    };
  }, Ro.prototype = new B0(), j0 = {
    100: !0,
    110: !0,
    122: !0,
    244: !0,
    44: !0,
    83: !0,
    86: !0,
    118: !0,
    128: !0,
    // TODO: the three profiles below don't
    // appear to have sps data in the specificiation anymore?
    138: !0,
    139: !0,
    134: !0
  }, Uo = function() {
    var w = new Ro(), A, O, R, V, X, re, ue;
    Uo.prototype.init.call(this), A = this, this.push = function(be) {
      be.type === "video" && (O = be.trackId, R = be.pts, V = be.dts, w.push(be));
    }, w.on("data", function(be) {
      var _e = {
        trackId: O,
        pts: R,
        dts: V,
        data: be,
        nalUnitTypeCode: be[0] & 31
      };
      switch (_e.nalUnitTypeCode) {
        case 5:
          _e.nalUnitType = "slice_layer_without_partitioning_rbsp_idr";
          break;
        case 6:
          _e.nalUnitType = "sei_rbsp", _e.escapedRBSP = X(be.subarray(1));
          break;
        case 7:
          _e.nalUnitType = "seq_parameter_set_rbsp", _e.escapedRBSP = X(be.subarray(1)), _e.config = re(_e.escapedRBSP);
          break;
        case 8:
          _e.nalUnitType = "pic_parameter_set_rbsp";
          break;
        case 9:
          _e.nalUnitType = "access_unit_delimiter_rbsp";
          break;
      }
      A.trigger("data", _e);
    }), w.on("done", function() {
      A.trigger("done");
    }), w.on("partialdone", function() {
      A.trigger("partialdone");
    }), w.on("reset", function() {
      A.trigger("reset");
    }), w.on("endedtimeline", function() {
      A.trigger("endedtimeline");
    }), this.flush = function() {
      w.flush();
    }, this.partialFlush = function() {
      w.partialFlush();
    }, this.reset = function() {
      w.reset();
    }, this.endTimeline = function() {
      w.endTimeline();
    }, ue = function(be, _e) {
      var Ae = 8, Oe = 8, We, Fe;
      for (We = 0; We < be; We++)
        Oe !== 0 && (Fe = _e.readExpGolomb(), Oe = (Ae + Fe + 256) % 256), Ae = Oe === 0 ? Ae : Oe;
    }, X = function(be) {
      for (var _e = be.byteLength, Ae = [], Oe = 1, We, Fe; Oe < _e - 2; )
        be[Oe] === 0 && be[Oe + 1] === 0 && be[Oe + 2] === 3 ? (Ae.push(Oe + 2), Oe += 2) : Oe++;
      if (Ae.length === 0)
        return be;
      We = _e - Ae.length, Fe = new Uint8Array(We);
      var Xe = 0;
      for (Oe = 0; Oe < We; Xe++, Oe++)
        Xe === Ae[0] && (Xe++, Ae.shift()), Fe[Oe] = be[Xe];
      return Fe;
    }, re = function(be) {
      var _e = 0, Ae = 0, Oe = 0, We = 0, Fe, Xe, nt, jt, vn, Wi, Ja, es, ts, ns, Ho, wt = [1, 1], is, zn;
      if (Fe = new DC(be), Xe = Fe.readUnsignedByte(), jt = Fe.readUnsignedByte(), nt = Fe.readUnsignedByte(), Fe.skipUnsignedExpGolomb(), j0[Xe] && (vn = Fe.readUnsignedExpGolomb(), vn === 3 && Fe.skipBits(1), Fe.skipUnsignedExpGolomb(), Fe.skipUnsignedExpGolomb(), Fe.skipBits(1), Fe.readBoolean()))
        for (Ho = vn !== 3 ? 8 : 12, zn = 0; zn < Ho; zn++)
          Fe.readBoolean() && (zn < 6 ? ue(16, Fe) : ue(64, Fe));
      if (Fe.skipUnsignedExpGolomb(), Wi = Fe.readUnsignedExpGolomb(), Wi === 0)
        Fe.readUnsignedExpGolomb();
      else if (Wi === 1)
        for (Fe.skipBits(1), Fe.skipExpGolomb(), Fe.skipExpGolomb(), Ja = Fe.readUnsignedExpGolomb(), zn = 0; zn < Ja; zn++)
          Fe.skipExpGolomb();
      if (Fe.skipUnsignedExpGolomb(), Fe.skipBits(1), es = Fe.readUnsignedExpGolomb(), ts = Fe.readUnsignedExpGolomb(), ns = Fe.readBits(1), ns === 0 && Fe.skipBits(1), Fe.skipBits(1), Fe.readBoolean() && (_e = Fe.readUnsignedExpGolomb(), Ae = Fe.readUnsignedExpGolomb(), Oe = Fe.readUnsignedExpGolomb(), We = Fe.readUnsignedExpGolomb()), Fe.readBoolean() && Fe.readBoolean()) {
        switch (is = Fe.readUnsignedByte(), is) {
          case 1:
            wt = [1, 1];
            break;
          case 2:
            wt = [12, 11];
            break;
          case 3:
            wt = [10, 11];
            break;
          case 4:
            wt = [16, 11];
            break;
          case 5:
            wt = [40, 33];
            break;
          case 6:
            wt = [24, 11];
            break;
          case 7:
            wt = [20, 11];
            break;
          case 8:
            wt = [32, 11];
            break;
          case 9:
            wt = [80, 33];
            break;
          case 10:
            wt = [18, 11];
            break;
          case 11:
            wt = [15, 11];
            break;
          case 12:
            wt = [64, 33];
            break;
          case 13:
            wt = [160, 99];
            break;
          case 14:
            wt = [4, 3];
            break;
          case 15:
            wt = [3, 2];
            break;
          case 16:
            wt = [2, 1];
            break;
          case 255: {
            wt = [Fe.readUnsignedByte() << 8 | Fe.readUnsignedByte(), Fe.readUnsignedByte() << 8 | Fe.readUnsignedByte()];
            break;
          }
        }
        wt && wt[0] / wt[1];
      }
      return {
        profileIdc: Xe,
        levelIdc: nt,
        profileCompatibility: jt,
        width: (es + 1) * 16 - _e * 2 - Ae * 2,
        height: (2 - ns) * (ts + 1) * 16 - Oe * 2 - We * 2,
        // sar is sample aspect ratio
        sarRatio: wt
      };
    };
  }, Uo.prototype = new B0();
  var SC = {
    H264Stream: Uo
  }, CC = [96e3, 88200, 64e3, 48e3, 44100, 32e3, 24e3, 22050, 16e3, 12e3, 11025, 8e3, 7350], q0 = function(w, A) {
    var O = w[A + 6] << 21 | w[A + 7] << 14 | w[A + 8] << 7 | w[A + 9], R = w[A + 5], V = (R & 16) >> 4;
    return O = O >= 0 ? O : 0, V ? O + 20 : O + 10;
  }, W0 = function(w, A) {
    return w.length - A < 10 || w[A] !== 73 || w[A + 1] !== 68 || w[A + 2] !== 51 ? A : (A += q0(w, A), W0(w, A));
  }, AC = function(w) {
    var A = W0(w, 0);
    return w.length >= A + 2 && (w[A] & 255) === 255 && (w[A + 1] & 240) === 240 && // verify that the 2 layer bits are 0, aka this
    // is not mp3 data but aac data.
    (w[A + 1] & 22) === 16;
  }, V0 = function(w) {
    return w[0] << 21 | w[1] << 14 | w[2] << 7 | w[3];
  }, kC = function(w, A, O) {
    var R, V = "";
    for (R = A; R < O; R++)
      V += "%" + ("00" + w[R].toString(16)).slice(-2);
    return V;
  }, IC = function(w, A, O) {
    return unescape(kC(w, A, O));
  }, UC = function(w, A) {
    var O = (w[A + 5] & 224) >> 5, R = w[A + 4] << 3, V = w[A + 3] & 6144;
    return V | R | O;
  }, RC = function(w, A) {
    return w[A] === 73 && w[A + 1] === 68 && w[A + 2] === 51 ? "timed-metadata" : w[A] & !0 && (w[A + 1] & 240) === 240 ? "audio" : null;
  }, OC = function(w) {
    for (var A = 0; A + 5 < w.length; ) {
      if (w[A] !== 255 || (w[A + 1] & 246) !== 240) {
        A++;
        continue;
      }
      return CC[(w[A + 2] & 60) >>> 2];
    }
    return null;
  }, LC = function(w) {
    var A, O, R, V;
    A = 10, w[5] & 64 && (A += 4, A += V0(w.subarray(10, 14)));
    do {
      if (O = V0(w.subarray(A + 4, A + 8)), O < 1)
        return null;
      if (V = String.fromCharCode(w[A], w[A + 1], w[A + 2], w[A + 3]), V === "PRIV") {
        R = w.subarray(A + 10, A + O + 10);
        for (var X = 0; X < R.byteLength; X++)
          if (R[X] === 0) {
            var re = IC(R, 0, X);
            if (re === "com.apple.streaming.transportStreamTimestamp") {
              var ue = R.subarray(X + 1), be = (ue[3] & 1) << 30 | ue[4] << 22 | ue[5] << 14 | ue[6] << 6 | ue[7] >>> 2;
              return be *= 4, be += ue[7] & 3, be;
            }
            break;
          }
      }
      A += 10, A += O;
    } while (A < w.byteLength);
    return null;
  }, Pl = {
    isLikelyAacData: AC,
    parseId3TagSize: q0,
    parseAdtsSize: UC,
    parseType: RC,
    parseSampleRate: OC,
    parseAacTimestamp: LC
  }, PC = t, H0 = Pl, Oo;
  Oo = function() {
    var w = new Uint8Array(), A = 0;
    Oo.prototype.init.call(this), this.setTimestamp = function(O) {
      A = O;
    }, this.push = function(O) {
      var R = 0, V = 0, X, re, ue, be;
      for (w.length ? (be = w.length, w = new Uint8Array(O.byteLength + be), w.set(w.subarray(0, be)), w.set(O, be)) : w = O; w.length - V >= 3; ) {
        if (w[V] === 73 && w[V + 1] === 68 && w[V + 2] === 51) {
          if (w.length - V < 10 || (R = H0.parseId3TagSize(w, V), V + R > w.length))
            break;
          re = {
            type: "timed-metadata",
            data: w.subarray(V, V + R)
          }, this.trigger("data", re), V += R;
          continue;
        } else if ((w[V] & 255) === 255 && (w[V + 1] & 240) === 240) {
          if (w.length - V < 7 || (R = H0.parseAdtsSize(w, V), V + R > w.length))
            break;
          ue = {
            type: "audio",
            data: w.subarray(V, V + R),
            pts: A,
            dts: A
          }, this.trigger("data", ue), V += R;
          continue;
        }
        V++;
      }
      X = w.length - V, X > 0 ? w = w.subarray(V) : w = new Uint8Array();
    }, this.reset = function() {
      w = new Uint8Array(), this.trigger("reset");
    }, this.endTimeline = function() {
      w = new Uint8Array(), this.trigger("endedtimeline");
    };
  }, Oo.prototype = new PC();
  var FC = Oo, NC = ["audioobjecttype", "channelcount", "samplerate", "samplingfrequencyindex", "samplesize"], MC = NC, BC = ["width", "height", "profileIdc", "levelIdc", "profileCompatibility", "sarRatio"], jC = BC, Lo = t, Ga = oe, Xa = te, Po = oi, Hn = Ce, Ei = xC, Fo = Te, z0 = wC, qC = SC.H264Stream, WC = FC, VC = Pl.isLikelyAacData, HC = Te.ONE_SECOND_IN_TS, $0 = MC, G0 = jC, No, Ka, Mo, hr, zC = function(w, A) {
    A.stream = w, this.trigger("log", A);
  }, X0 = function(w, A) {
    for (var O = Object.keys(A), R = 0; R < O.length; R++) {
      var V = O[R];
      V === "headOfPipeline" || !A[V].on || A[V].on("log", zC.bind(w, V));
    }
  }, K0 = function(w, A) {
    var O;
    if (w.length !== A.length)
      return !1;
    for (O = 0; O < w.length; O++)
      if (w[O] !== A[O])
        return !1;
    return !0;
  }, Y0 = function(w, A, O, R, V, X) {
    var re = O - A, ue = R - A, be = V - O;
    return {
      start: {
        dts: w,
        pts: w + re
      },
      end: {
        dts: w + ue,
        pts: w + be
      },
      prependedContentDuration: X,
      baseMediaDecodeTime: w
    };
  };
  Ka = function(w, A) {
    var O = [], R, V = 0, X = 0, re = 1 / 0;
    A = A || {}, R = A.firstSequenceNumber || 0, Ka.prototype.init.call(this), this.push = function(ue) {
      Hn.collectDtsInfo(w, ue), w && $0.forEach(function(be) {
        w[be] = ue[be];
      }), O.push(ue);
    }, this.setEarliestDts = function(ue) {
      V = ue;
    }, this.setVideoBaseMediaDecodeTime = function(ue) {
      re = ue;
    }, this.setAudioAppendStart = function(ue) {
      X = ue;
    }, this.flush = function() {
      var ue, be, _e, Ae, Oe, We, Fe;
      if (O.length === 0) {
        this.trigger("done", "AudioSegmentStream");
        return;
      }
      ue = Po.trimAdtsFramesByEarliestDts(O, w, V), w.baseMediaDecodeTime = Hn.calculateTrackBaseMediaDecodeTime(w, A.keepOriginalTimestamps), Fe = Po.prefixWithSilence(w, ue, X, re), w.samples = Po.generateSampleTable(ue), _e = Ga.mdat(Po.concatenateFrameData(ue)), O = [], be = Ga.moof(R, [w]), Ae = new Uint8Array(be.byteLength + _e.byteLength), R++, Ae.set(be), Ae.set(_e, be.byteLength), Hn.clearDtsInfo(w), Oe = Math.ceil(HC * 1024 / w.samplerate), ue.length && (We = ue.length * Oe, this.trigger("segmentTimingInfo", Y0(
        // The audio track's baseMediaDecodeTime is in audio clock cycles, but the
        // frame info is in video clock cycles. Convert to match expectation of
        // listeners (that all timestamps will be based on video clock cycles).
        Fo.audioTsToVideoTs(w.baseMediaDecodeTime, w.samplerate),
        // frame times are already in video clock, as is segment duration
        ue[0].dts,
        ue[0].pts,
        ue[0].dts + We,
        ue[0].pts + We,
        Fe || 0
      )), this.trigger("timingInfo", {
        start: ue[0].pts,
        end: ue[0].pts + We
      })), this.trigger("data", {
        track: w,
        boxes: Ae
      }), this.trigger("done", "AudioSegmentStream");
    }, this.reset = function() {
      Hn.clearDtsInfo(w), O = [], this.trigger("reset");
    };
  }, Ka.prototype = new Lo(), No = function(w, A) {
    var O, R = [], V = [], X, re;
    A = A || {}, O = A.firstSequenceNumber || 0, No.prototype.init.call(this), delete w.minPTS, this.gopCache_ = [], this.push = function(ue) {
      Hn.collectDtsInfo(w, ue), ue.nalUnitType === "seq_parameter_set_rbsp" && !X && (X = ue.config, w.sps = [ue.data], G0.forEach(function(be) {
        w[be] = X[be];
      }, this)), ue.nalUnitType === "pic_parameter_set_rbsp" && !re && (re = ue.data, w.pps = [ue.data]), R.push(ue);
    }, this.flush = function() {
      for (var ue, be, _e, Ae, Oe, We, Fe = 0, Xe, nt; R.length && R[0].nalUnitType !== "access_unit_delimiter_rbsp"; )
        R.shift();
      if (R.length === 0) {
        this.resetStream_(), this.trigger("done", "VideoSegmentStream");
        return;
      }
      if (ue = Xa.groupNalsIntoFrames(R), _e = Xa.groupFramesIntoGops(ue), _e[0][0].keyFrame || (be = this.getGopForFusion_(R[0], w), be ? (Fe = be.duration, _e.unshift(be), _e.byteLength += be.byteLength, _e.nalCount += be.nalCount, _e.pts = be.pts, _e.dts = be.dts, _e.duration += be.duration) : _e = Xa.extendFirstKeyFrame(_e)), V.length) {
        var jt;
        if (A.alignGopsAtEnd ? jt = this.alignGopsAtEnd_(_e) : jt = this.alignGopsAtStart_(_e), !jt) {
          this.gopCache_.unshift({
            gop: _e.pop(),
            pps: w.pps,
            sps: w.sps
          }), this.gopCache_.length = Math.min(6, this.gopCache_.length), R = [], this.resetStream_(), this.trigger("done", "VideoSegmentStream");
          return;
        }
        Hn.clearDtsInfo(w), _e = jt;
      }
      Hn.collectDtsInfo(w, _e), w.samples = Xa.generateSampleTable(_e), Oe = Ga.mdat(Xa.concatenateNalData(_e)), w.baseMediaDecodeTime = Hn.calculateTrackBaseMediaDecodeTime(w, A.keepOriginalTimestamps), this.trigger("processedGopsInfo", _e.map(function(vn) {
        return {
          pts: vn.pts,
          dts: vn.dts,
          byteLength: vn.byteLength
        };
      })), Xe = _e[0], nt = _e[_e.length - 1], this.trigger("segmentTimingInfo", Y0(w.baseMediaDecodeTime, Xe.dts, Xe.pts, nt.dts + nt.duration, nt.pts + nt.duration, Fe)), this.trigger("timingInfo", {
        start: _e[0].pts,
        end: _e[_e.length - 1].pts + _e[_e.length - 1].duration
      }), this.gopCache_.unshift({
        gop: _e.pop(),
        pps: w.pps,
        sps: w.sps
      }), this.gopCache_.length = Math.min(6, this.gopCache_.length), R = [], this.trigger("baseMediaDecodeTime", w.baseMediaDecodeTime), this.trigger("timelineStartInfo", w.timelineStartInfo), Ae = Ga.moof(O, [w]), We = new Uint8Array(Ae.byteLength + Oe.byteLength), O++, We.set(Ae), We.set(Oe, Ae.byteLength), this.trigger("data", {
        track: w,
        boxes: We
      }), this.resetStream_(), this.trigger("done", "VideoSegmentStream");
    }, this.reset = function() {
      this.resetStream_(), R = [], this.gopCache_.length = 0, V.length = 0, this.trigger("reset");
    }, this.resetStream_ = function() {
      Hn.clearDtsInfo(w), X = void 0, re = void 0;
    }, this.getGopForFusion_ = function(ue) {
      var be = 45e3, _e = 1 / 0, Ae, Oe, We, Fe, Xe;
      for (Xe = 0; Xe < this.gopCache_.length; Xe++)
        Fe = this.gopCache_[Xe], We = Fe.gop, !(!(w.pps && K0(w.pps[0], Fe.pps[0])) || !(w.sps && K0(w.sps[0], Fe.sps[0]))) && (We.dts < w.timelineStartInfo.dts || (Ae = ue.dts - We.dts - We.duration, Ae >= -1e4 && Ae <= be && (!Oe || _e > Ae) && (Oe = Fe, _e = Ae)));
      return Oe ? Oe.gop : null;
    }, this.alignGopsAtStart_ = function(ue) {
      var be, _e, Ae, Oe, We, Fe, Xe, nt;
      for (We = ue.byteLength, Fe = ue.nalCount, Xe = ue.duration, be = _e = 0; be < V.length && _e < ue.length && (Ae = V[be], Oe = ue[_e], Ae.pts !== Oe.pts); ) {
        if (Oe.pts > Ae.pts) {
          be++;
          continue;
        }
        _e++, We -= Oe.byteLength, Fe -= Oe.nalCount, Xe -= Oe.duration;
      }
      return _e === 0 ? ue : _e === ue.length ? null : (nt = ue.slice(_e), nt.byteLength = We, nt.duration = Xe, nt.nalCount = Fe, nt.pts = nt[0].pts, nt.dts = nt[0].dts, nt);
    }, this.alignGopsAtEnd_ = function(ue) {
      var be, _e, Ae, Oe, We, Fe;
      for (be = V.length - 1, _e = ue.length - 1, We = null, Fe = !1; be >= 0 && _e >= 0; ) {
        if (Ae = V[be], Oe = ue[_e], Ae.pts === Oe.pts) {
          Fe = !0;
          break;
        }
        if (Ae.pts > Oe.pts) {
          be--;
          continue;
        }
        be === V.length - 1 && (We = _e), _e--;
      }
      if (!Fe && We === null)
        return null;
      var Xe;
      if (Fe ? Xe = _e : Xe = We, Xe === 0)
        return ue;
      var nt = ue.slice(Xe), jt = nt.reduce(function(vn, Wi) {
        return vn.byteLength += Wi.byteLength, vn.duration += Wi.duration, vn.nalCount += Wi.nalCount, vn;
      }, {
        byteLength: 0,
        duration: 0,
        nalCount: 0
      });
      return nt.byteLength = jt.byteLength, nt.duration = jt.duration, nt.nalCount = jt.nalCount, nt.pts = nt[0].pts, nt.dts = nt[0].dts, nt;
    }, this.alignGopsWith = function(ue) {
      V = ue;
    };
  }, No.prototype = new Lo(), hr = function(w, A) {
    this.numberOfTracks = 0, this.metadataStream = A, w = w || {}, typeof w.remux < "u" ? this.remuxTracks = !!w.remux : this.remuxTracks = !0, typeof w.keepOriginalTimestamps == "boolean" ? this.keepOriginalTimestamps = w.keepOriginalTimestamps : this.keepOriginalTimestamps = !1, this.pendingTracks = [], this.videoTrack = null, this.pendingBoxes = [], this.pendingCaptions = [], this.pendingMetadata = [], this.pendingBytes = 0, this.emittedTracks = 0, hr.prototype.init.call(this), this.push = function(O) {
      if (O.content || O.text)
        return this.pendingCaptions.push(O);
      if (O.frames)
        return this.pendingMetadata.push(O);
      this.pendingTracks.push(O.track), this.pendingBytes += O.boxes.byteLength, O.track.type === "video" && (this.videoTrack = O.track, this.pendingBoxes.push(O.boxes)), O.track.type === "audio" && (this.audioTrack = O.track, this.pendingBoxes.unshift(O.boxes));
    };
  }, hr.prototype = new Lo(), hr.prototype.flush = function(w) {
    var A = 0, O = {
      captions: [],
      captionStreams: {},
      metadata: [],
      info: {}
    }, R, V, X, re = 0, ue;
    if (this.pendingTracks.length < this.numberOfTracks) {
      if (w !== "VideoSegmentStream" && w !== "AudioSegmentStream")
        return;
      if (this.remuxTracks)
        return;
      if (this.pendingTracks.length === 0) {
        this.emittedTracks++, this.emittedTracks >= this.numberOfTracks && (this.trigger("done"), this.emittedTracks = 0);
        return;
      }
    }
    if (this.videoTrack ? (re = this.videoTrack.timelineStartInfo.pts, G0.forEach(function(be) {
      O.info[be] = this.videoTrack[be];
    }, this)) : this.audioTrack && (re = this.audioTrack.timelineStartInfo.pts, $0.forEach(function(be) {
      O.info[be] = this.audioTrack[be];
    }, this)), this.videoTrack || this.audioTrack) {
      for (this.pendingTracks.length === 1 ? O.type = this.pendingTracks[0].type : O.type = "combined", this.emittedTracks += this.pendingTracks.length, X = Ga.initSegment(this.pendingTracks), O.initSegment = new Uint8Array(X.byteLength), O.initSegment.set(X), O.data = new Uint8Array(this.pendingBytes), ue = 0; ue < this.pendingBoxes.length; ue++)
        O.data.set(this.pendingBoxes[ue], A), A += this.pendingBoxes[ue].byteLength;
      for (ue = 0; ue < this.pendingCaptions.length; ue++)
        R = this.pendingCaptions[ue], R.startTime = Fo.metadataTsToSeconds(R.startPts, re, this.keepOriginalTimestamps), R.endTime = Fo.metadataTsToSeconds(R.endPts, re, this.keepOriginalTimestamps), O.captionStreams[R.stream] = !0, O.captions.push(R);
      for (ue = 0; ue < this.pendingMetadata.length; ue++)
        V = this.pendingMetadata[ue], V.cueTime = Fo.metadataTsToSeconds(V.pts, re, this.keepOriginalTimestamps), O.metadata.push(V);
      for (O.metadata.dispatchType = this.metadataStream.dispatchType, this.pendingTracks.length = 0, this.videoTrack = null, this.pendingBoxes.length = 0, this.pendingCaptions.length = 0, this.pendingBytes = 0, this.pendingMetadata.length = 0, this.trigger("data", O), ue = 0; ue < O.captions.length; ue++)
        R = O.captions[ue], this.trigger("caption", R);
      for (ue = 0; ue < O.metadata.length; ue++)
        V = O.metadata[ue], this.trigger("id3Frame", V);
    }
    this.emittedTracks >= this.numberOfTracks && (this.trigger("done"), this.emittedTracks = 0);
  }, hr.prototype.setRemux = function(w) {
    this.remuxTracks = w;
  }, Mo = function(w) {
    var A = this, O = !0, R, V;
    Mo.prototype.init.call(this), w = w || {}, this.baseMediaDecodeTime = w.baseMediaDecodeTime || 0, this.transmuxPipeline_ = {}, this.setupAacPipeline = function() {
      var X = {};
      this.transmuxPipeline_ = X, X.type = "aac", X.metadataStream = new Ei.MetadataStream(), X.aacStream = new WC(), X.audioTimestampRolloverStream = new Ei.TimestampRolloverStream("audio"), X.timedMetadataTimestampRolloverStream = new Ei.TimestampRolloverStream("timed-metadata"), X.adtsStream = new z0(), X.coalesceStream = new hr(w, X.metadataStream), X.headOfPipeline = X.aacStream, X.aacStream.pipe(X.audioTimestampRolloverStream).pipe(X.adtsStream), X.aacStream.pipe(X.timedMetadataTimestampRolloverStream).pipe(X.metadataStream).pipe(X.coalesceStream), X.metadataStream.on("timestamp", function(re) {
        X.aacStream.setTimestamp(re.timeStamp);
      }), X.aacStream.on("data", function(re) {
        re.type !== "timed-metadata" && re.type !== "audio" || X.audioSegmentStream || (V = V || {
          timelineStartInfo: {
            baseMediaDecodeTime: A.baseMediaDecodeTime
          },
          codec: "adts",
          type: "audio"
        }, X.coalesceStream.numberOfTracks++, X.audioSegmentStream = new Ka(V, w), X.audioSegmentStream.on("log", A.getLogTrigger_("audioSegmentStream")), X.audioSegmentStream.on("timingInfo", A.trigger.bind(A, "audioTimingInfo")), X.adtsStream.pipe(X.audioSegmentStream).pipe(X.coalesceStream), A.trigger("trackinfo", {
          hasAudio: !!V,
          hasVideo: !!R
        }));
      }), X.coalesceStream.on("data", this.trigger.bind(this, "data")), X.coalesceStream.on("done", this.trigger.bind(this, "done")), X0(this, X);
    }, this.setupTsPipeline = function() {
      var X = {};
      this.transmuxPipeline_ = X, X.type = "ts", X.metadataStream = new Ei.MetadataStream(), X.packetStream = new Ei.TransportPacketStream(), X.parseStream = new Ei.TransportParseStream(), X.elementaryStream = new Ei.ElementaryStream(), X.timestampRolloverStream = new Ei.TimestampRolloverStream(), X.adtsStream = new z0(), X.h264Stream = new qC(), X.captionStream = new Ei.CaptionStream(w), X.coalesceStream = new hr(w, X.metadataStream), X.headOfPipeline = X.packetStream, X.packetStream.pipe(X.parseStream).pipe(X.elementaryStream).pipe(X.timestampRolloverStream), X.timestampRolloverStream.pipe(X.h264Stream), X.timestampRolloverStream.pipe(X.adtsStream), X.timestampRolloverStream.pipe(X.metadataStream).pipe(X.coalesceStream), X.h264Stream.pipe(X.captionStream).pipe(X.coalesceStream), X.elementaryStream.on("data", function(re) {
        var ue;
        if (re.type === "metadata") {
          for (ue = re.tracks.length; ue--; )
            !R && re.tracks[ue].type === "video" ? (R = re.tracks[ue], R.timelineStartInfo.baseMediaDecodeTime = A.baseMediaDecodeTime) : !V && re.tracks[ue].type === "audio" && (V = re.tracks[ue], V.timelineStartInfo.baseMediaDecodeTime = A.baseMediaDecodeTime);
          R && !X.videoSegmentStream && (X.coalesceStream.numberOfTracks++, X.videoSegmentStream = new No(R, w), X.videoSegmentStream.on("log", A.getLogTrigger_("videoSegmentStream")), X.videoSegmentStream.on("timelineStartInfo", function(be) {
            V && !w.keepOriginalTimestamps && (V.timelineStartInfo = be, X.audioSegmentStream.setEarliestDts(be.dts - A.baseMediaDecodeTime));
          }), X.videoSegmentStream.on("processedGopsInfo", A.trigger.bind(A, "gopInfo")), X.videoSegmentStream.on("segmentTimingInfo", A.trigger.bind(A, "videoSegmentTimingInfo")), X.videoSegmentStream.on("baseMediaDecodeTime", function(be) {
            V && X.audioSegmentStream.setVideoBaseMediaDecodeTime(be);
          }), X.videoSegmentStream.on("timingInfo", A.trigger.bind(A, "videoTimingInfo")), X.h264Stream.pipe(X.videoSegmentStream).pipe(X.coalesceStream)), V && !X.audioSegmentStream && (X.coalesceStream.numberOfTracks++, X.audioSegmentStream = new Ka(V, w), X.audioSegmentStream.on("log", A.getLogTrigger_("audioSegmentStream")), X.audioSegmentStream.on("timingInfo", A.trigger.bind(A, "audioTimingInfo")), X.audioSegmentStream.on("segmentTimingInfo", A.trigger.bind(A, "audioSegmentTimingInfo")), X.adtsStream.pipe(X.audioSegmentStream).pipe(X.coalesceStream)), A.trigger("trackinfo", {
            hasAudio: !!V,
            hasVideo: !!R
          });
        }
      }), X.coalesceStream.on("data", this.trigger.bind(this, "data")), X.coalesceStream.on("id3Frame", function(re) {
        re.dispatchType = X.metadataStream.dispatchType, A.trigger("id3Frame", re);
      }), X.coalesceStream.on("caption", this.trigger.bind(this, "caption")), X.coalesceStream.on("done", this.trigger.bind(this, "done")), X0(this, X);
    }, this.setBaseMediaDecodeTime = function(X) {
      var re = this.transmuxPipeline_;
      w.keepOriginalTimestamps || (this.baseMediaDecodeTime = X), V && (V.timelineStartInfo.dts = void 0, V.timelineStartInfo.pts = void 0, Hn.clearDtsInfo(V), re.audioTimestampRolloverStream && re.audioTimestampRolloverStream.discontinuity()), R && (re.videoSegmentStream && (re.videoSegmentStream.gopCache_ = []), R.timelineStartInfo.dts = void 0, R.timelineStartInfo.pts = void 0, Hn.clearDtsInfo(R), re.captionStream.reset()), re.timestampRolloverStream && re.timestampRolloverStream.discontinuity();
    }, this.setAudioAppendStart = function(X) {
      V && this.transmuxPipeline_.audioSegmentStream.setAudioAppendStart(X);
    }, this.setRemux = function(X) {
      var re = this.transmuxPipeline_;
      w.remux = X, re && re.coalesceStream && re.coalesceStream.setRemux(X);
    }, this.alignGopsWith = function(X) {
      R && this.transmuxPipeline_.videoSegmentStream && this.transmuxPipeline_.videoSegmentStream.alignGopsWith(X);
    }, this.getLogTrigger_ = function(X) {
      var re = this;
      return function(ue) {
        ue.stream = X, re.trigger("log", ue);
      };
    }, this.push = function(X) {
      if (O) {
        var re = VC(X);
        re && this.transmuxPipeline_.type !== "aac" ? this.setupAacPipeline() : !re && this.transmuxPipeline_.type !== "ts" && this.setupTsPipeline(), O = !1;
      }
      this.transmuxPipeline_.headOfPipeline.push(X);
    }, this.flush = function() {
      O = !0, this.transmuxPipeline_.headOfPipeline.flush();
    }, this.endTimeline = function() {
      this.transmuxPipeline_.headOfPipeline.endTimeline();
    }, this.reset = function() {
      this.transmuxPipeline_.headOfPipeline && this.transmuxPipeline_.headOfPipeline.reset();
    }, this.resetCaptions = function() {
      this.transmuxPipeline_.captionStream && this.transmuxPipeline_.captionStream.reset();
    };
  }, Mo.prototype = new Lo();
  var $C = {
    Transmuxer: Mo
  }, GC = function(w) {
    return w >>> 0;
  }, XC = function(w) {
    return ("00" + w.toString(16)).slice(-2);
  }, Bo = {
    toUnsigned: GC,
    toHexString: XC
  }, KC = function(w) {
    var A = "";
    return A += String.fromCharCode(w[0]), A += String.fromCharCode(w[1]), A += String.fromCharCode(w[2]), A += String.fromCharCode(w[3]), A;
  }, Q0 = KC, YC = Bo.toUnsigned, QC = Q0, Z0 = function(w, A) {
    var O = [], R, V, X, re, ue;
    if (!A.length)
      return null;
    for (R = 0; R < w.byteLength; )
      V = YC(w[R] << 24 | w[R + 1] << 16 | w[R + 2] << 8 | w[R + 3]), X = QC(w.subarray(R + 4, R + 8)), re = V > 1 ? R + V : w.byteLength, X === A[0] && (A.length === 1 ? O.push(w.subarray(R + 8, re)) : (ue = Z0(w.subarray(R + 8, re), A.slice(1)), ue.length && (O = O.concat(ue)))), R = re;
    return O;
  }, Fl = Z0, ZC = Bo.toUnsigned, JC = a.getUint64, eA = function(w) {
    var A = {
      version: w[0],
      flags: new Uint8Array(w.subarray(1, 4))
    };
    return A.version === 1 ? A.baseMediaDecodeTime = JC(w.subarray(4)) : A.baseMediaDecodeTime = ZC(w[4] << 24 | w[5] << 16 | w[6] << 8 | w[7]), A;
  }, Nl = eA, tA = function(w) {
    var A = new DataView(w.buffer, w.byteOffset, w.byteLength), O = {
      version: w[0],
      flags: new Uint8Array(w.subarray(1, 4)),
      trackId: A.getUint32(4)
    }, R = O.flags[2] & 1, V = O.flags[2] & 2, X = O.flags[2] & 8, re = O.flags[2] & 16, ue = O.flags[2] & 32, be = O.flags[0] & 65536, _e = O.flags[0] & 131072, Ae;
    return Ae = 8, R && (Ae += 4, O.baseDataOffset = A.getUint32(12), Ae += 4), V && (O.sampleDescriptionIndex = A.getUint32(Ae), Ae += 4), X && (O.defaultSampleDuration = A.getUint32(Ae), Ae += 4), re && (O.defaultSampleSize = A.getUint32(Ae), Ae += 4), ue && (O.defaultSampleFlags = A.getUint32(Ae)), be && (O.durationIsEmpty = !0), !R && _e && (O.baseDataOffsetIsMoof = !0), O;
  }, J0 = tA, nA = function(w) {
    return {
      isLeading: (w[0] & 12) >>> 2,
      dependsOn: w[0] & 3,
      isDependedOn: (w[1] & 192) >>> 6,
      hasRedundancy: (w[1] & 48) >>> 4,
      paddingValue: (w[1] & 14) >>> 1,
      isNonSyncSample: w[1] & 1,
      degradationPriority: w[2] << 8 | w[3]
    };
  }, iA = nA, eb = iA, rA = function(w) {
    var A = {
      version: w[0],
      flags: new Uint8Array(w.subarray(1, 4)),
      samples: []
    }, O = new DataView(w.buffer, w.byteOffset, w.byteLength), R = A.flags[2] & 1, V = A.flags[2] & 4, X = A.flags[1] & 1, re = A.flags[1] & 2, ue = A.flags[1] & 4, be = A.flags[1] & 8, _e = O.getUint32(4), Ae = 8, Oe;
    for (R && (A.dataOffset = O.getInt32(Ae), Ae += 4), V && _e && (Oe = {
      flags: eb(w.subarray(Ae, Ae + 4))
    }, Ae += 4, X && (Oe.duration = O.getUint32(Ae), Ae += 4), re && (Oe.size = O.getUint32(Ae), Ae += 4), be && (A.version === 1 ? Oe.compositionTimeOffset = O.getInt32(Ae) : Oe.compositionTimeOffset = O.getUint32(Ae), Ae += 4), A.samples.push(Oe), _e--); _e--; )
      Oe = {}, X && (Oe.duration = O.getUint32(Ae), Ae += 4), re && (Oe.size = O.getUint32(Ae), Ae += 4), ue && (Oe.flags = eb(w.subarray(Ae, Ae + 4)), Ae += 4), be && (A.version === 1 ? Oe.compositionTimeOffset = O.getInt32(Ae) : Oe.compositionTimeOffset = O.getUint32(Ae), Ae += 4), A.samples.push(Oe);
    return A;
  }, tb = rA, nb = {
    tfdt: Nl,
    trun: tb
  }, ib = {
    parseTfdt: nb.tfdt,
    parseTrun: nb.trun
  }, aA = function(w) {
    for (var A = 0, O = String.fromCharCode(w[A]), R = ""; O !== "\0"; )
      R += O, A++, O = String.fromCharCode(w[A]);
    return R += O, R;
  }, sA = {
    uint8ToCString: aA
  }, jo = sA.uint8ToCString, oA = a.getUint64, uA = function(w) {
    var A = 4, O = w[0], R, V, X, re, ue, be, _e, Ae;
    if (O === 0) {
      R = jo(w.subarray(A)), A += R.length, V = jo(w.subarray(A)), A += V.length;
      var Oe = new DataView(w.buffer);
      X = Oe.getUint32(A), A += 4, ue = Oe.getUint32(A), A += 4, be = Oe.getUint32(A), A += 4, _e = Oe.getUint32(A), A += 4;
    } else if (O === 1) {
      var Oe = new DataView(w.buffer);
      X = Oe.getUint32(A), A += 4, re = oA(w.subarray(A)), A += 8, be = Oe.getUint32(A), A += 4, _e = Oe.getUint32(A), A += 4, R = jo(w.subarray(A)), A += R.length, V = jo(w.subarray(A)), A += V.length;
    }
    Ae = new Uint8Array(w.subarray(A, w.byteLength));
    var We = {
      scheme_id_uri: R,
      value: V,
      // if timescale is undefined or 0 set to 1 
      timescale: X || 1,
      presentation_time: re,
      presentation_time_delta: ue,
      event_duration: be,
      id: _e,
      message_data: Ae
    };
    return lA(O, We) ? We : void 0;
  }, cA = function(w, A, O, R) {
    return w || w === 0 ? w / A : R + O / A;
  }, lA = function(w, A) {
    var O = A.scheme_id_uri !== "\0", R = w === 0 && rb(A.presentation_time_delta) && O, V = w === 1 && rb(A.presentation_time) && O;
    return !(w > 1) && R || V;
  }, rb = function(w) {
    return w !== void 0 || w !== null;
  }, dA = {
    parseEmsgBox: uA,
    scaleTime: cA
  }, Ya;
  typeof window < "u" ? Ya = window : typeof n < "u" ? Ya = n : typeof self < "u" ? Ya = self : Ya = {};
  var ab = Ya, qo = Bo.toUnsigned, Qa = Bo.toHexString, Ot = Fl, Xr = Q0, Ml = dA, fA = J0, hA = tb, pA = Nl, mA = a.getUint64, sb, ob, ub, cb, lb, Bl, db, jl = ab, gA = P0.parseId3Frames;
  sb = function(w) {
    var A = {}, O = Ot(w, ["moov", "trak"]);
    return O.reduce(function(R, V) {
      var X, re, ue, be, _e;
      return X = Ot(V, ["tkhd"])[0], !X || (re = X[0], ue = re === 0 ? 12 : 20, be = qo(X[ue] << 24 | X[ue + 1] << 16 | X[ue + 2] << 8 | X[ue + 3]), _e = Ot(V, ["mdia", "mdhd"])[0], !_e) ? null : (re = _e[0], ue = re === 0 ? 12 : 20, R[be] = qo(_e[ue] << 24 | _e[ue + 1] << 16 | _e[ue + 2] << 8 | _e[ue + 3]), R);
    }, A);
  }, ob = function(w, A) {
    var O;
    O = Ot(A, ["moof", "traf"]);
    var R = O.reduce(function(V, X) {
      var re = Ot(X, ["tfhd"])[0], ue = qo(re[4] << 24 | re[5] << 16 | re[6] << 8 | re[7]), be = w[ue] || 9e4, _e = Ot(X, ["tfdt"])[0], Ae = new DataView(_e.buffer, _e.byteOffset, _e.byteLength), Oe;
      _e[0] === 1 ? Oe = mA(_e.subarray(4, 12)) : Oe = Ae.getUint32(4);
      let We;
      return typeof Oe == "bigint" ? We = Oe / jl.BigInt(be) : typeof Oe == "number" && !isNaN(Oe) && (We = Oe / be), We < Number.MAX_SAFE_INTEGER && (We = Number(We)), We < V && (V = We), V;
    }, 1 / 0);
    return typeof R == "bigint" || isFinite(R) ? R : 0;
  }, ub = function(w, A) {
    var O = Ot(A, ["moof", "traf"]), R = 0, V = 0, X;
    if (O && O.length) {
      var re = Ot(O[0], ["tfhd"])[0], ue = Ot(O[0], ["trun"])[0], be = Ot(O[0], ["tfdt"])[0];
      if (re) {
        var _e = fA(re);
        X = _e.trackId;
      }
      if (be) {
        var Ae = pA(be);
        R = Ae.baseMediaDecodeTime;
      }
      if (ue) {
        var Oe = hA(ue);
        Oe.samples && Oe.samples.length && (V = Oe.samples[0].compositionTimeOffset || 0);
      }
    }
    var We = w[X] || 9e4;
    typeof R == "bigint" && (V = jl.BigInt(V), We = jl.BigInt(We));
    var Fe = (R + V) / We;
    return typeof Fe == "bigint" && Fe < Number.MAX_SAFE_INTEGER && (Fe = Number(Fe)), Fe;
  }, cb = function(w) {
    var A = Ot(w, ["moov", "trak"]), O = [];
    return A.forEach(function(R) {
      var V = Ot(R, ["mdia", "hdlr"]), X = Ot(R, ["tkhd"]);
      V.forEach(function(re, ue) {
        var be = Xr(re.subarray(8, 12)), _e = X[ue], Ae, Oe, We;
        be === "vide" && (Ae = new DataView(_e.buffer, _e.byteOffset, _e.byteLength), Oe = Ae.getUint8(0), We = Oe === 0 ? Ae.getUint32(12) : Ae.getUint32(20), O.push(We));
      });
    }), O;
  }, Bl = function(w) {
    var A = w[0], O = A === 0 ? 12 : 20;
    return qo(w[O] << 24 | w[O + 1] << 16 | w[O + 2] << 8 | w[O + 3]);
  }, lb = function(w) {
    var A = Ot(w, ["moov", "trak"]), O = [];
    return A.forEach(function(R) {
      var V = {}, X = Ot(R, ["tkhd"])[0], re, ue;
      X && (re = new DataView(X.buffer, X.byteOffset, X.byteLength), ue = re.getUint8(0), V.id = ue === 0 ? re.getUint32(12) : re.getUint32(20));
      var be = Ot(R, ["mdia", "hdlr"])[0];
      if (be) {
        var _e = Xr(be.subarray(8, 12));
        _e === "vide" ? V.type = "video" : _e === "soun" ? V.type = "audio" : V.type = _e;
      }
      var Ae = Ot(R, ["mdia", "minf", "stbl", "stsd"])[0];
      if (Ae) {
        var Oe = Ae.subarray(8);
        V.codec = Xr(Oe.subarray(4, 8));
        var We = Ot(Oe, [V.codec])[0], Fe, Xe;
        We && (/^[asm]vc[1-9]$/i.test(V.codec) ? (Fe = We.subarray(78), Xe = Xr(Fe.subarray(4, 8)), Xe === "avcC" && Fe.length > 11 ? (V.codec += ".", V.codec += Qa(Fe[9]), V.codec += Qa(Fe[10]), V.codec += Qa(Fe[11])) : V.codec = "avc1.4d400d") : /^mp4[a,v]$/i.test(V.codec) ? (Fe = We.subarray(28), Xe = Xr(Fe.subarray(4, 8)), Xe === "esds" && Fe.length > 20 && Fe[19] !== 0 ? (V.codec += "." + Qa(Fe[19]), V.codec += "." + Qa(Fe[20] >>> 2 & 63).replace(/^0/, "")) : V.codec = "mp4a.40.2") : V.codec = V.codec.toLowerCase());
      }
      var nt = Ot(R, ["mdia", "mdhd"])[0];
      nt && (V.timescale = Bl(nt)), O.push(V);
    }), O;
  }, db = function(w, A = 0) {
    var O = Ot(w, ["emsg"]);
    return O.map((R) => {
      var V = Ml.parseEmsgBox(new Uint8Array(R)), X = gA(V.message_data);
      return {
        cueTime: Ml.scaleTime(V.presentation_time, V.timescale, V.presentation_time_delta, A),
        duration: Ml.scaleTime(V.event_duration, V.timescale),
        frames: X
      };
    });
  };
  var Za = {
    // export mp4 inspector's findBox and parseType for backwards compatibility
    findBox: Ot,
    parseType: Xr,
    timescale: sb,
    startTime: ob,
    compositionStartTime: ub,
    videoTrackIds: cb,
    tracks: lb,
    getTimescaleFromMediaHeader: Bl,
    getEmsgID3: db
  };
  const {
    parseTrun: bA
  } = ib, {
    findBox: fb
  } = Za;
  var hb = ab, yA = function(w) {
    var A = fb(w, ["moof", "traf"]), O = fb(w, ["mdat"]), R = [];
    return O.forEach(function(V, X) {
      var re = A[X];
      R.push({
        mdat: V,
        traf: re
      });
    }), R;
  }, vA = function(w, A, O) {
    var R = A, V = O.defaultSampleDuration || 0, X = O.defaultSampleSize || 0, re = O.trackId, ue = [];
    return w.forEach(function(be) {
      var _e = bA(be), Ae = _e.samples;
      Ae.forEach(function(Oe) {
        Oe.duration === void 0 && (Oe.duration = V), Oe.size === void 0 && (Oe.size = X), Oe.trackId = re, Oe.dts = R, Oe.compositionTimeOffset === void 0 && (Oe.compositionTimeOffset = 0), typeof R == "bigint" ? (Oe.pts = R + hb.BigInt(Oe.compositionTimeOffset), R += hb.BigInt(Oe.duration)) : (Oe.pts = R + Oe.compositionTimeOffset, R += Oe.duration);
      }), ue = ue.concat(Ae);
    }), ue;
  }, pb = {
    getMdatTrafPairs: yA,
    parseSamples: vA
  }, xA = An.discardEmulationPreventionBytes, _A = U0.CaptionStream, ql = Fl, TA = Nl, wA = J0, {
    getMdatTrafPairs: EA,
    parseSamples: DA
  } = pb, SA = function(w, A) {
    for (var O = w, R = 0; R < A.length; R++) {
      var V = A[R];
      if (O < V.size)
        return V;
      O -= V.size;
    }
    return null;
  }, CA = function(w, A, O) {
    var R = new DataView(w.buffer, w.byteOffset, w.byteLength), V = {
      logs: [],
      seiNals: []
    }, X, re, ue, be;
    for (re = 0; re + 4 < w.length; re += ue)
      if (ue = R.getUint32(re), re += 4, !(ue <= 0))
        switch (w[re] & 31) {
          case 6:
            var _e = w.subarray(re + 1, re + 1 + ue), Ae = SA(re, A);
            if (X = {
              nalUnitType: "sei_rbsp",
              size: ue,
              data: _e,
              escapedRBSP: xA(_e),
              trackId: O
            }, Ae)
              X.pts = Ae.pts, X.dts = Ae.dts, be = Ae;
            else if (be)
              X.pts = be.pts, X.dts = be.dts;
            else {
              V.logs.push({
                level: "warn",
                message: "We've encountered a nal unit without data at " + re + " for trackId " + O + ". See mux.js#223."
              });
              break;
            }
            V.seiNals.push(X);
            break;
        }
    return V;
  }, AA = function(w, A) {
    var O = {}, R = EA(w);
    return R.forEach(function(V) {
      var X = V.mdat, re = V.traf, ue = ql(re, ["tfhd"]), be = wA(ue[0]), _e = be.trackId, Ae = ql(re, ["tfdt"]), Oe = Ae.length > 0 ? TA(Ae[0]).baseMediaDecodeTime : 0, We = ql(re, ["trun"]), Fe, Xe;
      A === _e && We.length > 0 && (Fe = DA(We, Oe, be), Xe = CA(X, Fe, _e), O[_e] || (O[_e] = {
        seiNals: [],
        logs: []
      }), O[_e].seiNals = O[_e].seiNals.concat(Xe.seiNals), O[_e].logs = O[_e].logs.concat(Xe.logs));
    }), O;
  }, kA = function(w, A, O) {
    var R;
    if (A === null)
      return null;
    R = AA(w, A);
    var V = R[A] || {};
    return {
      seiNals: V.seiNals,
      logs: V.logs,
      timescale: O
    };
  }, IA = function() {
    var w = !1, A, O, R, V, X, re;
    this.isInitialized = function() {
      return w;
    }, this.init = function(ue) {
      A = new _A(), w = !0, re = ue ? ue.isPartial : !1, A.on("data", function(be) {
        be.startTime = be.startPts / V, be.endTime = be.endPts / V, X.captions.push(be), X.captionStreams[be.stream] = !0;
      }), A.on("log", function(be) {
        X.logs.push(be);
      });
    }, this.isNewInit = function(ue, be) {
      return ue && ue.length === 0 || be && typeof be == "object" && Object.keys(be).length === 0 ? !1 : R !== ue[0] || V !== be[R];
    }, this.parse = function(ue, be, _e) {
      var Ae;
      if (this.isInitialized()) {
        if (!be || !_e)
          return null;
        if (this.isNewInit(be, _e))
          R = be[0], V = _e[R];
        else if (R === null || !V)
          return O.push(ue), null;
      } else return null;
      for (; O.length > 0; ) {
        var Oe = O.shift();
        this.parse(Oe, be, _e);
      }
      return Ae = kA(ue, R, V), Ae && Ae.logs && (X.logs = X.logs.concat(Ae.logs)), Ae === null || !Ae.seiNals ? X.logs.length ? {
        logs: X.logs,
        captions: [],
        captionStreams: []
      } : null : (this.pushNals(Ae.seiNals), this.flushStream(), X);
    }, this.pushNals = function(ue) {
      if (!this.isInitialized() || !ue || ue.length === 0)
        return null;
      ue.forEach(function(be) {
        A.push(be);
      });
    }, this.flushStream = function() {
      if (!this.isInitialized())
        return null;
      re ? A.partialFlush() : A.flush();
    }, this.clearParsedCaptions = function() {
      X.captions = [], X.captionStreams = {}, X.logs = [];
    }, this.resetCaptionStream = function() {
      if (!this.isInitialized())
        return null;
      A.reset();
    }, this.clearAllCaptions = function() {
      this.clearParsedCaptions(), this.resetCaptionStream();
    }, this.reset = function() {
      O = [], R = null, V = null, X ? this.clearParsedCaptions() : X = {
        captions: [],
        // CC1, CC2, CC3, CC4
        captionStreams: {},
        logs: []
      }, this.resetCaptionStream();
    }, this.reset();
  }, UA = IA;
  const {
    parseTfdt: RA
  } = ib, qi = Fl, {
    getTimescaleFromMediaHeader: OA
  } = Za, {
    parseSamples: LA,
    getMdatTrafPairs: PA
  } = pb;
  var mb = function() {
    let w = 9e4;
    this.init = function(A) {
      const O = qi(A, ["moov", "trak", "mdia", "mdhd"])[0];
      O && (w = OA(O));
    }, this.parseSegment = function(A) {
      const O = [], R = PA(A);
      let V = 0;
      return R.forEach(function(X) {
        const re = X.mdat, ue = X.traf, be = qi(ue, ["tfdt"])[0], _e = qi(ue, ["tfhd"])[0], Ae = qi(ue, ["trun"]);
        if (be && (V = RA(be).baseMediaDecodeTime), Ae.length && _e) {
          const Oe = LA(Ae, V, _e);
          let We = 0;
          Oe.forEach(function(Fe) {
            const Xe = "utf-8", nt = new TextDecoder(Xe), jt = re.slice(We, We + Fe.size);
            if (qi(jt, ["vtte"])[0]) {
              We += Fe.size;
              return;
            }
            qi(jt, ["vttc"]).forEach(function(Ja) {
              const es = qi(Ja, ["payl"])[0], ts = qi(Ja, ["sttg"])[0], ns = Fe.pts / w, Ho = (Fe.pts + Fe.duration) / w;
              let wt, is;
              if (es)
                try {
                  wt = nt.decode(es);
                } catch (zn) {
                  console.error(zn);
                }
              if (ts)
                try {
                  is = nt.decode(ts);
                } catch (zn) {
                  console.error(zn);
                }
              Fe.duration && wt && O.push({
                cueText: wt,
                start: ns,
                end: Ho,
                settings: is
              });
            }), We += Fe.size;
          });
        }
      }), O;
    };
  }, Wl = Eo, gb = function(w) {
    var A = w[1] & 31;
    return A <<= 8, A |= w[2], A;
  }, Wo = function(w) {
    return !!(w[1] & 64);
  }, Vo = function(w) {
    var A = 0;
    return (w[3] & 48) >>> 4 > 1 && (A += w[4] + 1), A;
  }, FA = function(w, A) {
    var O = gb(w);
    return O === 0 ? "pat" : O === A ? "pmt" : A ? "pes" : null;
  }, NA = function(w) {
    var A = Wo(w), O = 4 + Vo(w);
    return A && (O += w[O] + 1), (w[O + 10] & 31) << 8 | w[O + 11];
  }, MA = function(w) {
    var A = {}, O = Wo(w), R = 4 + Vo(w);
    if (O && (R += w[R] + 1), !!(w[R + 5] & 1)) {
      var V, X, re;
      V = (w[R + 1] & 15) << 8 | w[R + 2], X = 3 + V - 4, re = (w[R + 10] & 15) << 8 | w[R + 11];
      for (var ue = 12 + re; ue < X; ) {
        var be = R + ue;
        A[(w[be + 1] & 31) << 8 | w[be + 2]] = w[be], ue += ((w[be + 3] & 15) << 8 | w[be + 4]) + 5;
      }
      return A;
    }
  }, BA = function(w, A) {
    var O = gb(w), R = A[O];
    switch (R) {
      case Wl.H264_STREAM_TYPE:
        return "video";
      case Wl.ADTS_STREAM_TYPE:
        return "audio";
      case Wl.METADATA_STREAM_TYPE:
        return "timed-metadata";
      default:
        return null;
    }
  }, jA = function(w) {
    var A = Wo(w);
    if (!A)
      return null;
    var O = 4 + Vo(w);
    if (O >= w.byteLength)
      return null;
    var R = null, V;
    return V = w[O + 7], V & 192 && (R = {}, R.pts = (w[O + 9] & 14) << 27 | (w[O + 10] & 255) << 20 | (w[O + 11] & 254) << 12 | (w[O + 12] & 255) << 5 | (w[O + 13] & 254) >>> 3, R.pts *= 4, R.pts += (w[O + 13] & 6) >>> 1, R.dts = R.pts, V & 64 && (R.dts = (w[O + 14] & 14) << 27 | (w[O + 15] & 255) << 20 | (w[O + 16] & 254) << 12 | (w[O + 17] & 255) << 5 | (w[O + 18] & 254) >>> 3, R.dts *= 4, R.dts += (w[O + 18] & 6) >>> 1)), R;
  }, Vl = function(w) {
    switch (w) {
      case 5:
        return "slice_layer_without_partitioning_rbsp_idr";
      case 6:
        return "sei_rbsp";
      case 7:
        return "seq_parameter_set_rbsp";
      case 8:
        return "pic_parameter_set_rbsp";
      case 9:
        return "access_unit_delimiter_rbsp";
      default:
        return null;
    }
  }, qA = function(w) {
    for (var A = 4 + Vo(w), O = w.subarray(A), R = 0, V = 0, X = !1, re; V < O.byteLength - 3; V++)
      if (O[V + 2] === 1) {
        R = V + 5;
        break;
      }
    for (; R < O.byteLength; )
      switch (O[R]) {
        case 0:
          if (O[R - 1] !== 0) {
            R += 2;
            break;
          } else if (O[R - 2] !== 0) {
            R++;
            break;
          }
          V + 3 !== R - 2 && (re = Vl(O[V + 3] & 31), re === "slice_layer_without_partitioning_rbsp_idr" && (X = !0));
          do
            R++;
          while (O[R] !== 1 && R < O.length);
          V = R - 2, R += 3;
          break;
        case 1:
          if (O[R - 1] !== 0 || O[R - 2] !== 0) {
            R += 3;
            break;
          }
          re = Vl(O[V + 3] & 31), re === "slice_layer_without_partitioning_rbsp_idr" && (X = !0), V = R - 2, R += 3;
          break;
        default:
          R += 3;
          break;
      }
    return O = O.subarray(V), R -= V, V = 0, O && O.byteLength > 3 && (re = Vl(O[V + 3] & 31), re === "slice_layer_without_partitioning_rbsp_idr" && (X = !0)), X;
  }, WA = {
    parseType: FA,
    parsePat: NA,
    parsePmt: MA,
    parsePayloadUnitStartIndicator: Wo,
    parsePesType: BA,
    parsePesTime: jA,
    videoPacketContainsKeyFrame: qA
  }, bb = Eo, Kr = O0.handleRollover, gt = {};
  gt.ts = WA, gt.aac = Pl;
  var pr = Te.ONE_SECOND_IN_TS, en = 188, li = 71, VA = function(w, A) {
    for (var O = 0, R = en, V, X; R < w.byteLength; ) {
      if (w[O] === li && w[R] === li) {
        switch (V = w.subarray(O, R), X = gt.ts.parseType(V, A.pid), X) {
          case "pat":
            A.pid = gt.ts.parsePat(V);
            break;
          case "pmt":
            var re = gt.ts.parsePmt(V);
            A.table = A.table || {}, Object.keys(re).forEach(function(ue) {
              A.table[ue] = re[ue];
            });
            break;
        }
        O += en, R += en;
        continue;
      }
      O++, R++;
    }
  }, yb = function(w, A, O) {
    for (var R = 0, V = en, X, re, ue, be, _e, Ae = !1; V <= w.byteLength; ) {
      if (w[R] === li && (w[V] === li || V === w.byteLength)) {
        switch (X = w.subarray(R, V), re = gt.ts.parseType(X, A.pid), re) {
          case "pes":
            ue = gt.ts.parsePesType(X, A.table), be = gt.ts.parsePayloadUnitStartIndicator(X), ue === "audio" && be && (_e = gt.ts.parsePesTime(X), _e && (_e.type = "audio", O.audio.push(_e), Ae = !0));
            break;
        }
        if (Ae)
          break;
        R += en, V += en;
        continue;
      }
      R++, V++;
    }
    for (V = w.byteLength, R = V - en, Ae = !1; R >= 0; ) {
      if (w[R] === li && (w[V] === li || V === w.byteLength)) {
        switch (X = w.subarray(R, V), re = gt.ts.parseType(X, A.pid), re) {
          case "pes":
            ue = gt.ts.parsePesType(X, A.table), be = gt.ts.parsePayloadUnitStartIndicator(X), ue === "audio" && be && (_e = gt.ts.parsePesTime(X), _e && (_e.type = "audio", O.audio.push(_e), Ae = !0));
            break;
        }
        if (Ae)
          break;
        R -= en, V -= en;
        continue;
      }
      R--, V--;
    }
  }, HA = function(w, A, O) {
    for (var R = 0, V = en, X, re, ue, be, _e, Ae, Oe, We, Fe = !1, Xe = {
      data: [],
      size: 0
    }; V < w.byteLength; ) {
      if (w[R] === li && w[V] === li) {
        switch (X = w.subarray(R, V), re = gt.ts.parseType(X, A.pid), re) {
          case "pes":
            if (ue = gt.ts.parsePesType(X, A.table), be = gt.ts.parsePayloadUnitStartIndicator(X), ue === "video" && (be && !Fe && (_e = gt.ts.parsePesTime(X), _e && (_e.type = "video", O.video.push(_e), Fe = !0)), !O.firstKeyFrame)) {
              if (be && Xe.size !== 0) {
                for (Ae = new Uint8Array(Xe.size), Oe = 0; Xe.data.length; )
                  We = Xe.data.shift(), Ae.set(We, Oe), Oe += We.byteLength;
                if (gt.ts.videoPacketContainsKeyFrame(Ae)) {
                  var nt = gt.ts.parsePesTime(Ae);
                  nt ? (O.firstKeyFrame = nt, O.firstKeyFrame.type = "video") : console.warn("Failed to extract PTS/DTS from PES at first keyframe. This could be an unusual TS segment, or else mux.js did not parse your TS segment correctly. If you know your TS segments do contain PTS/DTS on keyframes please file a bug report! You can try ffprobe to double check for yourself.");
                }
                Xe.size = 0;
              }
              Xe.data.push(X), Xe.size += X.byteLength;
            }
            break;
        }
        if (Fe && O.firstKeyFrame)
          break;
        R += en, V += en;
        continue;
      }
      R++, V++;
    }
    for (V = w.byteLength, R = V - en, Fe = !1; R >= 0; ) {
      if (w[R] === li && w[V] === li) {
        switch (X = w.subarray(R, V), re = gt.ts.parseType(X, A.pid), re) {
          case "pes":
            ue = gt.ts.parsePesType(X, A.table), be = gt.ts.parsePayloadUnitStartIndicator(X), ue === "video" && be && (_e = gt.ts.parsePesTime(X), _e && (_e.type = "video", O.video.push(_e), Fe = !0));
            break;
        }
        if (Fe)
          break;
        R -= en, V -= en;
        continue;
      }
      R--, V--;
    }
  }, zA = function(w, A) {
    if (w.audio && w.audio.length) {
      var O = A;
      (typeof O > "u" || isNaN(O)) && (O = w.audio[0].dts), w.audio.forEach(function(X) {
        X.dts = Kr(X.dts, O), X.pts = Kr(X.pts, O), X.dtsTime = X.dts / pr, X.ptsTime = X.pts / pr;
      });
    }
    if (w.video && w.video.length) {
      var R = A;
      if ((typeof R > "u" || isNaN(R)) && (R = w.video[0].dts), w.video.forEach(function(X) {
        X.dts = Kr(X.dts, R), X.pts = Kr(X.pts, R), X.dtsTime = X.dts / pr, X.ptsTime = X.pts / pr;
      }), w.firstKeyFrame) {
        var V = w.firstKeyFrame;
        V.dts = Kr(V.dts, R), V.pts = Kr(V.pts, R), V.dtsTime = V.dts / pr, V.ptsTime = V.pts / pr;
      }
    }
  }, $A = function(w) {
    for (var A = !1, O = 0, R = null, V = null, X = 0, re = 0, ue; w.length - re >= 3; ) {
      var be = gt.aac.parseType(w, re);
      switch (be) {
        case "timed-metadata":
          if (w.length - re < 10) {
            A = !0;
            break;
          }
          if (X = gt.aac.parseId3TagSize(w, re), X > w.length) {
            A = !0;
            break;
          }
          V === null && (ue = w.subarray(re, re + X), V = gt.aac.parseAacTimestamp(ue)), re += X;
          break;
        case "audio":
          if (w.length - re < 7) {
            A = !0;
            break;
          }
          if (X = gt.aac.parseAdtsSize(w, re), X > w.length) {
            A = !0;
            break;
          }
          R === null && (ue = w.subarray(re, re + X), R = gt.aac.parseSampleRate(ue)), O++, re += X;
          break;
        default:
          re++;
          break;
      }
      if (A)
        return null;
    }
    if (R === null || V === null)
      return null;
    var _e = pr / R, Ae = {
      audio: [{
        type: "audio",
        dts: V,
        pts: V
      }, {
        type: "audio",
        dts: V + O * 1024 * _e,
        pts: V + O * 1024 * _e
      }]
    };
    return Ae;
  }, GA = function(w) {
    var A = {
      pid: null,
      table: null
    }, O = {};
    VA(w, A);
    for (var R in A.table)
      if (A.table.hasOwnProperty(R)) {
        var V = A.table[R];
        switch (V) {
          case bb.H264_STREAM_TYPE:
            O.video = [], HA(w, A, O), O.video.length === 0 && delete O.video;
            break;
          case bb.ADTS_STREAM_TYPE:
            O.audio = [], yb(w, A, O), O.audio.length === 0 && delete O.audio;
            break;
        }
      }
    return O;
  }, XA = function(w, A) {
    var O = gt.aac.isLikelyAacData(w), R;
    return O ? R = $A(w) : R = GA(w), !R || !R.audio && !R.video ? null : (zA(R, A), R);
  }, KA = {
    inspect: XA,
    parseAudioPes_: yb
  };
  const YA = function(w, A) {
    A.on("data", function(O) {
      const R = O.initSegment;
      O.initSegment = {
        data: R.buffer,
        byteOffset: R.byteOffset,
        byteLength: R.byteLength
      };
      const V = O.data;
      O.data = V.buffer, w.postMessage({
        action: "data",
        segment: O,
        byteOffset: V.byteOffset,
        byteLength: V.byteLength
      }, [O.data]);
    }), A.on("done", function(O) {
      w.postMessage({
        action: "done"
      });
    }), A.on("gopInfo", function(O) {
      w.postMessage({
        action: "gopInfo",
        gopInfo: O
      });
    }), A.on("videoSegmentTimingInfo", function(O) {
      const R = {
        start: {
          decode: Te.videoTsToSeconds(O.start.dts),
          presentation: Te.videoTsToSeconds(O.start.pts)
        },
        end: {
          decode: Te.videoTsToSeconds(O.end.dts),
          presentation: Te.videoTsToSeconds(O.end.pts)
        },
        baseMediaDecodeTime: Te.videoTsToSeconds(O.baseMediaDecodeTime)
      };
      O.prependedContentDuration && (R.prependedContentDuration = Te.videoTsToSeconds(O.prependedContentDuration)), w.postMessage({
        action: "videoSegmentTimingInfo",
        videoSegmentTimingInfo: R
      });
    }), A.on("audioSegmentTimingInfo", function(O) {
      const R = {
        start: {
          decode: Te.videoTsToSeconds(O.start.dts),
          presentation: Te.videoTsToSeconds(O.start.pts)
        },
        end: {
          decode: Te.videoTsToSeconds(O.end.dts),
          presentation: Te.videoTsToSeconds(O.end.pts)
        },
        baseMediaDecodeTime: Te.videoTsToSeconds(O.baseMediaDecodeTime)
      };
      O.prependedContentDuration && (R.prependedContentDuration = Te.videoTsToSeconds(O.prependedContentDuration)), w.postMessage({
        action: "audioSegmentTimingInfo",
        audioSegmentTimingInfo: R
      });
    }), A.on("id3Frame", function(O) {
      w.postMessage({
        action: "id3Frame",
        id3Frame: O
      });
    }), A.on("caption", function(O) {
      w.postMessage({
        action: "caption",
        caption: O
      });
    }), A.on("trackinfo", function(O) {
      w.postMessage({
        action: "trackinfo",
        trackInfo: O
      });
    }), A.on("audioTimingInfo", function(O) {
      w.postMessage({
        action: "audioTimingInfo",
        audioTimingInfo: {
          start: Te.videoTsToSeconds(O.start),
          end: Te.videoTsToSeconds(O.end)
        }
      });
    }), A.on("videoTimingInfo", function(O) {
      w.postMessage({
        action: "videoTimingInfo",
        videoTimingInfo: {
          start: Te.videoTsToSeconds(O.start),
          end: Te.videoTsToSeconds(O.end)
        }
      });
    }), A.on("log", function(O) {
      w.postMessage({
        action: "log",
        log: O
      });
    });
  };
  class vb {
    constructor(A, O) {
      this.options = O || {}, this.self = A, this.init();
    }
    /**
     * initialize our web worker and wire all the events.
     */
    init() {
      this.transmuxer && this.transmuxer.dispose(), this.transmuxer = new $C.Transmuxer(this.options), YA(this.self, this.transmuxer);
    }
    pushMp4Captions(A) {
      this.captionParser || (this.captionParser = new UA(), this.captionParser.init());
      const O = new Uint8Array(A.data, A.byteOffset, A.byteLength), R = this.captionParser.parse(O, A.trackIds, A.timescales);
      this.self.postMessage({
        action: "mp4Captions",
        captions: R && R.captions || [],
        logs: R && R.logs || [],
        data: O.buffer
      }, [O.buffer]);
    }
    /**
     * Initializes the WebVttParser and passes the init segment.
     *
     * @param {Uint8Array} data mp4 boxed WebVTT init segment data
     */
    initMp4WebVttParser(A) {
      this.webVttParser || (this.webVttParser = new mb());
      const O = new Uint8Array(A.data, A.byteOffset, A.byteLength);
      this.webVttParser.init(O);
    }
    /**
     * Parse an mp4 encapsulated WebVTT segment and return an array of cues.
     *
     * @param {Uint8Array} data a text/webvtt segment
     * @return {Object[]} an array of parsed cue objects
     */
    getMp4WebVttText(A) {
      this.webVttParser || (this.webVttParser = new mb());
      const O = new Uint8Array(A.data, A.byteOffset, A.byteLength), R = this.webVttParser.parseSegment(O);
      this.self.postMessage({
        action: "getMp4WebVttText",
        mp4VttCues: R || [],
        data: O.buffer
      }, [O.buffer]);
    }
    probeMp4StartTime({
      timescales: A,
      data: O
    }) {
      const R = Za.startTime(A, O);
      this.self.postMessage({
        action: "probeMp4StartTime",
        startTime: R,
        data: O
      }, [O.buffer]);
    }
    probeMp4Tracks({
      data: A
    }) {
      const O = Za.tracks(A);
      this.self.postMessage({
        action: "probeMp4Tracks",
        tracks: O,
        data: A
      }, [A.buffer]);
    }
    /**
     * Probes an mp4 segment for EMSG boxes containing ID3 data.
     * https://aomediacodec.github.io/id3-emsg/
     *
     * @param {Uint8Array} data segment data
     * @param {number} offset segment start time
     * @return {Object[]} an array of ID3 frames
     */
    probeEmsgID3({
      data: A,
      offset: O
    }) {
      const R = Za.getEmsgID3(A, O);
      this.self.postMessage({
        action: "probeEmsgID3",
        id3Frames: R,
        emsgData: A
      }, [A.buffer]);
    }
    /**
     * Probe an mpeg2-ts segment to determine the start time of the segment in it's
     * internal "media time," as well as whether it contains video and/or audio.
     *
     * @private
     * @param {Uint8Array} bytes - segment bytes
     * @param {number} baseStartTime
     *        Relative reference timestamp used when adjusting frame timestamps for rollover.
     *        This value should be in seconds, as it's converted to a 90khz clock within the
     *        function body.
     * @return {Object} The start time of the current segment in "media time" as well as
     *                  whether it contains video and/or audio
     */
    probeTs({
      data: A,
      baseStartTime: O
    }) {
      const R = typeof O == "number" && !isNaN(O) ? O * Te.ONE_SECOND_IN_TS : void 0, V = KA.inspect(A, R);
      let X = null;
      V && (X = {
        // each type's time info comes back as an array of 2 times, start and end
        hasVideo: V.video && V.video.length === 2 || !1,
        hasAudio: V.audio && V.audio.length === 2 || !1
      }, X.hasVideo && (X.videoStart = V.video[0].ptsTime), X.hasAudio && (X.audioStart = V.audio[0].ptsTime)), this.self.postMessage({
        action: "probeTs",
        result: X,
        data: A
      }, [A.buffer]);
    }
    clearAllMp4Captions() {
      this.captionParser && this.captionParser.clearAllCaptions();
    }
    clearParsedMp4Captions() {
      this.captionParser && this.captionParser.clearParsedCaptions();
    }
    /**
     * Adds data (a ts segment) to the start of the transmuxer pipeline for
     * processing.
     *
     * @param {ArrayBuffer} data data to push into the muxer
     */
    push(A) {
      const O = new Uint8Array(A.data, A.byteOffset, A.byteLength);
      this.transmuxer.push(O);
    }
    /**
     * Recreate the transmuxer so that the next segment added via `push`
     * start with a fresh transmuxer.
     */
    reset() {
      this.transmuxer.reset();
    }
    /**
     * Set the value that will be used as the `baseMediaDecodeTime` time for the
     * next segment pushed in. Subsequent segments will have their `baseMediaDecodeTime`
     * set relative to the first based on the PTS values.
     *
     * @param {Object} data used to set the timestamp offset in the muxer
     */
    setTimestampOffset(A) {
      const O = A.timestampOffset || 0;
      this.transmuxer.setBaseMediaDecodeTime(Math.round(Te.secondsToVideoTs(O)));
    }
    setAudioAppendStart(A) {
      this.transmuxer.setAudioAppendStart(Math.ceil(Te.secondsToVideoTs(A.appendStart)));
    }
    setRemux(A) {
      this.transmuxer.setRemux(A.remux);
    }
    /**
     * Forces the pipeline to finish processing the last segment and emit it's
     * results.
     *
     * @param {Object} data event data, not really used
     */
    flush(A) {
      this.transmuxer.flush(), self.postMessage({
        action: "done",
        type: "transmuxed"
      });
    }
    endTimeline() {
      this.transmuxer.endTimeline(), self.postMessage({
        action: "endedtimeline",
        type: "transmuxed"
      });
    }
    alignGopsWith(A) {
      this.transmuxer.alignGopsWith(A.gopsToAlignWith.slice());
    }
  }
  self.onmessage = function(w) {
    if (w.data.action === "init" && w.data.options) {
      this.messageHandlers = new vb(self, w.data.options);
      return;
    }
    this.messageHandlers || (this.messageHandlers = new vb(self)), w.data && w.data.action && w.data.action !== "init" && this.messageHandlers[w.data.action] && this.messageHandlers[w.data.action](w.data);
  };
}));
var nL = m3(tL);
const iL = (n, e, t) => {
  const {
    type: i,
    initSegment: r,
    captions: a,
    captionStreams: s,
    metadata: o,
    videoFrameDtsTime: u,
    videoFramePtsTime: c
  } = n.data.segment;
  e.buffer.push({
    captions: a,
    captionStreams: s,
    metadata: o
  });
  const l = n.data.segment.boxes || {
    data: n.data.segment.data
  }, h = {
    type: i,
    // cast ArrayBuffer to TypedArray
    data: new Uint8Array(l.data, l.data.byteOffset, l.data.byteLength),
    initSegment: new Uint8Array(r.data, r.byteOffset, r.byteLength)
  };
  typeof u < "u" && (h.videoFrameDtsTime = u), typeof c < "u" && (h.videoFramePtsTime = c), t(h);
}, rL = ({
  transmuxedData: n,
  callback: e
}) => {
  n.buffer = [], e(n);
}, aL = (n, e) => {
  e.gopInfo = n.data.gopInfo;
}, y3 = (n) => {
  const {
    transmuxer: e,
    bytes: t,
    audioAppendStart: i,
    gopsToAlignWith: r,
    remux: a,
    onData: s,
    onTrackInfo: o,
    onAudioTimingInfo: u,
    onVideoTimingInfo: c,
    onVideoSegmentTimingInfo: l,
    onAudioSegmentTimingInfo: h,
    onId3: f,
    onCaptions: d,
    onDone: y,
    onEndedTimeline: m,
    onTransmuxerLog: b,
    isEndOfTimeline: p,
    segment: g,
    triggerSegmentEventFn: v
  } = n, _ = {
    buffer: []
  };
  let x = p;
  const T = (U) => {
    e.currentTransmux === n && (U.data.action === "data" && iL(U, _, s), U.data.action === "trackinfo" && o(U.data.trackInfo), U.data.action === "gopInfo" && aL(U, _), U.data.action === "audioTimingInfo" && u(U.data.audioTimingInfo), U.data.action === "videoTimingInfo" && c(U.data.videoTimingInfo), U.data.action === "videoSegmentTimingInfo" && l(U.data.videoSegmentTimingInfo), U.data.action === "audioSegmentTimingInfo" && h(U.data.audioSegmentTimingInfo), U.data.action === "id3Frame" && f([U.data.id3Frame], U.data.id3Frame.dispatchType), U.data.action === "caption" && d(U.data.caption), U.data.action === "endedtimeline" && (x = !1, m()), U.data.action === "log" && b(U.data.log), U.data.type === "transmuxed" && (x || (e.onmessage = null, rL({
      transmuxedData: _,
      callback: y
    }), v3(e))));
  }, E = () => {
    const U = {
      message: "Received an error message from the transmuxer worker",
      metadata: {
        errorType: ke.Error.StreamingFailedToTransmuxSegment,
        segmentInfo: Cr({
          segment: g
        })
      }
    };
    y(null, U);
  };
  if (e.onmessage = T, e.onerror = E, i && e.postMessage({
    action: "setAudioAppendStart",
    appendStart: i
  }), Array.isArray(r) && e.postMessage({
    action: "alignGopsWith",
    gopsToAlignWith: r
  }), typeof a < "u" && e.postMessage({
    action: "setRemux",
    remux: a
  }), t.byteLength) {
    const U = t instanceof ArrayBuffer ? t : t.buffer, D = t instanceof ArrayBuffer ? 0 : t.byteOffset;
    v({
      type: "segmenttransmuxingstart",
      segment: g
    }), e.postMessage({
      action: "push",
      // Send the typed-array of data as an ArrayBuffer so that
      // it can be sent as a "Transferable" and avoid the costly
      // memory copy
      data: U,
      // To recreate the original typed-array, we need information
      // about what portion of the ArrayBuffer it was a view into
      byteOffset: D,
      byteLength: t.byteLength
    }, [U]);
  }
  p && e.postMessage({
    action: "endTimeline"
  }), e.postMessage({
    action: "flush"
  });
}, v3 = (n) => {
  n.currentTransmux = null, n.transmuxQueue.length && (n.currentTransmux = n.transmuxQueue.shift(), typeof n.currentTransmux == "function" ? n.currentTransmux() : y3(n.currentTransmux));
}, G_ = (n, e) => {
  n.postMessage({
    action: e
  }), v3(n);
}, x3 = (n, e) => {
  if (!e.currentTransmux) {
    e.currentTransmux = n, G_(e, n);
    return;
  }
  e.transmuxQueue.push(G_.bind(null, e, n));
}, sL = (n) => {
  x3("reset", n);
}, oL = (n) => {
  x3("endTimeline", n);
}, _3 = (n) => {
  if (!n.transmuxer.currentTransmux) {
    n.transmuxer.currentTransmux = n, y3(n);
    return;
  }
  n.transmuxer.transmuxQueue.push(n);
}, uL = (n) => {
  const e = new nL();
  e.currentTransmux = null, e.transmuxQueue = [];
  const t = e.terminate;
  return e.terminate = () => (e.currentTransmux = null, e.transmuxQueue.length = 0, t.call(e)), e.postMessage({
    action: "init",
    options: n
  }), e;
};
var Mp = {
  reset: sL,
  endTimeline: oL,
  transmux: _3,
  createTransmuxer: uL
};
const ha = function(n) {
  const e = n.transmuxer, t = n.endAction || n.action, i = n.callback, r = Lt({}, n, {
    endAction: null,
    transmuxer: null,
    callback: null
  }), a = (s) => {
    s.data.action === t && (e.removeEventListener("message", a), s.data.data && (s.data.data = new Uint8Array(s.data.data, n.byteOffset || 0, n.byteLength || s.data.data.byteLength), n.data && (n.data = s.data.data)), i(s.data));
  };
  if (e.addEventListener("message", a), n.data) {
    const s = n.data instanceof ArrayBuffer;
    r.byteOffset = s ? 0 : n.data.byteOffset, r.byteLength = n.data.byteLength;
    const o = [s ? n.data : n.data.buffer];
    e.postMessage(r, o);
  } else
    e.postMessage(r);
}, yi = {
  FAILURE: 2,
  TIMEOUT: -101,
  ABORTED: -102
}, T3 = "wvtt", Im = (n) => {
  n.forEach((e) => {
    e.abort();
  });
}, cL = (n) => ({
  bandwidth: n.bandwidth,
  bytesReceived: n.bytesReceived || 0,
  roundTripTime: n.roundTripTime || 0
}), lL = (n) => {
  const e = n.target, i = {
    bandwidth: 1 / 0,
    bytesReceived: 0,
    roundTripTime: Date.now() - e.requestTime || 0
  };
  return i.bytesReceived = n.loaded, i.bandwidth = Math.floor(i.bytesReceived / i.roundTripTime * 8 * 1e3), i;
}, C0 = (n, e) => {
  const {
    requestType: t
  } = e, i = Pr({
    requestType: t,
    request: e,
    error: n
  });
  return e.timedout ? {
    status: e.status,
    message: "HLS request timed-out at URL: " + e.uri,
    code: yi.TIMEOUT,
    xhr: e,
    metadata: i
  } : e.aborted ? {
    status: e.status,
    message: "HLS request aborted at URL: " + e.uri,
    code: yi.ABORTED,
    xhr: e,
    metadata: i
  } : n ? {
    status: e.status,
    message: "HLS request errored at URL: " + e.uri,
    code: yi.FAILURE,
    xhr: e,
    metadata: i
  } : e.responseType === "arraybuffer" && e.response.byteLength === 0 ? {
    status: e.status,
    message: "Empty HLS response at URL: " + e.uri,
    code: yi.FAILURE,
    xhr: e,
    metadata: i
  } : null;
}, X_ = (n, e, t, i) => (r, a) => {
  const s = a.response, o = C0(r, a);
  if (o)
    return t(o, n);
  if (s.byteLength !== 16)
    return t({
      status: a.status,
      message: "Invalid HLS key at URL: " + a.uri,
      code: yi.FAILURE,
      xhr: a
    }, n);
  const u = new DataView(s), c = new Uint32Array([u.getUint32(0), u.getUint32(4), u.getUint32(8), u.getUint32(12)]);
  for (let h = 0; h < e.length; h++)
    e[h].bytes = c;
  const l = {
    uri: a.uri
  };
  return i({
    type: "segmentkeyloadcomplete",
    segment: n,
    keyInfo: l
  }), t(null, n);
}, dL = (n, e) => {
  e === T3 && n.transmuxer.postMessage({
    action: "initMp4WebVttParser",
    data: n.map.bytes
  });
}, fL = (n, e, t) => {
  e === T3 && ha({
    action: "getMp4WebVttText",
    data: n.bytes,
    transmuxer: n.transmuxer,
    callback: ({
      data: i,
      mp4VttCues: r
    }) => {
      n.bytes = i, t(null, n, {
        mp4VttCues: r
      });
    }
  });
}, w3 = (n, e) => {
  const t = Yg(n.map.bytes);
  if (t !== "mp4") {
    const i = n.map.resolvedUri || n.map.uri, r = t || "unknown";
    return e({
      internal: !0,
      message: `Found unsupported ${r} container for initialization segment at URL: ${i}`,
      code: yi.FAILURE,
      metadata: {
        mediaType: r
      }
    });
  }
  ha({
    action: "probeMp4Tracks",
    data: n.map.bytes,
    transmuxer: n.transmuxer,
    callback: ({
      tracks: i,
      data: r
    }) => (n.map.bytes = r, i.forEach(function(a) {
      n.map.tracks = n.map.tracks || {}, !n.map.tracks[a.type] && (n.map.tracks[a.type] = a, typeof a.id == "number" && a.timescale && (n.map.timescales = n.map.timescales || {}, n.map.timescales[a.id] = a.timescale), a.type === "text" && dL(n, a.codec));
    }), e(null))
  });
}, hL = ({
  segment: n,
  finishProcessingFn: e,
  triggerSegmentEventFn: t
}) => (i, r) => {
  const a = C0(i, r);
  if (a)
    return e(a, n);
  const s = new Uint8Array(r.response);
  if (t({
    type: "segmentloaded",
    segment: n
  }), n.map.key)
    return n.map.encryptedBytes = s, e(null, n);
  n.map.bytes = s, w3(n, function(o) {
    if (o)
      return o.xhr = r, o.status = r.status, e(o, n);
    e(null, n);
  });
}, pL = ({
  segment: n,
  finishProcessingFn: e,
  responseType: t,
  triggerSegmentEventFn: i
}) => (r, a) => {
  const s = C0(r, a);
  if (s)
    return e(s, n);
  i({
    type: "segmentloaded",
    segment: n
  });
  const o = (
    // although responseText "should" exist, this guard serves to prevent an error being
    // thrown for two primary cases:
    // 1. the mime type override stops working, or is not implemented for a specific
    //    browser
    // 2. when using mock XHR libraries like sinon that do not allow the override behavior
    t === "arraybuffer" || !a.responseText ? a.response : J9(a.responseText.substring(n.lastReachedChar || 0))
  );
  return n.stats = cL(a), n.key ? n.encryptedBytes = new Uint8Array(o) : n.bytes = new Uint8Array(o), e(null, n);
}, mL = ({
  segment: n,
  bytes: e,
  trackInfoFn: t,
  timingInfoFn: i,
  videoSegmentTimingInfoFn: r,
  audioSegmentTimingInfoFn: a,
  id3Fn: s,
  captionsFn: o,
  isEndOfTimeline: u,
  endedTimelineFn: c,
  dataFn: l,
  doneFn: h,
  onTransmuxerLog: f,
  triggerSegmentEventFn: d
}) => {
  const y = n.map && n.map.tracks || {}, m = !!(y.audio && y.video);
  let b = i.bind(null, n, "audio", "start");
  const p = i.bind(null, n, "audio", "end");
  let g = i.bind(null, n, "video", "start");
  const v = i.bind(null, n, "video", "end"), _ = () => _3({
    bytes: e,
    transmuxer: n.transmuxer,
    audioAppendStart: n.audioAppendStart,
    gopsToAlignWith: n.gopsToAlignWith,
    remux: m,
    onData: (x) => {
      x.type = x.type === "combined" ? "video" : x.type, l(n, x);
    },
    onTrackInfo: (x) => {
      t && (m && (x.isMuxed = !0), t(n, x));
    },
    onAudioTimingInfo: (x) => {
      b && typeof x.start < "u" && (b(x.start), b = null), p && typeof x.end < "u" && p(x.end);
    },
    onVideoTimingInfo: (x) => {
      g && typeof x.start < "u" && (g(x.start), g = null), v && typeof x.end < "u" && v(x.end);
    },
    onVideoSegmentTimingInfo: (x) => {
      const T = {
        pts: {
          start: x.start.presentation,
          end: x.end.presentation
        },
        dts: {
          start: x.start.decode,
          end: x.end.decode
        }
      };
      d({
        type: "segmenttransmuxingtiminginfoavailable",
        segment: n,
        timingInfo: T
      }), r(x);
    },
    onAudioSegmentTimingInfo: (x) => {
      const T = {
        pts: {
          start: x.start.pts,
          end: x.end.pts
        },
        dts: {
          start: x.start.dts,
          end: x.end.dts
        }
      };
      d({
        type: "segmenttransmuxingtiminginfoavailable",
        segment: n,
        timingInfo: T
      }), a(x);
    },
    onId3: (x, T) => {
      s(n, x, T);
    },
    onCaptions: (x) => {
      o(n, [x]);
    },
    isEndOfTimeline: u,
    onEndedTimeline: () => {
      c();
    },
    onTransmuxerLog: f,
    onDone: (x, T) => {
      h && (x.type = x.type === "combined" ? "video" : x.type, d({
        type: "segmenttransmuxingcomplete",
        segment: n
      }), h(T, n, x));
    },
    segment: n,
    triggerSegmentEventFn: d
  });
  ha({
    action: "probeTs",
    transmuxer: n.transmuxer,
    data: e,
    baseStartTime: n.baseStartTime,
    callback: (x) => {
      n.bytes = e = x.data;
      const T = x.result;
      T && (t(n, {
        hasAudio: T.hasAudio,
        hasVideo: T.hasVideo,
        isMuxed: m
      }), t = null), _();
    }
  });
}, E3 = ({
  segment: n,
  bytes: e,
  trackInfoFn: t,
  timingInfoFn: i,
  videoSegmentTimingInfoFn: r,
  audioSegmentTimingInfoFn: a,
  id3Fn: s,
  captionsFn: o,
  isEndOfTimeline: u,
  endedTimelineFn: c,
  dataFn: l,
  doneFn: h,
  onTransmuxerLog: f,
  triggerSegmentEventFn: d
}) => {
  let y = new Uint8Array(e);
  if (FR(y)) {
    n.isFmp4 = !0;
    const {
      tracks: m
    } = n.map;
    if (m.text && (!m.audio || !m.video)) {
      l(n, {
        data: y,
        type: "text"
      }), fL(n, m.text.codec, h);
      return;
    }
    const p = {
      isFmp4: !0,
      hasVideo: !!m.video,
      hasAudio: !!m.audio
    };
    m.audio && m.audio.codec && m.audio.codec !== "enca" && (p.audioCodec = m.audio.codec), m.video && m.video.codec && m.video.codec !== "encv" && (p.videoCodec = m.video.codec), m.video && m.audio && (p.isMuxed = !0), t(n, p);
    const g = (v, _) => {
      l(n, {
        data: y,
        type: p.hasAudio && !p.isMuxed ? "audio" : "video"
      }), _ && _.length && s(n, _), v && v.length && o(n, v), h(null, n, {});
    };
    ha({
      action: "probeMp4StartTime",
      timescales: n.map.timescales,
      data: y,
      transmuxer: n.transmuxer,
      callback: ({
        data: v,
        startTime: _
      }) => {
        e = v.buffer, n.bytes = y = v, p.hasAudio && !p.isMuxed && i(n, "audio", "start", _), p.hasVideo && i(n, "video", "start", _), ha({
          action: "probeEmsgID3",
          data: y,
          transmuxer: n.transmuxer,
          offset: _,
          callback: ({
            emsgData: x,
            id3Frames: T
          }) => {
            if (e = x.buffer, n.bytes = y = x, !m.video || !x.byteLength || !n.transmuxer) {
              g(void 0, T);
              return;
            }
            ha({
              action: "pushMp4Captions",
              endAction: "mp4Captions",
              transmuxer: n.transmuxer,
              data: y,
              timescales: n.map.timescales,
              trackIds: [m.video.id],
              callback: (E) => {
                e = E.data.buffer, n.bytes = y = E.data, E.logs.forEach(function(U) {
                  f(ft(U, {
                    stream: "mp4CaptionParser"
                  }));
                }), g(E.captions, T);
              }
            });
          }
        });
      }
    });
    return;
  }
  if (!n.transmuxer) {
    h(null, n, {});
    return;
  }
  if (typeof n.container > "u" && (n.container = Yg(y)), n.container !== "ts" && n.container !== "aac") {
    t(n, {
      hasAudio: !1,
      hasVideo: !1
    }), h(null, n, {});
    return;
  }
  mL({
    segment: n,
    bytes: e,
    trackInfoFn: t,
    timingInfoFn: i,
    videoSegmentTimingInfoFn: r,
    audioSegmentTimingInfoFn: a,
    id3Fn: s,
    captionsFn: o,
    isEndOfTimeline: u,
    endedTimelineFn: c,
    dataFn: l,
    doneFn: h,
    onTransmuxerLog: f,
    triggerSegmentEventFn: d
  });
}, D3 = function({
  id: n,
  key: e,
  encryptedBytes: t,
  decryptionWorker: i,
  segment: r,
  doneFn: a
}, s) {
  const o = (c) => {
    if (c.data.source === n) {
      i.removeEventListener("message", o);
      const l = c.data.decrypted;
      s(new Uint8Array(l.bytes, l.byteOffset, l.byteLength));
    }
  };
  i.onerror = () => {
    const c = "An error occurred in the decryption worker", l = Cr({
      segment: r
    }), h = {
      message: c,
      metadata: {
        error: new Error(c),
        errorType: ke.Error.StreamingFailedToDecryptSegment,
        segmentInfo: l,
        keyInfo: {
          uri: r.key.resolvedUri || r.map.key.resolvedUri
        }
      }
    };
    a(h, r);
  }, i.addEventListener("message", o);
  let u;
  e.bytes.slice ? u = e.bytes.slice() : u = new Uint32Array(Array.prototype.slice.call(e.bytes)), i.postMessage(c3({
    source: n,
    encrypted: t,
    key: u,
    iv: e.iv
  }), [t.buffer, u.buffer]);
}, gL = ({
  decryptionWorker: n,
  segment: e,
  trackInfoFn: t,
  timingInfoFn: i,
  videoSegmentTimingInfoFn: r,
  audioSegmentTimingInfoFn: a,
  id3Fn: s,
  captionsFn: o,
  isEndOfTimeline: u,
  endedTimelineFn: c,
  dataFn: l,
  doneFn: h,
  onTransmuxerLog: f,
  triggerSegmentEventFn: d
}) => {
  d({
    type: "segmentdecryptionstart"
  }), D3({
    id: e.requestId,
    key: e.key,
    encryptedBytes: e.encryptedBytes,
    decryptionWorker: n,
    segment: e,
    doneFn: h
  }, (y) => {
    e.bytes = y, d({
      type: "segmentdecryptioncomplete",
      segment: e
    }), E3({
      segment: e,
      bytes: e.bytes,
      trackInfoFn: t,
      timingInfoFn: i,
      videoSegmentTimingInfoFn: r,
      audioSegmentTimingInfoFn: a,
      id3Fn: s,
      captionsFn: o,
      isEndOfTimeline: u,
      endedTimelineFn: c,
      dataFn: l,
      doneFn: h,
      onTransmuxerLog: f,
      triggerSegmentEventFn: d
    });
  });
}, bL = ({
  activeXhrs: n,
  decryptionWorker: e,
  trackInfoFn: t,
  timingInfoFn: i,
  videoSegmentTimingInfoFn: r,
  audioSegmentTimingInfoFn: a,
  id3Fn: s,
  captionsFn: o,
  isEndOfTimeline: u,
  endedTimelineFn: c,
  dataFn: l,
  doneFn: h,
  onTransmuxerLog: f,
  triggerSegmentEventFn: d
}) => {
  let y = 0, m = !1;
  return (b, p) => {
    if (!m) {
      if (b)
        return m = !0, Im(n), h(b, p);
      if (y += 1, y === n.length) {
        const g = function() {
          if (p.encryptedBytes)
            return gL({
              decryptionWorker: e,
              segment: p,
              trackInfoFn: t,
              timingInfoFn: i,
              videoSegmentTimingInfoFn: r,
              audioSegmentTimingInfoFn: a,
              id3Fn: s,
              captionsFn: o,
              isEndOfTimeline: u,
              endedTimelineFn: c,
              dataFn: l,
              doneFn: h,
              onTransmuxerLog: f,
              triggerSegmentEventFn: d
            });
          E3({
            segment: p,
            bytes: p.bytes,
            trackInfoFn: t,
            timingInfoFn: i,
            videoSegmentTimingInfoFn: r,
            audioSegmentTimingInfoFn: a,
            id3Fn: s,
            captionsFn: o,
            isEndOfTimeline: u,
            endedTimelineFn: c,
            dataFn: l,
            doneFn: h,
            onTransmuxerLog: f,
            triggerSegmentEventFn: d
          });
        };
        if (p.endOfAllRequests = Date.now(), p.map && p.map.encryptedBytes && !p.map.bytes)
          return d({
            type: "segmentdecryptionstart",
            segment: p
          }), D3({
            decryptionWorker: e,
            // add -init to the "id" to differentiate between segment
            // and init segment decryption, just in case they happen
            // at the same time at some point in the future.
            id: p.requestId + "-init",
            encryptedBytes: p.map.encryptedBytes,
            key: p.map.key,
            segment: p,
            doneFn: h
          }, (v) => {
            p.map.bytes = v, d({
              type: "segmentdecryptioncomplete",
              segment: p
            }), w3(p, (_) => {
              if (_)
                return Im(n), h(_, p);
              g();
            });
          });
        g();
      }
    }
  };
}, yL = ({
  loadendState: n,
  abortFn: e
}) => (t) => {
  t.target.aborted && e && !n.calledAbortFn && (e(), n.calledAbortFn = !0);
}, vL = ({
  segment: n,
  progressFn: e,
  trackInfoFn: t,
  timingInfoFn: i,
  videoSegmentTimingInfoFn: r,
  audioSegmentTimingInfoFn: a,
  id3Fn: s,
  captionsFn: o,
  isEndOfTimeline: u,
  endedTimelineFn: c,
  dataFn: l
}) => (h) => {
  if (!h.target.aborted)
    return n.stats = ft(n.stats, lL(h)), !n.stats.firstBytesReceivedAt && n.stats.bytesReceived && (n.stats.firstBytesReceivedAt = Date.now()), e(h, n);
}, xL = ({
  xhr: n,
  xhrOptions: e,
  decryptionWorker: t,
  segment: i,
  abortFn: r,
  progressFn: a,
  trackInfoFn: s,
  timingInfoFn: o,
  videoSegmentTimingInfoFn: u,
  audioSegmentTimingInfoFn: c,
  id3Fn: l,
  captionsFn: h,
  isEndOfTimeline: f,
  endedTimelineFn: d,
  dataFn: y,
  doneFn: m,
  onTransmuxerLog: b,
  triggerSegmentEventFn: p
}) => {
  const g = [], v = bL({
    activeXhrs: g,
    decryptionWorker: t,
    trackInfoFn: s,
    timingInfoFn: o,
    videoSegmentTimingInfoFn: u,
    audioSegmentTimingInfoFn: c,
    id3Fn: l,
    captionsFn: h,
    isEndOfTimeline: f,
    endedTimelineFn: d,
    dataFn: y,
    doneFn: m,
    onTransmuxerLog: b,
    triggerSegmentEventFn: p
  });
  if (i.key && !i.key.bytes) {
    const U = [i.key];
    i.map && !i.map.bytes && i.map.key && i.map.key.resolvedUri === i.key.resolvedUri && U.push(i.map.key);
    const D = ft(e, {
      uri: i.key.resolvedUri,
      responseType: "arraybuffer",
      requestType: "segment-key"
    }), L = X_(i, U, v, p), j = {
      uri: i.key.resolvedUri
    };
    p({
      type: "segmentkeyloadstart",
      segment: i,
      keyInfo: j
    });
    const C = n(D, L);
    g.push(C);
  }
  if (i.map && !i.map.bytes) {
    if (i.map.key && (!i.key || i.key.resolvedUri !== i.map.key.resolvedUri)) {
      const C = ft(e, {
        uri: i.map.key.resolvedUri,
        responseType: "arraybuffer",
        requestType: "segment-key"
      }), k = X_(i, [i.map.key], v, p), I = {
        uri: i.map.key.resolvedUri
      };
      p({
        type: "segmentkeyloadstart",
        segment: i,
        keyInfo: I
      });
      const $ = n(C, k);
      g.push($);
    }
    const D = ft(e, {
      uri: i.map.resolvedUri,
      responseType: "arraybuffer",
      headers: Am(i.map),
      requestType: "segment-media-initialization"
    }), L = hL({
      segment: i,
      finishProcessingFn: v,
      triggerSegmentEventFn: p
    });
    p({
      type: "segmentloadstart",
      segment: i
    });
    const j = n(D, L);
    g.push(j);
  }
  const _ = ft(e, {
    uri: i.part && i.part.resolvedUri || i.resolvedUri,
    responseType: "arraybuffer",
    headers: Am(i),
    requestType: "segment"
  }), x = pL({
    segment: i,
    finishProcessingFn: v,
    responseType: _.responseType,
    triggerSegmentEventFn: p
  });
  p({
    type: "segmentloadstart",
    segment: i
  });
  const T = n(_, x);
  T.addEventListener("progress", vL({
    segment: i,
    progressFn: a,
    trackInfoFn: s,
    timingInfoFn: o,
    videoSegmentTimingInfoFn: u,
    audioSegmentTimingInfoFn: c,
    id3Fn: l,
    captionsFn: h,
    isEndOfTimeline: f,
    endedTimelineFn: d,
    dataFn: y
  })), g.push(T);
  const E = {};
  return g.forEach((U) => {
    U.addEventListener("loadend", yL({
      loadendState: E,
      abortFn: r
    }));
  }), () => Im(g);
}, Tu = jn("PlaylistSelector"), K_ = function(n) {
  if (!n || !n.playlist)
    return;
  const e = n.playlist;
  return JSON.stringify({
    id: e.id,
    bandwidth: n.bandwidth,
    width: n.width,
    height: n.height,
    codecs: e.attributes && e.attributes.CODECS || ""
  });
}, pa = function(n, e) {
  if (!n)
    return "";
  const t = me.getComputedStyle(n);
  return t ? t[e] : "";
}, ma = function(n, e) {
  const t = n.slice();
  n.sort(function(i, r) {
    const a = e(i, r);
    return a === 0 ? t.indexOf(i) - t.indexOf(r) : a;
  });
}, A0 = function(n, e) {
  let t, i;
  return n.attributes.BANDWIDTH && (t = n.attributes.BANDWIDTH), t = t || me.Number.MAX_VALUE, e.attributes.BANDWIDTH && (i = e.attributes.BANDWIDTH), i = i || me.Number.MAX_VALUE, t - i;
}, _L = function(n, e) {
  let t, i;
  return n.attributes.RESOLUTION && n.attributes.RESOLUTION.width && (t = n.attributes.RESOLUTION.width), t = t || me.Number.MAX_VALUE, e.attributes.RESOLUTION && e.attributes.RESOLUTION.width && (i = e.attributes.RESOLUTION.width), i = i || me.Number.MAX_VALUE, t === i && n.attributes.BANDWIDTH && e.attributes.BANDWIDTH ? n.attributes.BANDWIDTH - e.attributes.BANDWIDTH : t - i;
};
let S3 = function(n) {
  const {
    main: e,
    bandwidth: t,
    playerWidth: i,
    playerHeight: r,
    playerObjectFit: a,
    limitRenditionByPlayerDimensions: s,
    playlistController: o
  } = n;
  if (!e)
    return;
  const u = {
    bandwidth: t,
    width: i,
    height: r,
    limitRenditionByPlayerDimensions: s
  };
  let c = e.playlists;
  pn.isAudioOnly(e) && (c = o.getAudioTrackPlaylists_(), u.audioOnly = !0);
  let l = c.map((E) => {
    let U;
    const D = E.attributes && E.attributes.RESOLUTION && E.attributes.RESOLUTION.width, L = E.attributes && E.attributes.RESOLUTION && E.attributes.RESOLUTION.height;
    return U = E.attributes && E.attributes.BANDWIDTH, U = U || me.Number.MAX_VALUE, {
      bandwidth: U,
      width: D,
      height: L,
      playlist: E
    };
  });
  ma(l, (E, U) => E.bandwidth - U.bandwidth), l = l.filter((E) => !pn.isIncompatible(E.playlist));
  let h = l.filter((E) => pn.isEnabled(E.playlist));
  h.length || (h = l.filter((E) => !pn.isDisabled(E.playlist)));
  const f = h.filter((E) => E.bandwidth * qt.BANDWIDTH_VARIANCE < t);
  let d = f[f.length - 1];
  const y = f.filter((E) => E.bandwidth === d.bandwidth)[0];
  if (s === !1) {
    const E = y || h[0] || l[0];
    if (E && E.playlist) {
      let U = "sortedPlaylistReps";
      return y && (U = "bandwidthBestRep"), h[0] && (U = "enabledPlaylistReps"), Tu(`choosing ${K_(E)} using ${U} with options`, u), E.playlist;
    }
    return Tu("could not choose a playlist with options", u), null;
  }
  const m = f.filter((E) => E.width && E.height);
  ma(m, (E, U) => E.width - U.width);
  const b = m.filter((E) => E.width === i && E.height === r);
  d = b[b.length - 1];
  const p = b.filter((E) => E.bandwidth === d.bandwidth)[0];
  let g, v, _;
  p || (g = m.filter((E) => a === "cover" ? E.width > i && E.height > r : E.width > i || E.height > r), v = g.filter((E) => E.width === g[0].width && E.height === g[0].height), d = v[v.length - 1], _ = v.filter((E) => E.bandwidth === d.bandwidth)[0]);
  let x;
  if (o.leastPixelDiffSelector) {
    const E = m.map((U) => (U.pixelDiff = Math.abs(U.width - i) + Math.abs(U.height - r), U));
    ma(E, (U, D) => U.pixelDiff === D.pixelDiff ? D.bandwidth - U.bandwidth : U.pixelDiff - D.pixelDiff), x = E[0];
  }
  const T = x || _ || p || y || h[0] || l[0];
  if (T && T.playlist) {
    let E = "sortedPlaylistReps";
    return x ? E = "leastPixelDiffRep" : _ ? E = "resolutionPlusOneRep" : p ? E = "resolutionBestRep" : y ? E = "bandwidthBestRep" : h[0] && (E = "enabledPlaylistReps"), Tu(`choosing ${K_(T)} using ${E} with options`, u), T.playlist;
  }
  return Tu("could not choose a playlist with options", u), null;
};
const Y_ = function() {
  let n = this.useDevicePixelRatio && me.devicePixelRatio || 1;
  return isNaN(this.customPixelRatio) || (n = this.customPixelRatio), S3({
    main: this.playlists.main,
    bandwidth: this.systemBandwidth,
    playerWidth: parseInt(pa(this.tech_.el(), "width"), 10) * n,
    playerHeight: parseInt(pa(this.tech_.el(), "height"), 10) * n,
    playerObjectFit: this.usePlayerObjectFit ? pa(this.tech_.el(), "objectFit") : "",
    limitRenditionByPlayerDimensions: this.limitRenditionByPlayerDimensions,
    playlistController: this.playlistController_
  });
}, TL = function(n) {
  let e = -1, t = -1;
  if (n < 0 || n > 1)
    throw new Error("Moving average bandwidth decay must be between 0 and 1.");
  return function() {
    let i = this.useDevicePixelRatio && me.devicePixelRatio || 1;
    return isNaN(this.customPixelRatio) || (i = this.customPixelRatio), e < 0 && (e = this.systemBandwidth, t = this.systemBandwidth), this.systemBandwidth > 0 && this.systemBandwidth !== t && (e = n * this.systemBandwidth + (1 - n) * e, t = this.systemBandwidth), S3({
      main: this.playlists.main,
      bandwidth: e,
      playerWidth: parseInt(pa(this.tech_.el(), "width"), 10) * i,
      playerHeight: parseInt(pa(this.tech_.el(), "height"), 10) * i,
      playerObjectFit: this.usePlayerObjectFit ? pa(this.tech_.el(), "objectFit") : "",
      limitRenditionByPlayerDimensions: this.limitRenditionByPlayerDimensions,
      playlistController: this.playlistController_
    });
  };
}, wL = function(n) {
  const {
    main: e,
    currentTime: t,
    bandwidth: i,
    duration: r,
    segmentDuration: a,
    timeUntilRebuffer: s,
    currentTimeline: o,
    syncController: u
  } = n, c = e.playlists.filter((y) => !pn.isIncompatible(y));
  let l = c.filter(pn.isEnabled);
  l.length || (l = c.filter((y) => !pn.isDisabled(y)));
  const f = l.filter(pn.hasAttribute.bind(null, "BANDWIDTH")).map((y) => {
    const b = u.getSyncPoint(y, r, o, t) ? 1 : 2, g = pn.estimateSegmentRequestTime(a, i, y) * b - s;
    return {
      playlist: y,
      rebufferingImpact: g
    };
  }), d = f.filter((y) => y.rebufferingImpact <= 0);
  return ma(d, (y, m) => A0(m.playlist, y.playlist)), d.length ? d[0] : (ma(f, (y, m) => y.rebufferingImpact - m.rebufferingImpact), f[0] || null);
}, EL = function() {
  const n = this.playlists.main.playlists.filter(pn.isEnabled);
  return ma(n, (t, i) => A0(t, i)), n.filter((t) => !!Ns(this.playlists.main, t).video)[0] || null;
}, DL = (n) => {
  let e = 0, t;
  return n.bytes && (t = new Uint8Array(n.bytes), n.segments.forEach((i) => {
    t.set(i, e), e += i.byteLength;
  })), t;
};
function C3(n) {
  try {
    return new URL(n).pathname.split("/").slice(-2).join("/");
  } catch {
    return "";
  }
}
const SL = function(n, e, t) {
  if (!n[t]) {
    e.trigger({
      type: "usage",
      name: "vhs-608"
    });
    let i = t;
    /^cc708_/.test(t) && (i = "SERVICE" + t.split("_")[1]);
    const r = e.textTracks().getTrackById(i);
    if (r)
      n[t] = r;
    else {
      const a = e.options_.vhs && e.options_.vhs.captionServices || {};
      let s = t, o = t, u = !1;
      const c = a[i];
      c && (s = c.label, o = c.language, u = c.default), n[t] = e.addRemoteTextTrack({
        kind: "captions",
        id: i,
        // TODO: investigate why this doesn't seem to turn the caption on by default
        default: u,
        label: s,
        language: o
      }, !1).track;
    }
  }
}, CL = function({
  inbandTextTracks: n,
  captionArray: e,
  timestampOffset: t
}) {
  if (!e)
    return;
  const i = me.WebKitDataCue || me.VTTCue;
  e.forEach((r) => {
    const a = r.stream;
    r.content ? r.content.forEach((s) => {
      const o = new i(r.startTime + t, r.endTime + t, s.text);
      o.line = s.line, o.align = "left", o.position = s.position, o.positionAlign = "line-left", n[a].addCue(o);
    }) : n[a].addCue(new i(r.startTime + t, r.endTime + t, r.text));
  });
}, AL = function(n) {
  Object.defineProperties(n.frame, {
    id: {
      get() {
        return ke.log.warn("cue.frame.id is deprecated. Use cue.value.key instead."), n.value.key;
      }
    },
    value: {
      get() {
        return ke.log.warn("cue.frame.value is deprecated. Use cue.value.data instead."), n.value.data;
      }
    },
    privateData: {
      get() {
        return ke.log.warn("cue.frame.privateData is deprecated. Use cue.value.data instead."), n.value.data;
      }
    }
  });
}, kL = ({
  inbandTextTracks: n,
  metadataArray: e,
  timestampOffset: t,
  videoDuration: i
}) => {
  if (!e)
    return;
  const r = me.WebKitDataCue || me.VTTCue, a = n.metadataTrack_;
  if (!a || (e.forEach((l) => {
    const h = l.cueTime + t;
    typeof h != "number" || me.isNaN(h) || h < 0 || !(h < 1 / 0) || !l.frames || !l.frames.length || l.frames.forEach((f) => {
      const d = new r(h, h, f.value || f.url || f.data || "");
      d.frame = f, d.value = f, AL(d), a.addCue(d);
    });
  }), !a.cues || !a.cues.length))
    return;
  const s = a.cues, o = [];
  for (let l = 0; l < s.length; l++)
    s[l] && o.push(s[l]);
  const u = o.reduce((l, h) => {
    const f = l[h.startTime] || [];
    return f.push(h), l[h.startTime] = f, l;
  }, {}), c = Object.keys(u).sort((l, h) => Number(l) - Number(h));
  c.forEach((l, h) => {
    const f = u[l], d = isFinite(i) ? i : l, y = Number(c[h + 1]) || d;
    f.forEach((m) => {
      m.endTime = y;
    });
  });
}, IL = {
  id: "ID",
  class: "CLASS",
  startDate: "START-DATE",
  duration: "DURATION",
  endDate: "END-DATE",
  endOnNext: "END-ON-NEXT",
  plannedDuration: "PLANNED-DURATION",
  scte35Out: "SCTE35-OUT",
  scte35In: "SCTE35-IN"
}, UL = /* @__PURE__ */ new Set(["id", "class", "startDate", "duration", "endDate", "endOnNext", "startTime", "endTime", "processDateRange"]), RL = ({
  inbandTextTracks: n,
  dateRanges: e
}) => {
  const t = n.metadataTrack_;
  if (!t)
    return;
  const i = me.WebKitDataCue || me.VTTCue;
  e.forEach((r) => {
    for (const a of Object.keys(r)) {
      if (UL.has(a))
        continue;
      const s = new i(r.startTime, r.endTime, "");
      s.id = r.id, s.type = "com.apple.quicktime.HLS", s.value = {
        key: IL[a],
        data: r[a]
      }, (a === "scte35Out" || a === "scte35In") && (s.value.data = new Uint8Array(s.value.data.match(/[\da-f]{2}/gi)).buffer), t.addCue(s);
    }
    r.processDateRange();
  });
}, Q_ = (n, e, t) => {
  n.metadataTrack_ || (n.metadataTrack_ = t.addRemoteTextTrack({
    kind: "metadata",
    label: "Timed Metadata"
  }, !1).track, ke.browser.IS_ANY_SAFARI || (n.metadataTrack_.inBandMetadataTrackDispatchType = e));
}, Ds = function(n, e, t) {
  let i, r;
  if (t && t.cues)
    for (i = t.cues.length; i--; )
      r = t.cues[i], r.startTime >= n && r.endTime <= e && t.removeCue(r);
}, OL = function(n) {
  const e = n.cues;
  if (!e)
    return;
  const t = {};
  for (let i = e.length - 1; i >= 0; i--) {
    const r = e[i], a = `${r.startTime}-${r.endTime}-${r.text}`;
    t[a] ? n.removeCue(r) : t[a] = r;
  }
}, LL = (n, e, t) => {
  if (typeof e > "u" || e === null || !n.length)
    return [];
  const i = Math.ceil((e - t + 3) * Ar.ONE_SECOND_IN_TS);
  let r;
  for (r = 0; r < n.length && !(n[r].pts > i); r++)
    ;
  return n.slice(r);
}, PL = (n, e, t) => {
  if (!e.length)
    return n;
  if (t)
    return e.slice();
  const i = e[0].pts;
  let r = 0;
  for (r; r < n.length && !(n[r].pts >= i); r++)
    ;
  return n.slice(0, r).concat(e);
}, FL = (n, e, t, i) => {
  const r = Math.ceil((e - i) * Ar.ONE_SECOND_IN_TS), a = Math.ceil((t - i) * Ar.ONE_SECOND_IN_TS), s = n.slice();
  let o = n.length;
  for (; o-- && !(n[o].pts <= a); )
    ;
  if (o === -1)
    return s;
  let u = o + 1;
  for (; u-- && !(n[u].pts <= r); )
    ;
  return u = Math.max(u, 0), s.splice(u, o - u + 1), s;
}, NL = function(n, e) {
  if (!n && !e || !n && e || n && !e)
    return !1;
  if (n === e)
    return !0;
  const t = Object.keys(n).sort(), i = Object.keys(e).sort();
  if (t.length !== i.length)
    return !1;
  for (let r = 0; r < t.length; r++) {
    const a = t[r];
    if (a !== i[r] || n[a] !== e[a])
      return !1;
  }
  return !0;
}, ML = function(n, e, t) {
  e = e || [];
  const i = [];
  let r = 0;
  for (let a = 0; a < e.length; a++) {
    const s = e[a];
    if (n === s.timeline && (i.push(a), r += s.duration, r > t))
      return a;
  }
  return i.length === 0 ? 0 : i[i.length - 1];
}, xs = 1, BL = 500, Z_ = (n) => typeof n == "number" && isFinite(n), wu = 1 / 60, jL = (n, e, t) => n !== "main" || !e || !t ? null : !t.hasAudio && !t.hasVideo ? "Neither audio nor video found in segment." : e.hasVideo && !t.hasVideo ? "Only audio found in segment when we expected video. We can't switch to audio only from a stream that had video. To get rid of this message, please add codec information to the manifest." : !e.hasVideo && t.hasVideo ? "Video found in segment when we expected only audio. We can't switch to a stream with video from an audio only stream. To get rid of this message, please add codec information to the manifest." : null, qL = (n, e, t) => {
  let i = e - qt.BACK_BUFFER_LENGTH;
  n.length && (i = Math.max(i, n.start(0)));
  const r = e - t;
  return Math.min(r, i);
}, ta = (n) => {
  const {
    startOfSegment: e,
    duration: t,
    segment: i,
    part: r,
    playlist: {
      mediaSequence: a,
      id: s,
      segments: o = []
    },
    mediaIndex: u,
    partIndex: c,
    timeline: l
  } = n, h = o.length - 1;
  let f = "mediaIndex/partIndex increment";
  n.getMediaInfoForTime ? f = `getMediaInfoForTime (${n.getMediaInfoForTime})` : n.isSyncRequest && (f = "getSyncSegmentCandidate (isSyncRequest)"), n.independent && (f += ` with independent ${n.independent}`);
  const d = typeof c == "number", y = n.segment.uri ? "segment" : "pre-segment", m = d ? zS({
    preloadSegment: i
  }) - 1 : 0;
  return `${y} [${a + u}/${a + h}]` + (d ? ` part [${c}/${m}]` : "") + ` segment start/end [${i.start} => ${i.end}]` + (d ? ` part start/end [${r.start} => ${r.end}]` : "") + ` startOfSegment [${e}] duration [${t}] timeline [${l}] selected by [${f}] playlist [${s}]`;
}, J_ = (n) => `${n}TimingInfo`, WL = ({
  segmentTimeline: n,
  currentTimeline: e,
  startOfSegment: t,
  buffered: i,
  overrideCheck: r
}) => !r && n === e ? null : n < e ? t : i.length ? i.end(i.length - 1) : t, Um = ({
  timelineChangeController: n,
  currentTimeline: e,
  segmentTimeline: t,
  loaderType: i,
  audioDisabled: r
}) => {
  if (e === t)
    return !1;
  if (i === "audio") {
    const a = n.lastTimelineChange({
      type: "main"
    });
    return !a || a.to !== t;
  }
  if (i === "main" && r) {
    const a = n.pendingTimelineChange({
      type: "audio"
    });
    return !(a && a.to === t);
  }
  return !1;
}, VL = (n) => {
  if (!n)
    return !1;
  const e = n.pendingTimelineChange({
    type: "audio"
  }), t = n.pendingTimelineChange({
    type: "main"
  }), i = e && t, r = i && e.to !== t.to;
  return !!(i && e.from !== -1 && t.from !== -1 && r);
}, HL = (n) => {
  const e = n.timelineChangeController_.pendingTimelineChange({
    type: "audio"
  }), t = n.timelineChangeController_.pendingTimelineChange({
    type: "main"
  });
  return e && t && e.to < t.to;
}, Gi = (n) => {
  const e = n.pendingSegment_;
  if (!e)
    return;
  if (Um({
    timelineChangeController: n.timelineChangeController_,
    currentTimeline: n.currentTimeline_,
    segmentTimeline: e.timeline,
    loaderType: n.loaderType_,
    audioDisabled: n.audioDisabled_
  }) && VL(n.timelineChangeController_)) {
    if (HL(n)) {
      n.timelineChangeController_.trigger("audioTimelineBehind");
      return;
    }
    n.timelineChangeController_.trigger("fixBadTimelineChange");
  }
}, zL = (n) => {
  let e = 0;
  return ["video", "audio"].forEach(function(t) {
    const i = n[`${t}TimingInfo`];
    if (!i)
      return;
    const {
      start: r,
      end: a
    } = i;
    let s;
    typeof r == "bigint" || typeof a == "bigint" ? s = me.BigInt(a) - me.BigInt(r) : typeof r == "number" && typeof a == "number" && (s = a - r), typeof s < "u" && s > e && (e = s);
  }), typeof e == "bigint" && e < Number.MAX_SAFE_INTEGER && (e = Number(e)), e;
}, eT = ({
  segmentDuration: n,
  maxDuration: e
}) => n ? Math.round(n) > e + gi : !1, $L = (n, e) => {
  if (e !== "hls")
    return null;
  const t = zL({
    audioTimingInfo: n.audioTimingInfo,
    videoTimingInfo: n.videoTimingInfo
  });
  if (!t)
    return null;
  const i = n.playlist.targetDuration, r = eT({
    segmentDuration: t,
    maxDuration: i * 2
  }), a = eT({
    segmentDuration: t,
    maxDuration: i
  }), s = `Segment with index ${n.mediaIndex} from playlist ${n.playlist.id} has a duration of ${t} when the reported duration is ${n.duration} and the target duration is ${i}. For HLS content, a duration in excess of the target duration may result in playback issues. See the HLS specification section on EXT-X-TARGETDURATION for more details: https://tools.ietf.org/html/draft-pantos-http-live-streaming-23#section-4.3.3.1`;
  return r || a ? {
    severity: r ? "warn" : "info",
    message: s
  } : null;
}, Cr = ({
  type: n,
  segment: e
}) => {
  if (!e)
    return;
  const t = !!(e.key || e.map && e.map.ke), i = !!(e.map && !e.map.bytes), r = e.startOfSegment === void 0 ? e.start : e.startOfSegment;
  return {
    type: n || e.type,
    uri: e.resolvedUri || e.uri,
    start: r,
    duration: e.duration,
    isEncrypted: t,
    isMediaInitialization: i
  };
};
class Rm extends ke.EventTarget {
  constructor(e, t = {}) {
    if (super(), !e)
      throw new TypeError("Initialization settings are required");
    if (typeof e.currentTime != "function")
      throw new TypeError("No currentTime getter specified");
    if (!e.mediaSource)
      throw new TypeError("No MediaSource specified");
    this.bandwidth = e.bandwidth, this.throughput = {
      rate: 0,
      count: 0
    }, this.roundTrip = NaN, this.resetStats_(), this.mediaIndex = null, this.partIndex = null, this.hasPlayed_ = e.hasPlayed, this.currentTime_ = e.currentTime, this.seekable_ = e.seekable, this.seeking_ = e.seeking, this.duration_ = e.duration, this.mediaSource_ = e.mediaSource, this.vhs_ = e.vhs, this.loaderType_ = e.loaderType, this.currentMediaInfo_ = void 0, this.startingMediaInfo_ = void 0, this.segmentMetadataTrack_ = e.segmentMetadataTrack, this.goalBufferLength_ = e.goalBufferLength, this.sourceType_ = e.sourceType, this.sourceUpdater_ = e.sourceUpdater, this.inbandTextTracks_ = e.inbandTextTracks, this.state_ = "INIT", this.timelineChangeController_ = e.timelineChangeController, this.shouldSaveSegmentTimingInfo_ = !0, this.parse708captions_ = e.parse708captions, this.useDtsForTimestampOffset_ = e.useDtsForTimestampOffset, this.captionServices_ = e.captionServices, this.exactManifestTimings = e.exactManifestTimings, this.addMetadataToTextTrack = e.addMetadataToTextTrack, this.checkBufferTimeout_ = null, this.error_ = void 0, this.currentTimeline_ = -1, this.shouldForceTimestampOffsetAfterResync_ = !1, this.pendingSegment_ = null, this.xhrOptions_ = null, this.pendingSegments_ = [], this.audioDisabled_ = !1, this.isPendingTimestampOffset_ = !1, this.gopBuffer_ = [], this.timeMapping_ = 0, this.safeAppend_ = !1, this.appendInitSegment_ = {
      audio: !0,
      video: !0
    }, this.playlistOfLastInitSegment_ = {
      audio: null,
      video: null
    }, this.callQueue_ = [], this.loadQueue_ = [], this.metadataQueue_ = {
      id3: [],
      caption: []
    }, this.waitingOnRemove_ = !1, this.quotaExceededErrorRetryTimeout_ = null, this.activeInitSegmentId_ = null, this.initSegments_ = {}, this.cacheEncryptionKeys_ = e.cacheEncryptionKeys, this.keyCache_ = {}, this.decrypter_ = e.decrypter, this.syncController_ = e.syncController, this.syncPoint_ = {
      segmentIndex: 0,
      time: 0
    }, this.transmuxer_ = this.createTransmuxer_(), this.triggerSyncInfoUpdate_ = () => this.trigger("syncinfoupdate"), this.syncController_.on("syncinfoupdate", this.triggerSyncInfoUpdate_), this.mediaSource_.addEventListener("sourceopen", () => {
      this.isEndOfStream_() || (this.ended_ = !1);
    }), this.fetchAtBuffer_ = !1, this.logger_ = jn(`SegmentLoader[${this.loaderType_}]`), Object.defineProperty(this, "state", {
      get() {
        return this.state_;
      },
      set(i) {
        i !== this.state_ && (this.logger_(`${this.state_} -> ${i}`), this.state_ = i, this.trigger("statechange"));
      }
    }), this.sourceUpdater_.on("ready", () => {
      this.hasEnoughInfoToAppend_() ? this.processCallQueue_() : Gi(this);
    }), this.sourceUpdater_.on("codecschange", (i) => {
      this.trigger(Lt({
        type: "codecschange"
      }, i));
    }), this.loaderType_ === "main" && this.timelineChangeController_.on("pendingtimelinechange", () => {
      this.hasEnoughInfoToAppend_() ? this.processCallQueue_() : Gi(this);
    }), this.loaderType_ === "audio" && this.timelineChangeController_.on("timelinechange", (i) => {
      this.trigger(Lt({
        type: "timelinechange"
      }, i)), this.hasEnoughInfoToLoad_() ? this.processLoadQueue_() : Gi(this), this.hasEnoughInfoToAppend_() ? this.processCallQueue_() : Gi(this);
    });
  }
  /**
   * TODO: Current sync controller consists of many hls-specific strategies
   * media sequence sync is also hls-specific, and we would like to be protocol-agnostic on this level
   * this should be a part of the sync-controller and sync controller should expect different strategy list based on the protocol.
   *
   * @return {MediaSequenceSync|null}
   * @private
   */
  get mediaSequenceSync_() {
    return this.syncController_.getMediaSequenceSync(this.loaderType_);
  }
  createTransmuxer_() {
    return Mp.createTransmuxer({
      remux: !1,
      alignGopsAtEnd: this.safeAppend_,
      keepOriginalTimestamps: !0,
      parse708captions: this.parse708captions_,
      captionServices: this.captionServices_
    });
  }
  /**
   * reset all of our media stats
   *
   * @private
   */
  resetStats_() {
    this.mediaBytesTransferred = 0, this.mediaRequests = 0, this.mediaRequestsAborted = 0, this.mediaRequestsTimedout = 0, this.mediaRequestsErrored = 0, this.mediaTransferDuration = 0, this.mediaSecondsLoaded = 0, this.mediaAppends = 0;
  }
  /**
   * dispose of the SegmentLoader and reset to the default state
   */
  dispose() {
    this.trigger("dispose"), this.state = "DISPOSED", this.pause(), this.abort_(), this.transmuxer_ && this.transmuxer_.terminate(), this.resetStats_(), this.checkBufferTimeout_ && me.clearTimeout(this.checkBufferTimeout_), this.syncController_ && this.triggerSyncInfoUpdate_ && this.syncController_.off("syncinfoupdate", this.triggerSyncInfoUpdate_), this.off();
  }
  setAudio(e) {
    this.audioDisabled_ = !e, e ? this.appendInitSegment_.audio = !0 : this.sourceUpdater_.removeAudio(0, this.duration_());
  }
  /**
   * abort anything that is currently doing on with the SegmentLoader
   * and reset to a default state
   */
  abort() {
    if (this.state !== "WAITING") {
      this.pendingSegment_ && (this.pendingSegment_ = null), this.timelineChangeController_.clearPendingTimelineChange(this.loaderType_);
      return;
    }
    this.abort_(), this.state = "READY", this.paused() || this.monitorBuffer_();
  }
  /**
   * abort all pending xhr requests and null any pending segements
   *
   * @private
   */
  abort_() {
    this.pendingSegment_ && this.pendingSegment_.abortRequests && this.pendingSegment_.abortRequests(), this.pendingSegment_ = null, this.callQueue_ = [], this.loadQueue_ = [], this.metadataQueue_.id3 = [], this.metadataQueue_.caption = [], this.timelineChangeController_.clearPendingTimelineChange(this.loaderType_), this.waitingOnRemove_ = !1, me.clearTimeout(this.quotaExceededErrorRetryTimeout_), this.quotaExceededErrorRetryTimeout_ = null;
  }
  checkForAbort_(e) {
    return this.state === "APPENDING" && !this.pendingSegment_ ? (this.state = "READY", !0) : !this.pendingSegment_ || this.pendingSegment_.requestId !== e;
  }
  /**
   * set an error on the segment loader and null out any pending segements
   *
   * @param {Error} error the error to set on the SegmentLoader
   * @return {Error} the error that was set or that is currently set
   */
  error(e) {
    return typeof e < "u" && (this.logger_("error occurred:", e), this.error_ = e), this.pendingSegment_ = null, this.error_;
  }
  endOfStream() {
    this.ended_ = !0, this.transmuxer_ && Mp.reset(this.transmuxer_), this.gopBuffer_.length = 0, this.pause(), this.trigger("ended");
  }
  /**
   * Indicates which time ranges are buffered
   *
   * @return {TimeRange}
   *         TimeRange object representing the current buffered ranges
   */
  buffered_() {
    const e = this.getMediaInfo_();
    if (!this.sourceUpdater_ || !e)
      return Vt();
    if (this.loaderType_ === "main") {
      const {
        hasAudio: t,
        hasVideo: i,
        isMuxed: r
      } = e;
      if (i && t && !this.audioDisabled_ && !r)
        return this.sourceUpdater_.buffered();
      if (i)
        return this.sourceUpdater_.videoBuffered();
    }
    return this.sourceUpdater_.audioBuffered();
  }
  /**
   * Gets and sets init segment for the provided map
   *
   * @param {Object} map
   *        The map object representing the init segment to get or set
   * @param {boolean=} set
   *        If true, the init segment for the provided map should be saved
   * @return {Object}
   *         map object for desired init segment
   */
  initSegmentForMap(e, t = !1) {
    if (!e)
      return null;
    const i = Dc(e);
    let r = this.initSegments_[i];
    return t && !r && e.bytes && (this.initSegments_[i] = r = {
      resolvedUri: e.resolvedUri,
      byterange: e.byterange,
      bytes: e.bytes,
      tracks: e.tracks,
      timescales: e.timescales
    }), r || e;
  }
  /**
   * Gets and sets key for the provided key
   *
   * @param {Object} key
   *        The key object representing the key to get or set
   * @param {boolean=} set
   *        If true, the key for the provided key should be saved
   * @return {Object}
   *         Key object for desired key
   */
  segmentKey(e, t = !1) {
    if (!e)
      return null;
    const i = l3(e);
    let r = this.keyCache_[i];
    this.cacheEncryptionKeys_ && t && !r && e.bytes && (this.keyCache_[i] = r = {
      resolvedUri: e.resolvedUri,
      bytes: e.bytes
    });
    const a = {
      resolvedUri: (r || e).resolvedUri
    };
    return r && (a.bytes = r.bytes), a;
  }
  /**
   * Returns true if all configuration required for loading is present, otherwise false.
   *
   * @return {boolean} True if the all configuration is ready for loading
   * @private
   */
  couldBeginLoading_() {
    return this.playlist_ && !this.paused();
  }
  /**
   * load a playlist and start to fill the buffer
   */
  load() {
    if (this.monitorBuffer_(), !!this.playlist_) {
      if (this.state === "INIT" && this.couldBeginLoading_())
        return this.init_();
      !this.couldBeginLoading_() || this.state !== "READY" && this.state !== "INIT" || (this.state = "READY");
    }
  }
  /**
   * Once all the starting parameters have been specified, begin
   * operation. This method should only be invoked from the INIT
   * state.
   *
   * @private
   */
  init_() {
    return this.state = "READY", this.resetEverything(), this.monitorBuffer_();
  }
  /**
   * set a playlist on the segment loader
   *
   * @param {PlaylistLoader} media the playlist to set on the segment loader
   */
  playlist(e, t = {}) {
    if (!e || this.playlist_ && this.playlist_.endList && e.endList && this.playlist_.uri === e.uri)
      return;
    const i = this.playlist_, r = this.pendingSegment_;
    this.playlist_ = e, this.xhrOptions_ = t, this.state === "INIT" && (e.syncInfo = {
      mediaSequence: e.mediaSequence,
      time: 0
    }, this.loaderType_ === "main" && this.syncController_.setDateTimeMappingForStart(e));
    let a = null;
    if (i && (i.id ? a = i.id : i.uri && (a = i.uri)), this.logger_(`playlist update [${a} => ${e.id || e.uri}]`), this.mediaSequenceSync_ && (this.mediaSequenceSync_.update(e, this.currentTime_()), this.logger_(`Playlist update:
currentTime: ${this.currentTime_()}
bufferedEnd: ${Fp(this.buffered_())}
`, this.mediaSequenceSync_.diagnostics)), this.trigger("syncinfoupdate"), this.state === "INIT" && this.couldBeginLoading_())
      return this.init_();
    if (!i || i.uri !== e.uri) {
      this.mediaIndex !== null && (!e.endList && typeof e.partTargetDuration == "number" ? this.resetLoader() : this.resyncLoader()), this.currentMediaInfo_ = void 0, this.trigger("playlistupdate");
      return;
    }
    const s = e.mediaSequence - i.mediaSequence;
    if (this.logger_(`live window shift [${s}]`), this.mediaIndex !== null)
      if (this.mediaIndex -= s, this.mediaIndex < 0)
        this.mediaIndex = null, this.partIndex = null;
      else {
        const o = this.playlist_.segments[this.mediaIndex];
        if (this.partIndex && (!o.parts || !o.parts.length || !o.parts[this.partIndex])) {
          const u = this.mediaIndex;
          this.logger_(`currently processing part (index ${this.partIndex}) no longer exists.`), this.resetLoader(), this.mediaIndex = u;
        }
      }
    r && (r.mediaIndex -= s, r.mediaIndex < 0 ? (r.mediaIndex = null, r.partIndex = null) : (r.mediaIndex >= 0 && (r.segment = e.segments[r.mediaIndex]), r.partIndex >= 0 && r.segment.parts && (r.part = r.segment.parts[r.partIndex]))), this.syncController_.saveExpiredSegmentInfo(i, e);
  }
  /**
   * Prevent the loader from fetching additional segments. If there
   * is a segment request outstanding, it will finish processing
   * before the loader halts. A segment loader can be unpaused by
   * calling load().
   */
  pause() {
    this.checkBufferTimeout_ && (me.clearTimeout(this.checkBufferTimeout_), this.checkBufferTimeout_ = null);
  }
  /**
   * Returns whether the segment loader is fetching additional
   * segments when given the opportunity. This property can be
   * modified through calls to pause() and load().
   */
  paused() {
    return this.checkBufferTimeout_ === null;
  }
  /**
   * Delete all the buffered data and reset the SegmentLoader
   *
   * @param {Function} [done] an optional callback to be executed when the remove
   * operation is complete
   */
  resetEverything(e) {
    this.ended_ = !1, this.activeInitSegmentId_ = null, this.appendInitSegment_ = {
      audio: !0,
      video: !0
    }, this.resetLoader(), this.remove(0, 1 / 0, e), this.transmuxer_ && (this.transmuxer_.postMessage({
      action: "clearAllMp4Captions"
    }), this.transmuxer_.postMessage({
      action: "reset"
    }));
  }
  /**
   * Force the SegmentLoader to resync and start loading around the currentTime instead
   * of starting at the end of the buffer
   *
   * Useful for fast quality changes
   */
  resetLoader() {
    this.fetchAtBuffer_ = !1, this.mediaSequenceSync_ && this.mediaSequenceSync_.resetAppendedStatus(), this.resyncLoader();
  }
  /**
   * Force the SegmentLoader to restart synchronization and make a conservative guess
   * before returning to the simple walk-forward method
   */
  resyncLoader() {
    this.transmuxer_ && Mp.reset(this.transmuxer_), this.mediaIndex = null, this.partIndex = null, this.syncPoint_ = null, this.isPendingTimestampOffset_ = !1;
    const e = this.currentMediaInfo_ && this.currentMediaInfo_.isFmp4;
    this.sourceType_ === "hls" && !e && (this.shouldForceTimestampOffsetAfterResync_ = !0), this.callQueue_ = [], this.loadQueue_ = [], this.metadataQueue_.id3 = [], this.metadataQueue_.caption = [], this.abort(), this.transmuxer_ && this.transmuxer_.postMessage({
      action: "clearParsedMp4Captions"
    });
  }
  /**
   * Remove any data in the source buffer between start and end times
   *
   * @param {number} start - the start time of the region to remove from the buffer
   * @param {number} end - the end time of the region to remove from the buffer
   * @param {Function} [done] - an optional callback to be executed when the remove
   * @param {boolean} force - force all remove operations to happen
   * operation is complete
   */
  remove(e, t, i = () => {
  }, r = !1) {
    if (t === 1 / 0 && (t = this.duration_()), t <= e) {
      this.logger_("skipping remove because end ${end} is <= start ${start}");
      return;
    }
    if (!this.sourceUpdater_ || !this.getMediaInfo_()) {
      this.logger_("skipping remove because no source updater or starting media info");
      return;
    }
    let a = 1;
    const s = () => {
      a--, a === 0 && i();
    };
    (r || !this.audioDisabled_) && (a++, this.sourceUpdater_.removeAudio(e, t, s)), (r || this.loaderType_ === "main") && (this.gopBuffer_ = FL(this.gopBuffer_, e, t, this.timeMapping_), a++, this.sourceUpdater_.removeVideo(e, t, s));
    for (const o in this.inbandTextTracks_)
      Ds(e, t, this.inbandTextTracks_[o]);
    Ds(e, t, this.segmentMetadataTrack_), s();
  }
  /**
   * (re-)schedule monitorBufferTick_ to run as soon as possible
   *
   * @private
   */
  monitorBuffer_() {
    this.checkBufferTimeout_ && me.clearTimeout(this.checkBufferTimeout_), this.checkBufferTimeout_ = me.setTimeout(this.monitorBufferTick_.bind(this), 1);
  }
  /**
   * As long as the SegmentLoader is in the READY state, periodically
   * invoke fillBuffer_().
   *
   * @private
   */
  monitorBufferTick_() {
    this.state === "READY" && this.fillBuffer_(), this.checkBufferTimeout_ && me.clearTimeout(this.checkBufferTimeout_), this.checkBufferTimeout_ = me.setTimeout(this.monitorBufferTick_.bind(this), BL);
  }
  /**
   * fill the buffer with segements unless the sourceBuffers are
   * currently updating
   *
   * Note: this function should only ever be called by monitorBuffer_
   * and never directly
   *
   * @private
   */
  fillBuffer_() {
    if (this.sourceUpdater_.updating())
      return;
    const e = this.chooseNextRequest_();
    if (!e)
      return;
    const t = {
      segmentInfo: Cr({
        type: this.loaderType_,
        segment: e
      })
    };
    this.trigger({
      type: "segmentselected",
      metadata: t
    }), typeof e.timestampOffset == "number" && (this.isPendingTimestampOffset_ = !1, this.timelineChangeController_.pendingTimelineChange({
      type: this.loaderType_,
      from: this.currentTimeline_,
      to: e.timeline
    })), this.loadSegment_(e);
  }
  /**
   * Determines if we should call endOfStream on the media source based
   * on the state of the buffer or if appened segment was the final
   * segment in the playlist.
   *
   * @param {number} [mediaIndex] the media index of segment we last appended
   * @param {Object} [playlist] a media playlist object
   * @return {boolean} do we need to call endOfStream on the MediaSource
   */
  isEndOfStream_(e = this.mediaIndex, t = this.playlist_, i = this.partIndex) {
    if (!t || !this.mediaSource_)
      return !1;
    const r = typeof e == "number" && t.segments[e], a = e + 1 === t.segments.length, s = !r || !r.parts || i + 1 === r.parts.length;
    return t.endList && this.mediaSource_.readyState === "open" && a && s;
  }
  /**
   * Determines what request should be made given current segment loader state.
   *
   * @return {Object} a request object that describes the segment/part to load
   */
  chooseNextRequest_() {
    const e = this.buffered_(), t = Fp(e) || 0, i = w0(e, this.currentTime_()), r = !this.hasPlayed_() && i >= 1, a = i >= this.goalBufferLength_(), s = this.playlist_.segments;
    if (!s.length || r || a)
      return null;
    this.syncPoint_ = this.syncPoint_ || this.syncController_.getSyncPoint(this.playlist_, this.duration_(), this.currentTimeline_, this.currentTime_(), this.loaderType_);
    const o = {
      partIndex: null,
      mediaIndex: null,
      startOfSegment: null,
      playlist: this.playlist_,
      isSyncRequest: !this.syncPoint_
    };
    if (o.isSyncRequest)
      o.mediaIndex = ML(this.currentTimeline_, s, t), this.logger_(`choose next request. Can not find sync point. Fallback to media Index: ${o.mediaIndex}`);
    else if (this.mediaIndex !== null) {
      const f = s[this.mediaIndex], d = typeof this.partIndex == "number" ? this.partIndex : -1;
      o.startOfSegment = f.end ? f.end : t, f.parts && f.parts[d + 1] ? (o.mediaIndex = this.mediaIndex, o.partIndex = d + 1) : o.mediaIndex = this.mediaIndex + 1;
    } else {
      let f, d, y;
      const m = this.fetchAtBuffer_ ? t : this.currentTime_();
      if (this.mediaSequenceSync_ && this.logger_(`chooseNextRequest_ request after Quality Switch:
For TargetTime: ${m}.
CurrentTime: ${this.currentTime_()}
BufferedEnd: ${t}
Fetch At Buffer: ${this.fetchAtBuffer_}
`, this.mediaSequenceSync_.diagnostics), this.mediaSequenceSync_ && this.mediaSequenceSync_.isReliable) {
        const b = this.getSyncInfoFromMediaSequenceSync_(m);
        if (!b) {
          const p = "No sync info found while using media sequence sync";
          return this.error({
            message: p,
            metadata: {
              errorType: ke.Error.StreamingFailedToSelectNextSegment,
              error: new Error(p)
            }
          }), this.logger_("chooseNextRequest_ - no sync info found using media sequence sync"), null;
        }
        this.logger_(`chooseNextRequest_ mediaSequence syncInfo (${b.start} --> ${b.end})`), f = b.segmentIndex, d = b.partIndex, y = b.start;
      } else {
        this.logger_("chooseNextRequest_ - fallback to a regular segment selection algorithm, based on a syncPoint.");
        const b = pn.getMediaInfoForTime({
          exactManifestTimings: this.exactManifestTimings,
          playlist: this.playlist_,
          currentTime: m,
          startingPartIndex: this.syncPoint_.partIndex,
          startingSegmentIndex: this.syncPoint_.segmentIndex,
          startTime: this.syncPoint_.time
        });
        f = b.segmentIndex, d = b.partIndex, y = b.startTime;
      }
      o.getMediaInfoForTime = this.fetchAtBuffer_ ? `bufferedEnd ${m}` : `currentTime ${m}`, o.mediaIndex = f, o.startOfSegment = y, o.partIndex = d, this.logger_(`choose next request. Playlist switched and we have a sync point. Media Index: ${o.mediaIndex} `);
    }
    const u = s[o.mediaIndex];
    let c = u && typeof o.partIndex == "number" && u.parts && u.parts[o.partIndex];
    if (!u || typeof o.partIndex == "number" && !c)
      return null;
    typeof o.partIndex != "number" && u.parts && (o.partIndex = 0, c = u.parts[0]);
    const l = this.vhs_.playlists && this.vhs_.playlists.main && this.vhs_.playlists.main.independentSegments || this.playlist_.independentSegments;
    if (!i && c && !l && !c.independent)
      if (o.partIndex === 0) {
        const f = s[o.mediaIndex - 1], d = f.parts && f.parts.length && f.parts[f.parts.length - 1];
        d && d.independent && (o.mediaIndex -= 1, o.partIndex = f.parts.length - 1, o.independent = "previous segment");
      } else u.parts[o.partIndex - 1].independent && (o.partIndex -= 1, o.independent = "previous part");
    const h = this.mediaSource_ && this.mediaSource_.readyState === "ended";
    return o.mediaIndex >= s.length - 1 && h && !this.seeking_() ? null : (this.shouldForceTimestampOffsetAfterResync_ && (this.shouldForceTimestampOffsetAfterResync_ = !1, o.forceTimestampOffset = !0, this.logger_("choose next request. Force timestamp offset after loader resync")), this.generateSegmentInfo_(o));
  }
  getSyncInfoFromMediaSequenceSync_(e) {
    if (!this.mediaSequenceSync_)
      return null;
    const t = Math.max(e, this.mediaSequenceSync_.start);
    e !== t && this.logger_(`getSyncInfoFromMediaSequenceSync_. Pulled target time from ${e} to ${t}`);
    const i = this.mediaSequenceSync_.getSyncInfoForTime(t);
    if (!i)
      return null;
    if (!i.isAppended)
      return i;
    const r = this.mediaSequenceSync_.getSyncInfoForTime(i.end);
    return r ? (r.isAppended && this.logger_("getSyncInfoFromMediaSequenceSync_: We encounter unexpected scenario where next media sequence sync info is also appended!"), r) : null;
  }
  generateSegmentInfo_(e) {
    const {
      independent: t,
      playlist: i,
      mediaIndex: r,
      startOfSegment: a,
      isSyncRequest: s,
      partIndex: o,
      forceTimestampOffset: u,
      getMediaInfoForTime: c
    } = e, l = i.segments[r], h = typeof o == "number" && l.parts[o], f = {
      requestId: "segment-loader-" + Math.random(),
      // resolve the segment URL relative to the playlist
      uri: h && h.resolvedUri || l.resolvedUri,
      // the segment's mediaIndex at the time it was requested
      mediaIndex: r,
      partIndex: h ? o : null,
      // whether or not to update the SegmentLoader's state with this
      // segment's mediaIndex
      isSyncRequest: s,
      startOfSegment: a,
      // the segment's playlist
      playlist: i,
      // unencrypted bytes of the segment
      bytes: null,
      // when a key is defined for this segment, the encrypted bytes
      encryptedBytes: null,
      // The target timestampOffset for this segment when we append it
      // to the source buffer
      timestampOffset: null,
      // The timeline that the segment is in
      timeline: l.timeline,
      // The expected duration of the segment in seconds
      duration: h && h.duration || l.duration,
      // retain the segment in case the playlist updates while doing an async process
      segment: l,
      part: h,
      byteLength: 0,
      transmuxer: this.transmuxer_,
      // type of getMediaInfoForTime that was used to get this segment
      getMediaInfoForTime: c,
      independent: t
    }, d = typeof u < "u" ? u : this.isPendingTimestampOffset_;
    f.timestampOffset = this.timestampOffsetForSegment_({
      segmentTimeline: l.timeline,
      currentTimeline: this.currentTimeline_,
      startOfSegment: a,
      buffered: this.buffered_(),
      overrideCheck: d
    });
    const y = Fp(this.sourceUpdater_.audioBuffered());
    return typeof y == "number" && (f.audioAppendStart = y - this.sourceUpdater_.audioTimestampOffset()), this.sourceUpdater_.videoBuffered().length && (f.gopsToAlignWith = LL(
      this.gopBuffer_,
      // since the transmuxer is using the actual timing values, but the time is
      // adjusted by the timestmap offset, we must adjust the value here
      this.currentTime_() - this.sourceUpdater_.videoTimestampOffset(),
      this.timeMapping_
    )), f;
  }
  // get the timestampoffset for a segment,
  // added so that vtt segment loader can override and prevent
  // adding timestamp offsets.
  timestampOffsetForSegment_(e) {
    return WL(e);
  }
  /**
   * Determines if the network has enough bandwidth to complete the current segment
   * request in a timely manner. If not, the request will be aborted early and bandwidth
   * updated to trigger a playlist switch.
   *
   * @param {Object} stats
   *        Object containing stats about the request timing and size
   * @private
   */
  earlyAbortWhenNeeded_(e) {
    if (this.vhs_.tech_.paused() || // Don't abort if the current playlist is on the lowestEnabledRendition
    // TODO: Replace using timeout with a boolean indicating whether this playlist is
    //       the lowestEnabledRendition.
    !this.xhrOptions_.timeout || // Don't abort if we have no bandwidth information to estimate segment sizes
    !this.playlist_.attributes.BANDWIDTH || Date.now() - (e.firstBytesReceivedAt || Date.now()) < 1e3)
      return;
    const t = this.currentTime_(), i = e.bandwidth, r = this.pendingSegment_.duration, a = pn.estimateSegmentRequestTime(r, i, this.playlist_, e.bytesReceived), s = l9(this.buffered_(), t, this.vhs_.tech_.playbackRate()) - 1;
    if (a <= s)
      return;
    const o = wL({
      main: this.vhs_.playlists.main,
      currentTime: t,
      bandwidth: i,
      duration: this.duration_(),
      segmentDuration: r,
      timeUntilRebuffer: s,
      currentTimeline: this.currentTimeline_,
      syncController: this.syncController_
    });
    if (!o)
      return;
    const c = a - s - o.rebufferingImpact;
    let l = 0.5;
    s <= gi && (l = 1), !(!o.playlist || o.playlist.uri === this.playlist_.uri || c < l) && (this.bandwidth = o.playlist.attributes.BANDWIDTH * qt.BANDWIDTH_VARIANCE + 1, this.trigger("earlyabort"));
  }
  handleAbort_(e) {
    this.logger_(`Aborting ${ta(e)}`), this.mediaRequestsAborted += 1;
  }
  /**
   * XHR `progress` event handler
   *
   * @param {Event}
   *        The XHR `progress` event
   * @param {Object} simpleSegment
   *        A simplified segment object copy
   * @private
   */
  handleProgress_(e, t) {
    this.earlyAbortWhenNeeded_(t.stats), !this.checkForAbort_(t.requestId) && this.trigger("progress");
  }
  handleTrackInfo_(e, t) {
    const {
      hasAudio: i,
      hasVideo: r
    } = t, a = {
      segmentInfo: Cr({
        type: this.loaderType_,
        segment: e
      }),
      trackInfo: {
        hasAudio: i,
        hasVideo: r
      }
    };
    this.trigger({
      type: "segmenttransmuxingtrackinfoavailable",
      metadata: a
    }), this.earlyAbortWhenNeeded_(e.stats), !this.checkForAbort_(e.requestId) && (this.checkForIllegalMediaSwitch(t) || (t = t || {}, NL(this.currentMediaInfo_, t) || (this.appendInitSegment_ = {
      audio: !0,
      video: !0
    }, this.startingMediaInfo_ = t, this.currentMediaInfo_ = t, this.logger_("trackinfo update", t), this.trigger("trackinfo")), !this.checkForAbort_(e.requestId) && (this.pendingSegment_.trackInfo = t, this.hasEnoughInfoToAppend_() ? this.processCallQueue_() : Gi(this))));
  }
  handleTimingInfo_(e, t, i, r) {
    if (this.earlyAbortWhenNeeded_(e.stats), this.checkForAbort_(e.requestId))
      return;
    const a = this.pendingSegment_, s = J_(t);
    a[s] = a[s] || {}, a[s][i] = r, this.logger_(`timinginfo: ${t} - ${i} - ${r}`), this.hasEnoughInfoToAppend_() ? this.processCallQueue_() : Gi(this);
  }
  handleCaptions_(e, t) {
    if (this.earlyAbortWhenNeeded_(e.stats), this.checkForAbort_(e.requestId))
      return;
    if (t.length === 0) {
      this.logger_("SegmentLoader received no captions from a caption event");
      return;
    }
    if (!this.pendingSegment_.hasAppendedData_) {
      this.metadataQueue_.caption.push(this.handleCaptions_.bind(this, e, t));
      return;
    }
    const r = this.sourceUpdater_.videoTimestampOffset() === null ? this.sourceUpdater_.audioTimestampOffset() : this.sourceUpdater_.videoTimestampOffset(), a = {};
    t.forEach((s) => {
      a[s.stream] = a[s.stream] || {
        // Infinity, as any other value will be less than this
        startTime: 1 / 0,
        captions: [],
        // 0 as an other value will be more than this
        endTime: 0
      };
      const o = a[s.stream];
      o.startTime = Math.min(o.startTime, s.startTime + r), o.endTime = Math.max(o.endTime, s.endTime + r), o.captions.push(s);
    }), Object.keys(a).forEach((s) => {
      const {
        startTime: o,
        endTime: u,
        captions: c
      } = a[s], l = this.inbandTextTracks_;
      this.logger_(`adding cues from ${o} -> ${u} for ${s}`), SL(l, this.vhs_.tech_, s), Ds(o, u, l[s]), CL({
        captionArray: c,
        inbandTextTracks: l,
        timestampOffset: r
      });
    }), this.transmuxer_ && this.transmuxer_.postMessage({
      action: "clearParsedMp4Captions"
    });
  }
  handleId3_(e, t, i) {
    if (this.earlyAbortWhenNeeded_(e.stats), this.checkForAbort_(e.requestId))
      return;
    if (!this.pendingSegment_.hasAppendedData_) {
      this.metadataQueue_.id3.push(this.handleId3_.bind(this, e, t, i));
      return;
    }
    this.addMetadataToTextTrack(i, t, this.duration_());
  }
  processMetadataQueue_() {
    this.metadataQueue_.id3.forEach((e) => e()), this.metadataQueue_.caption.forEach((e) => e()), this.metadataQueue_.id3 = [], this.metadataQueue_.caption = [];
  }
  processCallQueue_() {
    const e = this.callQueue_;
    this.callQueue_ = [], e.forEach((t) => t());
  }
  processLoadQueue_() {
    const e = this.loadQueue_;
    this.loadQueue_ = [], e.forEach((t) => t());
  }
  /**
   * Determines whether the loader has enough info to load the next segment.
   *
   * @return {boolean}
   *         Whether or not the loader has enough info to load the next segment
   */
  hasEnoughInfoToLoad_() {
    if (this.loaderType_ !== "audio")
      return !0;
    const e = this.pendingSegment_;
    return e ? this.getCurrentMediaInfo_() ? (
      // Technically, instead of waiting to load a segment on timeline changes, a segment
      // can be requested and downloaded and only wait before it is transmuxed or parsed.
      // But in practice, there are a few reasons why it is better to wait until a loader
      // is ready to append that segment before requesting and downloading:
      //
      // 1. Because audio and main loaders cross discontinuities together, if this loader
      //    is waiting for the other to catch up, then instead of requesting another
      //    segment and using up more bandwidth, by not yet loading, more bandwidth is
      //    allotted to the loader currently behind.
      // 2. media-segment-request doesn't have to have logic to consider whether a segment
      // is ready to be processed or not, isolating the queueing behavior to the loader.
      // 3. The audio loader bases some of its segment properties on timing information
      //    provided by the main loader, meaning that, if the logic for waiting on
      //    processing was in media-segment-request, then it would also need to know how
      //    to re-generate the segment information after the main loader caught up.
      !Um({
        timelineChangeController: this.timelineChangeController_,
        currentTimeline: this.currentTimeline_,
        segmentTimeline: e.timeline,
        loaderType: this.loaderType_,
        audioDisabled: this.audioDisabled_
      })
    ) : !0 : !1;
  }
  getCurrentMediaInfo_(e = this.pendingSegment_) {
    return e && e.trackInfo || this.currentMediaInfo_;
  }
  getMediaInfo_(e = this.pendingSegment_) {
    return this.getCurrentMediaInfo_(e) || this.startingMediaInfo_;
  }
  getPendingSegmentPlaylist() {
    return this.pendingSegment_ ? this.pendingSegment_.playlist : null;
  }
  hasEnoughInfoToAppend_() {
    if (!this.sourceUpdater_.ready() || this.waitingOnRemove_ || this.quotaExceededErrorRetryTimeout_)
      return !1;
    const e = this.pendingSegment_, t = this.getCurrentMediaInfo_();
    if (!e || !t)
      return !1;
    const {
      hasAudio: i,
      hasVideo: r,
      isMuxed: a
    } = t;
    return !(r && !e.videoTimingInfo || i && !this.audioDisabled_ && !a && !e.audioTimingInfo || Um({
      timelineChangeController: this.timelineChangeController_,
      currentTimeline: this.currentTimeline_,
      segmentTimeline: e.timeline,
      loaderType: this.loaderType_,
      audioDisabled: this.audioDisabled_
    }));
  }
  handleData_(e, t) {
    if (this.earlyAbortWhenNeeded_(e.stats), this.checkForAbort_(e.requestId))
      return;
    if (this.callQueue_.length || !this.hasEnoughInfoToAppend_()) {
      Gi(this), this.callQueue_.push(this.handleData_.bind(this, e, t));
      return;
    }
    const i = this.pendingSegment_;
    if (this.setTimeMapping_(i.timeline), this.updateMediaSecondsLoaded_(i.part || i.segment), this.mediaSource_.readyState !== "closed") {
      if (e.map && (e.map = this.initSegmentForMap(e.map, !0), i.segment.map = e.map), e.key && this.segmentKey(e.key, !0), i.isFmp4 = e.isFmp4, i.timingInfo = i.timingInfo || {}, i.isFmp4)
        this.trigger("fmp4"), i.timingInfo.start = i[J_(t.type)].start;
      else {
        const r = this.getCurrentMediaInfo_(), a = this.loaderType_ === "main" && r && r.hasVideo;
        let s;
        a && (s = i.videoTimingInfo.start), i.timingInfo.start = this.trueSegmentStart_({
          currentStart: i.timingInfo.start,
          playlist: i.playlist,
          mediaIndex: i.mediaIndex,
          currentVideoTimestampOffset: this.sourceUpdater_.videoTimestampOffset(),
          useVideoTimingInfo: a,
          firstVideoFrameTimeForData: s,
          videoTimingInfo: i.videoTimingInfo,
          audioTimingInfo: i.audioTimingInfo
        });
      }
      if (this.updateAppendInitSegmentStatus(i, t.type), this.updateSourceBufferTimestampOffset_(i), i.isSyncRequest) {
        this.updateTimingInfoEnd_(i), this.syncController_.saveSegmentTimingInfo({
          segmentInfo: i,
          shouldSaveTimelineMapping: this.loaderType_ === "main"
        });
        const r = this.chooseNextRequest_();
        if (r.mediaIndex !== i.mediaIndex || r.partIndex !== i.partIndex) {
          this.logger_("sync segment was incorrect, not appending");
          return;
        }
        this.logger_("sync segment was correct, appending");
      }
      i.hasAppendedData_ = !0, this.processMetadataQueue_(), this.appendData_(i, t);
    }
  }
  updateAppendInitSegmentStatus(e, t) {
    this.loaderType_ === "main" && typeof e.timestampOffset == "number" && // in the case that we're handling partial data, we don't want to append an init
    // segment for each chunk
    !e.changedTimestampOffset && (this.appendInitSegment_ = {
      audio: !0,
      video: !0
    }), this.playlistOfLastInitSegment_[t] !== e.playlist && (this.appendInitSegment_[t] = !0);
  }
  getInitSegmentAndUpdateState_({
    type: e,
    initSegment: t,
    map: i,
    playlist: r
  }) {
    if (i) {
      const a = Dc(i);
      if (this.activeInitSegmentId_ === a)
        return null;
      t = this.initSegmentForMap(i, !0).bytes, this.activeInitSegmentId_ = a;
    }
    return t && this.appendInitSegment_[e] ? (this.playlistOfLastInitSegment_[e] = r, this.appendInitSegment_[e] = !1, this.activeInitSegmentId_ = null, t) : null;
  }
  handleQuotaExceededError_({
    segmentInfo: e,
    type: t,
    bytes: i
  }, r) {
    const a = this.sourceUpdater_.audioBuffered(), s = this.sourceUpdater_.videoBuffered();
    a.length > 1 && this.logger_("On QUOTA_EXCEEDED_ERR, found gaps in the audio buffer: " + kr(a).join(", ")), s.length > 1 && this.logger_("On QUOTA_EXCEEDED_ERR, found gaps in the video buffer: " + kr(s).join(", "));
    const o = a.length ? a.start(0) : 0, u = a.length ? a.end(a.length - 1) : 0, c = s.length ? s.start(0) : 0, l = s.length ? s.end(s.length - 1) : 0;
    if (u - o <= xs && l - c <= xs) {
      this.logger_(`On QUOTA_EXCEEDED_ERR, single segment too large to append to buffer, triggering an error. Appended byte length: ${i.byteLength}, audio buffer: ${kr(a).join(", ")}, video buffer: ${kr(s).join(", ")}, `), this.error({
        message: "Quota exceeded error with append of a single segment of content",
        excludeUntil: 1 / 0
      }), this.trigger("error");
      return;
    }
    this.waitingOnRemove_ = !0, this.callQueue_.push(this.appendToSourceBuffer_.bind(this, {
      segmentInfo: e,
      type: t,
      bytes: i
    }));
    const f = this.currentTime_() - xs;
    this.logger_(`On QUOTA_EXCEEDED_ERR, removing audio/video from 0 to ${f}`), this.remove(0, f, () => {
      this.logger_(`On QUOTA_EXCEEDED_ERR, retrying append in ${xs}s`), this.waitingOnRemove_ = !1, this.quotaExceededErrorRetryTimeout_ = me.setTimeout(() => {
        this.logger_("On QUOTA_EXCEEDED_ERR, re-processing call queue"), this.quotaExceededErrorRetryTimeout_ = null, this.processCallQueue_();
      }, xs * 1e3);
    }, !0);
  }
  handleAppendError_({
    segmentInfo: e,
    type: t,
    bytes: i
  }, r) {
    if (r) {
      if (r.code === n3) {
        this.handleQuotaExceededError_({
          segmentInfo: e,
          type: t,
          bytes: i
        });
        return;
      }
      this.logger_("Received non QUOTA_EXCEEDED_ERR on append", r), this.error({
        message: `${t} append of ${i.length}b failed for segment #${e.mediaIndex} in playlist ${e.playlist.id}`,
        metadata: {
          errorType: ke.Error.StreamingFailedToAppendSegment
        }
      }), this.trigger("appenderror");
    }
  }
  appendToSourceBuffer_({
    segmentInfo: e,
    type: t,
    initSegment: i,
    data: r,
    bytes: a
  }) {
    if (!a) {
      const o = [r];
      let u = r.byteLength;
      i && (o.unshift(i), u += i.byteLength), a = DL({
        bytes: u,
        segments: o
      });
    }
    const s = {
      segmentInfo: Cr({
        type: this.loaderType_,
        segment: e
      })
    };
    this.trigger({
      type: "segmentappendstart",
      metadata: s
    }), this.sourceUpdater_.appendBuffer({
      segmentInfo: e,
      type: t,
      bytes: a
    }, this.handleAppendError_.bind(this, {
      segmentInfo: e,
      type: t,
      bytes: a
    }));
  }
  handleSegmentTimingInfo_(e, t, i) {
    if (!this.pendingSegment_ || t !== this.pendingSegment_.requestId)
      return;
    const r = this.pendingSegment_.segment, a = `${e}TimingInfo`;
    r[a] || (r[a] = {}), r[a].transmuxerPrependedSeconds = i.prependedContentDuration || 0, r[a].transmuxedPresentationStart = i.start.presentation, r[a].transmuxedDecodeStart = i.start.decode, r[a].transmuxedPresentationEnd = i.end.presentation, r[a].transmuxedDecodeEnd = i.end.decode, r[a].baseMediaDecodeTime = i.baseMediaDecodeTime;
  }
  appendData_(e, t) {
    const {
      type: i,
      data: r
    } = t;
    if (!r || !r.byteLength || i === "audio" && this.audioDisabled_)
      return;
    const a = this.getInitSegmentAndUpdateState_({
      type: i,
      initSegment: t.initSegment,
      playlist: e.playlist,
      map: e.isFmp4 ? e.segment.map : null
    });
    this.appendToSourceBuffer_({
      segmentInfo: e,
      type: i,
      initSegment: a,
      data: r
    });
  }
  /**
   * load a specific segment from a request into the buffer
   *
   * @private
   */
  loadSegment_(e) {
    if (this.state = "WAITING", this.pendingSegment_ = e, this.trimBackBuffer_(e), typeof e.timestampOffset == "number" && this.transmuxer_ && this.transmuxer_.postMessage({
      action: "clearAllMp4Captions"
    }), !this.hasEnoughInfoToLoad_()) {
      Gi(this), this.loadQueue_.push(() => {
        const t = Lt({}, e, {
          forceTimestampOffset: !0
        });
        Lt(e, this.generateSegmentInfo_(t)), this.isPendingTimestampOffset_ = !1, this.updateTransmuxerAndRequestSegment_(e);
      });
      return;
    }
    this.updateTransmuxerAndRequestSegment_(e);
  }
  updateTransmuxerAndRequestSegment_(e) {
    this.shouldUpdateTransmuxerTimestampOffset_(e.timestampOffset) && (this.gopBuffer_.length = 0, e.gopsToAlignWith = [], this.timeMapping_ = 0, this.transmuxer_.postMessage({
      action: "reset"
    }), this.transmuxer_.postMessage({
      action: "setTimestampOffset",
      timestampOffset: e.timestampOffset
    }));
    const t = this.createSimplifiedSegmentObj_(e), i = this.isEndOfStream_(e.mediaIndex, e.playlist, e.partIndex), r = this.mediaIndex !== null, a = e.timeline !== this.currentTimeline_ && // currentTimeline starts at -1, so we shouldn't end the timeline switching to 0,
    // the first timeline
    e.timeline > 0, s = i || r && a;
    this.logger_(`Requesting
${C3(e.uri)}
${ta(e)}`), t.map && !t.map.bytes && (this.logger_("going to request init segment."), this.appendInitSegment_ = {
      video: !0,
      audio: !0
    }), e.abortRequests = xL({
      xhr: this.vhs_.xhr,
      xhrOptions: this.xhrOptions_,
      decryptionWorker: this.decrypter_,
      segment: t,
      abortFn: this.handleAbort_.bind(this, e),
      progressFn: this.handleProgress_.bind(this),
      trackInfoFn: this.handleTrackInfo_.bind(this),
      timingInfoFn: this.handleTimingInfo_.bind(this),
      videoSegmentTimingInfoFn: this.handleSegmentTimingInfo_.bind(this, "video", e.requestId),
      audioSegmentTimingInfoFn: this.handleSegmentTimingInfo_.bind(this, "audio", e.requestId),
      captionsFn: this.handleCaptions_.bind(this),
      isEndOfTimeline: s,
      endedTimelineFn: () => {
        this.logger_("received endedtimeline callback");
      },
      id3Fn: this.handleId3_.bind(this),
      dataFn: this.handleData_.bind(this),
      doneFn: this.segmentRequestFinished_.bind(this),
      onTransmuxerLog: ({
        message: o,
        level: u,
        stream: c
      }) => {
        this.logger_(`${ta(e)} logged from transmuxer stream ${c} as a ${u}: ${o}`);
      },
      triggerSegmentEventFn: ({
        type: o,
        segment: u,
        keyInfo: c,
        trackInfo: l,
        timingInfo: h
      }) => {
        const d = {
          segmentInfo: Cr({
            segment: u
          })
        };
        c && (d.keyInfo = c), l && (d.trackInfo = l), h && (d.timingInfo = h), this.trigger({
          type: o,
          metadata: d
        });
      }
    });
  }
  /**
   * trim the back buffer so that we don't have too much data
   * in the source buffer
   *
   * @private
   *
   * @param {Object} segmentInfo - the current segment
   */
  trimBackBuffer_(e) {
    const t = qL(this.seekable_(), this.currentTime_(), this.playlist_.targetDuration || 10);
    t > 0 && this.remove(0, t);
  }
  /**
   * created a simplified copy of the segment object with just the
   * information necessary to perform the XHR and decryption
   *
   * @private
   *
   * @param {Object} segmentInfo - the current segment
   * @return {Object} a simplified segment object copy
   */
  createSimplifiedSegmentObj_(e) {
    const t = e.segment, i = e.part, r = e.segment.key || e.segment.map && e.segment.map.key, a = e.segment.map && !e.segment.map.bytes, s = {
      resolvedUri: i ? i.resolvedUri : t.resolvedUri,
      byterange: i ? i.byterange : t.byterange,
      requestId: e.requestId,
      transmuxer: e.transmuxer,
      audioAppendStart: e.audioAppendStart,
      gopsToAlignWith: e.gopsToAlignWith,
      part: e.part,
      type: this.loaderType_,
      start: e.startOfSegment,
      duration: e.duration,
      isEncrypted: r,
      isMediaInitialization: a
    }, o = e.playlist.segments[e.mediaIndex - 1];
    if (o && o.timeline === t.timeline && (o.videoTimingInfo ? s.baseStartTime = o.videoTimingInfo.transmuxedDecodeEnd : o.audioTimingInfo && (s.baseStartTime = o.audioTimingInfo.transmuxedDecodeEnd)), t.key) {
      const u = t.key.iv || new Uint32Array([0, 0, 0, e.mediaIndex + e.playlist.mediaSequence]);
      s.key = this.segmentKey(t.key), s.key.iv = u;
    }
    return t.map && (s.map = this.initSegmentForMap(t.map)), s;
  }
  saveTransferStats_(e) {
    this.mediaRequests += 1, e && (this.mediaBytesTransferred += e.bytesReceived, this.mediaTransferDuration += e.roundTripTime);
  }
  saveBandwidthRelatedStats_(e, t) {
    if (this.pendingSegment_.byteLength = t.bytesReceived, e < wu) {
      this.logger_(`Ignoring segment's bandwidth because its duration of ${e} is less than the min to record ${wu}`);
      return;
    }
    const i = {
      bandwidthInfo: {
        from: this.bandwidth,
        to: t.bandwidth
      }
    };
    this.trigger({
      type: "bandwidthupdated",
      metadata: i
    }), this.bandwidth = t.bandwidth, this.roundTrip = t.roundTripTime;
  }
  handleTimeout_() {
    this.mediaRequestsTimedout += 1, this.bandwidth = 1, this.roundTrip = NaN, this.trigger("bandwidthupdate"), this.trigger("timeout");
  }
  /**
   * Handle the callback from the segmentRequest function and set the
   * associated SegmentLoader state and errors if necessary
   *
   * @private
   */
  segmentRequestFinished_(e, t, i) {
    if (this.callQueue_.length) {
      this.callQueue_.push(this.segmentRequestFinished_.bind(this, e, t, i));
      return;
    }
    if (this.saveTransferStats_(t.stats), !this.pendingSegment_ || t.requestId !== this.pendingSegment_.requestId)
      return;
    if (e) {
      if (this.pendingSegment_ = null, this.state = "READY", e.code === yi.ABORTED)
        return;
      if (this.pause(), e.code === yi.TIMEOUT) {
        this.handleTimeout_();
        return;
      }
      this.mediaRequestsErrored += 1, this.error(e), this.trigger("error");
      return;
    }
    const r = this.pendingSegment_;
    this.saveBandwidthRelatedStats_(r.duration, t.stats), r.endOfAllRequests = t.endOfAllRequests, i.gopInfo && (this.gopBuffer_ = PL(this.gopBuffer_, i.gopInfo, this.safeAppend_)), this.state = "APPENDING", this.trigger("appending"), this.waitForAppendsToComplete_(r);
  }
  setTimeMapping_(e) {
    const t = this.syncController_.mappingForTimeline(e);
    t !== null && (this.timeMapping_ = t);
  }
  updateMediaSecondsLoaded_(e) {
    typeof e.start == "number" && typeof e.end == "number" ? this.mediaSecondsLoaded += e.end - e.start : this.mediaSecondsLoaded += e.duration;
  }
  shouldUpdateTransmuxerTimestampOffset_(e) {
    return e === null ? !1 : this.loaderType_ === "main" && e !== this.sourceUpdater_.videoTimestampOffset() || !this.audioDisabled_ && e !== this.sourceUpdater_.audioTimestampOffset();
  }
  trueSegmentStart_({
    currentStart: e,
    playlist: t,
    mediaIndex: i,
    firstVideoFrameTimeForData: r,
    currentVideoTimestampOffset: a,
    useVideoTimingInfo: s,
    videoTimingInfo: o,
    audioTimingInfo: u
  }) {
    if (typeof e < "u")
      return e;
    if (!s)
      return u.start;
    const c = t.segments[i - 1];
    return i === 0 || !c || typeof c.start > "u" || c.end !== r + a ? r : o.start;
  }
  waitForAppendsToComplete_(e) {
    const t = this.getCurrentMediaInfo_(e);
    if (!t) {
      this.error({
        message: "No starting media returned, likely due to an unsupported media format.",
        playlistExclusionDuration: 1 / 0
      }), this.trigger("error");
      return;
    }
    const {
      hasAudio: i,
      hasVideo: r,
      isMuxed: a
    } = t, s = this.loaderType_ === "main" && r, o = !this.audioDisabled_ && i && !a;
    if (e.waitingOnAppends = 0, !e.hasAppendedData_) {
      !e.timingInfo && typeof e.timestampOffset == "number" && (this.isPendingTimestampOffset_ = !0), e.timingInfo = {
        start: 0
      }, e.waitingOnAppends++, this.isPendingTimestampOffset_ || (this.updateSourceBufferTimestampOffset_(e), this.processMetadataQueue_()), this.checkAppendsDone_(e);
      return;
    }
    s && e.waitingOnAppends++, o && e.waitingOnAppends++, s && this.sourceUpdater_.videoQueueCallback(this.checkAppendsDone_.bind(this, e)), o && this.sourceUpdater_.audioQueueCallback(this.checkAppendsDone_.bind(this, e));
  }
  checkAppendsDone_(e) {
    this.checkForAbort_(e.requestId) || (e.waitingOnAppends--, e.waitingOnAppends === 0 && this.handleAppendsDone_());
  }
  checkForIllegalMediaSwitch(e) {
    const t = jL(this.loaderType_, this.getCurrentMediaInfo_(), e);
    return t ? (this.error({
      message: t,
      playlistExclusionDuration: 1 / 0
    }), this.trigger("error"), !0) : !1;
  }
  updateSourceBufferTimestampOffset_(e) {
    if (e.timestampOffset === null || // we don't yet have the start for whatever media type (video or audio) has
    // priority, timing-wise, so we must wait
    typeof e.timingInfo.start != "number" || // already updated the timestamp offset for this segment
    e.changedTimestampOffset || // the alt audio loader should not be responsible for setting the timestamp offset
    this.loaderType_ !== "main")
      return;
    let t = !1;
    e.timestampOffset -= this.getSegmentStartTimeForTimestampOffsetCalculation_({
      videoTimingInfo: e.segment.videoTimingInfo,
      audioTimingInfo: e.segment.audioTimingInfo,
      timingInfo: e.timingInfo
    }), e.changedTimestampOffset = !0, e.timestampOffset !== this.sourceUpdater_.videoTimestampOffset() && (this.sourceUpdater_.videoTimestampOffset(e.timestampOffset), t = !0), e.timestampOffset !== this.sourceUpdater_.audioTimestampOffset() && (this.sourceUpdater_.audioTimestampOffset(e.timestampOffset), t = !0), t && this.trigger("timestampoffset");
  }
  getSegmentStartTimeForTimestampOffsetCalculation_({
    videoTimingInfo: e,
    audioTimingInfo: t,
    timingInfo: i
  }) {
    return this.useDtsForTimestampOffset_ ? e && typeof e.transmuxedDecodeStart == "number" ? e.transmuxedDecodeStart : t && typeof t.transmuxedDecodeStart == "number" ? t.transmuxedDecodeStart : i.start : i.start;
  }
  updateTimingInfoEnd_(e) {
    e.timingInfo = e.timingInfo || {};
    const t = this.getMediaInfo_(), r = this.loaderType_ === "main" && t && t.hasVideo && e.videoTimingInfo ? e.videoTimingInfo : e.audioTimingInfo;
    r && (e.timingInfo.end = typeof r.end == "number" ? (
      // End time may not exist in a case where we aren't parsing the full segment (one
      // current example is the case of fmp4), so use the rough duration to calculate an
      // end time.
      r.end
    ) : r.start + e.duration);
  }
  /**
   * callback to run when appendBuffer is finished. detects if we are
   * in a good state to do things with the data we got, or if we need
   * to wait for more
   *
   * @private
   */
  handleAppendsDone_() {
    if (this.pendingSegment_) {
      const u = {
        segmentInfo: Cr({
          type: this.loaderType_,
          segment: this.pendingSegment_
        })
      };
      this.trigger({
        type: "appendsdone",
        metadata: u
      });
    }
    if (!this.pendingSegment_) {
      this.state = "READY", this.paused() || this.monitorBuffer_();
      return;
    }
    const e = this.pendingSegment_;
    e.part && e.part.syncInfo ? e.part.syncInfo.markAppended() : e.segment.syncInfo && e.segment.syncInfo.markAppended(), this.updateTimingInfoEnd_(e), this.shouldSaveSegmentTimingInfo_ && this.syncController_.saveSegmentTimingInfo({
      segmentInfo: e,
      shouldSaveTimelineMapping: this.loaderType_ === "main"
    });
    const t = $L(e, this.sourceType_);
    if (t && (t.severity === "warn" ? ke.log.warn(t.message) : this.logger_(t.message)), this.recordThroughput_(e), this.pendingSegment_ = null, this.state = "READY", e.isSyncRequest && (this.trigger("syncinfoupdate"), !e.hasAppendedData_)) {
      this.logger_(`Throwing away un-appended sync request ${ta(e)}`);
      return;
    }
    this.logger_(`Appended ${ta(e)}`), this.addSegmentMetadataCue_(e), this.fetchAtBuffer_ = !0, this.currentTimeline_ !== e.timeline && (this.timelineChangeController_.lastTimelineChange({
      type: this.loaderType_,
      from: this.currentTimeline_,
      to: e.timeline
    }), this.loaderType_ === "main" && !this.audioDisabled_ && this.timelineChangeController_.lastTimelineChange({
      type: "audio",
      from: this.currentTimeline_,
      to: e.timeline
    })), this.currentTimeline_ = e.timeline, this.trigger("syncinfoupdate");
    const i = e.segment, r = e.part, a = i.end && this.currentTime_() - i.end > e.playlist.targetDuration * 3, s = r && r.end && this.currentTime_() - r.end > e.playlist.partTargetDuration * 3;
    if (a || s) {
      this.logger_(`bad ${a ? "segment" : "part"} ${ta(e)}`), this.resetEverything();
      return;
    }
    this.mediaIndex !== null && this.trigger("bandwidthupdate"), this.trigger("progress"), this.mediaIndex = e.mediaIndex, this.partIndex = e.partIndex, this.isEndOfStream_(e.mediaIndex, e.playlist, e.partIndex) && this.endOfStream(), this.trigger("appended"), e.hasAppendedData_ && this.mediaAppends++, this.paused() || this.monitorBuffer_();
  }
  /**
   * Records the current throughput of the decrypt, transmux, and append
   * portion of the semgment pipeline. `throughput.rate` is a the cumulative
   * moving average of the throughput. `throughput.count` is the number of
   * data points in the average.
   *
   * @private
   * @param {Object} segmentInfo the object returned by loadSegment
   */
  recordThroughput_(e) {
    if (e.duration < wu) {
      this.logger_(`Ignoring segment's throughput because its duration of ${e.duration} is less than the min to record ${wu}`);
      return;
    }
    const t = this.throughput.rate, i = Date.now() - e.endOfAllRequests + 1, r = Math.floor(e.byteLength / i * 8 * 1e3);
    this.throughput.rate += (r - t) / ++this.throughput.count;
  }
  /**
   * Adds a cue to the segment-metadata track with some metadata information about the
   * segment
   *
   * @private
   * @param {Object} segmentInfo
   *        the object returned by loadSegment
   * @method addSegmentMetadataCue_
   */
  addSegmentMetadataCue_(e) {
    if (!this.segmentMetadataTrack_)
      return;
    const t = e.segment, i = t.start, r = t.end;
    if (!Z_(i) || !Z_(r))
      return;
    Ds(i, r, this.segmentMetadataTrack_);
    const a = me.WebKitDataCue || me.VTTCue, s = {
      custom: t.custom,
      dateTimeObject: t.dateTimeObject,
      dateTimeString: t.dateTimeString,
      programDateTime: t.programDateTime,
      bandwidth: e.playlist.attributes.BANDWIDTH,
      resolution: e.playlist.attributes.RESOLUTION,
      codecs: e.playlist.attributes.CODECS,
      byteLength: e.byteLength,
      uri: e.uri,
      timeline: e.timeline,
      playlist: e.playlist.id,
      start: i,
      end: r
    }, o = JSON.stringify(s), u = new a(i, r, o);
    u.value = s, this.segmentMetadataTrack_.addCue(u);
  }
}
function Ii() {
}
const A3 = function(n) {
  return typeof n != "string" ? n : n.replace(/./, (e) => e.toUpperCase());
}, GL = ["video", "audio"], Om = (n, e) => {
  const t = e[`${n}Buffer`];
  return t && t.updating || e.queuePending[n];
}, XL = (n, e) => {
  for (let t = 0; t < e.length; t++) {
    const i = e[t];
    if (i.type === "mediaSource")
      return null;
    if (i.type === n)
      return t;
  }
  return null;
}, ga = (n, e) => {
  if (e.queue.length === 0)
    return;
  let t = 0, i = e.queue[t];
  if (i.type === "mediaSource") {
    !e.updating() && e.mediaSource.readyState !== "closed" && (e.queue.shift(), i.action(e), i.doneFn && i.doneFn(), ga("audio", e), ga("video", e));
    return;
  }
  if (n !== "mediaSource" && !(!e.ready() || e.mediaSource.readyState === "closed" || Om(n, e))) {
    if (i.type !== n) {
      if (t = XL(n, e.queue), t === null)
        return;
      i = e.queue[t];
    }
    if (e.queue.splice(t, 1), e.queuePending[n] = i, i.action(n, e), !i.doneFn) {
      e.queuePending[n] = null, ga(n, e);
      return;
    }
  }
}, k3 = (n, e) => {
  const t = e[`${n}Buffer`], i = A3(n);
  t && (t.removeEventListener("updateend", e[`on${i}UpdateEnd_`]), t.removeEventListener("error", e[`on${i}Error_`]), e.codecs[n] = null, e[`${n}Buffer`] = null);
}, pi = (n, e) => n && e && Array.prototype.indexOf.call(n.sourceBuffers, e) !== -1, _n = {
  appendBuffer: (n, e, t) => (i, r) => {
    const a = r[`${i}Buffer`];
    if (pi(r.mediaSource, a)) {
      r.logger_(`Appending segment ${e.mediaIndex}'s ${n.length} bytes to ${i}Buffer`);
      try {
        a.appendBuffer(n);
      } catch (s) {
        r.logger_(`Error with code ${s.code} ` + (s.code === n3 ? "(QUOTA_EXCEEDED_ERR) " : "") + `when appending segment ${e.mediaIndex} to ${i}Buffer`), r.queuePending[i] = null, t(s);
      }
    }
  },
  remove: (n, e) => (t, i) => {
    const r = i[`${t}Buffer`];
    if (pi(i.mediaSource, r)) {
      i.logger_(`Removing ${n} to ${e} from ${t}Buffer`);
      try {
        r.remove(n, e);
      } catch {
        i.logger_(`Remove ${n} to ${e} from ${t}Buffer failed`);
      }
    }
  },
  timestampOffset: (n) => (e, t) => {
    const i = t[`${e}Buffer`];
    pi(t.mediaSource, i) && (t.logger_(`Setting ${e}timestampOffset to ${n}`), i.timestampOffset = n);
  },
  callback: (n) => (e, t) => {
    n();
  },
  endOfStream: (n) => (e) => {
    if (e.mediaSource.readyState === "open") {
      e.logger_(`Calling mediaSource endOfStream(${n || ""})`);
      try {
        e.mediaSource.endOfStream(n);
      } catch (t) {
        ke.log.warn("Failed to call media source endOfStream", t);
      }
    }
  },
  duration: (n) => (e) => {
    e.logger_(`Setting mediaSource duration to ${n}`);
    try {
      e.mediaSource.duration = n;
    } catch (t) {
      ke.log.warn("Failed to set media source duration", t);
    }
  },
  abort: () => (n, e) => {
    if (e.mediaSource.readyState !== "open")
      return;
    const t = e[`${n}Buffer`];
    if (pi(e.mediaSource, t)) {
      e.logger_(`calling abort on ${n}Buffer`);
      try {
        t.abort();
      } catch (i) {
        ke.log.warn(`Failed to abort on ${n}Buffer`, i);
      }
    }
  },
  addSourceBuffer: (n, e) => (t) => {
    const i = A3(n), r = xa(e);
    t.logger_(`Adding ${n}Buffer with codec ${e} to mediaSource`);
    const a = t.mediaSource.addSourceBuffer(r);
    a.addEventListener("updateend", t[`on${i}UpdateEnd_`]), a.addEventListener("error", t[`on${i}Error_`]), t.codecs[n] = e, t[`${n}Buffer`] = a;
  },
  removeSourceBuffer: (n) => (e) => {
    const t = e[`${n}Buffer`];
    if (k3(n, e), !!pi(e.mediaSource, t)) {
      e.logger_(`Removing ${n}Buffer with codec ${e.codecs[n]} from mediaSource`);
      try {
        e.mediaSource.removeSourceBuffer(t);
      } catch (i) {
        ke.log.warn(`Failed to removeSourceBuffer ${n}Buffer`, i);
      }
    }
  },
  changeType: (n) => (e, t) => {
    const i = t[`${e}Buffer`], r = xa(n);
    if (!pi(t.mediaSource, i))
      return;
    const a = n.substring(0, n.indexOf(".")), s = t.codecs[e];
    if (s.substring(0, s.indexOf(".")) === a)
      return;
    const u = {
      codecsChangeInfo: {
        from: s,
        to: n
      }
    };
    t.trigger({
      type: "codecschange",
      metadata: u
    }), t.logger_(`changing ${e}Buffer codec from ${s} to ${n}`);
    try {
      i.changeType(r), t.codecs[e] = n;
    } catch (c) {
      u.errorType = ke.Error.StreamingCodecsChangeError, u.error = c, c.metadata = u, t.error_ = c, t.trigger("error"), ke.log.warn(`Failed to changeType on ${e}Buffer`, c);
    }
  }
}, Tn = ({
  type: n,
  sourceUpdater: e,
  action: t,
  doneFn: i,
  name: r
}) => {
  e.queue.push({
    type: n,
    action: t,
    doneFn: i,
    name: r
  }), ga(n, e);
}, tT = (n, e) => (t) => {
  const i = e[`${n}Buffered`](), r = o9(i);
  if (e.logger_(`received "updateend" event for ${n} Source Buffer: `, r), e.queuePending[n]) {
    const a = e.queuePending[n].doneFn;
    e.queuePending[n] = null, a && a(e[`${n}Error_`]);
  }
  ga(n, e);
};
class I3 extends ke.EventTarget {
  constructor(e) {
    super(), this.mediaSource = e, this.sourceopenListener_ = () => ga("mediaSource", this), this.mediaSource.addEventListener("sourceopen", this.sourceopenListener_), this.logger_ = jn("SourceUpdater"), this.audioTimestampOffset_ = 0, this.videoTimestampOffset_ = 0, this.queue = [], this.queuePending = {
      audio: null,
      video: null
    }, this.delayedAudioAppendQueue_ = [], this.videoAppendQueued_ = !1, this.codecs = {}, this.onVideoUpdateEnd_ = tT("video", this), this.onAudioUpdateEnd_ = tT("audio", this), this.onVideoError_ = (t) => {
      this.videoError_ = t;
    }, this.onAudioError_ = (t) => {
      this.audioError_ = t;
    }, this.createdSourceBuffers_ = !1, this.initializedEme_ = !1, this.triggeredReady_ = !1;
  }
  initializedEme() {
    this.initializedEme_ = !0, this.triggerReady();
  }
  hasCreatedSourceBuffers() {
    return this.createdSourceBuffers_;
  }
  hasInitializedAnyEme() {
    return this.initializedEme_;
  }
  ready() {
    return this.hasCreatedSourceBuffers() && this.hasInitializedAnyEme();
  }
  createSourceBuffers(e) {
    this.hasCreatedSourceBuffers() || (this.addOrChangeSourceBuffers(e), this.createdSourceBuffers_ = !0, this.trigger("createdsourcebuffers"), this.triggerReady());
  }
  triggerReady() {
    this.ready() && !this.triggeredReady_ && (this.triggeredReady_ = !0, this.trigger("ready"));
  }
  /**
   * Add a type of source buffer to the media source.
   *
   * @param {string} type
   *        The type of source buffer to add.
   *
   * @param {string} codec
   *        The codec to add the source buffer with.
   */
  addSourceBuffer(e, t) {
    Tn({
      type: "mediaSource",
      sourceUpdater: this,
      action: _n.addSourceBuffer(e, t),
      name: "addSourceBuffer"
    });
  }
  /**
   * call abort on a source buffer.
   *
   * @param {string} type
   *        The type of source buffer to call abort on.
   */
  abort(e) {
    Tn({
      type: e,
      sourceUpdater: this,
      action: _n.abort(e),
      name: "abort"
    });
  }
  /**
   * Call removeSourceBuffer and remove a specific type
   * of source buffer on the mediaSource.
   *
   * @param {string} type
   *        The type of source buffer to remove.
   */
  removeSourceBuffer(e) {
    if (!this.canRemoveSourceBuffer()) {
      ke.log.error("removeSourceBuffer is not supported!");
      return;
    }
    Tn({
      type: "mediaSource",
      sourceUpdater: this,
      action: _n.removeSourceBuffer(e),
      name: "removeSourceBuffer"
    });
  }
  /**
   * Whether or not the removeSourceBuffer function is supported
   * on the mediaSource.
   *
   * @return {boolean}
   *          if removeSourceBuffer can be called.
   */
  canRemoveSourceBuffer() {
    return !ke.browser.IS_FIREFOX && me.MediaSource && me.MediaSource.prototype && typeof me.MediaSource.prototype.removeSourceBuffer == "function";
  }
  /**
   * Whether or not the changeType function is supported
   * on our SourceBuffers.
   *
   * @return {boolean}
   *         if changeType can be called.
   */
  static canChangeType() {
    return me.SourceBuffer && me.SourceBuffer.prototype && typeof me.SourceBuffer.prototype.changeType == "function";
  }
  /**
   * Whether or not the changeType function is supported
   * on our SourceBuffers.
   *
   * @return {boolean}
   *         if changeType can be called.
   */
  canChangeType() {
    return this.constructor.canChangeType();
  }
  /**
   * Call the changeType function on a source buffer, given the code and type.
   *
   * @param {string} type
   *        The type of source buffer to call changeType on.
   *
   * @param {string} codec
   *        The codec string to change type with on the source buffer.
   */
  changeType(e, t) {
    if (!this.canChangeType()) {
      ke.log.error("changeType is not supported!");
      return;
    }
    Tn({
      type: e,
      sourceUpdater: this,
      action: _n.changeType(t),
      name: "changeType"
    });
  }
  /**
   * Add source buffers with a codec or, if they are already created,
   * call changeType on source buffers using changeType.
   *
   * @param {Object} codecs
   *        Codecs to switch to
   */
  addOrChangeSourceBuffers(e) {
    if (!e || typeof e != "object" || Object.keys(e).length === 0)
      throw new Error("Cannot addOrChangeSourceBuffers to undefined codecs");
    Object.keys(e).forEach((t) => {
      const i = e[t];
      if (!this.hasCreatedSourceBuffers())
        return this.addSourceBuffer(t, i);
      this.canChangeType() && this.changeType(t, i);
    });
  }
  /**
   * Queue an update to append an ArrayBuffer.
   *
   * @param {MediaObject} object containing audioBytes and/or videoBytes
   * @param {Function} done the function to call when done
   * @see http://www.w3.org/TR/media-source/#widl-SourceBuffer-appendBuffer-void-ArrayBuffer-data
   */
  appendBuffer(e, t) {
    const {
      segmentInfo: i,
      type: r,
      bytes: a
    } = e;
    if (this.processedAppend_ = !0, r === "audio" && this.videoBuffer && !this.videoAppendQueued_) {
      this.delayedAudioAppendQueue_.push([e, t]), this.logger_(`delayed audio append of ${a.length} until video append`);
      return;
    }
    const s = t;
    if (Tn({
      type: r,
      sourceUpdater: this,
      action: _n.appendBuffer(a, i || {
        mediaIndex: -1
      }, s),
      doneFn: t,
      name: "appendBuffer"
    }), r === "video") {
      if (this.videoAppendQueued_ = !0, !this.delayedAudioAppendQueue_.length)
        return;
      const o = this.delayedAudioAppendQueue_.slice();
      this.logger_(`queuing delayed audio ${o.length} appendBuffers`), this.delayedAudioAppendQueue_.length = 0, o.forEach((u) => {
        this.appendBuffer.apply(this, u);
      });
    }
  }
  /**
   * Get the audio buffer's buffered timerange.
   *
   * @return {TimeRange}
   *         The audio buffer's buffered time range
   */
  audioBuffered() {
    return pi(this.mediaSource, this.audioBuffer) && this.audioBuffer.buffered ? this.audioBuffer.buffered : Vt();
  }
  /**
   * Get the video buffer's buffered timerange.
   *
   * @return {TimeRange}
   *         The video buffer's buffered time range
   */
  videoBuffered() {
    return pi(this.mediaSource, this.videoBuffer) && this.videoBuffer.buffered ? this.videoBuffer.buffered : Vt();
  }
  /**
   * Get a combined video/audio buffer's buffered timerange.
   *
   * @return {TimeRange}
   *         the combined time range
   */
  buffered() {
    const e = pi(this.mediaSource, this.videoBuffer) ? this.videoBuffer : null, t = pi(this.mediaSource, this.audioBuffer) ? this.audioBuffer : null;
    return t && !e ? this.audioBuffered() : e && !t ? this.videoBuffered() : c9(this.audioBuffered(), this.videoBuffered());
  }
  /**
   * Add a callback to the queue that will set duration on the mediaSource.
   *
   * @param {number} duration
   *        The duration to set
   *
   * @param {Function} [doneFn]
   *        function to run after duration has been set.
   */
  setDuration(e, t = Ii) {
    Tn({
      type: "mediaSource",
      sourceUpdater: this,
      action: _n.duration(e),
      name: "duration",
      doneFn: t
    });
  }
  /**
   * Add a mediaSource endOfStream call to the queue
   *
   * @param {Error} [error]
   *        Call endOfStream with an error
   *
   * @param {Function} [doneFn]
   *        A function that should be called when the
   *        endOfStream call has finished.
   */
  endOfStream(e = null, t = Ii) {
    typeof e != "string" && (e = void 0), Tn({
      type: "mediaSource",
      sourceUpdater: this,
      action: _n.endOfStream(e),
      name: "endOfStream",
      doneFn: t
    });
  }
  /**
   * Queue an update to remove a time range from the buffer.
   *
   * @param {number} start where to start the removal
   * @param {number} end where to end the removal
   * @param {Function} [done=noop] optional callback to be executed when the remove
   * operation is complete
   * @see http://www.w3.org/TR/media-source/#widl-SourceBuffer-remove-void-double-start-unrestricted-double-end
   */
  removeAudio(e, t, i = Ii) {
    if (!this.audioBuffered().length || this.audioBuffered().end(0) === 0) {
      i();
      return;
    }
    Tn({
      type: "audio",
      sourceUpdater: this,
      action: _n.remove(e, t),
      doneFn: i,
      name: "remove"
    });
  }
  /**
   * Queue an update to remove a time range from the buffer.
   *
   * @param {number} start where to start the removal
   * @param {number} end where to end the removal
   * @param {Function} [done=noop] optional callback to be executed when the remove
   * operation is complete
   * @see http://www.w3.org/TR/media-source/#widl-SourceBuffer-remove-void-double-start-unrestricted-double-end
   */
  removeVideo(e, t, i = Ii) {
    if (!this.videoBuffered().length || this.videoBuffered().end(0) === 0) {
      i();
      return;
    }
    Tn({
      type: "video",
      sourceUpdater: this,
      action: _n.remove(e, t),
      doneFn: i,
      name: "remove"
    });
  }
  /**
   * Whether the underlying sourceBuffer is updating or not
   *
   * @return {boolean} the updating status of the SourceBuffer
   */
  updating() {
    return !!(Om("audio", this) || Om("video", this));
  }
  /**
   * Set/get the timestampoffset on the audio SourceBuffer
   *
   * @return {number} the timestamp offset
   */
  audioTimestampOffset(e) {
    return typeof e < "u" && this.audioBuffer && // no point in updating if it's the same
    this.audioTimestampOffset_ !== e && (Tn({
      type: "audio",
      sourceUpdater: this,
      action: _n.timestampOffset(e),
      name: "timestampOffset"
    }), this.audioTimestampOffset_ = e), this.audioTimestampOffset_;
  }
  /**
   * Set/get the timestampoffset on the video SourceBuffer
   *
   * @return {number} the timestamp offset
   */
  videoTimestampOffset(e) {
    return typeof e < "u" && this.videoBuffer && // no point in updating if it's the same
    this.videoTimestampOffset_ !== e && (Tn({
      type: "video",
      sourceUpdater: this,
      action: _n.timestampOffset(e),
      name: "timestampOffset"
    }), this.videoTimestampOffset_ = e), this.videoTimestampOffset_;
  }
  /**
   * Add a function to the queue that will be called
   * when it is its turn to run in the audio queue.
   *
   * @param {Function} callback
   *        The callback to queue.
   */
  audioQueueCallback(e) {
    this.audioBuffer && Tn({
      type: "audio",
      sourceUpdater: this,
      action: _n.callback(e),
      name: "callback"
    });
  }
  /**
   * Add a function to the queue that will be called
   * when it is its turn to run in the video queue.
   *
   * @param {Function} callback
   *        The callback to queue.
   */
  videoQueueCallback(e) {
    this.videoBuffer && Tn({
      type: "video",
      sourceUpdater: this,
      action: _n.callback(e),
      name: "callback"
    });
  }
  /**
   * dispose of the source updater and the underlying sourceBuffer
   */
  dispose() {
    this.trigger("dispose"), GL.forEach((e) => {
      this.abort(e), this.canRemoveSourceBuffer() ? this.removeSourceBuffer(e) : this[`${e}QueueCallback`](() => k3(e, this));
    }), this.videoAppendQueued_ = !1, this.delayedAudioAppendQueue_.length = 0, this.sourceopenListener_ && this.mediaSource.removeEventListener("sourceopen", this.sourceopenListener_), this.off();
  }
}
const nT = (n) => decodeURIComponent(escape(String.fromCharCode.apply(null, n))), KL = (n) => {
  const e = new Uint8Array(n);
  return Array.from(e).map((t) => t.toString(16).padStart(2, "0")).join("");
}, iT = new Uint8Array(`

`.split("").map((n) => n.charCodeAt(0)));
class YL extends Error {
  constructor() {
    super("Trying to parse received VTT cues, but there is no WebVTT. Make sure vtt.js is loaded.");
  }
}
class QL extends Rm {
  constructor(e, t = {}) {
    super(e, t), this.mediaSource_ = null, this.subtitlesTrack_ = null, this.featuresNativeTextTracks_ = e.featuresNativeTextTracks, this.loadVttJs = e.loadVttJs, this.shouldSaveSegmentTimingInfo_ = !1;
  }
  /**
   * Indicates which time ranges are buffered
   *
   * @return {TimeRange}
   *         TimeRange object representing the current buffered ranges
   */
  buffered_() {
    if (!this.subtitlesTrack_ || !this.subtitlesTrack_.cues || !this.subtitlesTrack_.cues.length)
      return Vt();
    const e = this.subtitlesTrack_.cues, t = e[0].startTime, i = e[e.length - 1].startTime;
    return Vt([[t, i]]);
  }
  /**
   * Gets and sets init segment for the provided map
   *
   * @param {Object} map
   *        The map object representing the init segment to get or set
   * @param {boolean=} set
   *        If true, the init segment for the provided map should be saved
   * @return {Object}
   *         map object for desired init segment
   */
  initSegmentForMap(e, t = !1) {
    if (!e)
      return null;
    const i = Dc(e);
    let r = this.initSegments_[i];
    if (t && !r && e.bytes) {
      const a = iT.byteLength + e.bytes.byteLength, s = new Uint8Array(a);
      s.set(e.bytes), s.set(iT, e.bytes.byteLength), this.initSegments_[i] = r = {
        resolvedUri: e.resolvedUri,
        byterange: e.byterange,
        bytes: s
      };
    }
    return r || e;
  }
  /**
   * Returns true if all configuration required for loading is present, otherwise false.
   *
   * @return {boolean} True if the all configuration is ready for loading
   * @private
   */
  couldBeginLoading_() {
    return this.playlist_ && this.subtitlesTrack_ && !this.paused();
  }
  /**
   * Once all the starting parameters have been specified, begin
   * operation. This method should only be invoked from the INIT
   * state.
   *
   * @private
   */
  init_() {
    return this.state = "READY", this.resetEverything(), this.monitorBuffer_();
  }
  /**
   * Set a subtitle track on the segment loader to add subtitles to
   *
   * @param {TextTrack=} track
   *        The text track to add loaded subtitles to
   * @return {TextTrack}
   *        Returns the subtitles track
   */
  track(e) {
    return typeof e > "u" ? this.subtitlesTrack_ : (this.subtitlesTrack_ = e, this.state === "INIT" && this.couldBeginLoading_() && this.init_(), this.subtitlesTrack_);
  }
  /**
   * Remove any data in the source buffer between start and end times
   *
   * @param {number} start - the start time of the region to remove from the buffer
   * @param {number} end - the end time of the region to remove from the buffer
   */
  remove(e, t) {
    Ds(e, t, this.subtitlesTrack_);
  }
  /**
   * fill the buffer with segements unless the sourceBuffers are
   * currently updating
   *
   * Note: this function should only ever be called by monitorBuffer_
   * and never directly
   *
   * @private
   */
  fillBuffer_() {
    const e = this.chooseNextRequest_();
    if (e) {
      if (this.syncController_.timestampOffsetForTimeline(e.timeline) === null) {
        const t = () => {
          this.state = "READY", this.paused() || this.monitorBuffer_();
        };
        this.syncController_.one("timestampoffset", t), this.state = "WAITING_ON_TIMELINE";
        return;
      }
      this.loadSegment_(e);
    }
  }
  // never set a timestamp offset for vtt segments.
  timestampOffsetForSegment_() {
    return null;
  }
  chooseNextRequest_() {
    return this.skipEmptySegments_(super.chooseNextRequest_());
  }
  /**
   * Prevents the segment loader from requesting segments we know contain no subtitles
   * by walking forward until we find the next segment that we don't know whether it is
   * empty or not.
   *
   * @param {Object} segmentInfo
   *        a segment info object that describes the current segment
   * @return {Object}
   *         a segment info object that describes the current segment
   */
  skipEmptySegments_(e) {
    for (; e && e.segment.empty; ) {
      if (e.mediaIndex + 1 >= e.playlist.segments.length) {
        e = null;
        break;
      }
      e = this.generateSegmentInfo_({
        playlist: e.playlist,
        mediaIndex: e.mediaIndex + 1,
        startOfSegment: e.startOfSegment + e.duration,
        isSyncRequest: e.isSyncRequest
      });
    }
    return e;
  }
  stopForError(e) {
    this.error(e), this.state = "READY", this.pause(), this.trigger("error");
  }
  /**
   * append a decrypted segement to the SourceBuffer through a SourceUpdater
   *
   * @private
   */
  segmentRequestFinished_(e, t, i) {
    if (!this.subtitlesTrack_) {
      this.state = "READY";
      return;
    }
    if (this.saveTransferStats_(t.stats), !this.pendingSegment_) {
      this.state = "READY", this.mediaRequestsAborted += 1;
      return;
    }
    if (e) {
      e.code === yi.TIMEOUT && this.handleTimeout_(), e.code === yi.ABORTED ? this.mediaRequestsAborted += 1 : this.mediaRequestsErrored += 1, this.stopForError(e);
      return;
    }
    const r = this.pendingSegment_, a = i.mp4VttCues && i.mp4VttCues.length;
    a && (r.mp4VttCues = i.mp4VttCues), this.saveBandwidthRelatedStats_(r.duration, t.stats), t.key && this.segmentKey(t.key, !0), this.state = "APPENDING", this.trigger("appending");
    const s = r.segment;
    if (s.map && (s.map.bytes = t.map.bytes), r.bytes = t.bytes, typeof me.WebVTT != "function" && typeof this.loadVttJs == "function") {
      this.state = "WAITING_ON_VTTJS", this.loadVttJs().then(() => this.segmentRequestFinished_(e, t, i), () => this.stopForError({
        message: "Error loading vtt.js"
      }));
      return;
    }
    s.requested = !0;
    try {
      this.parseVTTCues_(r);
    } catch (o) {
      this.stopForError({
        message: o.message,
        metadata: {
          errorType: ke.Error.StreamingVttParserError,
          error: o
        }
      });
      return;
    }
    if (a || this.updateTimeMapping_(r, this.syncController_.timelines[r.timeline], this.playlist_), r.cues.length ? r.timingInfo = {
      start: r.cues[0].startTime,
      end: r.cues[r.cues.length - 1].endTime
    } : r.timingInfo = {
      start: r.startOfSegment,
      end: r.startOfSegment + r.duration
    }, r.isSyncRequest) {
      this.trigger("syncinfoupdate"), this.pendingSegment_ = null, this.state = "READY";
      return;
    }
    r.byteLength = r.bytes.byteLength, this.mediaSecondsLoaded += s.duration, r.cues.forEach((o) => {
      this.subtitlesTrack_.addCue(this.featuresNativeTextTracks_ ? new me.VTTCue(o.startTime, o.endTime, o.text) : o);
    }), OL(this.subtitlesTrack_), this.handleAppendsDone_();
  }
  handleData_(e, t) {
    const i = e && e.type === "vtt", r = t && t.type === "text";
    i && r && super.handleData_(e, t);
  }
  updateTimingInfoEnd_() {
  }
  /**
   * Utility function for converting mp4 webvtt cue objects into VTTCues.
   *
   * @param {Object} segmentInfo with mp4 webvtt cues for parsing into VTTCue objecs
   */
  parseMp4VttCues_(e) {
    const t = this.sourceUpdater_.videoTimestampOffset() === null ? this.sourceUpdater_.audioTimestampOffset() : this.sourceUpdater_.videoTimestampOffset();
    e.mp4VttCues.forEach((i) => {
      const r = i.start + t, a = i.end + t, s = new me.VTTCue(r, a, i.cueText);
      i.settings && i.settings.split(" ").forEach((o) => {
        const u = o.split(":"), c = u[0], l = u[1];
        s[c] = isNaN(l) ? l : Number(l);
      }), e.cues.push(s);
    });
  }
  /**
   * Uses the WebVTT parser to parse the segment response
   *
   * @throws NoVttJsError
   *
   * @param {Object} segmentInfo
   *        a segment info object that describes the current segment
   * @private
   */
  parseVTTCues_(e) {
    let t, i = !1;
    if (typeof me.WebVTT != "function")
      throw new YL();
    if (e.cues = [], e.timestampmap = {
      MPEGTS: 0,
      LOCAL: 0
    }, e.mp4VttCues) {
      this.parseMp4VttCues_(e);
      return;
    }
    typeof me.TextDecoder == "function" ? t = new me.TextDecoder("utf8") : (t = me.WebVTT.StringDecoder(), i = !0);
    const r = new me.WebVTT.Parser(me, me.vttjs, t);
    if (r.oncue = e.cues.push.bind(e.cues), r.ontimestampmap = (s) => {
      e.timestampmap = s;
    }, r.onparsingerror = (s) => {
      ke.log.warn("Error encountered when parsing cues: " + s.message);
    }, e.segment.map) {
      let s = e.segment.map.bytes;
      i && (s = nT(s)), r.parse(s);
    }
    let a = e.bytes;
    i && (a = nT(a)), r.parse(a), r.flush();
  }
  /**
   * Updates the start and end times of any cues parsed by the WebVTT parser using
   * the information parsed from the X-TIMESTAMP-MAP header and a TS to media time mapping
   * from the SyncController
   *
   * @param {Object} segmentInfo
   *        a segment info object that describes the current segment
   * @param {Object} mappingObj
   *        object containing a mapping from TS to media time
   * @param {Object} playlist
   *        the playlist object containing the segment
   * @private
   */
  updateTimeMapping_(e, t, i) {
    const r = e.segment;
    if (!t)
      return;
    if (!e.cues.length) {
      r.empty = !0;
      return;
    }
    const {
      MPEGTS: a,
      LOCAL: s
    } = e.timestampmap, u = a / Ar.ONE_SECOND_IN_TS - s + t.mapping;
    if (e.cues.forEach((c) => {
      const l = c.endTime - c.startTime, h = this.handleRollover_(c.startTime + u, t.time);
      c.startTime = Math.max(h, 0), c.endTime = Math.max(h + l, 0);
    }), !i.syncInfo) {
      const c = e.cues[0].startTime, l = e.cues[e.cues.length - 1].startTime;
      i.syncInfo = {
        mediaSequence: i.mediaSequence + e.mediaIndex,
        time: Math.min(c, l - r.duration)
      };
    }
  }
  /**
   * MPEG-TS PES timestamps are limited to 2^33.
   * Once they reach 2^33, they roll over to 0.
   * mux.js handles PES timestamp rollover for the following scenarios:
   * [forward rollover(right)] ->
   *    PES timestamps monotonically increase, and once they reach 2^33, they roll over to 0
   * [backward rollover(left)] -->
   *    we seek back to position before rollover.
   *
   * According to the HLS SPEC:
   * When synchronizing WebVTT with PES timestamps, clients SHOULD account
   * for cases where the 33-bit PES timestamps have wrapped and the WebVTT
   * cue times have not.  When the PES timestamp wraps, the WebVTT Segment
   * SHOULD have a X-TIMESTAMP-MAP header that maps the current WebVTT
   * time to the new (low valued) PES timestamp.
   *
   * So we want to handle rollover here and align VTT Cue start/end time to the player's time.
   */
  handleRollover_(e, t) {
    if (t === null)
      return e;
    let i = e * Ar.ONE_SECOND_IN_TS;
    const r = t * Ar.ONE_SECOND_IN_TS;
    let a;
    for (r < i ? a = -8589934592 : a = 8589934592; Math.abs(i - r) > 4294967296; )
      i += a;
    return i / Ar.ONE_SECOND_IN_TS;
  }
}
const ZL = function(n, e) {
  const t = n.cues;
  for (let i = 0; i < t.length; i++) {
    const r = t[i];
    if (e >= r.adStartTime && e <= r.adEndTime)
      return r;
  }
  return null;
}, JL = function(n, e, t = 0) {
  if (!n.segments)
    return;
  let i = t, r;
  for (let a = 0; a < n.segments.length; a++) {
    const s = n.segments[a];
    if (r || (r = ZL(e, i + s.duration / 2)), r) {
      if ("cueIn" in s) {
        r.endTime = i, r.adEndTime = i, i += s.duration, r = null;
        continue;
      }
      if (i < r.endTime) {
        i += s.duration;
        continue;
      }
      r.endTime += s.duration;
    } else if ("cueOut" in s && (r = new me.VTTCue(i, i + s.duration, s.cueOut), r.adStartTime = i, r.adEndTime = i + parseFloat(s.cueOut), e.addCue(r)), "cueOutCont" in s) {
      const [o, u] = s.cueOutCont.split("/").map(parseFloat);
      r = new me.VTTCue(i, i + s.duration, ""), r.adStartTime = i - o, r.adEndTime = r.adStartTime + u, e.addCue(r);
    }
    i += s.duration;
  }
};
class rT {
  /**
   * @param {number} start - media sequence start
   * @param {number} end - media sequence end
   * @param {number} segmentIndex - index for associated segment
   * @param {number|null} [partIndex] - index for associated part
   * @param {boolean} [appended] - appended indicator
   *
   */
  constructor({
    start: e,
    end: t,
    segmentIndex: i,
    partIndex: r = null,
    appended: a = !1
  }) {
    this.start_ = e, this.end_ = t, this.segmentIndex_ = i, this.partIndex_ = r, this.appended_ = a;
  }
  isInRange(e) {
    return e >= this.start && e < this.end;
  }
  markAppended() {
    this.appended_ = !0;
  }
  resetAppendedStatus() {
    this.appended_ = !1;
  }
  get isAppended() {
    return this.appended_;
  }
  get start() {
    return this.start_;
  }
  get end() {
    return this.end_;
  }
  get segmentIndex() {
    return this.segmentIndex_;
  }
  get partIndex() {
    return this.partIndex_;
  }
}
class eP {
  /**
   *
   * @param {SyncInfo} segmentSyncInfo - sync info for a given segment
   * @param {Array<SyncInfo>} [partsSyncInfo] - sync infos for a list of parts for a given segment
   */
  constructor(e, t = []) {
    this.segmentSyncInfo_ = e, this.partsSyncInfo_ = t;
  }
  get segmentSyncInfo() {
    return this.segmentSyncInfo_;
  }
  get partsSyncInfo() {
    return this.partsSyncInfo_;
  }
  get hasPartsSyncInfo() {
    return this.partsSyncInfo_.length > 0;
  }
  resetAppendStatus() {
    this.segmentSyncInfo_.resetAppendedStatus(), this.partsSyncInfo_.forEach((e) => e.resetAppendedStatus());
  }
}
class U3 {
  constructor() {
    this.storage_ = /* @__PURE__ */ new Map(), this.diagnostics_ = "", this.isReliable_ = !1, this.start_ = -1 / 0, this.end_ = 1 / 0;
  }
  get start() {
    return this.start_;
  }
  get end() {
    return this.end_;
  }
  get diagnostics() {
    return this.diagnostics_;
  }
  get isReliable() {
    return this.isReliable_;
  }
  resetAppendedStatus() {
    this.storage_.forEach((e) => e.resetAppendStatus());
  }
  /**
   * update sync storage
   *
   * @param {Object} playlist
   * @param {number} currentTime
   *
   * @return {void}
   */
  update(e, t) {
    const {
      mediaSequence: i,
      segments: r
    } = e;
    if (this.isReliable_ = this.isReliablePlaylist_(i, r), !!this.isReliable_)
      return this.updateStorage_(r, i, this.calculateBaseTime_(i, r, t));
  }
  /**
   * @param {number} targetTime
   * @return {SyncInfo|null}
   */
  getSyncInfoForTime(e) {
    for (const {
      segmentSyncInfo: t,
      partsSyncInfo: i
    } of this.storage_.values())
      if (i.length) {
        for (const r of i)
          if (r.isInRange(e))
            return r;
      } else if (t.isInRange(e))
        return t;
    return null;
  }
  getSyncInfoForMediaSequence(e) {
    return this.storage_.get(e);
  }
  updateStorage_(e, t, i) {
    const r = /* @__PURE__ */ new Map();
    let a = `
`, s = i, o = t;
    this.start_ = s, e.forEach((u, c) => {
      const l = this.storage_.get(o), h = s, f = h + u.duration, d = !!(l && l.segmentSyncInfo && l.segmentSyncInfo.isAppended), y = new rT({
        start: h,
        end: f,
        appended: d,
        segmentIndex: c
      });
      u.syncInfo = y;
      let m = s;
      const b = (u.parts || []).map((p, g) => {
        const v = m, _ = m + p.duration, x = !!(l && l.partsSyncInfo && l.partsSyncInfo[g] && l.partsSyncInfo[g].isAppended), T = new rT({
          start: v,
          end: _,
          appended: x,
          segmentIndex: c,
          partIndex: g
        });
        return m = _, a += `Media Sequence: ${o}.${g} | Range: ${v} --> ${_} | Appended: ${x}
`, p.syncInfo = T, T;
      });
      r.set(o, new eP(y, b)), a += `${C3(u.resolvedUri)} | Media Sequence: ${o} | Range: ${h} --> ${f} | Appended: ${d}
`, o++, s = f;
    }), this.end_ = s, this.storage_ = r, this.diagnostics_ = a;
  }
  calculateBaseTime_(e, t, i) {
    if (!this.storage_.size)
      return 0;
    if (this.storage_.has(e))
      return this.storage_.get(e).segmentSyncInfo.start;
    const r = Math.min(...this.storage_.keys());
    if (e < r) {
      const a = r - e;
      let s = this.storage_.get(r).segmentSyncInfo.start;
      for (let o = 0; o < a; o++) {
        const u = t[o];
        s -= u.duration;
      }
      return s;
    }
    return i;
  }
  isReliablePlaylist_(e, t) {
    return e != null && Array.isArray(t) && t.length;
  }
}
class aT extends U3 {
  constructor(e) {
    super(), this.parent_ = e;
  }
  calculateBaseTime_(e, t, i) {
    if (!this.storage_.size) {
      const r = this.parent_.getSyncInfoForMediaSequence(e);
      return r ? r.segmentSyncInfo.start : 0;
    }
    return super.calculateBaseTime_(e, t, i);
  }
}
const tP = 86400, Bp = [
  // Stategy "VOD": Handle the VOD-case where the sync-point is *always*
  //                the equivalence display-time 0 === segment-index 0
  {
    name: "VOD",
    run: (n, e, t, i, r) => t !== 1 / 0 ? {
      time: 0,
      segmentIndex: 0,
      partIndex: null
    } : null
  },
  {
    name: "MediaSequence",
    /**
     * run media sequence strategy
     *
     * @param {SyncController} syncController
     * @param {Object} playlist
     * @param {number} duration
     * @param {number} currentTimeline
     * @param {number} currentTime
     * @param {string} type
     */
    run: (n, e, t, i, r, a) => {
      const s = n.getMediaSequenceSync(a);
      if (!s || !s.isReliable)
        return null;
      const o = s.getSyncInfoForTime(r);
      return o ? {
        time: o.start,
        partIndex: o.partIndex,
        segmentIndex: o.segmentIndex
      } : null;
    }
  },
  // Stategy "ProgramDateTime": We have a program-date-time tag in this playlist
  {
    name: "ProgramDateTime",
    run: (n, e, t, i, r) => {
      if (!Object.keys(n.timelineToDatetimeMappings).length)
        return null;
      let a = null, s = null;
      const o = wm(e);
      r = r || 0;
      for (let u = 0; u < o.length; u++) {
        const c = e.endList || r === 0 ? u : o.length - (u + 1), l = o[c], h = l.segment, f = n.timelineToDatetimeMappings[h.timeline];
        if (!f || !h.dateTimeObject)
          continue;
        let y = h.dateTimeObject.getTime() / 1e3 + f;
        if (h.parts && typeof l.partIndex == "number")
          for (let b = 0; b < l.partIndex; b++)
            y += h.parts[b].duration;
        const m = Math.abs(r - y);
        if (s !== null && (m === 0 || s < m))
          break;
        s = m, a = {
          time: y,
          segmentIndex: l.segmentIndex,
          partIndex: l.partIndex
        };
      }
      return a;
    }
  },
  // Stategy "Segment": We have a known time mapping for a timeline and a
  //                    segment in the current timeline with timing data
  {
    name: "Segment",
    run: (n, e, t, i, r) => {
      let a = null, s = null;
      r = r || 0;
      const o = wm(e);
      for (let u = 0; u < o.length; u++) {
        const c = e.endList || r === 0 ? u : o.length - (u + 1), l = o[c], h = l.segment, f = l.part && l.part.start || h && h.start;
        if (h.timeline === i && typeof f < "u") {
          const d = Math.abs(r - f);
          if (s !== null && s < d)
            break;
          (!a || s === null || s >= d) && (s = d, a = {
            time: f,
            segmentIndex: l.segmentIndex,
            partIndex: l.partIndex
          });
        }
      }
      return a;
    }
  },
  // Stategy "Discontinuity": We have a discontinuity with a known
  //                          display-time
  {
    name: "Discontinuity",
    run: (n, e, t, i, r) => {
      let a = null;
      if (r = r || 0, e.discontinuityStarts && e.discontinuityStarts.length) {
        let s = null;
        for (let o = 0; o < e.discontinuityStarts.length; o++) {
          const u = e.discontinuityStarts[o], c = e.discontinuitySequence + o + 1, l = n.discontinuities[c];
          if (l) {
            const h = Math.abs(r - l.time);
            if (s !== null && s < h)
              break;
            (!a || s === null || s >= h) && (s = h, a = {
              time: l.time,
              segmentIndex: u,
              partIndex: null
            });
          }
        }
      }
      return a;
    }
  },
  // Stategy "Playlist": We have a playlist with a known mapping of
  //                     segment index to display time
  {
    name: "Playlist",
    run: (n, e, t, i, r) => e.syncInfo ? {
      time: e.syncInfo.time,
      segmentIndex: e.syncInfo.mediaSequence - e.mediaSequence,
      partIndex: null
    } : null
  }
];
class nP extends ke.EventTarget {
  constructor(e = {}) {
    super(), this.timelines = [], this.discontinuities = [], this.timelineToDatetimeMappings = {};
    const t = new U3(), i = new aT(t), r = new aT(t);
    this.mediaSequenceStorage_ = {
      main: t,
      audio: i,
      vtt: r
    }, this.logger_ = jn("SyncController");
  }
  /**
   *
   * @param {string} loaderType
   * @return {MediaSequenceSync|null}
   */
  getMediaSequenceSync(e) {
    return this.mediaSequenceStorage_[e] || null;
  }
  /**
   * Find a sync-point for the playlist specified
   *
   * A sync-point is defined as a known mapping from display-time to
   * a segment-index in the current playlist.
   *
   * @param {Playlist} playlist
   *        The playlist that needs a sync-point
   * @param {number} duration
   *        Duration of the MediaSource (Infinite if playing a live source)
   * @param {number} currentTimeline
   *        The last timeline from which a segment was loaded
   * @param {number} currentTime
   *        Current player's time
   * @param {string} type
   *        Segment loader type
   * @return {Object}
   *          A sync-point object
   */
  getSyncPoint(e, t, i, r, a) {
    if (t !== 1 / 0)
      return Bp.find(({
        name: u
      }) => u === "VOD").run(this, e, t);
    const s = this.runStrategies_(e, t, i, r, a);
    if (!s.length)
      return null;
    for (const o of s) {
      const {
        syncPoint: u,
        strategy: c
      } = o, {
        segmentIndex: l,
        time: h
      } = u;
      if (l < 0)
        continue;
      const f = e.segments[l], d = h, y = d + f.duration;
      if (this.logger_(`Strategy: ${c}. Current time: ${r}. selected segment: ${l}. Time: [${d} -> ${y}]}`), r >= d && r < y)
        return this.logger_("Found sync point with exact match: ", u), u;
    }
    return this.selectSyncPoint_(s, {
      key: "time",
      value: r
    });
  }
  /**
   * Calculate the amount of time that has expired off the playlist during playback
   *
   * @param {Playlist} playlist
   *        Playlist object to calculate expired from
   * @param {number} duration
   *        Duration of the MediaSource (Infinity if playling a live source)
   * @return {number|null}
   *          The amount of time that has expired off the playlist during playback. Null
   *          if no sync-points for the playlist can be found.
   */
  getExpiredTime(e, t) {
    if (!e || !e.segments)
      return null;
    const i = this.runStrategies_(e, t, e.discontinuitySequence, 0);
    if (!i.length)
      return null;
    const r = this.selectSyncPoint_(i, {
      key: "segmentIndex",
      value: 0
    });
    return r.segmentIndex > 0 && (r.time *= -1), Math.abs(r.time + Fs({
      defaultDuration: e.targetDuration,
      durationList: e.segments,
      startIndex: r.segmentIndex,
      endIndex: 0
    }));
  }
  /**
   * Runs each sync-point strategy and returns a list of sync-points returned by the
   * strategies
   *
   * @private
   * @param {Playlist} playlist
   *        The playlist that needs a sync-point
   * @param {number} duration
   *        Duration of the MediaSource (Infinity if playing a live source)
   * @param {number} currentTimeline
   *        The last timeline from which a segment was loaded
   * @param {number} currentTime
   *        Current player's time
   * @param {string} type
   *        Segment loader type
   * @return {Array}
   *          A list of sync-point objects
   */
  runStrategies_(e, t, i, r, a) {
    const s = [];
    for (let o = 0; o < Bp.length; o++) {
      const u = Bp[o], c = u.run(this, e, t, i, r, a);
      c && (c.strategy = u.name, s.push({
        strategy: u.name,
        syncPoint: c
      }));
    }
    return s;
  }
  /**
   * Selects the sync-point nearest the specified target
   *
   * @private
   * @param {Array} syncPoints
   *        List of sync-points to select from
   * @param {Object} target
   *        Object specifying the property and value we are targeting
   * @param {string} target.key
   *        Specifies the property to target. Must be either 'time' or 'segmentIndex'
   * @param {number} target.value
   *        The value to target for the specified key.
   * @return {Object}
   *          The sync-point nearest the target
   */
  selectSyncPoint_(e, t) {
    let i = e[0].syncPoint, r = Math.abs(e[0].syncPoint[t.key] - t.value), a = e[0].strategy;
    for (let s = 1; s < e.length; s++) {
      const o = Math.abs(e[s].syncPoint[t.key] - t.value);
      o < r && (r = o, i = e[s].syncPoint, a = e[s].strategy);
    }
    return this.logger_(`syncPoint for [${t.key}: ${t.value}] chosen with strategy [${a}]: [time:${i.time}, segmentIndex:${i.segmentIndex}` + (typeof i.partIndex == "number" ? `,partIndex:${i.partIndex}` : "") + "]"), i;
  }
  /**
   * Save any meta-data present on the segments when segments leave
   * the live window to the playlist to allow for synchronization at the
   * playlist level later.
   *
   * @param {Playlist} oldPlaylist - The previous active playlist
   * @param {Playlist} newPlaylist - The updated and most current playlist
   */
  saveExpiredSegmentInfo(e, t) {
    const i = t.mediaSequence - e.mediaSequence;
    if (i > tP) {
      ke.log.warn(`Not saving expired segment info. Media sequence gap ${i} is too large.`);
      return;
    }
    for (let r = i - 1; r >= 0; r--) {
      const a = e.segments[r];
      if (a && typeof a.start < "u") {
        t.syncInfo = {
          mediaSequence: e.mediaSequence + r,
          time: a.start
        }, this.logger_(`playlist refresh sync: [time:${t.syncInfo.time}, mediaSequence: ${t.syncInfo.mediaSequence}]`), this.trigger("syncinfoupdate");
        break;
      }
    }
  }
  /**
   * Save the mapping from playlist's ProgramDateTime to display. This should only happen
   * before segments start to load.
   *
   * @param {Playlist} playlist - The currently active playlist
   */
  setDateTimeMappingForStart(e) {
    if (this.timelineToDatetimeMappings = {}, e.segments && e.segments.length && e.segments[0].dateTimeObject) {
      const t = e.segments[0], i = t.dateTimeObject.getTime() / 1e3;
      this.timelineToDatetimeMappings[t.timeline] = -i;
    }
  }
  /**
   * Calculates and saves timeline mappings, playlist sync info, and segment timing values
   * based on the latest timing information.
   *
   * @param {Object} options
   *        Options object
   * @param {SegmentInfo} options.segmentInfo
   *        The current active request information
   * @param {boolean} options.shouldSaveTimelineMapping
   *        If there's a timeline change, determines if the timeline mapping should be
   *        saved for timeline mapping and program date time mappings.
   */
  saveSegmentTimingInfo({
    segmentInfo: e,
    shouldSaveTimelineMapping: t
  }) {
    const i = this.calculateSegmentTimeMapping_(e, e.timingInfo, t), r = e.segment;
    i && (this.saveDiscontinuitySyncInfo_(e), e.playlist.syncInfo || (e.playlist.syncInfo = {
      mediaSequence: e.playlist.mediaSequence + e.mediaIndex,
      time: r.start
    }));
    const a = r.dateTimeObject;
    r.discontinuity && t && a && (this.timelineToDatetimeMappings[r.timeline] = -(a.getTime() / 1e3));
  }
  timestampOffsetForTimeline(e) {
    return typeof this.timelines[e] > "u" ? null : this.timelines[e].time;
  }
  mappingForTimeline(e) {
    return typeof this.timelines[e] > "u" ? null : this.timelines[e].mapping;
  }
  /**
   * Use the "media time" for a segment to generate a mapping to "display time" and
   * save that display time to the segment.
   *
   * @private
   * @param {SegmentInfo} segmentInfo
   *        The current active request information
   * @param {Object} timingInfo
   *        The start and end time of the current segment in "media time"
   * @param {boolean} shouldSaveTimelineMapping
   *        If there's a timeline change, determines if the timeline mapping should be
   *        saved in timelines.
   * @return {boolean}
   *          Returns false if segment time mapping could not be calculated
   */
  calculateSegmentTimeMapping_(e, t, i) {
    const r = e.segment, a = e.part;
    let s = this.timelines[e.timeline], o, u;
    if (typeof e.timestampOffset == "number")
      s = {
        time: e.startOfSegment,
        mapping: e.startOfSegment - t.start
      }, i && (this.timelines[e.timeline] = s, this.trigger("timestampoffset"), this.logger_(`time mapping for timeline ${e.timeline}: [time: ${s.time}] [mapping: ${s.mapping}]`)), o = e.startOfSegment, u = t.end + s.mapping;
    else if (s)
      o = t.start + s.mapping, u = t.end + s.mapping;
    else
      return !1;
    return a && (a.start = o, a.end = u), (!r.start || o < r.start) && (r.start = o), r.end = u, !0;
  }
  /**
   * Each time we have discontinuity in the playlist, attempt to calculate the location
   * in display of the start of the discontinuity and save that. We also save an accuracy
   * value so that we save values with the most accuracy (closest to 0.)
   *
   * @private
   * @param {SegmentInfo} segmentInfo - The current active request information
   */
  saveDiscontinuitySyncInfo_(e) {
    const t = e.playlist, i = e.segment;
    if (i.discontinuity)
      this.discontinuities[i.timeline] = {
        time: i.start,
        accuracy: 0
      };
    else if (t.discontinuityStarts && t.discontinuityStarts.length)
      for (let r = 0; r < t.discontinuityStarts.length; r++) {
        const a = t.discontinuityStarts[r], s = t.discontinuitySequence + r + 1, o = a - e.mediaIndex, u = Math.abs(o);
        if (!this.discontinuities[s] || this.discontinuities[s].accuracy > u) {
          let c;
          o < 0 ? c = i.start - Fs({
            defaultDuration: t.targetDuration,
            durationList: t.segments,
            startIndex: e.mediaIndex,
            endIndex: a
          }) : c = i.end + Fs({
            defaultDuration: t.targetDuration,
            durationList: t.segments,
            startIndex: e.mediaIndex + 1,
            endIndex: a
          }), this.discontinuities[s] = {
            time: c,
            accuracy: u
          };
        }
      }
  }
  dispose() {
    this.trigger("dispose"), this.off();
  }
}
class iP extends ke.EventTarget {
  constructor() {
    super(), this.pendingTimelineChanges_ = {}, this.lastTimelineChanges_ = {};
  }
  clearPendingTimelineChange(e) {
    this.pendingTimelineChanges_[e] = null, this.trigger("pendingtimelinechange");
  }
  pendingTimelineChange({
    type: e,
    from: t,
    to: i
  }) {
    return typeof t == "number" && typeof i == "number" && (this.pendingTimelineChanges_[e] = {
      type: e,
      from: t,
      to: i
    }, this.trigger("pendingtimelinechange")), this.pendingTimelineChanges_[e];
  }
  lastTimelineChange({
    type: e,
    from: t,
    to: i
  }) {
    if (typeof t == "number" && typeof i == "number") {
      this.lastTimelineChanges_[e] = {
        type: e,
        from: t,
        to: i
      }, delete this.pendingTimelineChanges_[e];
      const r = {
        timelineChangeInfo: {
          from: t,
          to: i
        }
      };
      this.trigger({
        type: "timelinechange",
        metadata: r
      });
    }
    return this.lastTimelineChanges_[e];
  }
  dispose() {
    this.trigger("dispose"), this.pendingTimelineChanges_ = {}, this.lastTimelineChanges_ = {}, this.off();
  }
}
const rP = g3(b3(function() {
  var n = /* @__PURE__ */ (function() {
    function m() {
      this.listeners = {};
    }
    var b = m.prototype;
    return b.on = function(g, v) {
      this.listeners[g] || (this.listeners[g] = []), this.listeners[g].push(v);
    }, b.off = function(g, v) {
      if (!this.listeners[g])
        return !1;
      var _ = this.listeners[g].indexOf(v);
      return this.listeners[g] = this.listeners[g].slice(0), this.listeners[g].splice(_, 1), _ > -1;
    }, b.trigger = function(g) {
      var v = this.listeners[g];
      if (v)
        if (arguments.length === 2)
          for (var _ = v.length, x = 0; x < _; ++x)
            v[x].call(this, arguments[1]);
        else
          for (var T = Array.prototype.slice.call(arguments, 1), E = v.length, U = 0; U < E; ++U)
            v[U].apply(this, T);
    }, b.dispose = function() {
      this.listeners = {};
    }, b.pipe = function(g) {
      this.on("data", function(v) {
        g.push(v);
      });
    }, m;
  })();
  /*! @name pkcs7 @version 1.0.4 @license Apache-2.0 */
  function e(m) {
    return m.subarray(0, m.byteLength - m[m.byteLength - 1]);
  }
  /*! @name aes-decrypter @version 4.0.2 @license Apache-2.0 */
  const t = function() {
    const m = [[[], [], [], [], []], [[], [], [], [], []]], b = m[0], p = m[1], g = b[4], v = p[4];
    let _, x, T;
    const E = [], U = [];
    let D, L, j, C, k, I;
    for (_ = 0; _ < 256; _++)
      U[(E[_] = _ << 1 ^ (_ >> 7) * 283) ^ _] = _;
    for (x = T = 0; !g[x]; x ^= D || 1, T = U[T] || 1)
      for (C = T ^ T << 1 ^ T << 2 ^ T << 3 ^ T << 4, C = C >> 8 ^ C & 255 ^ 99, g[x] = C, v[C] = x, j = E[L = E[D = E[x]]], I = j * 16843009 ^ L * 65537 ^ D * 257 ^ x * 16843008, k = E[C] * 257 ^ C * 16843008, _ = 0; _ < 4; _++)
        b[_][x] = k = k << 24 ^ k >>> 8, p[_][C] = I = I << 24 ^ I >>> 8;
    for (_ = 0; _ < 5; _++)
      b[_] = b[_].slice(0), p[_] = p[_].slice(0);
    return m;
  };
  let i = null;
  class r {
    constructor(b) {
      i || (i = t()), this._tables = [[i[0][0].slice(), i[0][1].slice(), i[0][2].slice(), i[0][3].slice(), i[0][4].slice()], [i[1][0].slice(), i[1][1].slice(), i[1][2].slice(), i[1][3].slice(), i[1][4].slice()]];
      let p, g, v;
      const _ = this._tables[0][4], x = this._tables[1], T = b.length;
      let E = 1;
      if (T !== 4 && T !== 6 && T !== 8)
        throw new Error("Invalid aes key size");
      const U = b.slice(0), D = [];
      for (this._key = [U, D], p = T; p < 4 * T + 28; p++)
        v = U[p - 1], (p % T === 0 || T === 8 && p % T === 4) && (v = _[v >>> 24] << 24 ^ _[v >> 16 & 255] << 16 ^ _[v >> 8 & 255] << 8 ^ _[v & 255], p % T === 0 && (v = v << 8 ^ v >>> 24 ^ E << 24, E = E << 1 ^ (E >> 7) * 283)), U[p] = U[p - T] ^ v;
      for (g = 0; p; g++, p--)
        v = U[g & 3 ? p : p - 4], p <= 4 || g < 4 ? D[g] = v : D[g] = x[0][_[v >>> 24]] ^ x[1][_[v >> 16 & 255]] ^ x[2][_[v >> 8 & 255]] ^ x[3][_[v & 255]];
    }
    /**
     * Decrypt 16 bytes, specified as four 32-bit words.
     *
     * @param {number} encrypted0 the first word to decrypt
     * @param {number} encrypted1 the second word to decrypt
     * @param {number} encrypted2 the third word to decrypt
     * @param {number} encrypted3 the fourth word to decrypt
     * @param {Int32Array} out the array to write the decrypted words
     * into
     * @param {number} offset the offset into the output array to start
     * writing results
     * @return {Array} The plaintext.
     */
    decrypt(b, p, g, v, _, x) {
      const T = this._key[1];
      let E = b ^ T[0], U = v ^ T[1], D = g ^ T[2], L = p ^ T[3], j, C, k;
      const I = T.length / 4 - 2;
      let $, W = 4;
      const B = this._tables[1], z = B[0], q = B[1], Y = B[2], H = B[3], K = B[4];
      for ($ = 0; $ < I; $++)
        j = z[E >>> 24] ^ q[U >> 16 & 255] ^ Y[D >> 8 & 255] ^ H[L & 255] ^ T[W], C = z[U >>> 24] ^ q[D >> 16 & 255] ^ Y[L >> 8 & 255] ^ H[E & 255] ^ T[W + 1], k = z[D >>> 24] ^ q[L >> 16 & 255] ^ Y[E >> 8 & 255] ^ H[U & 255] ^ T[W + 2], L = z[L >>> 24] ^ q[E >> 16 & 255] ^ Y[U >> 8 & 255] ^ H[D & 255] ^ T[W + 3], W += 4, E = j, U = C, D = k;
      for ($ = 0; $ < 4; $++)
        _[(3 & -$) + x] = K[E >>> 24] << 24 ^ K[U >> 16 & 255] << 16 ^ K[D >> 8 & 255] << 8 ^ K[L & 255] ^ T[W++], j = E, E = U, U = D, D = L, L = j;
    }
  }
  class a extends n {
    constructor() {
      super(n), this.jobs = [], this.delay = 1, this.timeout_ = null;
    }
    /**
     * process an async job
     *
     * @private
     */
    processJob_() {
      this.jobs.shift()(), this.jobs.length ? this.timeout_ = setTimeout(this.processJob_.bind(this), this.delay) : this.timeout_ = null;
    }
    /**
     * push a job into the stream
     *
     * @param {Function} job the job to push into the stream
     */
    push(b) {
      this.jobs.push(b), this.timeout_ || (this.timeout_ = setTimeout(this.processJob_.bind(this), this.delay));
    }
  }
  const s = function(m) {
    return m << 24 | (m & 65280) << 8 | (m & 16711680) >> 8 | m >>> 24;
  }, o = function(m, b, p) {
    const g = new Int32Array(m.buffer, m.byteOffset, m.byteLength >> 2), v = new r(Array.prototype.slice.call(b)), _ = new Uint8Array(m.byteLength), x = new Int32Array(_.buffer);
    let T, E, U, D, L, j, C, k, I;
    for (T = p[0], E = p[1], U = p[2], D = p[3], I = 0; I < g.length; I += 4)
      L = s(g[I]), j = s(g[I + 1]), C = s(g[I + 2]), k = s(g[I + 3]), v.decrypt(L, j, C, k, x, I), x[I] = s(x[I] ^ T), x[I + 1] = s(x[I + 1] ^ E), x[I + 2] = s(x[I + 2] ^ U), x[I + 3] = s(x[I + 3] ^ D), T = L, E = j, U = C, D = k;
    return _;
  };
  class u {
    constructor(b, p, g, v) {
      const _ = u.STEP, x = new Int32Array(b.buffer), T = new Uint8Array(b.byteLength);
      let E = 0;
      for (this.asyncStream_ = new a(), this.asyncStream_.push(this.decryptChunk_(x.subarray(E, E + _), p, g, T)), E = _; E < x.length; E += _)
        g = new Uint32Array([s(x[E - 4]), s(x[E - 3]), s(x[E - 2]), s(x[E - 1])]), this.asyncStream_.push(this.decryptChunk_(x.subarray(E, E + _), p, g, T));
      this.asyncStream_.push(function() {
        v(null, e(T));
      });
    }
    /**
     * a getter for step the maximum number of bytes to process at one time
     *
     * @return {number} the value of step 32000
     */
    static get STEP() {
      return 32e3;
    }
    /**
     * @private
     */
    decryptChunk_(b, p, g, v) {
      return function() {
        const _ = o(b, p, g);
        v.set(_, b.byteOffset);
      };
    }
  }
  var c = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {}, l;
  typeof window < "u" ? l = window : typeof c < "u" ? l = c : typeof self < "u" ? l = self : l = {};
  var h = l, f = function(b) {
    return ArrayBuffer.isView === "function" ? ArrayBuffer.isView(b) : b && b.buffer instanceof ArrayBuffer;
  }, d = h.BigInt || Number;
  d("0x1"), d("0x100"), d("0x10000"), d("0x1000000"), d("0x100000000"), d("0x10000000000"), d("0x1000000000000"), d("0x100000000000000"), d("0x10000000000000000"), (function() {
    var m = new Uint16Array([65484]), b = new Uint8Array(m.buffer, m.byteOffset, m.byteLength);
    return b[0] === 255 ? "big" : b[0] === 204 ? "little" : "unknown";
  })();
  const y = function(m) {
    const b = {};
    return Object.keys(m).forEach((p) => {
      const g = m[p];
      f(g) ? b[p] = {
        bytes: g.buffer,
        byteOffset: g.byteOffset,
        byteLength: g.byteLength
      } : b[p] = g;
    }), b;
  };
  self.onmessage = function(m) {
    const b = m.data, p = new Uint8Array(b.encrypted.bytes, b.encrypted.byteOffset, b.encrypted.byteLength), g = new Uint32Array(b.key.bytes, b.key.byteOffset, b.key.byteLength / 4), v = new Uint32Array(b.iv.bytes, b.iv.byteOffset, b.iv.byteLength / 4);
    new u(p, g, v, function(_, x) {
      self.postMessage(y({
        source: b.source,
        decrypted: x
      }), [x.buffer]);
    });
  };
}));
var aP = m3(rP);
const sP = (n) => {
  let e = n.default ? "main" : "alternative";
  return n.characteristics && n.characteristics.indexOf("public.accessibility.describes-video") >= 0 && (e = "main-desc"), e;
}, R3 = (n, e) => {
  n.abort(), n.pause(), e && e.activePlaylistLoader && (e.activePlaylistLoader.pause(), e.activePlaylistLoader = null);
}, Lm = (n, e) => {
  e.activePlaylistLoader = n, n.load();
}, oP = (n, e) => () => {
  const {
    segmentLoaders: {
      [n]: t,
      main: i
    },
    mediaTypes: {
      [n]: r
    }
  } = e, a = r.activeTrack(), s = r.getActiveGroup(), o = r.activePlaylistLoader, u = r.lastGroup_;
  if (!(s && u && s.id === u.id) && (r.lastGroup_ = s, r.lastTrack_ = a, R3(t, r), !(!s || s.isMainPlaylist))) {
    if (!s.playlistLoader) {
      o && i.resetEverything();
      return;
    }
    t.resyncLoader(), Lm(s.playlistLoader, r);
  }
}, uP = (n, e) => () => {
  const {
    segmentLoaders: {
      [n]: t
    },
    mediaTypes: {
      [n]: i
    }
  } = e;
  i.lastGroup_ = null, t.abort(), t.pause();
}, cP = (n, e) => () => {
  const {
    mainPlaylistLoader: t,
    segmentLoaders: {
      [n]: i,
      main: r
    },
    mediaTypes: {
      [n]: a
    }
  } = e, s = a.activeTrack(), o = a.getActiveGroup(), u = a.activePlaylistLoader, c = a.lastTrack_;
  if (!(c && s && c.id === s.id) && (a.lastGroup_ = o, a.lastTrack_ = s, R3(i, a), !!o)) {
    if (o.isMainPlaylist) {
      if (!s || !c || s.id === c.id)
        return;
      const l = e.vhs.playlistController_, h = l.selectPlaylist();
      if (l.media() === h)
        return;
      a.logger_(`track change. Switching main audio from ${c.id} to ${s.id}`), t.pause(), r.resetEverything(), l.fastQualityChange_(h);
      return;
    }
    if (n === "AUDIO") {
      if (!o.playlistLoader) {
        r.setAudio(!0), r.resetEverything();
        return;
      }
      i.setAudio(!0), r.setAudio(!1);
    }
    if (u === o.playlistLoader) {
      Lm(o.playlistLoader, a);
      return;
    }
    i.track && i.track(s), i.resetEverything(), Lm(o.playlistLoader, a);
  }
}, Sc = {
  /**
   * Returns a function to be called when a SegmentLoader or PlaylistLoader encounters
   * an error.
   *
   * @param {string} type
   *        MediaGroup type
   * @param {Object} settings
   *        Object containing required information for media groups
   * @return {Function}
   *         Error handler. Logs warning (or error if the playlist is excluded) to
   *         console and switches back to default audio track.
   * @function onError.AUDIO
   */
  AUDIO: (n, e) => () => {
    const {
      mediaTypes: {
        [n]: t
      },
      excludePlaylist: i
    } = e, r = t.activeTrack(), a = t.activeGroup(), s = (a.filter((u) => u.default)[0] || a[0]).id, o = t.tracks[s];
    if (r === o) {
      i({
        error: {
          message: "Problem encountered loading the default audio track."
        }
      });
      return;
    }
    ke.log.warn("Problem encountered loading the alternate audio track.Switching back to default.");
    for (const u in t.tracks)
      t.tracks[u].enabled = t.tracks[u] === o;
    t.onTrackChanged();
  },
  /**
   * Returns a function to be called when a SegmentLoader or PlaylistLoader encounters
   * an error.
   *
   * @param {string} type
   *        MediaGroup type
   * @param {Object} settings
   *        Object containing required information for media groups
   * @return {Function}
   *         Error handler. Logs warning to console and disables the active subtitle track
   * @function onError.SUBTITLES
   */
  SUBTITLES: (n, e) => () => {
    const {
      mediaTypes: {
        [n]: t
      }
    } = e;
    ke.log.warn("Problem encountered loading the subtitle track.Disabling subtitle track.");
    const i = t.activeTrack();
    i && (i.mode = "disabled"), t.onTrackChanged();
  }
}, sT = {
  /**
   * Setup event listeners for audio playlist loader
   *
   * @param {string} type
   *        MediaGroup type
   * @param {PlaylistLoader|null} playlistLoader
   *        PlaylistLoader to register listeners on
   * @param {Object} settings
   *        Object containing required information for media groups
   * @function setupListeners.AUDIO
   */
  AUDIO: (n, e, t) => {
    if (!e)
      return;
    const {
      tech: i,
      requestOptions: r,
      segmentLoaders: {
        [n]: a
      }
    } = t;
    e.on("loadedmetadata", () => {
      const s = e.media();
      a.playlist(s, r), (!i.paused() || s.endList && i.preload() !== "none") && a.load();
    }), e.on("loadedplaylist", () => {
      a.playlist(e.media(), r), i.paused() || a.load();
    }), e.on("error", Sc[n](n, t));
  },
  /**
   * Setup event listeners for subtitle playlist loader
   *
   * @param {string} type
   *        MediaGroup type
   * @param {PlaylistLoader|null} playlistLoader
   *        PlaylistLoader to register listeners on
   * @param {Object} settings
   *        Object containing required information for media groups
   * @function setupListeners.SUBTITLES
   */
  SUBTITLES: (n, e, t) => {
    const {
      tech: i,
      requestOptions: r,
      segmentLoaders: {
        [n]: a
      },
      mediaTypes: {
        [n]: s
      }
    } = t;
    e.on("loadedmetadata", () => {
      const o = e.media();
      a.playlist(o, r), a.track(s.activeTrack()), (!i.paused() || o.endList && i.preload() !== "none") && a.load();
    }), e.on("loadedplaylist", () => {
      a.playlist(e.media(), r), i.paused() || a.load();
    }), e.on("error", Sc[n](n, t));
  }
}, lP = {
  /**
   * Setup PlaylistLoaders and AudioTracks for the audio groups
   *
   * @param {string} type
   *        MediaGroup type
   * @param {Object} settings
   *        Object containing required information for media groups
   * @function initialize.AUDIO
   */
  AUDIO: (n, e) => {
    const {
      vhs: t,
      sourceType: i,
      segmentLoaders: {
        [n]: r
      },
      requestOptions: a,
      main: {
        mediaGroups: s
      },
      mediaTypes: {
        [n]: {
          groups: o,
          tracks: u,
          logger_: c
        }
      },
      mainPlaylistLoader: l
    } = e, h = vo(l.main);
    (!s[n] || Object.keys(s[n]).length === 0) && (s[n] = {
      main: {
        default: {
          default: !0
        }
      }
    }, h && (s[n].main.default.playlists = l.main.playlists));
    for (const f in s[n]) {
      o[f] || (o[f] = []);
      for (const d in s[n][f]) {
        let y = s[n][f][d], m;
        if (h ? (c(`AUDIO group '${f}' label '${d}' is a main playlist`), y.isMainPlaylist = !0, m = null) : i === "vhs-json" && y.playlists ? m = new ra(y.playlists[0], t, a) : y.resolvedUri ? m = new ra(y.resolvedUri, t, a) : y.playlists && i === "dash" ? m = new km(y.playlists[0], t, a, l) : m = null, y = ft({
          id: d,
          playlistLoader: m
        }, y), sT[n](n, y.playlistLoader, e), o[f].push(y), typeof u[d] > "u") {
          const b = new ke.AudioTrack({
            id: d,
            kind: sP(y),
            enabled: !1,
            language: y.language,
            default: y.default,
            label: d
          });
          u[d] = b;
        }
      }
    }
    r.on("error", Sc[n](n, e));
  },
  /**
   * Setup PlaylistLoaders and TextTracks for the subtitle groups
   *
   * @param {string} type
   *        MediaGroup type
   * @param {Object} settings
   *        Object containing required information for media groups
   * @function initialize.SUBTITLES
   */
  SUBTITLES: (n, e) => {
    const {
      tech: t,
      vhs: i,
      sourceType: r,
      segmentLoaders: {
        [n]: a
      },
      requestOptions: s,
      main: {
        mediaGroups: o
      },
      mediaTypes: {
        [n]: {
          groups: u,
          tracks: c
        }
      },
      mainPlaylistLoader: l
    } = e;
    for (const h in o[n]) {
      u[h] || (u[h] = []);
      for (const f in o[n][h]) {
        if (!i.options_.useForcedSubtitles && o[n][h][f].forced)
          continue;
        let d = o[n][h][f], y;
        if (r === "hls")
          y = new ra(d.resolvedUri, i, s);
        else if (r === "dash") {
          if (!d.playlists.filter((b) => b.excludeUntil !== 1 / 0).length)
            return;
          y = new km(d.playlists[0], i, s, l);
        } else r === "vhs-json" && (y = new ra(
          // if the vhs-json object included the media playlist, use the media playlist
          // as provided, otherwise use the resolved URI to load the playlist
          d.playlists ? d.playlists[0] : d.resolvedUri,
          i,
          s
        ));
        if (d = ft({
          id: f,
          playlistLoader: y
        }, d), sT[n](n, d.playlistLoader, e), u[h].push(d), typeof c[f] > "u") {
          const m = t.addRemoteTextTrack({
            id: f,
            kind: "subtitles",
            default: d.default && d.autoselect,
            language: d.language,
            label: f
          }, !1).track;
          c[f] = m;
        }
      }
    }
    a.on("error", Sc[n](n, e));
  },
  /**
   * Setup TextTracks for the closed-caption groups
   *
   * @param {String} type
   *        MediaGroup type
   * @param {Object} settings
   *        Object containing required information for media groups
   * @function initialize['CLOSED-CAPTIONS']
   */
  "CLOSED-CAPTIONS": (n, e) => {
    const {
      tech: t,
      main: {
        mediaGroups: i
      },
      mediaTypes: {
        [n]: {
          groups: r,
          tracks: a
        }
      }
    } = e;
    for (const s in i[n]) {
      r[s] || (r[s] = []);
      for (const o in i[n][s]) {
        const u = i[n][s][o];
        if (!/^(?:CC|SERVICE)/.test(u.instreamId))
          continue;
        const c = t.options_.vhs && t.options_.vhs.captionServices || {};
        let l = {
          label: o,
          language: u.language,
          instreamId: u.instreamId,
          default: u.default && u.autoselect
        };
        if (c[l.instreamId] && (l = ft(l, c[l.instreamId])), l.default === void 0 && delete l.default, r[s].push(ft({
          id: o
        }, u)), typeof a[o] > "u") {
          const h = t.addRemoteTextTrack({
            id: l.instreamId,
            kind: "captions",
            default: l.default,
            language: l.language,
            label: l.label
          }, !1).track;
          a[o] = h;
        }
      }
    }
  }
}, O3 = (n, e) => {
  for (let t = 0; t < n.length; t++)
    if (S0(e, n[t]) || n[t].playlists && O3(n[t].playlists, e))
      return !0;
  return !1;
}, dP = (n, e) => (t) => {
  const {
    mainPlaylistLoader: i,
    mediaTypes: {
      [n]: {
        groups: r
      }
    }
  } = e, a = i.media();
  if (!a)
    return null;
  let s = null;
  a.attributes[n] && (s = r[a.attributes[n]]);
  const o = Object.keys(r);
  if (!s)
    if (n === "AUDIO" && o.length > 1 && vo(e.main))
      for (let u = 0; u < o.length; u++) {
        const c = r[o[u]];
        if (O3(c, a)) {
          s = c;
          break;
        }
      }
    else r.main ? s = r.main : o.length === 1 && (s = r[o[0]]);
  return typeof t > "u" ? s : t === null || !s ? null : s.filter((u) => u.id === t.id)[0] || null;
}, fP = {
  /**
   * Returns a function used to get the active track of type provided
   *
   * @param {string} type
   *        MediaGroup type
   * @param {Object} settings
   *        Object containing required information for media groups
   * @return {Function}
   *         Function that returns the active media track for the provided type. Returns
   *         null if no track is active
   * @function activeTrack.AUDIO
   */
  AUDIO: (n, e) => () => {
    const {
      mediaTypes: {
        [n]: {
          tracks: t
        }
      }
    } = e;
    for (const i in t)
      if (t[i].enabled)
        return t[i];
    return null;
  },
  /**
   * Returns a function used to get the active track of type provided
   *
   * @param {string} type
   *        MediaGroup type
   * @param {Object} settings
   *        Object containing required information for media groups
   * @return {Function}
   *         Function that returns the active media track for the provided type. Returns
   *         null if no track is active
   * @function activeTrack.SUBTITLES
   */
  SUBTITLES: (n, e) => () => {
    const {
      mediaTypes: {
        [n]: {
          tracks: t
        }
      }
    } = e;
    for (const i in t)
      if (t[i].mode === "showing" || t[i].mode === "hidden")
        return t[i];
    return null;
  }
}, hP = (n, {
  mediaTypes: e
}) => () => {
  const t = e[n].activeTrack();
  return t ? e[n].activeGroup(t) : null;
}, pP = (n) => {
  ["AUDIO", "SUBTITLES", "CLOSED-CAPTIONS"].forEach((c) => {
    lP[c](c, n);
  });
  const {
    mediaTypes: e,
    mainPlaylistLoader: t,
    tech: i,
    vhs: r,
    segmentLoaders: {
      ["AUDIO"]: a,
      main: s
    }
  } = n;
  ["AUDIO", "SUBTITLES"].forEach((c) => {
    e[c].activeGroup = dP(c, n), e[c].activeTrack = fP[c](c, n), e[c].onGroupChanged = oP(c, n), e[c].onGroupChanging = uP(c, n), e[c].onTrackChanged = cP(c, n), e[c].getActiveGroup = hP(c, n);
  });
  const o = e.AUDIO.activeGroup();
  if (o) {
    const c = (o.filter((h) => h.default)[0] || o[0]).id;
    e.AUDIO.tracks[c].enabled = !0, e.AUDIO.onGroupChanged(), e.AUDIO.onTrackChanged(), e.AUDIO.getActiveGroup().playlistLoader ? (s.setAudio(!1), a.setAudio(!0)) : s.setAudio(!0);
  }
  t.on("mediachange", () => {
    ["AUDIO", "SUBTITLES"].forEach((c) => e[c].onGroupChanged());
  }), t.on("mediachanging", () => {
    ["AUDIO", "SUBTITLES"].forEach((c) => e[c].onGroupChanging());
  });
  const u = () => {
    e.AUDIO.onTrackChanged(), i.trigger({
      type: "usage",
      name: "vhs-audio-change"
    });
  };
  i.audioTracks().addEventListener("change", u), i.remoteTextTracks().addEventListener("change", e.SUBTITLES.onTrackChanged), r.on("dispose", () => {
    i.audioTracks().removeEventListener("change", u), i.remoteTextTracks().removeEventListener("change", e.SUBTITLES.onTrackChanged);
  }), i.clearTracks("audio");
  for (const c in e.AUDIO.tracks)
    i.audioTracks().addTrack(e.AUDIO.tracks[c]);
}, mP = () => {
  const n = {};
  return ["AUDIO", "SUBTITLES", "CLOSED-CAPTIONS"].forEach((e) => {
    n[e] = {
      groups: {},
      tracks: {},
      activePlaylistLoader: null,
      activeGroup: Ii,
      activeTrack: Ii,
      getActiveGroup: Ii,
      onGroupChanged: Ii,
      onTrackChanged: Ii,
      lastTrack_: null,
      logger_: jn(`MediaGroups[${e}]`)
    };
  }), n;
};
class oT {
  constructor() {
    this.priority_ = [], this.pathwayClones_ = /* @__PURE__ */ new Map();
  }
  set version(e) {
    e === 1 && (this.version_ = e);
  }
  set ttl(e) {
    this.ttl_ = e || 300;
  }
  set reloadUri(e) {
    e && (this.reloadUri_ = hn(this.reloadUri_, e));
  }
  set priority(e) {
    e && e.length && (this.priority_ = e);
  }
  set pathwayClones(e) {
    e && e.length && (this.pathwayClones_ = new Map(e.map((t) => [t.ID, t])));
  }
  get version() {
    return this.version_;
  }
  get ttl() {
    return this.ttl_;
  }
  get reloadUri() {
    return this.reloadUri_;
  }
  get priority() {
    return this.priority_;
  }
  get pathwayClones() {
    return this.pathwayClones_;
  }
}
class gP extends ke.EventTarget {
  constructor(e, t) {
    super(), this.currentPathway = null, this.defaultPathway = null, this.queryBeforeStart = !1, this.availablePathways_ = /* @__PURE__ */ new Set(), this.steeringManifest = new oT(), this.proxyServerUrl_ = null, this.manifestType_ = null, this.ttlTimeout_ = null, this.request_ = null, this.currentPathwayClones = /* @__PURE__ */ new Map(), this.nextPathwayClones = /* @__PURE__ */ new Map(), this.excludedSteeringManifestURLs = /* @__PURE__ */ new Set(), this.logger_ = jn("Content Steering"), this.xhr_ = e, this.getBandwidth_ = t;
  }
  /**
   * Assigns the content steering tag properties to the steering controller
   *
   * @param {string} baseUrl the baseURL from the main manifest for resolving the steering manifest url
   * @param {Object} steeringTag the content steering tag from the main manifest
   */
  assignTagProperties(e, t) {
    this.manifestType_ = t.serverUri ? "HLS" : "DASH";
    const i = t.serverUri || t.serverURL;
    if (!i) {
      this.logger_(`steering manifest URL is ${i}, cannot request steering manifest.`), this.trigger("error");
      return;
    }
    if (i.startsWith("data:")) {
      this.decodeDataUriManifest_(i.substring(i.indexOf(",") + 1));
      return;
    }
    this.steeringManifest.reloadUri = hn(e, i), this.defaultPathway = t.pathwayId || t.defaultServiceLocation, this.queryBeforeStart = t.queryBeforeStart, this.proxyServerUrl_ = t.proxyServerURL, this.defaultPathway && !this.queryBeforeStart && this.trigger("content-steering");
  }
  /**
   * Requests the content steering manifest and parse the response. This should only be called after
   * assignTagProperties was called with a content steering tag.
   *
   * @param {string} initialUri The optional uri to make the request with.
   *    If set, the request should be made with exactly what is passed in this variable.
   *    This scenario should only happen once on initalization.
   */
  requestSteeringManifest(e) {
    const t = this.steeringManifest.reloadUri;
    if (!t)
      return;
    const i = e ? t : this.getRequestURI(t);
    if (!i) {
      this.logger_("No valid content steering manifest URIs. Stopping content steering."), this.trigger("error"), this.dispose();
      return;
    }
    const r = {
      contentSteeringInfo: {
        uri: i
      }
    };
    this.trigger({
      type: "contentsteeringloadstart",
      metadata: r
    }), this.request_ = this.xhr_({
      uri: i,
      requestType: "content-steering-manifest"
    }, (a, s) => {
      if (a) {
        if (s.status === 410) {
          this.logger_(`manifest request 410 ${a}.`), this.logger_(`There will be no more content steering requests to ${i} this session.`), this.excludedSteeringManifestURLs.add(i);
          return;
        }
        if (s.status === 429) {
          const c = s.responseHeaders["retry-after"];
          this.logger_(`manifest request 429 ${a}.`), this.logger_(`content steering will retry in ${c} seconds.`), this.startTTLTimeout_(parseInt(c, 10));
          return;
        }
        this.logger_(`manifest failed to load ${a}.`), this.startTTLTimeout_();
        return;
      }
      this.trigger({
        type: "contentsteeringloadcomplete",
        metadata: r
      });
      let o;
      try {
        o = JSON.parse(this.request_.responseText);
      } catch (c) {
        const l = {
          errorType: ke.Error.StreamingContentSteeringParserError,
          error: c
        };
        this.trigger({
          type: "error",
          metadata: l
        });
      }
      this.assignSteeringProperties_(o);
      const u = {
        contentSteeringInfo: r.contentSteeringInfo,
        contentSteeringManifest: {
          version: this.steeringManifest.version,
          reloadUri: this.steeringManifest.reloadUri,
          priority: this.steeringManifest.priority
        }
      };
      this.trigger({
        type: "contentsteeringparsed",
        metadata: u
      }), this.startTTLTimeout_();
    });
  }
  /**
   * Set the proxy server URL and add the steering manifest url as a URI encoded parameter.
   *
   * @param {string} steeringUrl the steering manifest url
   * @return the steering manifest url to a proxy server with all parameters set
   */
  setProxyServerUrl_(e) {
    const t = new me.URL(e), i = new me.URL(this.proxyServerUrl_);
    return i.searchParams.set("url", encodeURI(t.toString())), this.setSteeringParams_(i.toString());
  }
  /**
   * Decodes and parses the data uri encoded steering manifest
   *
   * @param {string} dataUri the data uri to be decoded and parsed.
   */
  decodeDataUriManifest_(e) {
    const t = JSON.parse(me.atob(e));
    this.assignSteeringProperties_(t);
  }
  /**
   * Set the HLS or DASH content steering manifest request query parameters. For example:
   * _HLS_pathway="<CURRENT-PATHWAY-ID>" and _HLS_throughput=<THROUGHPUT>
   * _DASH_pathway and _DASH_throughput
   *
   * @param {string} uri to add content steering server parameters to.
   * @return a new uri as a string with the added steering query parameters.
   */
  setSteeringParams_(e) {
    const t = new me.URL(e), i = this.getPathway(), r = this.getBandwidth_();
    if (i) {
      const a = `_${this.manifestType_}_pathway`;
      t.searchParams.set(a, i);
    }
    if (r) {
      const a = `_${this.manifestType_}_throughput`;
      t.searchParams.set(a, r);
    }
    return t.toString();
  }
  /**
   * Assigns the current steering manifest properties and to the SteeringManifest object
   *
   * @param {Object} steeringJson the raw JSON steering manifest
   */
  assignSteeringProperties_(e) {
    if (this.steeringManifest.version = e.VERSION, !this.steeringManifest.version) {
      this.logger_(`manifest version is ${e.VERSION}, which is not supported.`), this.trigger("error");
      return;
    }
    this.steeringManifest.ttl = e.TTL, this.steeringManifest.reloadUri = e["RELOAD-URI"], this.steeringManifest.priority = e["PATHWAY-PRIORITY"] || e["SERVICE-LOCATION-PRIORITY"], this.steeringManifest.pathwayClones = e["PATHWAY-CLONES"], this.nextPathwayClones = this.steeringManifest.pathwayClones, this.availablePathways_.size || (this.logger_("There are no available pathways for content steering. Ending content steering."), this.trigger("error"), this.dispose());
    const i = ((r) => {
      for (const a of r)
        if (this.availablePathways_.has(a))
          return a;
      return [...this.availablePathways_][0];
    })(this.steeringManifest.priority);
    this.currentPathway !== i && (this.currentPathway = i, this.trigger("content-steering"));
  }
  /**
   * Returns the pathway to use for steering decisions
   *
   * @return {string} returns the current pathway or the default
   */
  getPathway() {
    return this.currentPathway || this.defaultPathway;
  }
  /**
   * Chooses the manifest request URI based on proxy URIs and server URLs.
   * Also accounts for exclusion on certain manifest URIs.
   *
   * @param {string} reloadUri the base uri before parameters
   *
   * @return {string} the final URI for the request to the manifest server.
   */
  getRequestURI(e) {
    if (!e)
      return null;
    const t = (r) => this.excludedSteeringManifestURLs.has(r);
    if (this.proxyServerUrl_) {
      const r = this.setProxyServerUrl_(e);
      if (!t(r))
        return r;
    }
    const i = this.setSteeringParams_(e);
    return t(i) ? null : i;
  }
  /**
   * Start the timeout for re-requesting the steering manifest at the TTL interval.
   *
   * @param {number} ttl time in seconds of the timeout. Defaults to the
   *        ttl interval in the steering manifest
   */
  startTTLTimeout_(e = this.steeringManifest.ttl) {
    const t = e * 1e3;
    this.ttlTimeout_ = me.setTimeout(() => {
      this.requestSteeringManifest();
    }, t);
  }
  /**
   * Clear the TTL timeout if necessary.
   */
  clearTTLTimeout_() {
    me.clearTimeout(this.ttlTimeout_), this.ttlTimeout_ = null;
  }
  /**
   * aborts any current steering xhr and sets the current request object to null
   */
  abort() {
    this.request_ && this.request_.abort(), this.request_ = null;
  }
  /**
   * aborts steering requests clears the ttl timeout and resets all properties.
   */
  dispose() {
    this.off("content-steering"), this.off("error"), this.abort(), this.clearTTLTimeout_(), this.currentPathway = null, this.defaultPathway = null, this.queryBeforeStart = null, this.proxyServerUrl_ = null, this.manifestType_ = null, this.ttlTimeout_ = null, this.request_ = null, this.excludedSteeringManifestURLs = /* @__PURE__ */ new Set(), this.availablePathways_ = /* @__PURE__ */ new Set(), this.steeringManifest = new oT();
  }
  /**
   * adds a pathway to the available pathways set
   *
   * @param {string} pathway the pathway string to add
   */
  addAvailablePathway(e) {
    e && this.availablePathways_.add(e);
  }
  /**
   * Clears all pathways from the available pathways set
   */
  clearAvailablePathways() {
    this.availablePathways_.clear();
  }
  /**
   * Removes a pathway from the available pathways set.
   */
  excludePathway(e) {
    return this.availablePathways_.delete(e);
  }
  /**
   * Checks the refreshed DASH manifest content steering tag for changes.
   *
   * @param {string} baseURL new steering tag on DASH manifest refresh
   * @param {Object} newTag the new tag to check for changes
   * @return a true or false whether the new tag has different values
   */
  didDASHTagChange(e, t) {
    return !t && this.steeringManifest.reloadUri || t && (hn(e, t.serverURL) !== this.steeringManifest.reloadUri || t.defaultServiceLocation !== this.defaultPathway || t.queryBeforeStart !== this.queryBeforeStart || t.proxyServerURL !== this.proxyServerUrl_);
  }
  getAvailablePathways() {
    return this.availablePathways_;
  }
}
const bP = (n, e) => {
  let t = null;
  return (...i) => {
    clearTimeout(t), t = setTimeout(() => {
      n.apply(null, i);
    }, e);
  };
}, yP = 10;
let Xi;
const vP = ["mediaRequests", "mediaRequestsAborted", "mediaRequestsTimedout", "mediaRequestsErrored", "mediaTransferDuration", "mediaBytesTransferred", "mediaAppends"], xP = function(n) {
  return this.audioSegmentLoader_[n] + this.mainSegmentLoader_[n];
}, _P = function({
  currentPlaylist: n,
  buffered: e,
  currentTime: t,
  nextPlaylist: i,
  bufferLowWaterLine: r,
  bufferHighWaterLine: a,
  duration: s,
  bufferBasedABR: o,
  log: u
}) {
  if (!i)
    return ke.log.warn("We received no playlist to switch to. Please check your stream."), !1;
  const c = `allowing switch ${n && n.id || "null"} -> ${i.id}`;
  if (!n)
    return u(`${c} as current playlist is not set`), !0;
  if (i.id === n.id)
    return !1;
  const l = !!ia(e, t).length;
  if (!n.endList)
    return !l && typeof n.partTargetDuration == "number" ? (u(`not ${c} as current playlist is live llhls, but currentTime isn't in buffered.`), !1) : (u(`${c} as current playlist is live`), !0);
  const h = w0(e, t), f = o ? qt.EXPERIMENTAL_MAX_BUFFER_LOW_WATER_LINE : qt.MAX_BUFFER_LOW_WATER_LINE;
  if (s < f)
    return u(`${c} as duration < max low water line (${s} < ${f})`), !0;
  const d = i.attributes.BANDWIDTH, y = n.attributes.BANDWIDTH;
  if (d < y && (!o || h < a)) {
    let m = `${c} as next bandwidth < current bandwidth (${d} < ${y})`;
    return o && (m += ` and forwardBuffer < bufferHighWaterLine (${h} < ${a})`), u(m), !0;
  }
  if ((!o || d > y) && h >= r) {
    let m = `${c} as forwardBuffer >= bufferLowWaterLine (${h} >= ${r})`;
    return o && (m += ` and next bandwidth > current bandwidth (${d} > ${y})`), u(m), !0;
  }
  return u(`not ${c} as no switching criteria met`), !1;
};
class TP extends ke.EventTarget {
  constructor(e) {
    super(), this.fastQualityChange_ = bP(this.fastQualityChange_.bind(this), 100);
    const {
      src: t,
      withCredentials: i,
      tech: r,
      bandwidth: a,
      externVhs: s,
      useCueTags: o,
      playlistExclusionDuration: u,
      enableLowInitialPlaylist: c,
      sourceType: l,
      cacheEncryptionKeys: h,
      bufferBasedABR: f,
      leastPixelDiffSelector: d,
      captionServices: y,
      experimentalUseMMS: m
    } = e;
    if (!t)
      throw new Error("A non-empty playlist URL or JSON manifest string is required");
    let {
      maxPlaylistRetries: b
    } = e;
    (b === null || typeof b > "u") && (b = 1 / 0), Xi = s, this.bufferBasedABR = !!f, this.leastPixelDiffSelector = !!d, this.withCredentials = i, this.tech_ = r, this.vhs_ = r.vhs, this.player_ = e.player_, this.sourceType_ = l, this.useCueTags_ = o, this.playlistExclusionDuration = u, this.maxPlaylistRetries = b, this.enableLowInitialPlaylist = c, this.usingManagedMediaSource_ = !1, this.useCueTags_ && (this.cueTagsTrack_ = this.tech_.addTextTrack("metadata", "ad-cues"), this.cueTagsTrack_.inBandMetadataTrackDispatchType = ""), this.requestOptions_ = {
      withCredentials: i,
      maxPlaylistRetries: b,
      timeout: null
    }, this.on("error", this.pauseLoading), this.mediaTypes_ = mP(), m && me.ManagedMediaSource ? (this.tech_.el_.disableRemotePlayback = !0, this.mediaSource = new me.ManagedMediaSource(), this.usingManagedMediaSource_ = !0, ke.log("Using ManagedMediaSource")) : me.MediaSource && (this.mediaSource = new me.MediaSource()), this.handleDurationChange_ = this.handleDurationChange_.bind(this), this.handleSourceOpen_ = this.handleSourceOpen_.bind(this), this.handleSourceEnded_ = this.handleSourceEnded_.bind(this), this.load = this.load.bind(this), this.pause = this.pause.bind(this), this.mediaSource.addEventListener("durationchange", this.handleDurationChange_), this.mediaSource.addEventListener("sourceopen", this.handleSourceOpen_), this.mediaSource.addEventListener("sourceended", this.handleSourceEnded_), this.mediaSource.addEventListener("startstreaming", this.load), this.mediaSource.addEventListener("endstreaming", this.pause), this.seekable_ = Vt(), this.hasPlayed_ = !1, this.syncController_ = new nP(e), this.segmentMetadataTrack_ = r.addRemoteTextTrack({
      kind: "metadata",
      label: "segment-metadata"
    }, !1).track, this.segmentMetadataTrack_.mode = "hidden", this.decrypter_ = new aP(), this.sourceUpdater_ = new I3(this.mediaSource), this.inbandTextTracks_ = {}, this.timelineChangeController_ = new iP(), this.keyStatusMap_ = /* @__PURE__ */ new Map();
    const p = {
      vhs: this.vhs_,
      parse708captions: e.parse708captions,
      useDtsForTimestampOffset: e.useDtsForTimestampOffset,
      captionServices: y,
      mediaSource: this.mediaSource,
      currentTime: this.tech_.currentTime.bind(this.tech_),
      seekable: () => this.seekable(),
      seeking: () => this.tech_.seeking(),
      duration: () => this.duration(),
      hasPlayed: () => this.hasPlayed_,
      goalBufferLength: () => this.goalBufferLength(),
      bandwidth: a,
      syncController: this.syncController_,
      decrypter: this.decrypter_,
      sourceType: this.sourceType_,
      inbandTextTracks: this.inbandTextTracks_,
      cacheEncryptionKeys: h,
      sourceUpdater: this.sourceUpdater_,
      timelineChangeController: this.timelineChangeController_,
      exactManifestTimings: e.exactManifestTimings,
      addMetadataToTextTrack: this.addMetadataToTextTrack.bind(this)
    };
    this.mainPlaylistLoader_ = this.sourceType_ === "dash" ? new km(t, this.vhs_, ft(this.requestOptions_, {
      addMetadataToTextTrack: this.addMetadataToTextTrack.bind(this)
    })) : new ra(t, this.vhs_, ft(this.requestOptions_, {
      addDateRangesToTextTrack: this.addDateRangesToTextTrack_.bind(this)
    })), this.setupMainPlaylistLoaderListeners_(), this.mainSegmentLoader_ = new Rm(ft(p, {
      segmentMetadataTrack: this.segmentMetadataTrack_,
      loaderType: "main"
    }), e), this.audioSegmentLoader_ = new Rm(ft(p, {
      loaderType: "audio"
    }), e), this.subtitleSegmentLoader_ = new QL(ft(p, {
      loaderType: "vtt",
      featuresNativeTextTracks: this.tech_.featuresNativeTextTracks,
      loadVttJs: () => new Promise((_, x) => {
        function T() {
          r.off("vttjserror", E), _();
        }
        function E() {
          r.off("vttjsloaded", T), x();
        }
        r.one("vttjsloaded", T), r.one("vttjserror", E), r.addWebVttScript_();
      })
    }), e);
    const g = () => this.mainSegmentLoader_.bandwidth;
    this.contentSteeringController_ = new gP(this.vhs_.xhr, g), this.setupSegmentLoaderListeners_(), this.bufferBasedABR && (this.mainPlaylistLoader_.one("loadedplaylist", () => this.startABRTimer_()), this.tech_.on("pause", () => this.stopABRTimer_()), this.tech_.on("play", () => this.startABRTimer_())), vP.forEach((_) => {
      this[_ + "_"] = xP.bind(this, _);
    }), this.logger_ = jn("pc"), this.triggeredFmp4Usage = !1, this.tech_.preload() === "none" ? (this.loadOnPlay_ = () => {
      this.loadOnPlay_ = null, this.mainPlaylistLoader_.load();
    }, this.tech_.one("play", this.loadOnPlay_)) : this.mainPlaylistLoader_.load(), this.timeToLoadedData__ = -1, this.mainAppendsToLoadedData__ = -1, this.audioAppendsToLoadedData__ = -1;
    const v = this.tech_.preload() === "none" ? "play" : "loadstart";
    this.tech_.one(v, () => {
      const _ = Date.now();
      this.tech_.one("loadeddata", () => {
        this.timeToLoadedData__ = Date.now() - _, this.mainAppendsToLoadedData__ = this.mainSegmentLoader_.mediaAppends, this.audioAppendsToLoadedData__ = this.audioSegmentLoader_.mediaAppends;
      });
    });
  }
  mainAppendsToLoadedData_() {
    return this.mainAppendsToLoadedData__;
  }
  audioAppendsToLoadedData_() {
    return this.audioAppendsToLoadedData__;
  }
  appendsToLoadedData_() {
    const e = this.mainAppendsToLoadedData_(), t = this.audioAppendsToLoadedData_();
    return e === -1 || t === -1 ? -1 : e + t;
  }
  timeToLoadedData_() {
    return this.timeToLoadedData__;
  }
  /**
   * Run selectPlaylist and switch to the new playlist if we should
   *
   * @param {string} [reason=abr] a reason for why the ABR check is made
   * @private
   */
  checkABR_(e = "abr") {
    const t = this.selectPlaylist();
    t && this.shouldSwitchToMedia_(t) && this.switchMedia_(t, e);
  }
  switchMedia_(e, t, i) {
    const r = this.media(), a = r && (r.id || r.uri), s = e && (e.id || e.uri);
    if (a && a !== s) {
      this.logger_(`switch media ${a} -> ${s} from ${t}`);
      const o = {
        renditionInfo: {
          id: s,
          bandwidth: e.attributes.BANDWIDTH,
          resolution: e.attributes.RESOLUTION,
          codecs: e.attributes.CODECS
        },
        cause: t
      };
      this.trigger({
        type: "renditionselected",
        metadata: o
      }), this.tech_.trigger({
        type: "usage",
        name: `vhs-rendition-change-${t}`
      });
    }
    this.mainPlaylistLoader_.media(e, i);
  }
  /**
   * A function that ensures we switch our playlists inside of `mediaTypes`
   * to match the current `serviceLocation` provided by the contentSteering controller.
   * We want to check media types of `AUDIO`, `SUBTITLES`, and `CLOSED-CAPTIONS`.
   *
   * This should only be called on a DASH playback scenario while using content steering.
   * This is necessary due to differences in how media in HLS manifests are generally tied to
   * a video playlist, where in DASH that is not always the case.
   */
  switchMediaForDASHContentSteering_() {
    ["AUDIO", "SUBTITLES", "CLOSED-CAPTIONS"].forEach((e) => {
      const t = this.mediaTypes_[e], i = t ? t.activeGroup() : null, r = this.contentSteeringController_.getPathway();
      if (i && r) {
        const s = (i.length ? i[0].playlists : i.playlists).filter((o) => o.attributes.serviceLocation === r);
        s.length && this.mediaTypes_[e].activePlaylistLoader.media(s[0]);
      }
    });
  }
  /**
   * Start a timer that periodically calls checkABR_
   *
   * @private
   */
  startABRTimer_() {
    this.stopABRTimer_(), this.abrTimer_ = me.setInterval(() => this.checkABR_(), 250);
  }
  /**
   * Stop the timer that periodically calls checkABR_
   *
   * @private
   */
  stopABRTimer_() {
    this.tech_.scrubbing && this.tech_.scrubbing() || (me.clearInterval(this.abrTimer_), this.abrTimer_ = null);
  }
  /**
   * Get a list of playlists for the currently selected audio playlist
   *
   * @return {Array} the array of audio playlists
   */
  getAudioTrackPlaylists_() {
    const e = this.main(), t = e && e.playlists || [];
    if (!e || !e.mediaGroups || !e.mediaGroups.AUDIO)
      return t;
    const i = e.mediaGroups.AUDIO, r = Object.keys(i);
    let a;
    if (Object.keys(this.mediaTypes_.AUDIO.groups).length)
      a = this.mediaTypes_.AUDIO.activeTrack();
    else {
      const o = i.main || r.length && i[r[0]];
      for (const u in o)
        if (o[u].default) {
          a = {
            label: u
          };
          break;
        }
    }
    if (!a)
      return t;
    const s = [];
    for (const o in i)
      if (i[o][a.label]) {
        const u = i[o][a.label];
        if (u.playlists && u.playlists.length)
          s.push.apply(s, u.playlists);
        else if (u.uri)
          s.push(u);
        else if (e.playlists.length)
          for (let c = 0; c < e.playlists.length; c++) {
            const l = e.playlists[c];
            l.attributes && l.attributes.AUDIO && l.attributes.AUDIO === o && s.push(l);
          }
      }
    return s.length ? s : t;
  }
  /**
   * Register event handlers on the main playlist loader. A helper
   * function for construction time.
   *
   * @private
   */
  setupMainPlaylistLoaderListeners_() {
    this.mainPlaylistLoader_.on("loadedmetadata", () => {
      const t = this.mainPlaylistLoader_.media(), i = t.targetDuration * 1.5 * 1e3;
      Em(this.mainPlaylistLoader_.main, this.mainPlaylistLoader_.media()) ? this.requestOptions_.timeout = 0 : this.requestOptions_.timeout = i, t.endList && this.tech_.preload() !== "none" && (this.mainSegmentLoader_.playlist(t, this.requestOptions_), this.mainSegmentLoader_.load()), pP({
        sourceType: this.sourceType_,
        segmentLoaders: {
          AUDIO: this.audioSegmentLoader_,
          SUBTITLES: this.subtitleSegmentLoader_,
          main: this.mainSegmentLoader_
        },
        tech: this.tech_,
        requestOptions: this.requestOptions_,
        mainPlaylistLoader: this.mainPlaylistLoader_,
        vhs: this.vhs_,
        main: this.main(),
        mediaTypes: this.mediaTypes_,
        excludePlaylist: this.excludePlaylist.bind(this)
      }), this.triggerPresenceUsage_(this.main(), t), this.setupFirstPlay(), !this.mediaTypes_.AUDIO.activePlaylistLoader || this.mediaTypes_.AUDIO.activePlaylistLoader.media() ? this.trigger("selectedinitialmedia") : this.mediaTypes_.AUDIO.activePlaylistLoader.one("loadedmetadata", () => {
        this.trigger("selectedinitialmedia");
      });
    }), this.mainPlaylistLoader_.on("loadedplaylist", () => {
      this.loadOnPlay_ && this.tech_.off("play", this.loadOnPlay_);
      let t = this.mainPlaylistLoader_.media();
      if (!t) {
        this.attachContentSteeringListeners_(), this.initContentSteeringController_(), this.excludeUnsupportedVariants_();
        let i;
        if (this.enableLowInitialPlaylist && (i = this.selectInitialPlaylist()), i || (i = this.selectPlaylist()), !i || !this.shouldSwitchToMedia_(i) || (this.initialMedia_ = i, this.switchMedia_(this.initialMedia_, "initial"), !(this.sourceType_ === "vhs-json" && this.initialMedia_.segments)))
          return;
        t = this.initialMedia_;
      }
      this.handleUpdatedMediaPlaylist(t);
    }), this.mainPlaylistLoader_.on("error", () => {
      const t = this.mainPlaylistLoader_.error;
      this.excludePlaylist({
        playlistToExclude: t.playlist,
        error: t
      });
    }), this.mainPlaylistLoader_.on("mediachanging", () => {
      this.mainSegmentLoader_.abort(), this.mainSegmentLoader_.pause();
    }), this.mainPlaylistLoader_.on("mediachange", () => {
      const t = this.mainPlaylistLoader_.media(), i = t.targetDuration * 1.5 * 1e3;
      Em(this.mainPlaylistLoader_.main, this.mainPlaylistLoader_.media()) ? this.requestOptions_.timeout = 0 : this.requestOptions_.timeout = i, this.sourceType_ === "dash" && this.mainPlaylistLoader_.isPaused && this.mainPlaylistLoader_.load(), this.mainSegmentLoader_.pause(), this.mainSegmentLoader_.playlist(t, this.requestOptions_), this.waitingForFastQualityPlaylistReceived_ ? this.runFastQualitySwitch_() : this.mainSegmentLoader_.load(), this.tech_.trigger({
        type: "mediachange",
        bubbles: !0
      });
    }), this.mainPlaylistLoader_.on("playlistunchanged", () => {
      const t = this.mainPlaylistLoader_.media();
      if (t.lastExcludeReason_ === "playlist-unchanged")
        return;
      this.stuckAtPlaylistEnd_(t) && (this.excludePlaylist({
        error: {
          message: "Playlist no longer updating.",
          reason: "playlist-unchanged"
        }
      }), this.tech_.trigger("playliststuck"));
    }), this.mainPlaylistLoader_.on("renditiondisabled", () => {
      this.tech_.trigger({
        type: "usage",
        name: "vhs-rendition-disabled"
      });
    }), this.mainPlaylistLoader_.on("renditionenabled", () => {
      this.tech_.trigger({
        type: "usage",
        name: "vhs-rendition-enabled"
      });
    }), ["manifestrequeststart", "manifestrequestcomplete", "manifestparsestart", "manifestparsecomplete", "playlistrequeststart", "playlistrequestcomplete", "playlistparsestart", "playlistparsecomplete", "renditiondisabled", "renditionenabled"].forEach((t) => {
      this.mainPlaylistLoader_.on(t, (i) => {
        this.player_.trigger(Lt({}, i));
      });
    });
  }
  /**
   * Given an updated media playlist (whether it was loaded for the first time, or
   * refreshed for live playlists), update any relevant properties and state to reflect
   * changes in the media that should be accounted for (e.g., cues and duration).
   *
   * @param {Object} updatedPlaylist the updated media playlist object
   *
   * @private
   */
  handleUpdatedMediaPlaylist(e) {
    this.useCueTags_ && this.updateAdCues_(e), this.mainSegmentLoader_.pause(), this.mainSegmentLoader_.playlist(e, this.requestOptions_), this.waitingForFastQualityPlaylistReceived_ && this.runFastQualitySwitch_(), this.updateDuration(!e.endList), this.tech_.paused() || (this.mainSegmentLoader_.load(), this.audioSegmentLoader_ && this.audioSegmentLoader_.load());
  }
  /**
   * A helper function for triggerring presence usage events once per source
   *
   * @private
   */
  triggerPresenceUsage_(e, t) {
    const i = e.mediaGroups || {};
    let r = !0;
    const a = Object.keys(i.AUDIO);
    for (const s in i.AUDIO)
      for (const o in i.AUDIO[s])
        i.AUDIO[s][o].uri || (r = !1);
    r && this.tech_.trigger({
      type: "usage",
      name: "vhs-demuxed"
    }), Object.keys(i.SUBTITLES).length && this.tech_.trigger({
      type: "usage",
      name: "vhs-webvtt"
    }), Xi.Playlist.isAes(t) && this.tech_.trigger({
      type: "usage",
      name: "vhs-aes"
    }), a.length && Object.keys(i.AUDIO[a[0]]).length > 1 && this.tech_.trigger({
      type: "usage",
      name: "vhs-alternate-audio"
    }), this.useCueTags_ && this.tech_.trigger({
      type: "usage",
      name: "vhs-playlist-cue-tags"
    });
  }
  shouldSwitchToMedia_(e) {
    const t = this.mainPlaylistLoader_.media() || this.mainPlaylistLoader_.pendingMedia_, i = this.tech_.currentTime(), r = this.bufferLowWaterLine(), a = this.bufferHighWaterLine(), s = this.tech_.buffered();
    return _P({
      buffered: s,
      currentTime: i,
      currentPlaylist: t,
      nextPlaylist: e,
      bufferLowWaterLine: r,
      bufferHighWaterLine: a,
      duration: this.duration(),
      bufferBasedABR: this.bufferBasedABR,
      log: this.logger_
    });
  }
  /**
   * Register event handlers on the segment loaders. A helper function
   * for construction time.
   *
   * @private
   */
  setupSegmentLoaderListeners_() {
    this.mainSegmentLoader_.on("bandwidthupdate", () => {
      this.checkABR_("bandwidthupdate"), this.tech_.trigger("bandwidthupdate");
    }), this.mainSegmentLoader_.on("timeout", () => {
      this.bufferBasedABR && this.mainSegmentLoader_.load();
    }), this.bufferBasedABR || this.mainSegmentLoader_.on("progress", () => {
      this.trigger("progress");
    }), this.mainSegmentLoader_.on("error", () => {
      const i = this.mainSegmentLoader_.error();
      this.excludePlaylist({
        playlistToExclude: i.playlist,
        error: i
      });
    }), this.mainSegmentLoader_.on("appenderror", () => {
      this.error = this.mainSegmentLoader_.error_, this.trigger("error");
    }), this.mainSegmentLoader_.on("syncinfoupdate", () => {
      this.onSyncInfoUpdate_();
    }), this.mainSegmentLoader_.on("timestampoffset", () => {
      this.tech_.trigger({
        type: "usage",
        name: "vhs-timestamp-offset"
      });
    }), this.audioSegmentLoader_.on("syncinfoupdate", () => {
      this.onSyncInfoUpdate_();
    }), this.audioSegmentLoader_.on("appenderror", () => {
      this.error = this.audioSegmentLoader_.error_, this.trigger("error");
    }), this.mainSegmentLoader_.on("ended", () => {
      this.logger_("main segment loader ended"), this.onEndOfStream();
    }), this.timelineChangeController_.on("audioTimelineBehind", () => {
      const i = this.audioSegmentLoader_.pendingSegment_;
      if (!i || !i.segment || !i.segment.syncInfo)
        return;
      const r = i.segment.syncInfo.end + 0.01;
      this.tech_.setCurrentTime(r);
    }), this.timelineChangeController_.on("fixBadTimelineChange", () => {
      this.logger_("Fix bad timeline change. Restarting al segment loaders..."), this.mainSegmentLoader_.pause(), this.mainSegmentLoader_.resetEverything(), this.mediaTypes_.AUDIO.activePlaylistLoader && (this.audioSegmentLoader_.pause(), this.audioSegmentLoader_.resetEverything()), this.mediaTypes_.SUBTITLES.activePlaylistLoader && (this.subtitleSegmentLoader_.pause(), this.subtitleSegmentLoader_.resetEverything()), this.load();
    }), this.mainSegmentLoader_.on("earlyabort", (i) => {
      this.bufferBasedABR || (this.delegateLoaders_("all", ["abort"]), this.excludePlaylist({
        error: {
          message: "Aborted early because there isn't enough bandwidth to complete the request without rebuffering."
        },
        playlistExclusionDuration: yP
      }));
    });
    const e = () => {
      if (!this.sourceUpdater_.hasCreatedSourceBuffers())
        return this.tryToCreateSourceBuffers_();
      const i = this.getCodecsOrExclude_();
      i && this.sourceUpdater_.addOrChangeSourceBuffers(i);
    };
    this.mainSegmentLoader_.on("trackinfo", e), this.audioSegmentLoader_.on("trackinfo", e), this.mainSegmentLoader_.on("fmp4", () => {
      this.triggeredFmp4Usage || (this.tech_.trigger({
        type: "usage",
        name: "vhs-fmp4"
      }), this.triggeredFmp4Usage = !0);
    }), this.audioSegmentLoader_.on("fmp4", () => {
      this.triggeredFmp4Usage || (this.tech_.trigger({
        type: "usage",
        name: "vhs-fmp4"
      }), this.triggeredFmp4Usage = !0);
    }), this.audioSegmentLoader_.on("ended", () => {
      this.logger_("audioSegmentLoader ended"), this.onEndOfStream();
    }), ["segmentselected", "segmentloadstart", "segmentloaded", "segmentkeyloadstart", "segmentkeyloadcomplete", "segmentdecryptionstart", "segmentdecryptioncomplete", "segmenttransmuxingstart", "segmenttransmuxingcomplete", "segmenttransmuxingtrackinfoavailable", "segmenttransmuxingtiminginfoavailable", "segmentappendstart", "appendsdone", "bandwidthupdated", "timelinechange", "codecschange"].forEach((i) => {
      this.mainSegmentLoader_.on(i, (r) => {
        this.player_.trigger(Lt({}, r));
      }), this.audioSegmentLoader_.on(i, (r) => {
        this.player_.trigger(Lt({}, r));
      }), this.subtitleSegmentLoader_.on(i, (r) => {
        this.player_.trigger(Lt({}, r));
      });
    });
  }
  mediaSecondsLoaded_() {
    return Math.max(this.audioSegmentLoader_.mediaSecondsLoaded + this.mainSegmentLoader_.mediaSecondsLoaded);
  }
  /**
   * Call load on our SegmentLoaders
   */
  load() {
    this.mainSegmentLoader_.load(), this.mediaTypes_.AUDIO.activePlaylistLoader && this.audioSegmentLoader_.load(), this.mediaTypes_.SUBTITLES.activePlaylistLoader && this.subtitleSegmentLoader_.load();
  }
  /**
   * Call pause on our SegmentLoaders
   */
  pause() {
    this.mainSegmentLoader_.pause(), this.mediaTypes_.AUDIO.activePlaylistLoader && this.audioSegmentLoader_.pause(), this.mediaTypes_.SUBTITLES.activePlaylistLoader && this.subtitleSegmentLoader_.pause();
  }
  /**
   * Re-tune playback quality level for the current player
   * conditions. This method will perform destructive actions like removing
   * already buffered content in order to readjust the currently active
   * playlist quickly. This is good for manual quality changes
   *
   * @private
   */
  fastQualityChange_(e = this.selectPlaylist()) {
    if (e && e === this.mainPlaylistLoader_.media()) {
      this.logger_("skipping fastQualityChange because new media is same as old");
      return;
    }
    this.switchMedia_(e, "fast-quality"), this.waitingForFastQualityPlaylistReceived_ = !0;
  }
  runFastQualitySwitch_() {
    this.waitingForFastQualityPlaylistReceived_ = !1, this.mainSegmentLoader_.pause(), this.mainSegmentLoader_.resetEverything(), this.mediaTypes_.AUDIO.activePlaylistLoader && (this.audioSegmentLoader_.pause(), this.audioSegmentLoader_.resetEverything()), this.mediaTypes_.SUBTITLES.activePlaylistLoader && (this.subtitleSegmentLoader_.pause(), this.subtitleSegmentLoader_.resetEverything()), this.load();
  }
  /**
   * Begin playback.
   */
  play() {
    if (this.setupFirstPlay())
      return;
    this.tech_.ended() && this.tech_.setCurrentTime(0), this.hasPlayed_ && this.load();
    const e = this.tech_.seekable();
    if (this.tech_.duration() === 1 / 0 && this.tech_.currentTime() < e.start(0))
      return this.tech_.setCurrentTime(e.end(e.length - 1));
  }
  /**
   * Seek to the latest media position if this is a live video and the
   * player and video are loaded and initialized.
   */
  setupFirstPlay() {
    const e = this.mainPlaylistLoader_.media();
    if (!e || this.tech_.paused() || this.hasPlayed_)
      return !1;
    if (!e.endList || e.start) {
      const t = this.seekable();
      if (!t.length)
        return !1;
      const i = t.end(0);
      let r = i;
      if (e.start) {
        const a = e.start.timeOffset;
        a < 0 ? r = Math.max(i + a, t.start(0)) : r = Math.min(i, a);
      }
      this.trigger("firstplay"), this.tech_.setCurrentTime(r);
    }
    return this.hasPlayed_ = !0, this.load(), !0;
  }
  /**
   * handle the sourceopen event on the MediaSource
   *
   * @private
   */
  handleSourceOpen_() {
    if (this.tryToCreateSourceBuffers_(), this.tech_.autoplay()) {
      const e = this.tech_.play();
      typeof e < "u" && typeof e.then == "function" && e.then(null, (t) => {
      });
    }
    this.trigger("sourceopen");
  }
  /**
   * handle the sourceended event on the MediaSource
   *
   * @private
   */
  handleSourceEnded_() {
    if (!this.inbandTextTracks_.metadataTrack_)
      return;
    const e = this.inbandTextTracks_.metadataTrack_.cues;
    if (!e || !e.length)
      return;
    const t = this.duration();
    e[e.length - 1].endTime = isNaN(t) || Math.abs(t) === 1 / 0 ? Number.MAX_VALUE : t;
  }
  /**
   * handle the durationchange event on the MediaSource
   *
   * @private
   */
  handleDurationChange_() {
    this.tech_.trigger("durationchange");
  }
  /**
   * Calls endOfStream on the media source when all active stream types have called
   * endOfStream
   *
   * @param {string} streamType
   *        Stream type of the segment loader that called endOfStream
   * @private
   */
  onEndOfStream() {
    let e = this.mainSegmentLoader_.ended_;
    if (this.mediaTypes_.AUDIO.activePlaylistLoader) {
      const t = this.mainSegmentLoader_.getCurrentMediaInfo_();
      !t || t.hasVideo ? e = e && this.audioSegmentLoader_.ended_ : e = this.audioSegmentLoader_.ended_;
    }
    e && (this.stopABRTimer_(), this.sourceUpdater_.endOfStream());
  }
  /**
   * Check if a playlist has stopped being updated
   *
   * @param {Object} playlist the media playlist object
   * @return {boolean} whether the playlist has stopped being updated or not
   */
  stuckAtPlaylistEnd_(e) {
    if (!this.seekable().length)
      return !1;
    const i = this.syncController_.getExpiredTime(e, this.duration());
    if (i === null)
      return !1;
    const r = Xi.Playlist.playlistEnd(e, i), a = this.tech_.currentTime(), s = this.tech_.buffered();
    if (!s.length)
      return r - a <= bi;
    const o = s.end(s.length - 1);
    return o - a <= bi && r - o <= bi;
  }
  /**
   * Exclude a playlist for a set amount of time, making it unavailable for selection by
   * the rendition selection algorithm, then force a new playlist (rendition) selection.
   *
   * @param {Object=} playlistToExclude
   *                  the playlist to exclude, defaults to the currently selected playlist
   * @param {Object=} error
   *                  an optional error
   * @param {number=} playlistExclusionDuration
   *                  an optional number of seconds to exclude the playlist
   */
  excludePlaylist({
    playlistToExclude: e = this.mainPlaylistLoader_.media(),
    error: t = {},
    playlistExclusionDuration: i
  }) {
    if (e = e || this.mainPlaylistLoader_.media(), i = i || t.playlistExclusionDuration || this.playlistExclusionDuration, !e) {
      this.error = t, this.mediaSource.readyState !== "open" ? this.trigger("error") : this.sourceUpdater_.endOfStream("network");
      return;
    }
    e.playlistErrors_++;
    const r = this.mainPlaylistLoader_.main.playlists, a = r.filter(Al), s = a.length === 1 && a[0] === e;
    if (r.length === 1 && i !== 1 / 0)
      return ke.log.warn(`Problem encountered with playlist ${e.id}. Trying again since it is the only playlist.`), this.tech_.trigger("retryplaylist"), this.mainPlaylistLoader_.load(s);
    if (s) {
      if (this.main().contentSteering) {
        const y = this.pathwayAttribute_(e), m = this.contentSteeringController_.steeringManifest.ttl * 1e3;
        this.contentSteeringController_.excludePathway(y), this.excludeThenChangePathway_(), setTimeout(() => {
          this.contentSteeringController_.addAvailablePathway(y);
        }, m);
        return;
      }
      let d = !1;
      r.forEach((y) => {
        if (y === e)
          return;
        const m = y.excludeUntil;
        typeof m < "u" && m !== 1 / 0 && (d = !0, delete y.excludeUntil);
      }), d && (ke.log.warn("Removing other playlists from the exclusion list because the last rendition is about to be excluded."), this.tech_.trigger("retryplaylist"));
    }
    let o;
    e.playlistErrors_ > this.maxPlaylistRetries ? o = 1 / 0 : o = Date.now() + i * 1e3, e.excludeUntil = o, t.reason && (e.lastExcludeReason_ = t.reason), this.tech_.trigger("excludeplaylist"), this.tech_.trigger({
      type: "usage",
      name: "vhs-rendition-excluded"
    });
    const u = this.selectPlaylist();
    if (!u) {
      this.error = "Playback cannot continue. No available working or supported playlists.", this.trigger("error");
      return;
    }
    const c = t.internal ? this.logger_ : ke.log.warn, l = t.message ? " " + t.message : "";
    c(`${t.internal ? "Internal problem" : "Problem"} encountered with playlist ${e.id}.${l} Switching to playlist ${u.id}.`), u.attributes.AUDIO !== e.attributes.AUDIO && this.delegateLoaders_("audio", ["abort", "pause"]), u.attributes.SUBTITLES !== e.attributes.SUBTITLES && this.delegateLoaders_("subtitle", ["abort", "pause"]), this.delegateLoaders_("main", ["abort", "pause"]);
    const h = u.targetDuration / 2 * 1e3 || 5 * 1e3, f = typeof u.lastRequest == "number" && Date.now() - u.lastRequest <= h;
    return this.switchMedia_(u, "exclude", s || f);
  }
  /**
   * Pause all segment/playlist loaders
   */
  pauseLoading() {
    this.delegateLoaders_("all", ["abort", "pause"]), this.stopABRTimer_();
  }
  /**
   * Call a set of functions in order on playlist loaders, segment loaders,
   * or both types of loaders.
   *
   * @param {string} filter
   *        Filter loaders that should call fnNames using a string. Can be:
   *        * all - run on all loaders
   *        * audio - run on all audio loaders
   *        * subtitle - run on all subtitle loaders
   *        * main - run on the main loaders
   *
   * @param {Array|string} fnNames
   *        A string or array of function names to call.
   */
  delegateLoaders_(e, t) {
    const i = [], r = e === "all";
    (r || e === "main") && i.push(this.mainPlaylistLoader_);
    const a = [];
    (r || e === "audio") && a.push("AUDIO"), (r || e === "subtitle") && (a.push("CLOSED-CAPTIONS"), a.push("SUBTITLES")), a.forEach((s) => {
      const o = this.mediaTypes_[s] && this.mediaTypes_[s].activePlaylistLoader;
      o && i.push(o);
    }), ["main", "audio", "subtitle"].forEach((s) => {
      const o = this[`${s}SegmentLoader_`];
      o && (e === s || e === "all") && i.push(o);
    }), i.forEach((s) => t.forEach((o) => {
      typeof s[o] == "function" && s[o]();
    }));
  }
  /**
   * set the current time on all segment loaders
   *
   * @param {TimeRange} currentTime the current time to set
   * @return {TimeRange} the current time
   */
  setCurrentTime(e) {
    const t = ia(this.tech_.buffered(), e);
    if (!(this.mainPlaylistLoader_ && this.mainPlaylistLoader_.media()) || !this.mainPlaylistLoader_.media().segments)
      return 0;
    if (t && t.length)
      return e;
    this.mainSegmentLoader_.pause(), this.mainSegmentLoader_.resetEverything(), this.mediaTypes_.AUDIO.activePlaylistLoader && (this.audioSegmentLoader_.pause(), this.audioSegmentLoader_.resetEverything()), this.mediaTypes_.SUBTITLES.activePlaylistLoader && (this.subtitleSegmentLoader_.pause(), this.subtitleSegmentLoader_.resetEverything()), this.load();
  }
  /**
   * get the current duration
   *
   * @return {TimeRange} the duration
   */
  duration() {
    if (!this.mainPlaylistLoader_)
      return 0;
    const e = this.mainPlaylistLoader_.media();
    return e ? e.endList ? this.mediaSource ? this.mediaSource.duration : Xi.Playlist.duration(e) : 1 / 0 : 0;
  }
  /**
   * check the seekable range
   *
   * @return {TimeRange} the seekable range
   */
  seekable() {
    return this.seekable_;
  }
  getSeekableRange_(e, t) {
    const i = e.media();
    if (!i)
      return null;
    const r = this.syncController_.getMediaSequenceSync(t);
    if (r && r.isReliable) {
      const o = r.start, u = r.end;
      if (!isFinite(o) || !isFinite(u))
        return null;
      const c = Xi.Playlist.liveEdgeDelay(this.mainPlaylistLoader_.main, i), l = Math.max(o, u - c);
      return Vt([[o, l]]);
    }
    const a = this.syncController_.getExpiredTime(i, this.duration());
    if (a === null)
      return null;
    const s = Xi.Playlist.seekable(i, a, Xi.Playlist.liveEdgeDelay(this.mainPlaylistLoader_.main, i));
    return s.length ? s : null;
  }
  computeFinalSeekable_(e, t) {
    if (!t)
      return e;
    const i = e.start(0), r = e.end(0), a = t.start(0), s = t.end(0);
    return a > r || i > s ? e : Vt([[Math.max(i, a), Math.min(r, s)]]);
  }
  onSyncInfoUpdate_() {
    if (!this.mainPlaylistLoader_)
      return;
    const e = this.getSeekableRange_(this.mainPlaylistLoader_, "main");
    if (!e)
      return;
    let t;
    if (this.mediaTypes_.AUDIO.activePlaylistLoader && (t = this.getSeekableRange_(this.mediaTypes_.AUDIO.activePlaylistLoader, "audio"), !t))
      return;
    const i = this.seekable_;
    if (this.seekable_ = this.computeFinalSeekable_(e, t), !this.seekable_ || i && i.length && this.seekable_.length && i.start(0) === this.seekable_.start(0) && i.end(0) === this.seekable_.end(0))
      return;
    this.logger_(`seekable updated [${VS(this.seekable_)}]`);
    const r = {
      seekableRanges: this.seekable_
    };
    this.trigger({
      type: "seekablerangeschanged",
      metadata: r
    }), this.tech_.trigger("seekablechanged");
  }
  /**
   * Update the player duration
   */
  updateDuration(e) {
    if (this.updateDuration_ && (this.mediaSource.removeEventListener("sourceopen", this.updateDuration_), this.updateDuration_ = null), this.mediaSource.readyState !== "open") {
      this.updateDuration_ = this.updateDuration.bind(this, e), this.mediaSource.addEventListener("sourceopen", this.updateDuration_);
      return;
    }
    if (e) {
      const r = this.seekable();
      if (!r.length)
        return;
      (isNaN(this.mediaSource.duration) || this.mediaSource.duration < r.end(r.length - 1)) && this.sourceUpdater_.setDuration(r.end(r.length - 1));
      return;
    }
    const t = this.tech_.buffered();
    let i = Xi.Playlist.duration(this.mainPlaylistLoader_.media());
    t.length > 0 && (i = Math.max(i, t.end(t.length - 1))), this.mediaSource.duration !== i && this.sourceUpdater_.setDuration(i);
  }
  /**
   * dispose of the PlaylistController and everything
   * that it controls
   */
  dispose() {
    this.trigger("dispose"), this.decrypter_.terminate(), this.mainPlaylistLoader_.dispose(), this.mainSegmentLoader_.dispose(), this.contentSteeringController_.dispose(), this.keyStatusMap_.clear(), this.loadOnPlay_ && this.tech_.off("play", this.loadOnPlay_), ["AUDIO", "SUBTITLES"].forEach((e) => {
      const t = this.mediaTypes_[e].groups;
      for (const i in t)
        t[i].forEach((r) => {
          r.playlistLoader && r.playlistLoader.dispose();
        });
    }), this.audioSegmentLoader_.dispose(), this.subtitleSegmentLoader_.dispose(), this.sourceUpdater_.dispose(), this.timelineChangeController_.dispose(), this.stopABRTimer_(), this.updateDuration_ && this.mediaSource.removeEventListener("sourceopen", this.updateDuration_), this.mediaSource.removeEventListener("durationchange", this.handleDurationChange_), this.mediaSource.removeEventListener("sourceopen", this.handleSourceOpen_), this.mediaSource.removeEventListener("sourceended", this.handleSourceEnded_), this.off();
  }
  /**
   * return the main playlist object if we have one
   *
   * @return {Object} the main playlist object that we parsed
   */
  main() {
    return this.mainPlaylistLoader_.main;
  }
  /**
   * return the currently selected playlist
   *
   * @return {Object} the currently selected playlist object that we parsed
   */
  media() {
    return this.mainPlaylistLoader_.media() || this.initialMedia_;
  }
  areMediaTypesKnown_() {
    const e = !!this.mediaTypes_.AUDIO.activePlaylistLoader, t = !!this.mainSegmentLoader_.getCurrentMediaInfo_(), i = e ? !!this.audioSegmentLoader_.getCurrentMediaInfo_() : !0;
    return !(!t || !i);
  }
  // find from and to for codec switch event
  getCodecsOrExclude_() {
    const e = {
      main: this.mainSegmentLoader_.getCurrentMediaInfo_() || {},
      audio: this.audioSegmentLoader_.getCurrentMediaInfo_() || {}
    }, t = this.mainSegmentLoader_.getPendingSegmentPlaylist() || this.media();
    e.video = e.main;
    const i = Ns(this.main(), t), r = {}, a = !!this.mediaTypes_.AUDIO.activePlaylistLoader;
    if (e.main.hasVideo && (r.video = i.video || e.main.videoCodec || sU), e.main.isMuxed && (r.video += `,${i.audio || e.main.audioCodec || G2}`), (e.main.hasAudio && !e.main.isMuxed || e.audio.hasAudio || a) && (r.audio = i.audio || e.main.audioCodec || e.audio.audioCodec || G2, e.audio.isFmp4 = e.main.hasAudio && !e.main.isMuxed ? e.main.isFmp4 : e.audio.isFmp4), !r.audio && !r.video) {
      this.excludePlaylist({
        playlistToExclude: t,
        error: {
          message: "Could not determine codecs for playlist."
        },
        playlistExclusionDuration: 1 / 0
      });
      return;
    }
    const s = (c, l) => c ? Rs(l, this.usingManagedMediaSource_) : yp(l), o = {};
    let u;
    if (["video", "audio"].forEach(function(c) {
      if (r.hasOwnProperty(c) && !s(e[c].isFmp4, r[c])) {
        const l = e[c].isFmp4 ? "browser" : "muxer";
        o[l] = o[l] || [], o[l].push(r[c]), c === "audio" && (u = l);
      }
    }), a && u && t.attributes.AUDIO) {
      const c = t.attributes.AUDIO;
      this.main().playlists.forEach((l) => {
        (l.attributes && l.attributes.AUDIO) === c && l !== t && (l.excludeUntil = 1 / 0);
      }), this.logger_(`excluding audio group ${c} as ${u} does not support codec(s): "${r.audio}"`);
    }
    if (Object.keys(o).length) {
      const c = Object.keys(o).reduce((l, h) => (l && (l += ", "), l += `${h} does not support codec(s): "${o[h].join(",")}"`, l), "") + ".";
      this.excludePlaylist({
        playlistToExclude: t,
        error: {
          internal: !0,
          message: c
        },
        playlistExclusionDuration: 1 / 0
      });
      return;
    }
    if (this.sourceUpdater_.hasCreatedSourceBuffers() && !this.sourceUpdater_.canChangeType()) {
      const c = [];
      if (["video", "audio"].forEach((l) => {
        const h = (hi(this.sourceUpdater_.codecs[l] || "")[0] || {}).type, f = (hi(r[l] || "")[0] || {}).type;
        h && f && h.toLowerCase() !== f.toLowerCase() && c.push(`"${this.sourceUpdater_.codecs[l]}" -> "${r[l]}"`);
      }), c.length) {
        this.excludePlaylist({
          playlistToExclude: t,
          error: {
            message: `Codec switching not supported: ${c.join(", ")}.`,
            internal: !0
          },
          playlistExclusionDuration: 1 / 0
        });
        return;
      }
    }
    return r;
  }
  /**
   * Create source buffers and exlude any incompatible renditions.
   *
   * @private
   */
  tryToCreateSourceBuffers_() {
    if (this.mediaSource.readyState !== "open" || this.sourceUpdater_.hasCreatedSourceBuffers() || !this.areMediaTypesKnown_())
      return;
    const e = this.getCodecsOrExclude_();
    if (!e)
      return;
    this.sourceUpdater_.createSourceBuffers(e);
    const t = [e.video, e.audio].filter(Boolean).join(",");
    this.excludeIncompatibleVariants_(t);
  }
  /**
   * Excludes playlists with codecs that are unsupported by the muxer and browser.
   */
  excludeUnsupportedVariants_() {
    const e = this.main().playlists, t = [];
    Object.keys(e).forEach((i) => {
      const r = e[i];
      if (t.indexOf(r.id) !== -1)
        return;
      t.push(r.id);
      const a = Ns(this.main, r), s = [];
      a.audio && !yp(a.audio) && !Rs(a.audio, this.usingManagedMediaSource_) && s.push(`audio codec ${a.audio}`), a.video && !yp(a.video) && !Rs(a.video, this.usingManagedMediaSource_) && s.push(`video codec ${a.video}`), a.text && a.text === "stpp.ttml.im1t" && s.push(`text codec ${a.text}`), s.length && (r.excludeUntil = 1 / 0, this.logger_(`excluding ${r.id} for unsupported: ${s.join(", ")}`));
    });
  }
  /**
   * Exclude playlists that are known to be codec or
   * stream-incompatible with the SourceBuffer configuration. For
   * instance, Media Source Extensions would cause the video element to
   * stall waiting for video data if you switched from a variant with
   * video and audio to an audio-only one.
   *
   * @param {Object} media a media playlist compatible with the current
   * set of SourceBuffers. Variants in the current main playlist that
   * do not appear to have compatible codec or stream configurations
   * will be excluded from the default playlist selection algorithm
   * indefinitely.
   * @private
   */
  excludeIncompatibleVariants_(e) {
    const t = [], i = this.main().playlists, r = eo(hi(e)), a = V_(r), s = r.video && hi(r.video)[0] || null, o = r.audio && hi(r.audio)[0] || null;
    Object.keys(i).forEach((u) => {
      const c = i[u];
      if (t.indexOf(c.id) !== -1 || c.excludeUntil === 1 / 0)
        return;
      t.push(c.id);
      const l = [], h = Ns(this.mainPlaylistLoader_.main, c), f = V_(h);
      if (!(!h.audio && !h.video)) {
        if (f !== a && l.push(`codec count "${f}" !== "${a}"`), !this.sourceUpdater_.canChangeType()) {
          const d = h.video && hi(h.video)[0] || null, y = h.audio && hi(h.audio)[0] || null;
          d && s && d.type.toLowerCase() !== s.type.toLowerCase() && l.push(`video codec "${d.type}" !== "${s.type}"`), y && o && y.type.toLowerCase() !== o.type.toLowerCase() && l.push(`audio codec "${y.type}" !== "${o.type}"`);
        }
        l.length && (c.excludeUntil = 1 / 0, this.logger_(`excluding ${c.id}: ${l.join(" && ")}`));
      }
    });
  }
  updateAdCues_(e) {
    let t = 0;
    const i = this.seekable();
    i.length && (t = i.start(0)), JL(e, this.cueTagsTrack_, t);
  }
  /**
   * Calculates the desired forward buffer length based on current time
   *
   * @return {number} Desired forward buffer length in seconds
   */
  goalBufferLength() {
    const e = this.tech_.currentTime(), t = qt.GOAL_BUFFER_LENGTH, i = qt.GOAL_BUFFER_LENGTH_RATE, r = Math.max(t, qt.MAX_GOAL_BUFFER_LENGTH);
    return Math.min(t + e * i, r);
  }
  /**
   * Calculates the desired buffer low water line based on current time
   *
   * @return {number} Desired buffer low water line in seconds
   */
  bufferLowWaterLine() {
    const e = this.tech_.currentTime(), t = qt.BUFFER_LOW_WATER_LINE, i = qt.BUFFER_LOW_WATER_LINE_RATE, r = Math.max(t, qt.MAX_BUFFER_LOW_WATER_LINE), a = Math.max(t, qt.EXPERIMENTAL_MAX_BUFFER_LOW_WATER_LINE);
    return Math.min(t + e * i, this.bufferBasedABR ? a : r);
  }
  bufferHighWaterLine() {
    return qt.BUFFER_HIGH_WATER_LINE;
  }
  addDateRangesToTextTrack_(e) {
    Q_(this.inbandTextTracks_, "com.apple.streaming", this.tech_), RL({
      inbandTextTracks: this.inbandTextTracks_,
      dateRanges: e
    });
  }
  addMetadataToTextTrack(e, t, i) {
    const r = this.sourceUpdater_.videoBuffer ? this.sourceUpdater_.videoTimestampOffset() : this.sourceUpdater_.audioTimestampOffset();
    Q_(this.inbandTextTracks_, e, this.tech_), kL({
      inbandTextTracks: this.inbandTextTracks_,
      metadataArray: t,
      timestampOffset: r,
      videoDuration: i
    });
  }
  /**
   * Utility for getting the pathway or service location from an HLS or DASH playlist.
   *
   * @param {Object} playlist for getting pathway from.
   * @return the pathway attribute of a playlist
   */
  pathwayAttribute_(e) {
    return e.attributes["PATHWAY-ID"] || e.attributes.serviceLocation;
  }
  /**
   * Initialize available pathways and apply the tag properties.
   */
  initContentSteeringController_() {
    const e = this.main();
    if (e.contentSteering) {
      for (const t of e.playlists)
        this.contentSteeringController_.addAvailablePathway(this.pathwayAttribute_(t));
      if (this.contentSteeringController_.assignTagProperties(e.uri, e.contentSteering), this.contentSteeringController_.queryBeforeStart) {
        this.contentSteeringController_.requestSteeringManifest(!0);
        return;
      }
      this.tech_.one("canplay", () => {
        this.contentSteeringController_.requestSteeringManifest();
      });
    }
  }
  /**
   * Reset the content steering controller and re-init.
   */
  resetContentSteeringController_() {
    this.contentSteeringController_.clearAvailablePathways(), this.contentSteeringController_.dispose(), this.initContentSteeringController_();
  }
  /**
   * Attaches the listeners for content steering.
   */
  attachContentSteeringListeners_() {
    this.contentSteeringController_.on("content-steering", this.excludeThenChangePathway_.bind(this)), ["contentsteeringloadstart", "contentsteeringloadcomplete", "contentsteeringparsed"].forEach((t) => {
      this.contentSteeringController_.on(t, (i) => {
        this.trigger(Lt({}, i));
      });
    }), this.sourceType_ === "dash" && this.mainPlaylistLoader_.on("loadedplaylist", () => {
      const t = this.main();
      (this.contentSteeringController_.didDASHTagChange(t.uri, t.contentSteering) || (() => {
        const a = this.contentSteeringController_.getAvailablePathways(), s = [];
        for (const o of t.playlists) {
          const u = o.attributes.serviceLocation;
          if (u && (s.push(u), !a.has(u)))
            return !0;
        }
        return !!(!s.length && a.size);
      })()) && this.resetContentSteeringController_();
    });
  }
  /**
   * Simple exclude and change playlist logic for content steering.
   */
  excludeThenChangePathway_() {
    const e = this.contentSteeringController_.getPathway();
    if (!e)
      return;
    this.handlePathwayClones_();
    const i = this.main().playlists, r = /* @__PURE__ */ new Set();
    let a = !1;
    Object.keys(i).forEach((s) => {
      const o = i[s], u = this.pathwayAttribute_(o), c = u && e !== u;
      o.excludeUntil === 1 / 0 && o.lastExcludeReason_ === "content-steering" && !c && (delete o.excludeUntil, delete o.lastExcludeReason_, a = !0);
      const h = !o.excludeUntil && o.excludeUntil !== 1 / 0;
      !r.has(o.id) && c && h && (r.add(o.id), o.excludeUntil = 1 / 0, o.lastExcludeReason_ = "content-steering", this.logger_(`excluding ${o.id} for ${o.lastExcludeReason_}`));
    }), this.contentSteeringController_.manifestType_ === "DASH" && Object.keys(this.mediaTypes_).forEach((s) => {
      const o = this.mediaTypes_[s];
      if (o.activePlaylistLoader) {
        const u = o.activePlaylistLoader.media_;
        u && u.attributes.serviceLocation !== e && (a = !0);
      }
    }), a && this.changeSegmentPathway_();
  }
  /**
   * Add, update, or delete playlists and media groups for
   * the pathway clones for HLS Content Steering.
   *
   * See https://datatracker.ietf.org/doc/draft-pantos-hls-rfc8216bis/
   *
   * NOTE: Pathway cloning does not currently support the `PER_VARIANT_URIS` and
   * `PER_RENDITION_URIS` as we do not handle `STABLE-VARIANT-ID` or
   * `STABLE-RENDITION-ID` values.
   */
  handlePathwayClones_() {
    const t = this.main().playlists, i = this.contentSteeringController_.currentPathwayClones, r = this.contentSteeringController_.nextPathwayClones;
    if (i && i.size || r && r.size) {
      for (const [s, o] of i.entries())
        r.get(s) || (this.mainPlaylistLoader_.updateOrDeleteClone(o), this.contentSteeringController_.excludePathway(s));
      for (const [s, o] of r.entries()) {
        const u = i.get(s);
        if (!u) {
          t.filter((l) => l.attributes["PATHWAY-ID"] === o["BASE-ID"]).forEach((l) => {
            this.mainPlaylistLoader_.addClonePathway(o, l);
          }), this.contentSteeringController_.addAvailablePathway(s);
          continue;
        }
        this.equalPathwayClones_(u, o) || (this.mainPlaylistLoader_.updateOrDeleteClone(o, !0), this.contentSteeringController_.addAvailablePathway(s));
      }
      this.contentSteeringController_.currentPathwayClones = new Map(JSON.parse(JSON.stringify([...r])));
    }
  }
  /**
   * Determines whether two pathway clone objects are equivalent.
   *
   * @param {Object} a The first pathway clone object.
   * @param {Object} b The second pathway clone object.
   * @return {boolean} True if the pathway clone objects are equal, false otherwise.
   */
  equalPathwayClones_(e, t) {
    if (e["BASE-ID"] !== t["BASE-ID"] || e.ID !== t.ID || e["URI-REPLACEMENT"].HOST !== t["URI-REPLACEMENT"].HOST)
      return !1;
    const i = e["URI-REPLACEMENT"].PARAMS, r = t["URI-REPLACEMENT"].PARAMS;
    for (const a in i)
      if (i[a] !== r[a])
        return !1;
    for (const a in r)
      if (i[a] !== r[a])
        return !1;
    return !0;
  }
  /**
   * Changes the current playlists for audio, video and subtitles after a new pathway
   * is chosen from content steering.
   */
  changeSegmentPathway_() {
    const e = this.selectPlaylist();
    this.pauseLoading(), this.contentSteeringController_.manifestType_ === "DASH" && this.switchMediaForDASHContentSteering_(), this.switchMedia_(e, "content-steering");
  }
  /**
   * Iterates through playlists and check their keyId set and compare with the
   * keyStatusMap, only enable playlists that have a usable key. If the playlist
   * has no keyId leave it enabled by default.
   */
  excludeNonUsablePlaylistsByKeyId_() {
    if (!this.mainPlaylistLoader_ || !this.mainPlaylistLoader_.main)
      return;
    let e = 0;
    const t = "non-usable";
    this.mainPlaylistLoader_.main.playlists.forEach((i) => {
      const r = this.mainPlaylistLoader_.getKeyIdSet(i);
      !r || !r.size || r.forEach((a) => {
        const s = "usable", o = this.keyStatusMap_.has(a) && this.keyStatusMap_.get(a) === s, u = i.lastExcludeReason_ === t && i.excludeUntil === 1 / 0;
        o ? o && u && (delete i.excludeUntil, delete i.lastExcludeReason_, this.logger_(`enabling playlist ${i.id} because key ID ${a} is ${s}`)) : (i.excludeUntil !== 1 / 0 && i.lastExcludeReason_ !== t && (i.excludeUntil = 1 / 0, i.lastExcludeReason_ = t, this.logger_(`excluding playlist ${i.id} because the key ID ${a} doesn't exist in the keyStatusMap or is not ${s}`)), e++);
      });
    }), e >= this.mainPlaylistLoader_.main.playlists.length && this.mainPlaylistLoader_.main.playlists.forEach((i) => {
      const r = i && i.attributes && i.attributes.RESOLUTION && i.attributes.RESOLUTION.height < 720, a = i.excludeUntil === 1 / 0 && i.lastExcludeReason_ === t;
      r && a && (delete i.excludeUntil, ke.log.warn(`enabling non-HD playlist ${i.id} because all playlists were excluded due to ${t} key IDs`));
    });
  }
  /**
   * Adds a keystatus to the keystatus map, tries to convert to string if necessary.
   *
   * @param {any} keyId the keyId to add a status for
   * @param {string} status the status of the keyId
   */
  addKeyStatus_(e, t) {
    const a = (typeof e == "string" ? e : KL(e)).slice(0, 32).toLowerCase();
    this.logger_(`KeyStatus '${t}' with key ID ${a} added to the keyStatusMap`), this.keyStatusMap_.set(a, t);
  }
  /**
   * Utility function for adding key status to the keyStatusMap and filtering usable encrypted playlists.
   *
   * @param {any} keyId the keyId from the keystatuschange event
   * @param {string} status the key status string
   */
  updatePlaylistByKeyStatus(e, t) {
    this.addKeyStatus_(e, t), this.waitingForFastQualityPlaylistReceived_ || this.excludeNonUsableThenChangePlaylist_(), this.mainPlaylistLoader_.off("loadedplaylist", this.excludeNonUsableThenChangePlaylist_.bind(this)), this.mainPlaylistLoader_.on("loadedplaylist", this.excludeNonUsableThenChangePlaylist_.bind(this));
  }
  excludeNonUsableThenChangePlaylist_() {
    this.excludeNonUsablePlaylistsByKeyId_(), this.fastQualityChange_();
  }
}
const wP = (n, e, t) => (i) => {
  const r = n.main.playlists[e], a = D0(r), s = Al(r);
  if (typeof i > "u")
    return s;
  i ? delete r.disabled : r.disabled = !0;
  const o = {
    renditionInfo: {
      id: e,
      bandwidth: r.attributes.BANDWIDTH,
      resolution: r.attributes.RESOLUTION,
      codecs: r.attributes.CODECS
    },
    cause: "fast-quality"
  };
  return i !== s && !a && (i ? (t(r), n.trigger({
    type: "renditionenabled",
    metadata: o
  })) : n.trigger({
    type: "renditiondisabled",
    metadata: o
  })), i;
};
class EP {
  constructor(e, t, i) {
    const {
      playlistController_: r
    } = e, a = r.fastQualityChange_.bind(r);
    if (t.attributes) {
      const s = t.attributes.RESOLUTION;
      this.width = s && s.width, this.height = s && s.height, this.bandwidth = t.attributes.BANDWIDTH, this.frameRate = t.attributes["FRAME-RATE"];
    }
    this.codecs = Ns(r.main(), t), this.playlist = t, this.id = i, this.enabled = wP(e.playlists, t.id, a);
  }
}
const DP = function(n) {
  n.representations = () => {
    const e = n.playlistController_.main(), t = vo(e) ? n.playlistController_.getAudioTrackPlaylists_() : e.playlists;
    return t ? t.filter((i) => !D0(i)).map((i, r) => new EP(n, i, i.id)) : [];
  };
}, uT = ["seeking", "seeked", "pause", "playing", "error"];
class SP extends ke.EventTarget {
  /**
   * Represents an PlaybackWatcher object.
   *
   * @class
   * @param {Object} options an object that includes the tech and settings
   */
  constructor(e) {
    super(), this.playlistController_ = e.playlistController, this.tech_ = e.tech, this.seekable = e.seekable, this.allowSeeksWithinUnsafeLiveWindow = e.allowSeeksWithinUnsafeLiveWindow, this.liveRangeSafeTimeDelta = e.liveRangeSafeTimeDelta, this.media = e.media, this.playedRanges_ = [], this.consecutiveUpdates = 0, this.lastRecordedTime = null, this.checkCurrentTimeTimeout_ = null, this.logger_ = jn("PlaybackWatcher"), this.logger_("initialize");
    const t = () => this.monitorCurrentTime_(), i = () => this.monitorCurrentTime_(), r = () => this.techWaiting_(), a = () => this.resetTimeUpdate_(), s = this.playlistController_, o = ["main", "subtitle", "audio"], u = {};
    o.forEach((l) => {
      u[l] = {
        reset: () => this.resetSegmentDownloads_(l),
        updateend: () => this.checkSegmentDownloads_(l)
      }, s[`${l}SegmentLoader_`].on("appendsdone", u[l].updateend), s[`${l}SegmentLoader_`].on("playlistupdate", u[l].reset), this.tech_.on(["seeked", "seeking"], u[l].reset);
    });
    const c = (l) => {
      ["main", "audio"].forEach((h) => {
        s[`${h}SegmentLoader_`][l]("appended", this.seekingAppendCheck_);
      });
    };
    this.seekingAppendCheck_ = () => {
      this.fixesBadSeeks_() && (this.consecutiveUpdates = 0, this.lastRecordedTime = this.tech_.currentTime(), c("off"));
    }, this.clearSeekingAppendCheck_ = () => c("off"), this.watchForBadSeeking_ = () => {
      this.clearSeekingAppendCheck_(), c("on");
    }, this.tech_.on("seeked", this.clearSeekingAppendCheck_), this.tech_.on("seeking", this.watchForBadSeeking_), this.tech_.on("waiting", r), this.tech_.on(uT, a), this.tech_.on("canplay", i), this.tech_.one("play", t), this.dispose = () => {
      this.clearSeekingAppendCheck_(), this.logger_("dispose"), this.tech_.off("waiting", r), this.tech_.off(uT, a), this.tech_.off("canplay", i), this.tech_.off("play", t), this.tech_.off("seeking", this.watchForBadSeeking_), this.tech_.off("seeked", this.clearSeekingAppendCheck_), o.forEach((l) => {
        s[`${l}SegmentLoader_`].off("appendsdone", u[l].updateend), s[`${l}SegmentLoader_`].off("playlistupdate", u[l].reset), this.tech_.off(["seeked", "seeking"], u[l].reset);
      }), this.checkCurrentTimeTimeout_ && me.clearTimeout(this.checkCurrentTimeTimeout_), this.resetTimeUpdate_();
    };
  }
  /**
   * Periodically check current time to see if playback stopped
   *
   * @private
   */
  monitorCurrentTime_() {
    this.checkCurrentTime_(), this.checkCurrentTimeTimeout_ && me.clearTimeout(this.checkCurrentTimeTimeout_), this.checkCurrentTimeTimeout_ = me.setTimeout(this.monitorCurrentTime_.bind(this), 250);
  }
  /**
   * Reset stalled download stats for a specific type of loader
   *
   * @param {string} type
   *        The segment loader type to check.
   *
   * @listens SegmentLoader#playlistupdate
   * @listens Tech#seeking
   * @listens Tech#seeked
   */
  resetSegmentDownloads_(e) {
    const t = this.playlistController_[`${e}SegmentLoader_`];
    this[`${e}StalledDownloads_`] > 0 && this.logger_(`resetting possible stalled download count for ${e} loader`), this[`${e}StalledDownloads_`] = 0, this[`${e}Buffered_`] = t.buffered_();
  }
  /**
   * Checks on every segment `appendsdone` to see
   * if segment appends are making progress. If they are not
   * and we are still downloading bytes. We exclude the playlist.
   *
   * @param {string} type
   *        The segment loader type to check.
   *
   * @listens SegmentLoader#appendsdone
   */
  checkSegmentDownloads_(e) {
    const t = this.playlistController_, i = t[`${e}SegmentLoader_`], r = i.buffered_(), a = d9(this[`${e}Buffered_`], r);
    if (this[`${e}Buffered_`] = r, a) {
      const s = {
        bufferedRanges: r
      };
      t.trigger({
        type: "bufferedrangeschanged",
        metadata: s
      }), this.resetSegmentDownloads_(e);
      return;
    }
    this[`${e}StalledDownloads_`]++, this.logger_(`found #${this[`${e}StalledDownloads_`]} ${e} appends that did not increase buffer (possible stalled download)`, {
      playlistId: i.playlist_ && i.playlist_.id,
      buffered: kr(r)
    }), !(this[`${e}StalledDownloads_`] < 10) && (this.logger_(`${e} loader stalled download exclusion`), this.resetSegmentDownloads_(e), this.tech_.trigger({
      type: "usage",
      name: `vhs-${e}-download-exclusion`
    }), e !== "subtitle" && t.excludePlaylist({
      error: {
        message: `Excessive ${e} segment downloading detected.`
      },
      playlistExclusionDuration: 1 / 0
    }));
  }
  /**
   * The purpose of this function is to emulate the "waiting" event on
   * browsers that do not emit it when they are waiting for more
   * data to continue playback
   *
   * @private
   */
  checkCurrentTime_() {
    if (this.tech_.paused() || this.tech_.seeking())
      return;
    const e = this.tech_.currentTime(), t = this.tech_.buffered();
    if (this.lastRecordedTime === e && (!t.length || e + bi >= t.end(t.length - 1)))
      return this.techWaiting_();
    if (this.consecutiveUpdates >= 5 && e === this.lastRecordedTime)
      this.consecutiveUpdates++, this.waiting_();
    else if (e === this.lastRecordedTime)
      this.consecutiveUpdates++;
    else {
      this.playedRanges_.push(Vt([this.lastRecordedTime, e]));
      const i = {
        playedRanges: this.playedRanges_
      };
      this.playlistController_.trigger({
        type: "playedrangeschanged",
        metadata: i
      }), this.consecutiveUpdates = 0, this.lastRecordedTime = e;
    }
  }
  /**
   * Resets the 'timeupdate' mechanism designed to detect that we are stalled
   *
   * @private
   */
  resetTimeUpdate_() {
    this.consecutiveUpdates = 0;
  }
  /**
   * Fixes situations where there's a bad seek
   *
   * @return {boolean} whether an action was taken to fix the seek
   * @private
   */
  fixesBadSeeks_() {
    if (!this.tech_.seeking())
      return !1;
    const t = this.seekable(), i = this.tech_.currentTime(), r = this.afterSeekableWindow_(t, i, this.media(), this.allowSeeksWithinUnsafeLiveWindow);
    let a;
    if (r && (a = t.end(t.length - 1)), this.beforeSeekableWindow_(t, i)) {
      const y = t.start(0);
      a = y + // if the playlist is too short and the seekable range is an exact time (can
      // happen in live with a 3 segment playlist), then don't use a time delta
      (y === t.end(0) ? 0 : bi);
    }
    if (typeof a < "u")
      return this.logger_(`Trying to seek outside of seekable at time ${i} with seekable range ${VS(t)}. Seeking to ${a}.`), this.tech_.setCurrentTime(a), !0;
    const s = this.playlistController_.sourceUpdater_, o = this.tech_.buffered(), u = s.audioBuffer ? s.audioBuffered() : null, c = s.videoBuffer ? s.videoBuffered() : null, l = this.media(), h = l.partTargetDuration ? l.partTargetDuration : (l.targetDuration - gi) * 2, f = [u, c];
    for (let y = 0; y < f.length; y++) {
      if (!f[y])
        continue;
      if (w0(f[y], i) < h)
        return !1;
    }
    const d = _u(o, i);
    return d.length === 0 ? !1 : (a = d.start(0) + bi, this.logger_(`Buffered region starts (${d.start(0)})  just beyond seek point (${i}). Seeking to ${a}.`), this.tech_.setCurrentTime(a), !0);
  }
  /**
   * Handler for situations when we determine the player is waiting.
   *
   * @private
   */
  waiting_() {
    if (this.techWaiting_())
      return;
    const e = this.tech_.currentTime(), t = this.tech_.buffered(), i = ia(t, e);
    if (i.length && e + 3 <= i.end(0)) {
      this.resetTimeUpdate_(), this.tech_.setCurrentTime(e), this.logger_(`Stopped at ${e} while inside a buffered region [${i.start(0)} -> ${i.end(0)}]. Attempting to resume playback by seeking to the current time.`), this.tech_.trigger({
        type: "usage",
        name: "vhs-unknown-waiting"
      });
      return;
    }
  }
  /**
   * Handler for situations when the tech fires a `waiting` event
   *
   * @return {boolean}
   *         True if an action (or none) was needed to correct the waiting. False if no
   *         checks passed
   * @private
   */
  techWaiting_() {
    const e = this.seekable(), t = this.tech_.currentTime();
    if (this.tech_.seeking())
      return !0;
    if (this.beforeSeekableWindow_(e, t)) {
      const o = e.end(e.length - 1);
      return this.logger_(`Fell out of live window at time ${t}. Seeking to live point (seekable end) ${o}`), this.resetTimeUpdate_(), this.tech_.setCurrentTime(o), this.tech_.trigger({
        type: "usage",
        name: "vhs-live-resync"
      }), !0;
    }
    const i = this.tech_.vhs.playlistController_.sourceUpdater_, r = this.tech_.buffered();
    if (this.videoUnderflow_({
      audioBuffered: i.audioBuffered(),
      videoBuffered: i.videoBuffered(),
      currentTime: t
    }))
      return this.resetTimeUpdate_(), this.tech_.setCurrentTime(t), this.tech_.trigger({
        type: "usage",
        name: "vhs-video-underflow"
      }), !0;
    const s = _u(r, t);
    return s.length > 0 ? (this.logger_(`Stopped at ${t} and seeking to ${s.start(0)}`), this.resetTimeUpdate_(), this.skipTheGap_(t), !0) : !1;
  }
  afterSeekableWindow_(e, t, i, r = !1) {
    if (!e.length)
      return !1;
    let a = e.end(e.length - 1) + bi;
    const s = !i.endList, o = typeof i.partTargetDuration == "number";
    return s && (o || r) && (a = e.end(e.length - 1) + i.targetDuration * 3), t > a;
  }
  beforeSeekableWindow_(e, t) {
    return !!(e.length && // can't fall before 0 and 0 seekable start identifies VOD stream
    e.start(0) > 0 && t < e.start(0) - this.liveRangeSafeTimeDelta);
  }
  videoUnderflow_({
    videoBuffered: e,
    audioBuffered: t,
    currentTime: i
  }) {
    if (!e)
      return;
    let r;
    if (e.length && t.length) {
      const a = ia(e, i - 3), s = ia(e, i), o = ia(t, i);
      o.length && !s.length && a.length && (r = {
        start: a.end(0),
        end: o.end(0)
      });
    } else
      _u(e, i).length || (r = this.gapFromVideoUnderflow_(e, i));
    return r ? (this.logger_(`Encountered a gap in video from ${r.start} to ${r.end}. Seeking to current time ${i}`), !0) : !1;
  }
  /**
   * Timer callback. If playback still has not proceeded, then we seek
   * to the start of the next buffered region.
   *
   * @private
   */
  skipTheGap_(e) {
    const t = this.tech_.buffered(), i = this.tech_.currentTime(), r = _u(t, i);
    if (this.resetTimeUpdate_(), r.length === 0 || i !== e)
      return;
    this.logger_("skipTheGap_:", "currentTime:", i, "scheduled currentTime:", e, "nextRange start:", r.start(0)), this.tech_.setCurrentTime(r.start(0) + gi);
    const a = {
      gapInfo: {
        from: i,
        to: r.start(0)
      }
    };
    this.playlistController_.trigger({
      type: "gapjumped",
      metadata: a
    }), this.tech_.trigger({
      type: "usage",
      name: "vhs-gap-skip"
    });
  }
  gapFromVideoUnderflow_(e, t) {
    const i = u9(e);
    for (let r = 0; r < i.length; r++) {
      const a = i.start(r), s = i.end(r);
      if (t - a < 4 && t - a > 2)
        return {
          start: a,
          end: s
        };
    }
    return null;
  }
}
const CP = {
  errorInterval: 30,
  getSource(n) {
    const t = this.tech({
      IWillNotUseThisInPlugins: !0
    }).currentSource_ || this.currentSource();
    return n(t);
  }
}, L3 = function(n, e) {
  let t = 0, i = 0;
  const r = ft(CP, e);
  n.ready(() => {
    n.trigger({
      type: "usage",
      name: "vhs-error-reload-initialized"
    });
  });
  const a = function() {
    i && n.currentTime(i);
  }, s = function(l) {
    l != null && (i = n.duration() !== 1 / 0 && n.currentTime() || 0, n.one("loadedmetadata", a), n.src(l), n.trigger({
      type: "usage",
      name: "vhs-error-reload"
    }), n.play());
  }, o = function() {
    if (Date.now() - t < r.errorInterval * 1e3) {
      n.trigger({
        type: "usage",
        name: "vhs-error-reload-canceled"
      });
      return;
    }
    if (!r.getSource || typeof r.getSource != "function") {
      ke.log.error("ERROR: reloadSourceOnError - The option getSource must be a function!");
      return;
    }
    return t = Date.now(), r.getSource.call(n, s);
  }, u = function() {
    n.off("loadedmetadata", a), n.off("error", o), n.off("dispose", u);
  }, c = function(l) {
    u(), L3(n, l);
  };
  n.on("error", o), n.on("dispose", u), n.reloadSourceOnError = c;
}, AP = function(n) {
  L3(this, n);
};
var P3 = "3.17.2", kP = "7.1.0", IP = "1.3.1", UP = "7.2.0", RP = "4.0.2";
const kt = {
  PlaylistLoader: ra,
  Playlist: pn,
  utils: N9,
  STANDARD_PLAYLIST_SELECTOR: Y_,
  INITIAL_PLAYLIST_SELECTOR: EL,
  lastBandwidthSelector: Y_,
  movingAverageBandwidthSelector: TL,
  comparePlaylistBandwidth: A0,
  comparePlaylistResolution: _L,
  xhr: u3()
};
Object.keys(qt).forEach((n) => {
  Object.defineProperty(kt, n, {
    get() {
      return ke.log.warn(`using Vhs.${n} is UNSAFE be sure you know what you are doing`), qt[n];
    },
    set(e) {
      if (ke.log.warn(`using Vhs.${n} is UNSAFE be sure you know what you are doing`), typeof e != "number" || e < 0) {
        ke.log.warn(`value of Vhs.${n} must be greater than or equal to 0`);
        return;
      }
      qt[n] = e;
    }
  });
});
const F3 = "videojs-vhs", N3 = function(n, e) {
  const t = e.media();
  let i = -1;
  for (let r = 0; r < n.length; r++)
    if (n[r].id === t.id) {
      i = r;
      break;
    }
  n.selectedIndex_ = i, n.trigger({
    selectedIndex: i,
    type: "change"
  });
}, OP = function(n, e) {
  e.representations().forEach((t) => {
    n.addQualityLevel(t);
  }), N3(n, e.playlists);
};
kt.canPlaySource = function() {
  return ke.log.warn("VHS is no longer a tech. Please remove it from your player's techOrder.");
};
const LP = (n, e, t) => {
  if (!n)
    return n;
  let i = {};
  e && e.attributes && e.attributes.CODECS && (i = eo(hi(e.attributes.CODECS))), t && t.attributes && t.attributes.CODECS && (i.audio = t.attributes.CODECS);
  const r = xa(i.video), a = xa(i.audio), s = {};
  for (const o in n)
    s[o] = {}, a && (s[o].audioContentType = a), r && (s[o].videoContentType = r), e.contentProtection && e.contentProtection[o] && e.contentProtection[o].pssh && (s[o].pssh = e.contentProtection[o].pssh), typeof n[o] == "string" && (s[o].url = n[o]);
  return ft(n, s);
}, PP = (n, e) => n.reduce((t, i) => {
  if (!i.contentProtection)
    return t;
  const r = e.reduce((a, s) => {
    const o = i.contentProtection[s];
    return o && o.pssh && (a[s] = {
      pssh: o.pssh
    }), a;
  }, {});
  return Object.keys(r).length && t.push(r), t;
}, []), FP = ({
  player: n,
  sourceKeySystems: e,
  audioMedia: t,
  mainPlaylists: i
}) => {
  if (!n.eme.initializeMediaKeys)
    return Promise.resolve();
  const r = t ? i.concat([t]) : i, a = PP(r, Object.keys(e)), s = [], o = [];
  return a.forEach((u) => {
    o.push(new Promise((c, l) => {
      n.tech_.one("keysessioncreated", c);
    })), s.push(new Promise((c, l) => {
      n.eme.initializeMediaKeys({
        keySystems: u
      }, (h) => {
        if (h) {
          l(h);
          return;
        }
        c();
      });
    }));
  }), Promise.race([
    // If a session was previously created, these will all finish resolving without
    // creating a new session, otherwise it will take until the end of all license
    // requests, which is why the key session check is used (to make setup much faster).
    Promise.all(s),
    // Once a single session is created, the browser knows DRM will be used.
    Promise.race(o)
  ]);
}, NP = ({
  player: n,
  sourceKeySystems: e,
  media: t,
  audioMedia: i
}) => {
  const r = LP(e, t, i);
  return r ? (n.currentSource().keySystems = r, r && !n.eme ? (ke.log.warn("DRM encrypted source cannot be decrypted without a DRM plugin"), !1) : !0) : !1;
}, M3 = () => {
  if (!me.localStorage)
    return null;
  const n = me.localStorage.getItem(F3);
  if (!n)
    return null;
  try {
    return JSON.parse(n);
  } catch {
    return null;
  }
}, MP = (n) => {
  if (!me.localStorage)
    return !1;
  let e = M3();
  e = e ? ft(e, n) : n;
  try {
    me.localStorage.setItem(F3, JSON.stringify(e));
  } catch {
    return !1;
  }
  return e;
}, BP = (n) => n.toLowerCase().indexOf("data:application/vnd.videojs.vhs+json,") === 0 ? JSON.parse(n.substring(n.indexOf(",") + 1)) : n, B3 = (n, e) => {
  n._requestCallbackSet || (n._requestCallbackSet = /* @__PURE__ */ new Set()), n._requestCallbackSet.add(e);
}, j3 = (n, e) => {
  n._responseCallbackSet || (n._responseCallbackSet = /* @__PURE__ */ new Set()), n._responseCallbackSet.add(e);
}, q3 = (n, e) => {
  n._requestCallbackSet && (n._requestCallbackSet.delete(e), n._requestCallbackSet.size || delete n._requestCallbackSet);
}, W3 = (n, e) => {
  n._responseCallbackSet && (n._responseCallbackSet.delete(e), n._responseCallbackSet.size || delete n._responseCallbackSet);
};
kt.supportsNativeHls = (function() {
  if (!Be || !Be.createElement)
    return !1;
  const n = Be.createElement("video");
  return ke.getTech("Html5").isSupported() ? [
    // Apple santioned
    "application/vnd.apple.mpegurl",
    // Apple sanctioned for backwards compatibility
    "audio/mpegurl",
    // Very common
    "audio/x-mpegurl",
    // Very common
    "application/x-mpegurl",
    // Included for completeness
    "video/x-mpegurl",
    "video/mpegurl",
    "application/mpegurl"
  ].some(function(t) {
    return /maybe|probably/i.test(n.canPlayType(t));
  }) : !1;
})();
kt.supportsNativeDash = (function() {
  return !Be || !Be.createElement || !ke.getTech("Html5").isSupported() ? !1 : /maybe|probably/i.test(Be.createElement("video").canPlayType("application/dash+xml"));
})();
kt.supportsTypeNatively = (n) => n === "hls" ? kt.supportsNativeHls : n === "dash" ? kt.supportsNativeDash : !1;
kt.isSupported = function() {
  return ke.log.warn("VHS is no longer a tech. Please remove it from your player's techOrder.");
};
kt.xhr.onRequest = function(n) {
  B3(kt.xhr, n);
};
kt.xhr.onResponse = function(n) {
  j3(kt.xhr, n);
};
kt.xhr.offRequest = function(n) {
  q3(kt.xhr, n);
};
kt.xhr.offResponse = function(n) {
  W3(kt.xhr, n);
};
const jP = ke.getComponent("Component");
class V3 extends jP {
  constructor(e, t, i) {
    if (super(t, i.vhs), typeof i.initialBandwidth == "number" && (this.options_.bandwidth = i.initialBandwidth), this.logger_ = jn("VhsHandler"), t.options_ && t.options_.playerId) {
      const r = ke.getPlayer(t.options_.playerId);
      this.player_ = r;
    }
    if (this.tech_ = t, this.source_ = e, this.stats = {}, this.ignoreNextSeekingEvent_ = !1, this.setOptions_(), this.options_.overrideNative && t.overrideNativeAudioTracks && t.overrideNativeVideoTracks)
      t.overrideNativeAudioTracks(!0), t.overrideNativeVideoTracks(!0);
    else if (this.options_.overrideNative && (t.featuresNativeVideoTracks || t.featuresNativeAudioTracks))
      throw new Error("Overriding native VHS requires emulated tracks. See https://git.io/vMpjB");
    this.on(Be, ["fullscreenchange", "webkitfullscreenchange", "mozfullscreenchange", "MSFullscreenChange"], (r) => {
      const a = Be.fullscreenElement || Be.webkitFullscreenElement || Be.mozFullScreenElement || Be.msFullscreenElement;
      a && a.contains(this.tech_.el()) ? this.playlistController_.fastQualityChange_() : this.playlistController_.checkABR_();
    }), this.on(this.tech_, "seeking", function() {
      if (this.ignoreNextSeekingEvent_) {
        this.ignoreNextSeekingEvent_ = !1;
        return;
      }
      this.setCurrentTime(this.tech_.currentTime());
    }), this.on(this.tech_, "error", function() {
      this.tech_.error() && this.playlistController_ && this.playlistController_.pauseLoading();
    }), this.on(this.tech_, "play", this.play);
  }
  /**
   * Set VHS options based on options from configuration, as well as partial
   * options to be passed at a later time.
   *
   * @param {Object} options A partial chunk of config options
   */
  setOptions_(e = {}) {
    if (this.options_ = ft(this.options_, e), this.options_.withCredentials = this.options_.withCredentials || !1, this.options_.limitRenditionByPlayerDimensions = this.options_.limitRenditionByPlayerDimensions !== !1, this.options_.useDevicePixelRatio = this.options_.useDevicePixelRatio || !1, this.options_.usePlayerObjectFit = this.options_.usePlayerObjectFit || !1, this.options_.useBandwidthFromLocalStorage = typeof this.source_.useBandwidthFromLocalStorage < "u" ? this.source_.useBandwidthFromLocalStorage : this.options_.useBandwidthFromLocalStorage || !1, this.options_.useForcedSubtitles = this.options_.useForcedSubtitles || !1, this.options_.useNetworkInformationApi = typeof this.options_.useNetworkInformationApi < "u" ? this.options_.useNetworkInformationApi : !0, this.options_.useDtsForTimestampOffset = this.options_.useDtsForTimestampOffset || !1, this.options_.customTagParsers = this.options_.customTagParsers || [], this.options_.customTagMappers = this.options_.customTagMappers || [], this.options_.cacheEncryptionKeys = this.options_.cacheEncryptionKeys || !1, this.options_.llhls = this.options_.llhls !== !1, this.options_.bufferBasedABR = this.options_.bufferBasedABR || !1, typeof this.options_.playlistExclusionDuration != "number" && (this.options_.playlistExclusionDuration = 60), typeof this.options_.bandwidth != "number" && this.options_.useBandwidthFromLocalStorage) {
      const i = M3();
      i && i.bandwidth && (this.options_.bandwidth = i.bandwidth, this.tech_.trigger({
        type: "usage",
        name: "vhs-bandwidth-from-local-storage"
      })), i && i.throughput && (this.options_.throughput = i.throughput, this.tech_.trigger({
        type: "usage",
        name: "vhs-throughput-from-local-storage"
      }));
    }
    typeof this.options_.bandwidth != "number" && (this.options_.bandwidth = qt.INITIAL_BANDWIDTH), this.options_.enableLowInitialPlaylist = this.options_.enableLowInitialPlaylist && this.options_.bandwidth === qt.INITIAL_BANDWIDTH, ["withCredentials", "useDevicePixelRatio", "usePlayerObjectFit", "customPixelRatio", "limitRenditionByPlayerDimensions", "bandwidth", "customTagParsers", "customTagMappers", "cacheEncryptionKeys", "playlistSelector", "initialPlaylistSelector", "bufferBasedABR", "liveRangeSafeTimeDelta", "llhls", "useForcedSubtitles", "useNetworkInformationApi", "useDtsForTimestampOffset", "exactManifestTimings", "leastPixelDiffSelector"].forEach((i) => {
      typeof this.source_[i] < "u" && (this.options_[i] = this.source_[i]);
    }), this.limitRenditionByPlayerDimensions = this.options_.limitRenditionByPlayerDimensions, this.useDevicePixelRatio = this.options_.useDevicePixelRatio, this.usePlayerObjectFit = this.options_.usePlayerObjectFit;
    const t = this.options_.customPixelRatio;
    typeof t == "number" && t >= 0 && (this.customPixelRatio = t);
  }
  // alias for public method to set options
  setOptions(e = {}) {
    this.setOptions_(e);
  }
  /**
   * called when player.src gets called, handle a new source
   *
   * @param {Object} src the source object to handle
   */
  src(e, t) {
    if (!e)
      return;
    this.setOptions_(), this.options_.src = BP(this.source_.src), this.options_.tech = this.tech_, this.options_.externVhs = kt, this.options_.sourceType = uD(t), this.options_.seekTo = (a) => {
      this.tech_.setCurrentTime(a);
    }, this.options_.player_ = this.player_, this.playlistController_ = new TP(this.options_);
    const i = ft({
      liveRangeSafeTimeDelta: bi
    }, this.options_, {
      seekable: () => this.seekable(),
      media: () => this.playlistController_.media(),
      playlistController: this.playlistController_
    });
    this.playbackWatcher_ = new SP(i), this.attachStreamingEventListeners_(), this.playlistController_.on("error", () => {
      const a = ke.players[this.tech_.options_.playerId];
      let s = this.playlistController_.error;
      typeof s == "object" && !s.code ? s.code = 3 : typeof s == "string" && (s = {
        message: s,
        code: 3
      }), a.error(s);
    });
    const r = this.options_.bufferBasedABR ? kt.movingAverageBandwidthSelector(0.55) : kt.STANDARD_PLAYLIST_SELECTOR;
    this.playlistController_.selectPlaylist = this.selectPlaylist ? this.selectPlaylist.bind(this) : r.bind(this), this.playlistController_.selectInitialPlaylist = kt.INITIAL_PLAYLIST_SELECTOR.bind(this), this.playlists = this.playlistController_.mainPlaylistLoader_, this.mediaSource = this.playlistController_.mediaSource, Object.defineProperties(this, {
      selectPlaylist: {
        get() {
          return this.playlistController_.selectPlaylist;
        },
        set(a) {
          this.playlistController_.selectPlaylist = a.bind(this);
        }
      },
      throughput: {
        get() {
          return this.playlistController_.mainSegmentLoader_.throughput.rate;
        },
        set(a) {
          this.playlistController_.mainSegmentLoader_.throughput.rate = a, this.playlistController_.mainSegmentLoader_.throughput.count = 1;
        }
      },
      bandwidth: {
        get() {
          let a = this.playlistController_.mainSegmentLoader_.bandwidth;
          const s = me.navigator.connection || me.navigator.mozConnection || me.navigator.webkitConnection, o = 1e7;
          if (this.options_.useNetworkInformationApi && s) {
            const u = s.downlink * 1e3 * 1e3;
            u >= o && a >= o ? a = Math.max(a, u) : a = u;
          }
          return a;
        },
        set(a) {
          this.playlistController_.mainSegmentLoader_.bandwidth = a, this.playlistController_.mainSegmentLoader_.throughput = {
            rate: 0,
            count: 0
          };
        }
      },
      /**
       * `systemBandwidth` is a combination of two serial processes bit-rates. The first
       * is the network bitrate provided by `bandwidth` and the second is the bitrate of
       * the entire process after that - decryption, transmuxing, and appending - provided
       * by `throughput`.
       *
       * Since the two process are serial, the overall system bandwidth is given by:
       *   sysBandwidth = 1 / (1 / bandwidth + 1 / throughput)
       */
      systemBandwidth: {
        get() {
          const a = 1 / (this.bandwidth || 1);
          let s;
          return this.throughput > 0 ? s = 1 / this.throughput : s = 0, Math.floor(1 / (a + s));
        },
        set() {
          ke.log.error('The "systemBandwidth" property is read-only');
        }
      }
    }), this.options_.bandwidth && (this.bandwidth = this.options_.bandwidth), this.options_.throughput && (this.throughput = this.options_.throughput), Object.defineProperties(this.stats, {
      bandwidth: {
        get: () => this.bandwidth || 0,
        enumerable: !0
      },
      mediaRequests: {
        get: () => this.playlistController_.mediaRequests_() || 0,
        enumerable: !0
      },
      mediaRequestsAborted: {
        get: () => this.playlistController_.mediaRequestsAborted_() || 0,
        enumerable: !0
      },
      mediaRequestsTimedout: {
        get: () => this.playlistController_.mediaRequestsTimedout_() || 0,
        enumerable: !0
      },
      mediaRequestsErrored: {
        get: () => this.playlistController_.mediaRequestsErrored_() || 0,
        enumerable: !0
      },
      mediaTransferDuration: {
        get: () => this.playlistController_.mediaTransferDuration_() || 0,
        enumerable: !0
      },
      mediaBytesTransferred: {
        get: () => this.playlistController_.mediaBytesTransferred_() || 0,
        enumerable: !0
      },
      mediaSecondsLoaded: {
        get: () => this.playlistController_.mediaSecondsLoaded_() || 0,
        enumerable: !0
      },
      mediaAppends: {
        get: () => this.playlistController_.mediaAppends_() || 0,
        enumerable: !0
      },
      mainAppendsToLoadedData: {
        get: () => this.playlistController_.mainAppendsToLoadedData_() || 0,
        enumerable: !0
      },
      audioAppendsToLoadedData: {
        get: () => this.playlistController_.audioAppendsToLoadedData_() || 0,
        enumerable: !0
      },
      appendsToLoadedData: {
        get: () => this.playlistController_.appendsToLoadedData_() || 0,
        enumerable: !0
      },
      timeToLoadedData: {
        get: () => this.playlistController_.timeToLoadedData_() || 0,
        enumerable: !0
      },
      buffered: {
        get: () => kr(this.tech_.buffered()),
        enumerable: !0
      },
      currentTime: {
        get: () => this.tech_.currentTime(),
        enumerable: !0
      },
      currentSource: {
        get: () => this.tech_.currentSource_,
        enumerable: !0
      },
      currentTech: {
        get: () => this.tech_.name_,
        enumerable: !0
      },
      duration: {
        get: () => this.tech_.duration(),
        enumerable: !0
      },
      main: {
        get: () => this.playlists.main,
        enumerable: !0
      },
      playerDimensions: {
        get: () => this.tech_.currentDimensions(),
        enumerable: !0
      },
      seekable: {
        get: () => kr(this.tech_.seekable()),
        enumerable: !0
      },
      timestamp: {
        get: () => Date.now(),
        enumerable: !0
      },
      videoPlaybackQuality: {
        get: () => this.tech_.getVideoPlaybackQuality(),
        enumerable: !0
      }
    }), this.tech_.one("canplay", this.playlistController_.setupFirstPlay.bind(this.playlistController_)), this.tech_.on("bandwidthupdate", () => {
      this.options_.useBandwidthFromLocalStorage && MP({
        bandwidth: this.bandwidth,
        throughput: Math.round(this.throughput)
      });
    }), this.playlistController_.on("selectedinitialmedia", () => {
      DP(this);
    }), this.playlistController_.sourceUpdater_.on("createdsourcebuffers", () => {
      this.setupEme_();
    }), this.on(this.playlistController_, "progress", function() {
      this.tech_.trigger("progress");
    }), this.on(this.playlistController_, "firstplay", function() {
      this.ignoreNextSeekingEvent_ = !0;
    }), this.setupQualityLevels_(), this.tech_.el() && (this.mediaSourceUrl_ = me.URL.createObjectURL(this.playlistController_.mediaSource), (ke.browser.IS_ANY_SAFARI || ke.browser.IS_IOS) && this.options_.overrideNative && this.options_.sourceType === "hls" && typeof this.tech_.addSourceElement == "function" ? (this.tech_.addSourceElement(this.mediaSourceUrl_), this.tech_.addSourceElement(this.source_.src)) : this.tech_.src(this.mediaSourceUrl_));
  }
  createKeySessions_() {
    const e = this.playlistController_.mediaTypes_.AUDIO.activePlaylistLoader;
    this.logger_("waiting for EME key session creation"), FP({
      player: this.player_,
      sourceKeySystems: this.source_.keySystems,
      audioMedia: e && e.media(),
      mainPlaylists: this.playlists.main.playlists
    }).then(() => {
      this.logger_("created EME key session"), this.playlistController_.sourceUpdater_.initializedEme();
    }).catch((t) => {
      this.logger_("error while creating EME key session", t), this.player_.error({
        message: "Failed to initialize media keys for EME",
        code: 3
      });
    });
  }
  handleWaitingForKey_() {
    this.logger_("waitingforkey fired, attempting to create any new key sessions"), this.createKeySessions_();
  }
  /**
   * If necessary and EME is available, sets up EME options and waits for key session
   * creation.
   *
   * This function also updates the source updater so taht it can be used, as for some
   * browsers, EME must be configured before content is appended (if appending unencrypted
   * content before encrypted content).
   */
  setupEme_() {
    const e = this.playlistController_.mediaTypes_.AUDIO.activePlaylistLoader, t = NP({
      player: this.player_,
      sourceKeySystems: this.source_.keySystems,
      media: this.playlists.media(),
      audioMedia: e && e.media()
    });
    if (this.player_.tech_.on("keystatuschange", (i) => {
      this.playlistController_.updatePlaylistByKeyStatus(i.keyId, i.status);
    }), this.handleWaitingForKey_ = this.handleWaitingForKey_.bind(this), this.player_.tech_.on("waitingforkey", this.handleWaitingForKey_), !t) {
      this.playlistController_.sourceUpdater_.initializedEme();
      return;
    }
    this.createKeySessions_();
  }
  /**
   * Initializes the quality levels and sets listeners to update them.
   *
   * @method setupQualityLevels_
   * @private
   */
  setupQualityLevels_() {
    const e = ke.players[this.tech_.options_.playerId];
    !e || !e.qualityLevels || this.qualityLevels_ || (this.qualityLevels_ = e.qualityLevels(), this.playlistController_.on("selectedinitialmedia", () => {
      OP(this.qualityLevels_, this);
    }), this.playlists.on("mediachange", () => {
      N3(this.qualityLevels_, this.playlists);
    }));
  }
  /**
   * return the version
   */
  static version() {
    return {
      "@videojs/http-streaming": P3,
      "mux.js": kP,
      "mpd-parser": IP,
      "m3u8-parser": UP,
      "aes-decrypter": RP
    };
  }
  /**
   * return the version
   */
  version() {
    return this.constructor.version();
  }
  canChangeType() {
    return I3.canChangeType();
  }
  /**
   * Begin playing the video.
   */
  play() {
    this.playlistController_.play();
  }
  /**
   * a wrapper around the function in PlaylistController
   */
  setCurrentTime(e) {
    this.playlistController_.setCurrentTime(e);
  }
  /**
   * a wrapper around the function in PlaylistController
   */
  duration() {
    return this.playlistController_.duration();
  }
  /**
   * a wrapper around the function in PlaylistController
   */
  seekable() {
    return this.playlistController_.seekable();
  }
  /**
   * Abort all outstanding work and cleanup.
   */
  dispose() {
    this.playbackWatcher_ && this.playbackWatcher_.dispose(), this.playlistController_ && this.playlistController_.dispose(), this.qualityLevels_ && this.qualityLevels_.dispose(), this.tech_ && this.tech_.vhs && delete this.tech_.vhs, this.mediaSourceUrl_ && me.URL.revokeObjectURL && (me.URL.revokeObjectURL(this.mediaSourceUrl_), this.mediaSourceUrl_ = null), this.tech_ && this.tech_.off("waitingforkey", this.handleWaitingForKey_), super.dispose();
  }
  convertToProgramTime(e, t) {
    return H9({
      playlist: this.playlistController_.media(),
      time: e,
      callback: t
    });
  }
  // the player must be playing before calling this
  seekToProgramTime(e, t, i = !0, r = 2) {
    return h3({
      programTime: e,
      playlist: this.playlistController_.media(),
      retryCount: r,
      pauseAfterSeek: i,
      seekTo: this.options_.seekTo,
      tech: this.options_.tech,
      callback: t
    });
  }
  /**
   * Adds the onRequest, onResponse, offRequest and offResponse functions
   * to the VhsHandler xhr Object.
   */
  setupXhrHooks_() {
    this.xhr.onRequest = (e) => {
      B3(this.xhr, e);
    }, this.xhr.onResponse = (e) => {
      j3(this.xhr, e);
    }, this.xhr.offRequest = (e) => {
      q3(this.xhr, e);
    }, this.xhr.offResponse = (e) => {
      W3(this.xhr, e);
    }, this.player_.trigger("xhr-hooks-ready");
  }
  attachStreamingEventListeners_() {
    const e = ["seekablerangeschanged", "bufferedrangeschanged", "contentsteeringloadstart", "contentsteeringloadcomplete", "contentsteeringparsed"], t = ["gapjumped", "playedrangeschanged"];
    e.forEach((i) => {
      this.playlistController_.on(i, (r) => {
        this.player_.trigger(Lt({}, r));
      });
    }), t.forEach((i) => {
      this.playbackWatcher_.on(i, (r) => {
        this.player_.trigger(Lt({}, r));
      });
    });
  }
}
const Cc = {
  name: "videojs-http-streaming",
  VERSION: P3,
  canHandleSource(n, e = {}) {
    const t = ft(ke.options, e);
    return !t.vhs.experimentalUseMMS && !Rs("avc1.4d400d,mp4a.40.2", !1) ? !1 : Cc.canPlayType(n.type, t);
  },
  handleSource(n, e, t = {}) {
    const i = ft(ke.options, t);
    return e.vhs = new V3(n, e, i), e.vhs.xhr = u3(), e.vhs.setupXhrHooks_(), e.vhs.src(n.src, n.type), e.vhs;
  },
  canPlayType(n, e) {
    const t = uD(n);
    if (!t)
      return "";
    const i = Cc.getOverrideNative(e);
    return !kt.supportsTypeNatively(t) || i ? "maybe" : "";
  },
  getOverrideNative(n = {}) {
    const {
      vhs: e = {}
    } = n, t = !(ke.browser.IS_ANY_SAFARI || ke.browser.IS_IOS), {
      overrideNative: i = t
    } = e;
    return i;
  }
}, qP = () => Rs("avc1.4d400d,mp4a.40.2", !0);
qP() && ke.getTech("Html5").registerSourceHandler(Cc, 0);
ke.VhsHandler = V3;
ke.VhsSourceHandler = Cc;
ke.Vhs = kt;
ke.use || ke.registerComponent("Vhs", kt);
ke.options.vhs = ke.options.vhs || {};
(!ke.getPlugin || !ke.getPlugin("reloadSourceOnError")) && ke.registerPlugin("reloadSourceOnError", AP);
const WP = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: ke
}, Symbol.toStringTag, { value: "Module" }));
var jp, cT;
function VP() {
  if (cT) return jp;
  cT = 1;
  var n = Mi(), e = function() {
    return n.Date.now();
  };
  return jp = e, jp;
}
var qp, lT;
function HP() {
  if (lT) return qp;
  lT = 1;
  var n = /\s/;
  function e(t) {
    for (var i = t.length; i-- && n.test(t.charAt(i)); )
      ;
    return i;
  }
  return qp = e, qp;
}
var Wp, dT;
function zP() {
  if (dT) return Wp;
  dT = 1;
  var n = HP(), e = /^\s+/;
  function t(i) {
    return i && i.slice(0, n(i) + 1).replace(e, "");
  }
  return Wp = t, Wp;
}
var Vp, fT;
function $P() {
  if (fT) return Vp;
  fT = 1;
  var n = no(), e = Ic(), t = "[object Symbol]";
  function i(r) {
    return typeof r == "symbol" || e(r) && n(r) == t;
  }
  return Vp = i, Vp;
}
var Hp, hT;
function GP() {
  if (hT) return Hp;
  hT = 1;
  var n = zP(), e = ao(), t = $P(), i = NaN, r = /^[-+]0x[0-9a-f]+$/i, a = /^0b[01]+$/i, s = /^0o[0-7]+$/i, o = parseInt;
  function u(c) {
    if (typeof c == "number")
      return c;
    if (t(c))
      return i;
    if (e(c)) {
      var l = typeof c.valueOf == "function" ? c.valueOf() : c;
      c = e(l) ? l + "" : l;
    }
    if (typeof c != "string")
      return c === 0 ? c : +c;
    c = n(c);
    var h = a.test(c);
    return h || s.test(c) ? o(c.slice(2), h ? 2 : 8) : r.test(c) ? i : +c;
  }
  return Hp = u, Hp;
}
var zp, pT;
function H3() {
  if (pT) return zp;
  pT = 1;
  var n = ao(), e = VP(), t = GP(), i = "Expected a function", r = Math.max, a = Math.min;
  function s(o, u, c) {
    var l, h, f, d, y, m, b = 0, p = !1, g = !1, v = !0;
    if (typeof o != "function")
      throw new TypeError(i);
    u = t(u) || 0, n(c) && (p = !!c.leading, g = "maxWait" in c, f = g ? r(t(c.maxWait) || 0, u) : f, v = "trailing" in c ? !!c.trailing : v);
    function _(k) {
      var I = l, $ = h;
      return l = h = void 0, b = k, d = o.apply($, I), d;
    }
    function x(k) {
      return b = k, y = setTimeout(U, u), p ? _(k) : d;
    }
    function T(k) {
      var I = k - m, $ = k - b, W = u - I;
      return g ? a(W, f - $) : W;
    }
    function E(k) {
      var I = k - m, $ = k - b;
      return m === void 0 || I >= u || I < 0 || g && $ >= f;
    }
    function U() {
      var k = e();
      if (E(k))
        return D(k);
      y = setTimeout(U, T(k));
    }
    function D(k) {
      return y = void 0, v && l ? _(k) : (l = h = void 0, d);
    }
    function L() {
      y !== void 0 && clearTimeout(y), b = 0, l = m = h = y = void 0;
    }
    function j() {
      return y === void 0 ? d : D(e());
    }
    function C() {
      var k = e(), I = E(k);
      if (l = arguments, h = this, m = k, I) {
        if (y === void 0)
          return x(m);
        if (g)
          return clearTimeout(y), y = setTimeout(U, u), _(m);
      }
      return y === void 0 && (y = setTimeout(U, u)), d;
    }
    return C.cancel = L, C.flush = j, C;
  }
  return zp = s, zp;
}
var $p, mT;
function XP() {
  if (mT) return $p;
  mT = 1;
  var n = H3(), e = ao(), t = "Expected a function";
  function i(r, a, s) {
    var o = !0, u = !0;
    if (typeof r != "function")
      throw new TypeError(t);
    return e(s) && (o = "leading" in s ? !!s.leading : o, u = "trailing" in s ? !!s.trailing : u), n(r, a, {
      leading: o,
      maxWait: a,
      trailing: u
    });
  }
  return $p = i, $p;
}
var KP = XP();
const Ac = /* @__PURE__ */ Qt(KP);
var Gp = {};
const YP = /* @__PURE__ */ kc(WP);
var gT;
function QP() {
  return gT || (gT = 1, (function(n) {
    (function(e, t) {
      t(YP);
    })(Gp, function(e) {
      var t = i(e);
      function i(l) {
        return l && l.__esModule ? l : {
          default: l
        };
      }
      var r = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(l) {
        return typeof l;
      } : function(l) {
        return l && typeof Symbol == "function" && l.constructor === Symbol && l !== Symbol.prototype ? "symbol" : typeof l;
      }, a = {
        markerStyle: {
          width: "7px",
          "border-radius": "30%",
          "background-color": "red"
        },
        markerTip: {
          display: !0,
          text: function(h) {
            return "Break: " + h.text;
          },
          time: function(h) {
            return h.time;
          }
        },
        breakOverlay: {
          display: !1,
          displayTime: 3,
          text: function(h) {
            return "Break overlay: " + h.overlayText;
          },
          style: {
            width: "100%",
            height: "20%",
            "background-color": "rgba(0,0,0,0.7)",
            color: "white",
            "font-size": "17px"
          }
        },
        onMarkerClick: function(h) {
        },
        onMarkerReached: function(h, f) {
        },
        markers: []
      };
      function s() {
        var l = (/* @__PURE__ */ new Date()).getTime(), h = "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function(f) {
          var d = (l + Math.random() * 16) % 16 | 0;
          return l = Math.floor(l / 16), (f == "x" ? d : d & 3 | 8).toString(16);
        });
        return h;
      }
      function o(l) {
        var h, f = {
          top: 0,
          bottom: 0,
          left: 0,
          width: 0,
          height: 0,
          right: 0
        };
        try {
          h = l.getBoundingClientRect();
        } catch {
          h = f;
        }
        return h;
      }
      var u = -1;
      function c(l) {
        if (!t.default.mergeOptions) {
          var h = function(Y) {
            return !!Y && (typeof Y > "u" ? "undefined" : r(Y)) === "object" && toString.call(Y) === "[object Object]" && Y.constructor === Object;
          }, f = function q(Y, H) {
            var K = {}, ie = [Y, H];
            return ie.forEach(function(ge) {
              ge && Object.keys(ge).forEach(function(pe) {
                var ce = ge[pe];
                if (!h(ce)) {
                  K[pe] = ce;
                  return;
                }
                h(K[pe]) || (K[pe] = {}), K[pe] = q(K[pe], ce);
              });
            }), K;
          };
          t.default.mergeOptions = f;
        }
        t.default.dom.createEl || (t.default.dom.createEl = function(q, Y, H) {
          var K = t.default.Player.prototype.dom.createEl(q, Y);
          return H && Object.keys(H).forEach(function(ie) {
            K.setAttribute(ie, H[ie]);
          }), K;
        });
        var d = t.default.mergeOptions(a, l), y = {}, m = [], b = u, p = this, g = null, v = null, _ = u;
        function x() {
          m.sort(function(q, Y) {
            return d.markerTip.time(q) - d.markerTip.time(Y);
          });
        }
        function T(q) {
          q.forEach(function(Y) {
            Y.key = s(), p.el().querySelector(".vjs-progress-holder").appendChild(D(Y)), y[Y.key] = Y, m.push(Y);
          }), x();
        }
        function E(q) {
          return d.markerTip.time(q) / p.duration() * 100;
        }
        function U(q, Y) {
          Y.className = "vjs-marker " + (q.class || ""), Object.keys(d.markerStyle).forEach(function(ie) {
            Y.style[ie] = d.markerStyle[ie];
          });
          var H = q.time / p.duration();
          if ((H < 0 || H > 1) && (Y.style.display = "none"), Y.style.left = E(q) + "%", q.duration)
            Y.style.width = q.duration / p.duration() * 100 + "%", Y.style.marginLeft = "0px";
          else {
            var K = o(Y);
            Y.style.marginLeft = K.width / 2 + "px";
          }
        }
        function D(q) {
          var Y = t.default.dom.createEl("div", {}, {
            "data-marker-key": q.key,
            "data-marker-time": d.markerTip.time(q)
          });
          return U(q, Y), Y.addEventListener("click", function(H) {
            var K = !1;
            if (typeof d.onMarkerClick == "function" && (K = d.onMarkerClick(q) === !1), !K) {
              var ie = this.getAttribute("data-marker-key");
              p.currentTime(d.markerTip.time(y[ie]));
            }
          }), d.markerTip.display && C(Y), Y;
        }
        function L(q) {
          m.forEach(function(Y) {
            var H = p.el().querySelector(".vjs-marker[data-marker-key='" + Y.key + "']"), K = d.markerTip.time(Y);
            (q || H.getAttribute("data-marker-time") !== K) && (U(Y, H), H.setAttribute("data-marker-time", K));
          }), x();
        }
        function j(q) {
          v && (_ = u, v.style.visibility = "hidden"), b = u;
          var Y = [];
          q.forEach(function(H) {
            var K = m[H];
            if (K) {
              delete y[K.key], Y.push(H);
              var ie = p.el().querySelector(".vjs-marker[data-marker-key='" + K.key + "']");
              ie && ie.parentNode.removeChild(ie);
            }
          }), Y.reverse(), Y.forEach(function(H) {
            m.splice(H, 1);
          }), x();
        }
        function C(q) {
          q.addEventListener("mouseover", function() {
            var Y = y[q.getAttribute("data-marker-key")];
            if (g) {
              d.markerTip.html ? g.querySelector(".vjs-tip-inner").innerHTML = d.markerTip.html(Y) : g.querySelector(".vjs-tip-inner").innerText = d.markerTip.text(Y), g.style.left = E(Y) + "%";
              var H = o(g), K = o(q);
              g.style.marginLeft = -parseFloat(H.width / 2) + parseFloat(K.width / 4) + "px", g.style.visibility = "visible";
            }
          }), q.addEventListener("mouseout", function() {
            g && (g.style.visibility = "hidden");
          });
        }
        function k() {
          g = t.default.dom.createEl("div", {
            className: "vjs-tip",
            innerHTML: "<div class='vjs-tip-arrow'></div><div class='vjs-tip-inner'></div>"
          }), p.el().querySelector(".vjs-progress-holder").appendChild(g);
        }
        function I() {
          if (!(!d.breakOverlay.display || b < 0)) {
            var q = p.currentTime(), Y = m[b], H = d.markerTip.time(Y);
            q >= H && q <= H + d.breakOverlay.displayTime ? (_ !== b && (_ = b, v && (v.querySelector(".vjs-break-overlay-text").innerHTML = d.breakOverlay.text(Y))), v && (v.style.visibility = "visible")) : (_ = u, v && (v.style.visibility = "hidden"));
          }
        }
        function $() {
          v = t.default.dom.createEl("div", {
            className: "vjs-break-overlay",
            innerHTML: "<div class='vjs-break-overlay-text'></div>"
          }), Object.keys(d.breakOverlay.style).forEach(function(q) {
            v && (v.style[q] = d.breakOverlay.style[q]);
          }), p.el().appendChild(v), _ = u;
        }
        function W() {
          B(), I(), l.onTimeUpdateAfterMarkerUpdate && l.onTimeUpdateAfterMarkerUpdate();
        }
        function B() {
          if (m.length) {
            var q = function(pe) {
              return pe < m.length - 1 ? d.markerTip.time(m[pe + 1]) : p.duration();
            }, Y = p.currentTime(), H = u;
            if (b !== u) {
              var K = q(b);
              if (Y >= d.markerTip.time(m[b]) && Y < K || b === m.length - 1 && Y === p.duration())
                return;
            }
            if (Y < d.markerTip.time(m[0]))
              H = u;
            else
              for (var ie = 0; ie < m.length; ie++)
                if (K = q(ie), Y >= d.markerTip.time(m[ie]) && Y < K) {
                  H = ie;
                  break;
                }
            H !== b && (H !== u && l.onMarkerReached && l.onMarkerReached(m[H], H), b = H);
          }
        }
        function z() {
          d.markerTip.display && k(), p.markers.removeAll(), T(d.markers), d.breakOverlay.display && $(), W(), p.on("timeupdate", W), p.off("loadedmetadata");
        }
        p.on("loadedmetadata", function() {
          z();
        }), p.markers = {
          getMarkers: function() {
            return m;
          },
          next: function() {
            for (var Y = p.currentTime(), H = 0; H < m.length; H++) {
              var K = d.markerTip.time(m[H]);
              if (K > Y) {
                p.currentTime(K);
                break;
              }
            }
          },
          prev: function() {
            for (var Y = p.currentTime(), H = m.length - 1; H >= 0; H--) {
              var K = d.markerTip.time(m[H]);
              if (K + 0.5 < Y) {
                p.currentTime(K);
                return;
              }
            }
          },
          add: function(Y) {
            T(Y);
          },
          remove: function(Y) {
            j(Y);
          },
          removeAll: function() {
            for (var Y = [], H = 0; H < m.length; H++)
              Y.push(H);
            j(Y);
          },
          // force - force all markers to be updated, regardless of if they have changed or not.
          updateTime: function(Y) {
            L(Y);
          },
          reset: function(Y) {
            p.markers.removeAll(), T(Y);
          },
          destroy: function() {
            p.markers.removeAll(), v && v.remove(), g && g.remove(), p.off("timeupdate", I), delete p.markers;
          }
        };
      }
      t.default.registerPlugin("markers", c);
    });
  })()), Gp;
}
QP();
let bT = !1, Ui = !1, Ms = !1, Bs = !1, Pm = !1, Qi = !1, js = !1, ei = !1, ti = !1, Ss = !1, Fm = !1, yT = !1, vT = !1;
const Ai = window.navigator && window.navigator.userAgentData;
Ai && Ai.platform && Ai.brands && (Ui = Ai.platform === "Android", Ms = !!Ai.brands.find((n) => n.brand === "Microsoft Edge"), Bs = !!Ai.brands.find((n) => n.brand === "Chromium"), Pm = !Ms && Bs, (Ai.brands.find((n) => n.brand === "Chromium") || {}).version, Ai.platform, ti = navigator.maxTouchPoints && navigator.maxTouchPoints > 2 && !window.matchMedia("(pointer: fine").matches, ei = Ai.mobile || Ui || ti);
if (!Bs) {
  const n = window.navigator && window.navigator.userAgent || "";
  bT = /iPod/i.test(n), (function() {
    const e = n.match(/OS (\d+)_/i);
    return e && e[1] ? e[1] : null;
  })(), Ui = /Android/i.test(n), (function() {
    const e = n.match(/Android (\d+)(?:\.(\d+))?(?:\.(\d+))*/i);
    if (!e)
      return null;
    const t = e[1] && parseFloat(e[1]), i = e[2] && parseFloat(e[2]);
    return t && i ? parseFloat(e[1] + "." + e[2]) : t || null;
  })(), Ms = /Edg/i.test(n), Bs = /Chrome/i.test(n) || /CriOS/i.test(n), Pm = !Ms && Bs, (function() {
    const e = n.match(/(Chrome|CriOS)\/(\d+)/);
    return e && e[2] ? parseFloat(e[2]) : null;
  })(), (function() {
    const e = /MSIE\s(\d+)\.\d/.exec(n);
    let t = e && parseFloat(e[1]);
    return !t && /Trident\/7.0/i.test(n) && /rv:11.0/.test(n) && (t = 11), t;
  })(), yT = /Tizen/i.test(n), vT = /Web0S/i.test(n), Qi = /Safari/i.test(n) && !Pm && !Ui && !Ms && !yT && !vT, Ss = /iPhone/i.test(n) && !js, Fm = Ss || js || bT, ti = navigator.maxTouchPoints && navigator.maxTouchPoints > 2 && !window.matchMedia("(pointer: fine").matches, js = ti && !Ui && !Ss, ei = Ui || Fm || Ss || ti || /Mobi/i.test(n);
}
function ZP(n, e) {
  try {
    return JSON.parse(localStorage.getItem(n)) ?? e;
  } catch {
    return e;
  }
}
const Eu = (n, e) => {
  const t = Et.c(9);
  let i;
  t[0] !== e || t[1] !== n ? (i = () => ZP(n, e), t[0] = e, t[1] = n, t[2] = i) : i = t[2];
  const [r, a] = $e(i);
  let s, o;
  t[3] !== n || t[4] !== r ? (s = () => {
    try {
      localStorage.setItem(n, JSON.stringify(r));
    } catch {
    }
  }, o = [n, r], t[3] = n, t[4] = r, t[5] = s, t[6] = o) : (s = t[5], o = t[6]), et(s, o);
  let u;
  return t[7] !== r ? (u = [r, a], t[7] = r, t[8] = u) : u = t[8], u;
}, JP = () => {
  const n = Et.c(1);
  let e;
  return n[0] === Symbol.for("react.memo_cache_sentinel") ? (e = /* @__PURE__ */ se.jsx("svg", { viewBox: "0 0 24 24", xmlns: "http://www.w3.org/2000/svg", style: {
    fill: "white",
    height: "1rem",
    width: "1rem",
    scale: 0.8
  }, children: /* @__PURE__ */ se.jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: `M21.1213 2.70705C19.9497 1.53548 18.0503 1.53547 16.8787 2.70705L15.1989 
        4.38685L7.29289 12.2928C7.16473 12.421 7.07382 12.5816 7.02986 12.7574L6.02986 
        16.7574C5.94466 17.0982 6.04451 17.4587 6.29289 17.707C6.54127 17.9554 6.90176 
        18.0553 7.24254 17.9701L11.2425 16.9701C11.4184 16.9261 11.5789 16.8352 11.7071 
        16.707L19.5556 8.85857L21.2929 7.12126C22.4645 5.94969 22.4645 4.05019 21.2929 
        2.87862L21.1213 2.70705ZM18.2929 4.12126C18.6834 3.73074 19.3166 3.73074 19.7071 
        4.12126L19.8787 4.29283C20.2692 4.68336 20.2692 5.31653 19.8787 5.70705L18.8622 
        6.72357L17.3068 5.10738L18.2929 4.12126ZM15.8923 6.52185L17.4477 8.13804L10.4888 
        15.097L8.37437 15.6256L8.90296 13.5112L15.8923 6.52185ZM4 7.99994C4 7.44766 4.44772 
        6.99994 5 6.99994H10C10.5523 6.99994 11 6.55223 11 5.99994C11 5.44766 10.5523 
        4.99994 10 4.99994H5C3.34315 4.99994 2 6.34309 2 7.99994V18.9999C2 20.6568 3.34315 
        21.9999 5 21.9999H16C17.6569 21.9999 19 20.6568 19 18.9999V13.9999C19 13.4477 
        18.5523 12.9999 18 12.9999C17.4477 12.9999 17 13.4477 17 13.9999V18.9999C17 
        19.5522 16.5523 19.9999 16 19.9999H5C4.44772 19.9999 4 19.5522 4 18.9999V7.99994Z`, fill: "#fffff" }) }), n[0] = e) : e = n[0], e;
}, e7 = () => {
  const n = Et.c(2);
  let e;
  n[0] === Symbol.for("react.memo_cache_sentinel") ? (e = {
    height: "1rem",
    width: "1rem",
    scale: 0.8
  }, n[0] = e) : e = n[0];
  let t;
  return n[1] === Symbol.for("react.memo_cache_sentinel") ? (t = /* @__PURE__ */ se.jsx("svg", { viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg", stroke: "#ffffff", style: e, children: /* @__PURE__ */ se.jsxs("g", { strokeWidth: "0", strokeLinecap: "round", strokeLinejoin: "round", children: [
    /* @__PURE__ */ se.jsx("path", { d: "M10 12V17", stroke: "#ffffff", strokeWidth: "2", strokeLinecap: "round", strokeLinejoin: "round" }),
    /* @__PURE__ */ se.jsx("path", { d: "M14 12V17", stroke: "#ffffff", strokeWidth: "2", strokeLinecap: "round", strokeLinejoin: "round" }),
    /* @__PURE__ */ se.jsx("path", { d: "M4 7H20", stroke: "#ffffff", strokeWidth: "2", strokeLinecap: "round", strokeLinejoin: "round" }),
    /* @__PURE__ */ se.jsx("path", { d: "M6 10V18C6 19.6569 7.34315 21 9 21H15C16.6569 21 18 19.6569 18 18V10", stroke: "#ffffff", strokeWidth: "2", strokeLinecap: "round", strokeLinejoin: "round" }),
    /* @__PURE__ */ se.jsx("path", { d: "M9 5C9 3.89543 9.89543 3 11 3H13C14.1046 3 15 3.89543 15 5V7H9V5Z", stroke: "#ffffff", strokeWidth: "2", strokeLinecap: "round", strokeLinejoin: "round" })
  ] }) }), n[1] = t) : t = n[1], t;
}, Nm = () => {
  const n = Et.c(2);
  let e;
  n[0] === Symbol.for("react.memo_cache_sentinel") ? (e = {
    height: "1rem",
    width: "1rem",
    scale: 0.8
  }, n[0] = e) : e = n[0];
  let t;
  return n[1] === Symbol.for("react.memo_cache_sentinel") ? (t = /* @__PURE__ */ se.jsx("svg", { viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg", style: e, children: /* @__PURE__ */ se.jsx("g", { strokeWidth: "0", strokeLinecap: "round", strokeLinejoin: "round", children: /* @__PURE__ */ se.jsx("path", { id: "Vector", d: "M6 12L10.2426 16.2426L18.727 7.75732", stroke: "#ffffff", strokeWidth: "2", strokeLinecap: "round", strokeLinejoin: "round" }) }) }), n[1] = t) : t = n[1], t;
}, Mm = () => {
  const n = Et.c(2);
  let e;
  n[0] === Symbol.for("react.memo_cache_sentinel") ? (e = {
    height: "1rem",
    width: "1rem",
    scale: 0.8
  }, n[0] = e) : e = n[0];
  let t;
  return n[1] === Symbol.for("react.memo_cache_sentinel") ? (t = /* @__PURE__ */ se.jsx("svg", { fill: "#ffffff", viewBox: "0 0 32 32", version: "1.1", xmlns: "http://www.w3.org/2000/svg", style: e, children: /* @__PURE__ */ se.jsx("g", { strokeWidth: "0", strokeLinecap: "round", strokeLinejoin: "round", children: /* @__PURE__ */ se.jsx("path", { d: `M19.587 16.001l6.096 6.096c0.396 0.396 0.396 1.039 0 1.435l-2.151 2.151c-0.396 
        0.396-1.038 0.396-1.435 0l-6.097-6.096-6.097 6.096c-0.396 0.396-1.038 
        0.396-1.434 0l-2.152-2.151c-0.396-0.396-0.396-1.038 
        0-1.435l6.097-6.096-6.097-6.097c-0.396-0.396-0.396-1.039 0-1.435l2.153-2.151c0.396-0.396 
        1.038-0.396 1.434 0l6.096 6.097 6.097-6.097c0.396-0.396 1.038-0.396 1.435 0l2.151 2.152c0.396 
        0.396 0.396 1.038 0 1.435l-6.096 6.096z` }) }) }), n[1] = t) : t = n[1], t;
}, xT = (n) => {
  const e = Et.c(5), {
    flip: t
  } = n, r = (t === void 0 ? !1 : t) ? "rotate(180deg)" : "rotate(0)";
  let a;
  e[0] !== r ? (a = {
    fill: "white",
    height: "1.25rem",
    width: "1.25rem",
    transform: r
  }, e[0] = r, e[1] = a) : a = e[1];
  let s;
  e[2] === Symbol.for("react.memo_cache_sentinel") ? (s = /* @__PURE__ */ se.jsxs("g", { strokeWidth: "0", strokeLinecap: "round", strokeLinejoin: "round", children: [
    /* @__PURE__ */ se.jsx("path", { d: "M4 20L15.3333 12L4 4V20Z", fill: "#ffffff" }),
    /* @__PURE__ */ se.jsx("path", { d: "M20 4H17.3333V20H20V4Z", fill: "#ffffff" })
  ] }), e[2] = s) : s = e[2];
  let o;
  return e[3] !== a ? (o = /* @__PURE__ */ se.jsx("svg", { viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg", style: a, children: s }), e[3] = a, e[4] = o) : o = e[4], o;
}, t7 = () => {
  const n = Et.c(2);
  let e;
  n[0] === Symbol.for("react.memo_cache_sentinel") ? (e = {
    height: "0.75rem",
    width: "0.75rem"
  }, n[0] = e) : e = n[0];
  let t;
  return n[1] === Symbol.for("react.memo_cache_sentinel") ? (t = /* @__PURE__ */ se.jsx("svg", { viewBox: "0 0 24 24", xmlns: "http://www.w3.org/2000/svg", style: e, className: "structure-item-locked", children: /* @__PURE__ */ se.jsx("g", { strokeWidth: "0", strokeLinecap: "round", strokeLinejoin: "round", children: /* @__PURE__ */ se.jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: `M5.25 10.0546V8C5.25 4.27208 8.27208 
          1.25 12 1.25C15.7279 1.25 18.75 4.27208 18.75 8V10.0546C19.8648 10.1379 20.5907 
          10.348 21.1213 10.8787C22 11.7574 22 13.1716 22 16C22 18.8284 22 20.2426 21.1213 
          21.1213C20.2426 22 18.8284 22 16 22H8C5.17157 22 3.75736 22 2.87868 21.1213C2 
          20.2426 2 18.8284 2 16C2 13.1716 2 11.7574 2.87868 10.8787C3.40931 10.348 4.13525 
          10.1379 5.25 10.0546ZM6.75 8C6.75 5.10051 9.10051 2.75 12 2.75C14.8995 2.75 17.25 
          5.10051 17.25 8V10.0036C16.867 10 16.4515 10 16 10H8C7.54849 10 7.13301 10 6.75 
          10.0036V8Z`, fill: "#000000" }) }) }), n[1] = t) : t = n[1], t;
}, _T = (n) => {
  const e = Et.c(7), {
    flip: t
  } = n, r = (t === void 0 ? !1 : t) ? "rotate(180deg)" : "rotate(0)";
  let a;
  e[0] !== r ? (a = {
    height: "1rem",
    width: "1rem",
    scale: 0.8,
    transform: r
  }, e[0] = r, e[1] = a) : a = e[1];
  let s, o;
  e[2] === Symbol.for("react.memo_cache_sentinel") ? (s = /* @__PURE__ */ se.jsx("g", { id: "SVGRepo_bgCarrier", strokeWidth: "0" }), o = /* @__PURE__ */ se.jsx("g", { id: "SVGRepo_tracerCarrier", strokeLinecap: "round", strokeLinejoin: "round" }), e[2] = s, e[3] = o) : (s = e[2], o = e[3]);
  let u;
  e[4] === Symbol.for("react.memo_cache_sentinel") ? (u = /* @__PURE__ */ se.jsx("g", { id: "SVGRepo_iconCarrier", children: /* @__PURE__ */ se.jsx("path", { d: "M256 120.768L306.432 64 768 512l-461.568 448L256 903.232 659.072 512z", fill: "#ffffff" }) }), e[4] = u) : u = e[4];
  let c;
  return e[5] !== a ? (c = /* @__PURE__ */ se.jsxs("svg", { viewBox: "0 0 1024 1024", fill: "#ffffff", xmlns: "http://www.w3.org/2000/svg", style: a, children: [
    s,
    o,
    u
  ] }), e[5] = a, e[6] = c) : c = e[6], c;
}, n7 = () => {
  const n = Et.c(4);
  let e, t, i;
  n[0] === Symbol.for("react.memo_cache_sentinel") ? (e = {
    fill: "none",
    height: "1.25rem",
    width: "1.25rem"
  }, t = /* @__PURE__ */ se.jsx("g", { id: "SVGRepo_bgCarrier", strokeWidth: "0" }), i = /* @__PURE__ */ se.jsx("g", { id: "SVGRepo_tracerCarrier", strokeLinecap: "round", strokeLinejoin: "round" }), n[0] = e, n[1] = t, n[2] = i) : (e = n[0], t = n[1], i = n[2]);
  let r;
  return n[3] === Symbol.for("react.memo_cache_sentinel") ? (r = /* @__PURE__ */ se.jsxs("svg", { viewBox: "0 0 24 24", fill: "#fffff", xmlns: "http://www.w3.org/2000/svg", style: e, children: [
    t,
    i,
    /* @__PURE__ */ se.jsxs("g", { id: "SVGRepo_iconCarrier", children: [
      /* @__PURE__ */ se.jsx("rect", { width: "24", height: "24", fill: "none" }),
      /* @__PURE__ */ se.jsx("path", { d: "M5 12V18C5 18.5523 5.44772 19 6 19H18C18.5523 19 19 18.5523 19 18V12", stroke: "#ffffff", strokeLinecap: "round", strokeLinejoin: "round" }),
      /* @__PURE__ */ se.jsx("path", { d: "M12 3L12 15M12 15L16 11M12 15L8 11", stroke: "#ffffff", strokeLinecap: "round", strokeLinejoin: "round" })
    ] })
  ] }), n[3] = r) : r = n[3], r;
}, i7 = () => {
  const n = Et.c(3), e = pt(Cn), {
    isEditing: t,
    hasAnnotationService: i
  } = e.playlist, r = t;
  let a;
  return n[0] !== i || n[1] !== r ? (a = {
    isDisabled: r,
    hasAnnotationService: i
  }, n[0] = i, n[1] = r, n[2] = a) : a = n[2], a;
}, xo = () => {
  const n = Et.c(16), e = pt(Cn), t = pt($r), {
    player: i
  } = t, {
    allCanvases: r,
    canvasIndex: a,
    canvasIsEmpty: s
  } = e, [o, u] = $e(-1);
  let c;
  n[0] === Symbol.for("react.memo_cache_sentinel") ? (c = Ac(u, 50), n[0] = c) : c = n[0];
  const l = c, h = He(null), f = r.length > 0 ? r.length - 1 : 0, d = r?.length - 1 > 0;
  let y;
  n[1] !== i ? (y = () => i ? i.currentTime() : 0, n[1] = i, n[2] = y) : y = n[2];
  const m = y;
  let b;
  n[3] !== e || n[4] !== t ? (b = () => {
    e && t && (h.current = t.player), h.current && h.current.on("timeupdate", () => {
      l(h.current.currentTime());
    });
  }, n[3] = e, n[4] = t, n[5] = b) : b = n[5];
  let p;
  n[6] !== e ? (p = [e], n[6] = e, n[7] = p) : p = n[7], et(b, p);
  let g;
  return n[8] !== a || n[9] !== s || n[10] !== o || n[11] !== m || n[12] !== d || n[13] !== f || n[14] !== i ? (g = {
    canvasIndex: a,
    canvasIsEmpty: s,
    currentTime: o,
    isMultiCanvased: d,
    lastCanvasIndex: f,
    player: i,
    getCurrentTime: m
  }, n[8] = a, n[9] = s, n[10] = o, n[11] = m, n[12] = d, n[13] = f, n[14] = i, n[15] = g) : g = n[15], g;
}, z3 = ({
  enableFileDownload: n = !1,
  lastCanvasIndex: e,
  withCredentials: t = !1
}) => {
  const i = pt(Hr), r = pt(La), a = pt(Cn), {
    allCanvases: s,
    canvasIndex: o,
    customStart: u,
    manifest: c,
    playlist: l,
    renderings: h,
    srcIndex: f
  } = a, {
    isPlaylist: d
  } = l, [y, m] = $e(), [b, p] = $e({
    error: "",
    sources: [],
    tracks: [],
    poster: null,
    targets: []
  }), [g, v] = $e(), [_, x] = $e(!0), [T, E] = $e(!1), U = Je(() => n && h != {} ? h?.manifest?.concat(h?.canvas[o]?.files) : [], [h, o]);
  et(() => {
    if (c) {
      if (o == null || o < 0)
        throw new Error("Invalid canvas index. Please check your Manifest.");
      D(o, d);
    }
    return () => {
      E(!1), r({
        player: null,
        type: "updatePlayer"
      });
    };
  }, [c, o]);
  const D = (C, k) => {
    const {
      isMultiSource: I,
      sources: $,
      tracks: W,
      canvasTargets: B,
      mediaType: z,
      error: q,
      poster: Y
    } = c6({
      manifest: c,
      canvasIndex: C,
      startTime: C === u.startIndex && _ ? u.startTime : 0,
      srcIndex: f,
      isPlaylist: d
    });
    t && $.map(function(K) {
      return K.withCredentials = !0;
    }), m(z === "video"), i({
      canvasTargets: B,
      type: "canvasTargets"
    }), i({
      isMultiSource: I,
      type: "hasMultipleItems"
    }), k && (B?.length > 0 ? r({
      currentTime: B[0].altStart,
      type: "setCurrentTime"
    }) : r({
      currentTime: 0,
      type: "setCurrentTime"
    })), p({
      ...b,
      error: q,
      sources: $,
      tracks: W,
      poster: Y,
      targets: B
    });
    const H = s.find((K) => K.canvasIndex === C);
    if (H && !H.isEmpty) {
      let ie = [c.label ? Object.values(c.label)[0][0] : "", H.label].filter(Boolean).join(" - ");
      i({
        canvasDuration: H.duration,
        type: "canvasDuration"
      }), i({
        canvasLink: {
          label: ie,
          id: H.canvasId
        },
        type: "canvasLink"
      }), i({
        type: "setCanvasIsEmpty",
        isEmpty: !1
      });
    } else
      r({
        type: "updatePlayer"
      }), i({
        type: "setCanvasIsEmpty",
        isEmpty: !0
      }), p({
        ...b,
        error: Y
      });
    v(I || !1), E(!q), x(!1);
  };
  return {
    isMultiSourced: g,
    isPlaylist: d,
    isVideo: y,
    nextItemClicked: (C, k) => {
      r({
        currentTime: k,
        type: "setCurrentTime"
      }), i({
        srcIndex: C,
        type: "setSrcIndex"
      });
    },
    playerConfig: b,
    ready: T,
    renderingFiles: U,
    srcIndex: f,
    switchPlayer: (C, k) => {
      C != null && C > -1 && C <= e && (i({
        canvasIndex: C,
        type: "switchCanvas"
      }), D(C, k));
    }
  };
}, r7 = ({
  options: n,
  playerInitSetup: e,
  startQuality: t,
  tracks: i,
  updatePlayer: r,
  videoJSRef: a,
  videoJSLangMap: s
}) => {
  const o = pt(Cn), u = pt($r), c = pt(La), {
    canvasDuration: l,
    canvasIndex: h,
    canvasIsEmpty: f,
    currentNavItem: d,
    playlist: y
  } = o, {
    currentTime: m,
    isClicked: b,
    player: p,
    searchMarkers: g
  } = u, [v, _] = $e(""), [x, T] = $e(null), [E, U] = $e(!1), D = He(E), L = (z) => {
    U(z), D.current = z;
  }, j = He(null), C = (z) => {
    z ? j.current = z : j.current.dispose();
  };
  et(() => () => {
    j.current && (C(null), document.removeEventListener("keydown", nm), L(!1));
  }, []), et(() => {
    if (W(n.sources), ke.addLanguage(n.language, JSON.parse(s)), !j.current && n.sources?.length > 0) {
      B(), ke.log.level("off");
      const z = ke(a.current, n, () => {
        e(z);
      });
      C(z), c({
        player: z,
        type: "updatePlayer"
      }), I(z);
    } else if (j.current && n.sources?.length > 0) {
      const z = j.current;
      v && z.markers?.removeAll(), _(null), f ? L(!0) : (z.addClass("vjs-disabled"), L(!1), r(z), c({
        player: z,
        type: "updatePlayer"
      }));
    }
  }, [n.sources, a, s]), et(() => {
    if (j.current) {
      const z = j.current;
      f ? (z.audioOnlyMode(!1), z.canvasIsEmpty = !0, z.aspectRatio("16:9"), z.controlBar.addClass("vjs-hidden"), z.removeClass("vjs-disabled"), z.pause(), _(d?.id)) : z.controlBar.removeClass("vjs-hidden");
    }
  }, [h, f, d]), et(() => {
    j.current && j.current.currentTime(m, c({
      type: "resetClick"
    }));
  }, [b, p]);
  const k = Je(() => {
    if (y?.markers?.length > 0) {
      const z = y.markers.filter((q) => q.canvasIndex === h);
      if (z?.length > 0)
        return z[0].canvasMarkers.map((q) => ({
          time: parseFloat(q.time),
          text: q.value,
          class: "ramp--track-marker--playlist"
        }));
    }
  }, [y.markers]);
  et(() => {
    if (j.current && j.current.markers && E) {
      typeof j.current.markers == "function" && j.current.markers({
        markerTip: {
          display: !1,
          // true,
          text: (q) => q.text
        },
        markerStyle: {},
        markers: []
      });
      let z = [];
      k?.length > 0 && (z = k.map((q) => ({
        time: parseFloat(q.time),
        text: q.value,
        class: "ramp--track-marker--playlist"
      }))), j.current.markers?.removeAll(), j.current.markers.add([...x ? [x] : [], ...g, ...z]);
    }
  }, [x, g, l, h, j.current, E, k]);
  const I = (z) => {
    z.controlBar.getChild("PlayToggle").on("pointerdown", () => {
      $();
    }), z.on("pointerdown", (q) => {
      q.target.nodeName.toLowerCase() == "video" && $();
    }), document.addEventListener("keydown", (q) => {
      switch (nm(q, j.current, f)) {
        case Qn.pause:
          $();
          break;
      }
    }), window.addEventListener("resize", () => {
      z?.player_ && z.trigger("resize");
    }), window.visualViewport && window.visualViewport.addEventListener("resize", () => {
      z?.player_ && z.trigger("resize");
    });
  }, $ = () => {
    c({
      isPlaying: !1,
      type: "setPlayingStatus"
    });
  }, W = (z) => {
    const q = z?.find((H) => H.selected == !0), Y = z?.find((H) => H.label == t);
    Y && (q.selected = !1, Y.selected = !0);
  }, B = () => {
    i?.length > 0 && a.current && i.map((z) => {
      let q = document.createElement("track");
      q.setAttribute("key", z.key), q.setAttribute("src", z.src), q.setAttribute("kind", z.kind), q.setAttribute("label", z.label), q.setAttribute("srclang", z.srclang), a.current.appendChild(q);
    });
  };
  return {
    activeId: v,
    fragmentMarker: x,
    isReadyRef: D,
    playerRef: j,
    setActiveId: _,
    setFragmentMarker: T,
    setIsReady: L
  };
}, a7 = ({
  lastCanvasIndex: n
}) => {
  const e = pt(Hr), t = pt(Cn), {
    autoAdvance: i,
    canvasIndex: r,
    canvasIsEmpty: a
  } = t, [s, o] = $e(Us / 1e3);
  let u = He(null);
  et(() => {
    l(), a && !u.current && i && (o(Us / 1e3), c());
  }, [r, i, a]);
  const c = $t(() => {
    const h = (/* @__PURE__ */ new Date()).getTime();
    u.current = setInterval(() => {
      let f = (/* @__PURE__ */ new Date()).getTime(), d = (Us - (f - h)) / 1e3;
      d > 0 ? o(Math.ceil(d)) : (r < n && i && e({
        canvasIndex: r + 1,
        type: "switchCanvas"
      }), l());
    }, 1e3);
  }), l = $t(() => {
    clearInterval(u.current), u.current = null;
  });
  return {
    messageTime: s,
    clearDisplayTimeInterval: l,
    createDisplayTimeInterval: c
  };
}, s7 = ({
  itemIndex: n,
  isRoot: e,
  itemId: t,
  liRef: i,
  sectionRef: r,
  structureContainerRef: a,
  isCanvas: s,
  isEmpty: o,
  canvasDuration: u,
  setSectionIsCollapsed: c,
  times: l
}) => {
  const h = pt(La), f = pt(Cn), {
    canvasIndex: d,
    currentNavItem: y,
    playlist: m
  } = f, {
    isPlaylist: b
  } = m, p = pt($r), {
    isPlaying: g
  } = p, v = Je(() => s && !b ? r : i, [r, i]), _ = Je(() => !!(t != null && y?.id === t && (b || !s) && y?.canvasIndex === d + 1), [y, d]), x = Je(() => d + 1 === n && (!e || g) ? (c(!1), !0) : !1, [d, g]), T = Je(() => l != null ? n6(l.start) : "", [t, u]), E = $t((U) => {
    if (U.preventDefault(), U.stopPropagation(), Jp(l, {
      end: u
    })) {
      h({
        clickedUrl: t,
        type: "navClick"
      }), v.current.isClicked = !0, r.current && (r.current.isClicked = !0);
      const L = a.current.querySelector('[aria-live="assertive"]');
      L && (s ? L.textContent = `Player seeked to ${T} in Canvas ${n}` : o || (L.textContent = `Player seeked to ${T}`));
    }
  });
  return {
    canvasIndex: d,
    currentNavItem: y,
    handleClick: E,
    isActiveLi: _,
    isActiveSection: x,
    isPlaylist: b,
    screenReaderTime: T
  };
}, $3 = () => {
  const n = pt(Hr), e = pt(Cn), {
    canvasIndex: t
  } = e, {
    isCollapsed: i,
    structItems: r
  } = e.structures, a = pt($r), {
    isPlaying: s
  } = a, o = Je(() => r?.length > 0 && r.map((h) => (h.items?.length > 0 && h.collapseStatus == null && (h.collapseStatus = i ? "isCollapsed" : "isExpanded"), h)), []);
  et(() => {
    s && c(t, !1);
  }, [s, t]);
  const u = $t(() => {
    const h = !i;
    n({
      type: "setIsCollapsed",
      isCollapsed: h
    });
    for (let f = o.length - 1; f > -1; f--)
      l(f, h);
  }), c = (h, f) => {
    l(h, f);
    const d = i ? "isCollapsed" : "isExpanded", y = o.map((m) => m.collapseStatus).filter((m) => m != null);
    y?.length > 0 && y.every((b) => b === y[0]) && y[0] != d && u();
  }, l = (h, f) => {
    o[h]?.items?.length > 0 && (o[h].collapseStatus = f ? "isCollapsed" : "isExpanded");
  };
  return {
    collapseExpandAll: u,
    isCollapsed: i,
    updateSectionStatus: c
  };
}, o7 = ({
  manifestUrl: n,
  playerID: e,
  setCurrentTime: t,
  showMetadata: i,
  showNotes: r,
  transcripts: a
}) => {
  const s = pt(Cn), o = pt($r), u = "No valid Transcript(s) found, please check again.", c = "Invalid URL for transcript, please check again.", l = "Invalid WebVTT file, please check again.", h = "Invalid timestamp format in cue(s), please check again.", f = "Transcript format is not supported, please check again.", d = new AbortController(), y = He(), m = (ge) => {
    d.abort(), y.current = ge;
  }, b = He(null), p = He(null), [g, v] = $e(!0), [_, x] = $e(!0), [T, E] = $e([]), [U, D] = $e([]), [L, j] = $e({
    title: null,
    filename: null,
    id: null,
    tUrl: null,
    tType: null,
    tFileExt: null,
    isMachineGen: !1,
    tError: null
  }), [C, k] = $e([]), [I, $] = $e([]), [W, B] = $e({
    url: "",
    isTimed: !1
  }), z = Je(() => s === void 0 ? [] : s.annotations, [s]), q = He(null);
  et(() => {
    s && o ? (y.current = s.canvasIndex, b.current = o.player) : p.current = setInterval(() => {
      const ge = document.getElementById(e);
      if (ge ? ge.player ? b.current = ge.player : b.current = ge : (console.warn(`Cannot find player, ${e} on page. Transcript synchronization is disabled`), x(!1)), b.current) {
        let pe = parseInt(b.current.canvasIndex);
        Number.isNaN(pe) && (pe = 0), pe !== y.current && (E([]), m(pe), t(b.current.currentTime()));
      }
    }, 500), b.current && b.current.on("timeupdate", () => {
      t(b.current.currentTime());
    });
  }, [s]), et(() => {
    if (a?.length === 0 && !n)
      x(!1), E([]), j({
        tType: ct.noTranscript,
        id: "",
        tError: u
      });
    else if (z?.length > 0 && a?.length === 0) {
      q?.current?.abort();
      const ge = z.filter((pe) => pe.canvasIndex == y.current);
      if (ge?.length > 0 && ge[0].annotationSets?.length > 0) {
        const pe = ge[0].annotationSets.filter((De) => De.motivation?.includes(tr) || De.isSupplementing), ce = pe?.length > 0 ? pe.map((De, Re) => {
          const {
            filename: Me,
            format: F,
            items: P,
            label: ne,
            url: S = n
          } = De;
          let {
            isMachineGen: he,
            labelText: ae
          } = Vs(ne);
          return {
            id: `${ae}-${y.current}-${Re}`,
            filename: Me,
            format: F,
            isMachineGen: he,
            title: ae,
            url: S,
            items: P
          };
        }) : [], oe = [...U, {
          canvasId: y.current,
          items: ce
        }];
        D(oe ?? []), H(oe ?? []);
      }
    } else
      q.current = new AbortController(), Y(a);
  }, [z]), et(() => () => {
    clearInterval(p.current), q.current?.abort(), d?.abort();
  }, []);
  const Y = async (ge) => {
    let pe = ge?.length > 0 ? await K5(ge) : await KE(n, "", q.current.signal);
    q.current.signal.aborted || (D(pe ?? []), H(pe ?? []));
  }, H = (ge) => {
    if (d.signal.aborted) return;
    const pe = (oe) => oe.filter((De) => De.canvasId == y.current), ce = (oe) => pe(oe)[0].items;
    if (!ge?.length > 0 || !pe(ge)?.length > 0 || !ce(ge)?.length > 0)
      v(!0), E([]), K(void 0);
    else {
      v(!1);
      const oe = pe(ge)[0];
      k(oe.items), K(oe.items[0]);
    }
  };
  et(() => {
    if (U?.length > 0 && y.current != null) {
      let ge = U.filter((pe) => pe.canvasId == y.current)[0];
      k(ge?.items), K(ge?.items[0]);
    }
  }, [y.current]);
  const K = async (ge) => {
    if (!ge || ge == null) {
      v(!0), x(!1), j({
        tType: ct.noTranscript,
        id: "",
        tError: u
      });
      return;
    }
    v(!1);
    const {
      id: pe,
      items: ce,
      title: oe,
      filename: De,
      url: Re,
      isMachineGen: Me,
      format: F
    } = ge, P = I.filter((ne) => ne.id == pe && ne.canvasId == y.current);
    if (P?.length > 0) {
      const {
        tData: ne,
        tFileExt: S,
        tType: he,
        tError: ae
      } = P[0];
      E(ne), j({
        title: oe,
        filename: De,
        id: pe,
        isMachineGen: Me,
        tType: he,
        tUrl: Re,
        tFileExt: S,
        tError: ae
      }), B({
        url: Re,
        isTimed: he == ct.timedText
      });
    } else
      await Promise.resolve(jg({
        url: Re,
        format: F,
        canvasIndex: y.current,
        inlineAnnotations: ce
      })).then(function(ne) {
        if (ne != null) {
          const {
            tData: S,
            tUrl: he,
            tType: ae,
            tFileExt: te
          } = ne;
          let ee = "";
          switch (ae) {
            case ct.invalid:
              ee = c;
              break;
            case ct.noTranscript:
              ee = u;
              break;
            case ct.noSupport:
              ee = f;
              break;
            case ct.invalidVTT:
              ee = l;
              break;
            case ct.invalidTimestamp:
              ee = h;
              break;
          }
          E(S), j({
            title: oe,
            filename: De,
            id: pe,
            isMachineGen: Me,
            tType: ae,
            tUrl: he,
            tFileExt: te,
            tError: ee
          }), B({
            url: he,
            isTimed: ae == ct.timedText
          }), ge = {
            ...ge,
            tType: ae,
            tData: S,
            tFileExt: te,
            canvasId: y.current,
            tError: ee
          }, $([...I, ge]);
        }
      });
    x(!1);
  }, ie = $t((ge) => {
    const pe = C.filter((ce) => ce.id === ge);
    K(pe[0]);
  }, [C]);
  return {
    canvasIndexRef: y,
    canvasTranscripts: C,
    isEmpty: g,
    isLoading: _,
    NO_SUPPORT_MSG: f,
    playerRef: b,
    selectedTranscript: W,
    selectTranscript: ie,
    transcript: T,
    transcriptInfo: L
  };
}, u7 = ({
  annotationId: n,
  canvasId: e,
  startTime: t,
  endTime: i,
  currentTime: r,
  displayedAnnotations: a = []
}) => {
  const s = pt(Cn), o = pt(Hr), {
    allCanvases: u,
    canvasIndex: c,
    clickedAnnotation: l
  } = s, h = Je(() => u[c].canvasId == e, [e, c]), f = $t((y) => {
    if (!h) {
      const m = u.filter((b) => b.canvasId === e);
      if (m?.length > 0) {
        const b = m[0];
        o({
          canvasIndex: b.canvasIndex,
          type: "switchCanvas"
        });
      }
    }
    o({
      clickedAnnotation: y,
      type: "setClickedAnnotation"
    });
  }, [h]), d = Je(() => {
    const y = a.findIndex((g) => g.time?.start === t), m = y < a?.length && y > -1 ? a[y + 1] : void 0, b = m?.time?.start, p = a.filter((g) => g.time?.start <= r);
    if (l != null) {
      if (l.id === n)
        return !0;
      (l.time.end === void 0 && l.time.start != r || l.time.start > r || l.time.end < r) && setTimeout(() => {
        o({
          clickedAnnotation: null,
          type: "setClickedAnnotation"
        });
      }, 0);
    } else if (p?.length > 0) {
      const g = p[p.length - 1];
      return g.time.start === t && i === void 0 || g.time?.start === t && r <= i || b != null && r < b && t <= r && r <= i;
    }
  }, [r, a]);
  return {
    checkCanvas: f,
    inPlayerRange: d
  };
}, c7 = () => {
  const n = Et.c(16), e = pt(Cn), t = pt(Hr), {
    annotations: i,
    canvasIndex: r,
    manifest: a,
    playlist: s
  } = e, {
    isPlaylist: o
  } = s;
  let u;
  n[0] !== i || n[1] !== r || n[2] !== a || n[3] !== t ? (u = () => {
    if ((i?.length > 0 || i?.filter((f) => f.canvasIndex === r).length === 0) && a !== null) {
      const f = qg(a, r);
      t({
        annotations: f,
        type: "setAnnotations"
      });
    }
  }, n[0] = i, n[1] = r, n[2] = a, n[3] = t, n[4] = u) : u = n[4];
  let c;
  n[5] !== a ? (c = [a], n[5] = a, n[6] = c) : c = n[6], et(u, c);
  let l;
  n[7] !== i || n[8] !== r || n[9] !== o || n[10] !== t ? (l = () => {
    if (o && i?.length > 0) {
      const f = i.filter((y) => y.canvasIndex === r);
      let d = [];
      if (f?.length > 0) {
        const {
          annotationSets: y
        } = f[0];
        d = y.map(l7).filter(d7).flat();
      }
      t({
        markers: {
          canvasIndex: r,
          canvasMarkers: d
        },
        type: "setPlaylistMarkers"
      });
    }
  }, n[7] = i, n[8] = r, n[9] = o, n[10] = t, n[11] = l) : l = n[11];
  let h;
  n[12] !== i || n[13] !== r || n[14] !== o ? (h = [o, r, i], n[12] = i, n[13] = r, n[14] = o, n[15] = h) : h = n[15], et(l, h);
}, G3 = ({
  autoScrollEnabled: n,
  enableShowMore: e,
  inPlayerRange: t,
  MAX_LINES: i,
  refs: r,
  setIsShowMoreRef: a,
  setIsActive: s,
  tags: o,
  texts: u
}) => {
  const {
    annotationRef: c,
    annotationTagsRef: l,
    annotationTextsRef: h,
    annotationTimesRef: f,
    containerRef: d,
    moreTagsButtonRef: y
  } = r, [m, b] = $e(0), [p, g] = $e(""), [v, _] = $e(!1), [x, T] = $e(!1), [E, U] = $e(!1);
  et(() => {
    s(!!t), n && t && Pn(c.current, d, !0);
  }, [t]), et(() => {
    const $ = h.current;
    let W, B;
    const z = () => {
      if ($ && u?.length > 0) {
        const q = $.clientWidth, Y = parseFloat(getComputedStyle($).fontSize);
        if (!isNaN(Y)) {
          W = document.createElement("canvas");
          const H = W.getContext("2d");
          H.font = getComputedStyle($).font;
          const ie = H.measureText(u).width / u.length, ge = q / ie, pe = ge * (i - 1) + Math.floor(ge / 2);
          let ce = u;
          if (u.includes("<br>")) {
            const Re = u.split("<br>");
            let Me = [];
            for (let F = 0; F < Re.length; F++) {
              const P = Re[F];
              if (P.length < ge) {
                const ne = ge > 4 ? ge - 4 : 0;
                Me.push(P.padEnd(ne));
              } else
                Me.push(P);
            }
            ce = Me.join("<br>");
          }
          const {
            truncated: oe,
            isTruncated: De
          } = o6(ce, pe);
          De ? (b(oe), g(oe), a(!0), _(!0)) : (b(ce), _(!1));
        }
      }
    };
    return e ? (B = new ResizeObserver((q) => {
      requestAnimationFrame(() => {
        for (let Y of q)
          z();
      });
    }), d.current && B.observe(d.current), z()) : b(u), () => {
      W?.remove(), B?.disconnect();
    };
  }, [u]), et(() => {
    let $;
    if (o) {
      $ = new ResizeObserver((B) => {
        requestAnimationFrame(() => {
          for (let z of B)
            W(!0);
        });
      }), d.current && $.observe(d.current);
      const W = (B) => {
        const z = D(B);
        T(z), U(z);
      };
      W(!0);
    }
    return () => {
      $?.disconnect();
    };
  }, [o]);
  const D = ($) => {
    let W = !1;
    const B = l.current, z = f.current;
    if (B && z && o?.length > 0) {
      B.style.gridColumn = "";
      const q = z?.clientWidth || 0, Y = B.parentElement.clientWidth - q;
      if (B.children?.length > 0) {
        const H = y.current?.clientWidth || 20;
        let K = Math.abs(Y - H), ie = !1;
        for (let ge = 0; ge < B.children.length; ge++) {
          const pe = B.children[ge];
          pe.classList.contains("hidden") && pe.classList.remove("hidden"), pe.clientWidth > Y && (ie = !0), $ && pe != y.current && (K = K - pe.clientWidth, K < H && (W = !0, pe.classList.add("hidden")));
        }
        ie && (B.style.gridColumn = "1 / -1");
      }
    }
    return W;
  }, L = ($, W) => {
    if ($.keyCode == 13 || $.keyCode == 32)
      W($);
    else
      return;
  }, j = ($) => {
    if ($.target.tagName == "A") {
      const W = /https?:\/\/[^\s/$.?#].[^\s]*/gi;
      if (!$.target.getAttribute("href")?.match(W))
        $.preventDefault();
      else {
        window.open($.target.href, "_self");
        return;
      }
    }
  }, C = ($, W) => {
    $ ? b(u) : (b(p), Pn(c.current, d, !0)), W(!$);
  };
  return {
    handleKeyDown: L,
    handleLinkClicks: j,
    handleLinkKeyDown: ($) => {
      ($.key == "Enter" || $.key == " ") && ($.preventDefault(), j($));
    },
    handleShowMoreLessClick: C,
    handleShowMoreLessKeydown: ($, W, B) => {
      ($.key == "Enter" || $.key == " ") && ($.preventDefault(), C(W, B));
    },
    hasLongerTags: x,
    hasLongerText: v,
    setShowMoreTags: U,
    showMoreTags: E,
    setTextToShow: b,
    textToShow: m,
    toggleTagsView: D,
    truncatedText: p
  };
};
function l7(n) {
  return n.markers;
}
function d7(n) {
  return n != null;
}
var f7 = H3();
const X3 = /* @__PURE__ */ Qt(f7), h7 = ke.getComponent("SeekBar");
class p7 extends h7 {
  constructor(e, t) {
    super(e, t), this.addClass("vjs-custom-progress-bar"), this.setAttribute("data-testid", "videojs-custom-seekbar"), this.setAttribute("tabindex", 0), this.player = e, this.options = t, this.selectSource = this.options.nextItemClicked, this.playerEventListener, this.initTimeRef = Zn(), this.progressRef = Zn(), this.canvasTargetsRef = Zn(), this.srcIndexRef = Zn(), this.isMultiSourceRef = Zn(), this.currentTimeRef = Zn(), this.pointerDragged = !1, this.totalDuration, this.playProgress = this.getChild("PlayProgressBar"), this.loadProgress = this.getChild("LoadProgressBar"), this.player.on("ready", () => {
      this.initializeEl(), this.updateComponent();
    }), this.player.on("loadstart", () => {
      this.updateComponent(), this.buildProgressBar();
    }), this.player.on("loadeddata", () => {
      this.setInitTime(this.player.currentTime());
    }), this.player.on("fullscreenchange", () => {
      if (!this.player.isFullscreen()) {
        const i = this.player.currentTime();
        let r = Math.min(100, Math.max(0, 100 * (i / this.totalDuration)));
        document.documentElement.style.setProperty("--range-progress", `calc(${r}%)`), this.setProgress(i);
      }
    }), this.player.on("dispose", () => {
      clearInterval(this.playerEventListener);
    });
  }
  setInitTime(e) {
    this.initTimeRef.current = e;
  }
  setSrcIndex(e) {
    this.srcIndexRef.current = e;
  }
  setProgress(e) {
    this.progressRef.current = e;
  }
  setCanvasTargets(e) {
    this.canvasTargetsRef.current = e, this.totalDuration = e.reduce((t, i) => t + i.duration, 0);
  }
  setIsMultiSource(e) {
    this.isMultiSourceRef.current = e;
  }
  setCurrentTime(e) {
    this.currentTimeRef.current = e;
  }
  // Update component's variables on Canvas changes
  updateComponent() {
    const {
      srcIndex: e,
      targets: t
    } = this.player;
    this.setSrcIndex(e), this.setCanvasTargets(t);
    const i = t[e];
    i.customStart > i.start ? this.initializeProgress(i.customStart) : this.initializeProgress(i.start), this.setIsMultiSource(t?.length > 1), this.playerEventListener || (this.playerEventListener = setInterval(() => {
      this.timeUpdateHandler();
    }, 100));
  }
  /**
   * Use Video.js' update function to update time in on both mobile
   * and desktop devices when changing Canvases.
   */
  update() {
    super.update(), ti && this.player.currentTime() === 0 && (this.removeClass("played-range"), document.documentElement.style.setProperty("--range-progress", "calc(0%)"));
    const e = this.player.structStart ?? 0;
    if (e != 0 && this.player.currentTime() === 0) {
      this.player.currentTime(e);
      let t = Math.min(100, Math.max(0, 100 * (e / this.totalDuration)));
      this.addClass("played-range"), document.documentElement.style.setProperty("--range-progress", `calc(${t}%)`), this.player.structStart = 0;
    }
  }
  /**
   * Set start values for progress bar
   * @param {Number} start canvas start time
   */
  initializeProgress = (e) => {
    this.setProgress(e), this.setInitTime(e), this.player.currentTime(e);
  };
  // Create progress bar using Video.js' SeekBar component
  initializeEl() {
    const e = ke.dom.createEl("div", {
      className: "block-stripes",
      role: "presentation",
      id: "left-block"
    }), t = ke.dom.createEl("div", {
      className: "block-stripes",
      role: "presentation",
      id: "right-block"
    });
    this.el().appendChild(e), this.el().appendChild(t), this.el().addEventListener("mouseenter", (i) => {
      this.handleMouseMove(i);
    }), this.el().addEventListener("pointerup", (i) => {
      this.pointerDragged && this.handleMouseUp(i);
    }), this.el().addEventListener("pointermove", (i) => {
      this.handleMouseMove(i), this.pointerDragged = !0;
    }), this.el().addEventListener("pointerdown", (i) => {
      this.handleMouseDown(i), this.pointerDragged = !1;
    });
  }
  handleMouseMove(e) {
    const {
      currentTime: t,
      offsetx: i
    } = this.convertToTime(e);
    t != null && this.setCurrentTime(t);
    const r = this.getChild("MouseTimeDisplay");
    if (r) {
      const s = r.getChild("TimeTooltip").el_;
      t && (s.innerHTML = wn(t));
      const o = s.clientWidth / 2;
      s.style.left = `${i - o}px`;
    }
  }
  handleMouseDown(e) {
    if (!ti && e.buttons === 2) return;
    const {
      currentTime: t,
      _: i
    } = this.convertToTime(e);
    if (Number.isNaN(t)) return;
    let r;
    if (this.isMultiSourceRef.current && (r = this.canvasTargetsRef.current.find((a) => {
      const s = a.altStart + a.duration;
      if (t >= a.altStart && t <= s)
        return a;
    })), r) {
      const a = r?.sIndex ?? 0;
      a != this.srcIndexRef.current ? (this.selectSource(r.sIndex, t - r.altStart), this.setSrcIndex(a)) : this.player.currentTime(t - r.altStart);
    } else
      this.player.currentTime(t);
    if (ti) {
      let a = Math.min(100, Math.max(0, 100 * (t / this.totalDuration)));
      this.player.currentTime(t), this.addClass("played-range"), document.documentElement.style.setProperty("--range-progress", `calc(${a}%)`);
    }
  }
  handleMouseUp(e) {
    this.handleMouseDown(e);
  }
  buildProgressBar() {
    this.removeClass("played-range");
    const {
      canvasTargetsRef: e,
      isMultiSourceRef: t,
      player: i,
      srcIndexRef: r,
      totalDuration: a
    } = this;
    if (e.current?.length > 0) {
      const {
        altStart: s,
        start: o,
        end: u,
        duration: c
      } = e.current[r.current], l = document.getElementById("left-block"), h = document.getElementById("right-block");
      if (t.current) {
        let f = Math.min(100, Math.max(0, 100 * (s / a)));
        this.playProgress.el_.style.left = `${f}%`, this.loadProgress.el_.style.left = `${f}%`, this.addClass("played-range"), document.documentElement.style.setProperty("--range-progress", `calc(${f}%)`);
      } else {
        const f = o * 100 / c, d = (c - u) * 100 / c;
        d > 0 ? i.isClipped = !0 : i.isClipped = !1, l && (l.style.width = `${f}%`), h && (h.style.width = d + "%", h.style.left = `${100 - d}%`);
      }
    }
  }
  /**
   * Convert mouse event's offset to timepoint value in the progressbar,
   * taking into account blocked ranges, and multi-source canvases.
   * @param {Event} e mouse event
   * @returns {currentTime: Number, offsetx: Number}
   */
  convertToTime(e) {
    const t = e.srcElement;
    if (t.classList.contains("block-stripes")) {
      const {
        altStart: o,
        end: u,
        duration: c
      } = this.canvasTargetsRef.current[0];
      return t.id === "right-block" ? {
        currentTime: u,
        offsetx: u / c * this.el().clientWidth
      } : {
        currentTime: o,
        offsetx: o / c * this.el().clientWidth
      };
    }
    let i = e.target.getBoundingClientRect().x, r = e.nativeEvent != null ? e.nativeEvent.offsetX != null ? e.nativeEvent.offsetX : e.nativeEvent.targetTouches[0]?.clientX - i : e.offsetX, a;
    const s = this.totalDuration ?? this.player.duration();
    if (t.classList.contains("ramp--track-marker--search"))
      return {
        currentTime: e.target.dataset.markerTime ?? 0,
        offsetx: e.target.offsetLeft
      };
    if (r && r != null) {
      if (this.isMultiSourceRef.current) {
        const o = parseFloat(this.playProgress.el_.style.left) / 100 * this.el().clientWidth, u = t.classList, c = u?.length > 0 ? u.contains("vjs-play-progress") || u.contains("vjs-load-progress") : !0;
        o > r && c && (r = r + o);
      }
      a = r / this.el().clientWidth * s;
    }
    if (e.target.hasAttribute("data-start")) {
      const {
        start: o,
        _: u
      } = e.target.dataset;
      a = a + parseFloat(o), r = a * this.el().clientWidth / this.totalDuration;
    }
    return {
      currentTime: a,
      offsetx: r
    };
  }
  // Update progress bar with timeupdate in the player
  timeUpdateHandler() {
    const {
      initTimeRef: e,
      player: t
    } = this;
    if (t.isDisposed() || t.ended() || t == null)
      return;
    let i;
    e.current > 0 && t.currentTime() == 0 ? (i = e.current, t.currentTime(e.current)) : i = t.currentTime(), Qi && !ei && t.paused() ? X3(() => {
      this.onTimeUpdate(i);
    }) : this.onTimeUpdate(i), this.setInitTime(0);
  }
  onTimeUpdate(e) {
    this.player.hasClass("vjs-ios-native-fs") && !this.player.audioOnlyMode_ || this.setProgress(e), this.handleTimeUpdate(e);
  }
  /**
   * Update CSS for the input range's track while the media
   * is playing
   * @param {Number} curTime current time of the player
   */
  handleTimeUpdate(e) {
    const {
      player: t,
      el_: i,
      canvasTargetsRef: r,
      srcIndexRef: a
    } = this;
    if (!i || !t || !r.current)
      return;
    const {
      start: s,
      end: o
    } = r.current[a.current ?? 0];
    if (ti) {
      let u = Math.min(100, Math.max(0, 100 * (e / this.totalDuration)));
      document.documentElement.style.setProperty("--range-progress", `calc(${u}%)`);
    }
    e < s && t.currentTime(s), e >= o && !t.paused() && !t.isDisposed() && (o < t.duration() && t.trigger("ended"), document.documentElement.style.setProperty("--range-progress", "calc(0%)"), this.removeClass("played-range"), t.one("play", () => {
      let u = t.currentTime();
      u < o ? t.currentTime(u) : t.currentTime(s);
    }));
  }
}
ke.registerComponent("CustomSeekBar", p7);
const m7 = ke.getComponent("ProgressControl");
class g7 extends m7 {
  constructor(e, t) {
    super(e, t), this.addClass("vjs-custom-progress-bar");
    const i = this.getChild("seekBar");
    i.el_.style.display = "none", i.removeClass("vjs-progress-holder"), this.addChild("CustomSeekBar", {
      nextItemClicked: t.nextItemClicked
    });
  }
  handleMouseSeek(e) {
    const t = this.getChild("customSeekBar");
    t && t.handleMouseMove(e);
  }
  /**
   * Override native component's handleMouseDown event to use custom
   * seekbar's handleMouseDown event handler
   * @param {Event} event 
   */
  handleMouseDown(e) {
    const t = this.el_.ownerDocument, i = this.getChild("customSeekBar");
    i && i.handleMouseDown(e), this.on(t, "mousemove", this.throttledHandleMouseSeek), this.on(t, "touchmove", this.throttledHandleMouseSeek), this.on(t, "mouseup", this.handleMouseUpHandler_), this.on(t, "touchend", this.handleMouseUpHandler_);
  }
}
ke.registerComponent("VideoJSProgress", g7);
const b7 = ke.getComponent("TimeDisplay");
class y7 extends b7 {
  constructor(e, t) {
    super(e, t), this.addClass("vjs-time-control vjs-current-time-display"), this.setAttribute("role", "presentation"), this.player = e, this.options = t, this.initTimeRef = Zn(), this.initTimeRef.current = t.currentTime, this.playerInterval, this.player.on("loadstart", () => {
      this.playerInterval = setInterval(() => {
        this.handleTimeUpdate();
      }, 100);
    }), this.player.on("seeked", () => {
      Qi && !ei && this.updateTextNode_(e.currentTime());
    }), this.player.on("fullscreenchange", () => {
      e.isFullscreen() || this.updateTextNode_(e.currentTime());
    }), this.player.on("dispose", () => {
      clearInterval(this.playerInterval);
    });
  }
  buildCSSClass() {
    return "current-time";
  }
  setInitTime(e) {
    this.initTimeRef.current = e;
  }
  handleTimeUpdate() {
    const {
      player: e,
      initTimeRef: t
    } = this, {
      targets: i,
      srcIndex: r
    } = e;
    if (!e || e.isDisposed() || !i)
      return;
    const a = e.hasClass("vjs-ios-native-fs");
    let s;
    t.current > 0 && e.currentTime() == 0 ? s = t.current : s = e.currentTime();
    const {
      start: o,
      altStart: u
    } = i[r ?? 0];
    u != o && r > 0 && (s = s + u), a && !e.audioOnlyMode_ || this.updateTextNode_(s), this.setInitTime(0);
  }
}
ke.registerComponent("VideoJSCurrentTime", y7);
const v7 = ke.getComponent("MenuButton"), x7 = ke.getComponent("MenuItem");
class _7 extends v7 {
  constructor(e, t) {
    super(e, t), this.addClass("vjs-file-download"), this.setAttribute("data-testid", "videojs-file-download"), this.setIcon("file-download");
  }
  createItems() {
    const {
      options_: e,
      player_: t
    } = this, {
      files: i
    } = e;
    return i?.length > 0 ? i.map(function(r) {
      let a = new x7(t, {
        label: r.label
      });
      return a.handleClick = function() {
        KT(r.id, r.filename, r.fileExt);
      }, a;
    }) : [];
  }
}
ke.registerComponent("VideoJSFileDownload", _7);
const T7 = ke.getComponent("Button");
class w7 extends T7 {
  constructor(e, t) {
    super(e, t), this.setIcon("next-item"), this.addClass("vjs-play-control vjs-control"), this.setAttribute("data-testid", "videojs-next-button"), this.controlText("Next"), this.options = t, this.player = e, this.cIndex = t.canvasIndex, this.player.on("loadstart", () => {
      this.updateComponent();
    });
  }
  updateComponent() {
    const {
      player: e
    } = this;
    e && e != null && (e.canvasIndex === void 0 && e.children()?.length > 0 ? this.cIndex = Number(e.children()[0].dataset.canvasindex) : this.cIndex = e.canvasIndex);
  }
  handleClick() {
    this.handleNextClick();
  }
  handleKeyDown(e) {
    (e.which === 32 || e.which === 13) && (e.stopPropagation(), this.handleNextClick());
  }
  handleNextClick() {
    this.cIndex != this.options.lastCanvasIndex && this.options.switchPlayer(this.cIndex + 1, !0);
  }
}
ke.registerComponent("VideoJSNextButton", w7);
const E7 = ke.getComponent("Button");
class D7 extends E7 {
  constructor(e, t) {
    super(e, t), this.setIcon("previous-item"), this.addClass("vjs-play-control vjs-control"), this.setAttribute("data-testid", "videojs-previous-button"), this.options = t, this.player = e, this.cIndex = t.canvasIndex, this.player.on("loadstart", () => {
      this.updateComponent();
    });
  }
  updateComponent() {
    const {
      player: e
    } = this;
    e && e != null && (e.canvasIndex === void 0 && e.children()?.length > 0 ? this.cIndex = Number(e.children()[0].dataset.canvasindex) : this.cIndex = e.canvasIndex), this.controlText(this.cIndex == 0 ? "Replay" : "Previous");
  }
  handleClick() {
    this.handlePreviousClick();
  }
  handleKeyDown(e) {
    (e.which === 32 || e.which === 13) && (e.stopPropagation(), this.handlePreviousClick());
  }
  handlePreviousClick() {
    this.cIndex > -1 && this.cIndex != 0 ? this.options.switchPlayer(this.cIndex - 1, !0) : this.cIndex == 0 && this.player.currentTime(0);
  }
}
ke.registerComponent("VideoJSPreviousButton", D7);
const K3 = ke.getComponent("Component");
class S7 extends K3 {
  constructor(e, t) {
    super(e, t), this.setAttribute("data-testid", "videojs-title-link"), this.addClass("vjs-title-bar"), this.options = t, this.player = e, this.player.on("loadstart", () => {
      this.updateComponent();
    });
  }
  updateComponent() {
    const {
      player: e
    } = this;
    if (e && e != null && e.canvasLink) {
      const {
        label: t,
        id: i
      } = e.canvasLink;
      let r = t, a = null;
      i.includes("manifest/canvas") ? a = i.replace("manifest/canvas", "section") : a = i;
      const s = ke.dom.createEl("a", {
        className: "vjs-title-link",
        href: a,
        target: "_blank",
        rel: "noreferrer noopener",
        innerHTML: r
      });
      this.el().hasChildNodes() ? this.el().replaceChildren(s) : this.el().appendChild(s);
    }
  }
}
K3.registerComponent("VideoJSTitleLink", S7);
const C7 = `
<symbol id="zoomed-out" viewBox="0 0 20 20">
  <g id="SVGRepo_bgCarrier" stroke-width="0"></g>
  <g id="SVGRepo_tracerCarrier" stroke-linecap="round" stroke-linejoin="round"></g>
  <g id="SVGRepo_iconCarrier">
    <path fill="#ffffff" fill-rule="evenodd" d="M4 9a5 5 0 1110 0A5 5 0 014 9zm5-7a7 7 
      0 104.2 12.6.999.999 0 00.093.107l3 3a1 1 0 001.414-1.414l-3-3a.999.999 0 00-.107-.093A7 
      7 0 009 2zM8 6.5a1 1 0 112 0V8h1.5a1 1 0 110 2H10v1.5a1 1 0 11-2 0V10H6.5a1 1 0 010-2H8V6.5z">
    </path>
  </g>
</symbol>`, A7 = `
<symbol id="zoomed-in" viewBox="0 0 20 20">
  <g id="SVGRepo_bgCarrier" stroke-width="0"></g>
  <g id="SVGRepo_tracerCarrier" stroke-linecap="round" stroke-linejoin="round"></g>
  <g id="SVGRepo_iconCarrier">
    <path fill="#ffffff" fill-rule="evenodd" d="M9 4a5 5 0 100 10A5 5 0 009 4zM2 9a7 
      7 0 1112.6 4.2.999.999 0 01.107.093l3 3a1 1 0 01-1.414 1.414l-3-3a.999.999 0 
      01-.093-.107A7 7 0 012 9zm10.5 0a1 1 0 00-1-1h-5a1 1 0 100 2h5a1 1 0 001-1z">
    </path>
  </g>
</symbol>`;
function k7() {
  const n = document.createElement("div");
  n.style.display = "none", n.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg">${C7}${A7}</svg>`, document.body.appendChild(n);
}
k7();
const I7 = ke.getComponent("Button");
class U7 extends I7 {
  constructor(e, t) {
    super(e, t), this.setAttribute("data-testid", "videojs-track-scrubber-button"), this.addClass("vjs-button vjs-track-scrubber"), this.controlText("Toggle track scrubber"), this.el().innerHTML = `
      <svg class="vjs-icon-zoom" role="presentation">
        <use xlink:href="#zoomed-out"></use>
      </svg>`, this.options = t, this.player = e, this.playerInterval, this.zoomedOutRef = Zn(), this.currentTrackRef = Zn(), this.player.on("ready", () => {
      this.options.trackScrubberRef.current && (this.playerInterval = setInterval(() => {
        this.handleTimeUpdate();
      }, 100));
    }), this.player.on("loadstart", () => {
      this.options.trackScrubberRef.current && (this.updateComponent(), this.playerInterval || (this.playerInterval = setInterval(() => {
        this.handleTimeUpdate();
      }, 100)));
    }), this.player.on("fullscreenchange", () => {
      if (this.player.isFullscreen() && !this.zoomedOutRef.current) {
        const i = this.zoomedOutRef.current;
        this.setZoomedOut(!i);
      }
    }), this.player.on("dispose", () => {
      clearInterval(this.playerInterval);
    });
  }
  setCurrentTrack(e) {
    this.currentTrackRef.current = e;
  }
  setZoomedOut(e) {
    this.zoomedOutRef.current = e, e ? (this.options.trackScrubberRef.current.classList.add("hidden"), this.el().innerHTML = `
        <svg class="vjs-icon-zoom" role="presentation">
          <use xlink:href="#zoomed-out"></use>
        </svg>`) : (this.options.trackScrubberRef.current.classList.remove("hidden"), this.el().innerHTML = `
        <svg class="vjs-icon-zoom" role="presentation">
          <use xlink:href="#zoomed-in"></use>
        </svg>`);
  }
  attachListeners() {
    const {
      trackScrubberRef: e
    } = this.options;
    if (e.current) {
      this.populateTrackScrubber(), this.updateTrackScrubberProgressBar();
      let t = !1, [i, r, a] = e.current.children;
      r.addEventListener("mouseenter", (s) => {
        this.handleMouseMove(s);
      }), r.addEventListener("pointerup", (s) => {
        t && this.handleSetProgress(s);
      }), r.addEventListener("pointermove", (s) => {
        this.handleMouseMove(s), t = !0;
      }), r.addEventListener("pointerdown", (s) => {
        s.which === 1 && (this.handleSetProgress(s), t = !1);
      });
    }
  }
  updateComponent() {
    this.zoomedOutRef.current = !0, this.currentTrackRef.current = {}, this.attachListeners();
  }
  /**
   * Keydown event handler for the track button on the player controls,
   * when using keyboard navigation
   * @param {Event} e keydown event
   */
  handleKeyDown(e) {
    (e.which === 32 || e.which === 13) && (e.preventDefault(), this.handleTrackScrubberClick(), e.stopPropagation());
  }
  handleClick() {
    this.handleTrackScrubberClick();
  }
  /**
   * Click event handler for the track button on the player controls
   */
  handleTrackScrubberClick() {
    const {
      currentTrackRef: e,
      player: t,
      options: i
    } = this;
    if (!i.trackScrubberRef.current || !e.current) return;
    t.isFullscreen() && t.exitFullscreen();
    const r = this.zoomedOutRef.current;
    this.setZoomedOut(!r);
  }
  /**
   * Event handler for VideoJS player instance's 'timeupdate' event, which
   * updates the track scrubber from player state.
   */
  handleTimeUpdate() {
    const {
      player: e,
      options: t,
      zoomedOutRef: i
    } = this;
    if (e.canvasIsEmpty && !i.current && this.setZoomedOut(!0), e.isDisposed() || e.ended()) return;
    let r = e.currentTime();
    e.markers && typeof e.markers != "function" && typeof e.markers.getMarkers == "function" && e.markers.getMarkers()?.length > 0 && !t.isPlaylist ? this.readPlayerMarkers() : (this.setCurrentTrack({
      duration: e.playableDuration ?? e.duration(),
      time: e.altStart ?? 0,
      key: "",
      text: "Complete media file"
    }), r = e.srcIndex && e.srcIndex > 0 ? r + e.altStart : r), this.updateTrackScrubberProgressBar(r);
  }
  /**
   * Calculate the progress and current time within the track and
   * update them accordingly when the player's 'timeupdate' event fires.
   * @param {Number} currentTime player's current time
   */
  updateTrackScrubberProgressBar(e = 0) {
    const {
      player: t,
      currentTrackRef: i
    } = this;
    i.current || t.markers && typeof t.markers.getMarkers == "function" && this.readPlayerMarkers();
    const {
      altStart: r,
      srcIndex: a
    } = t;
    let s = a > 0 ? e - i.current.time + r : e - i.current.time, o = Math.min(100, Math.max(0, 100 * s / i.current.duration));
    this.populateTrackScrubber(s, o);
  }
  /**
   * Update the track scrubber's current time, duration and played percentage
   * when it is visible in UI. 
   * @param {Number} currentTime current time corresponding to the track
   * @param {Number} playedPercentage elapsed time percentage of the track duration
   */
  populateTrackScrubber(e = 0, t = 0) {
    const {
      trackScrubberRef: i
    } = this.options;
    if (!i.current)
      return;
    let [r, a, s] = i.current.children;
    this.setTrackScrubberValue(t, e), s.innerHTML = wn(this.currentTrackRef.current.duration);
    let o = !isNaN(e) && e > 0 ? e : 0;
    r.innerHTML = wn(o);
  }
  readPlayerMarkers() {
    const e = this.player.markers.getMarkers().filter((t) => t.class == "ramp--track-marker--fragment");
    e?.length > 0 && this.setCurrentTrack(e[0]);
  }
  /**
   * Event handler for mouseenter and mousemove pointer events on the
   * the track scrubber. This sets the time tooltip value and its offset
   * position in the UI.
   * @param {Event} e pointer event for user interaction
   */
  handleMouseMove(e) {
    const {
      timeToolRef: t
    } = this.options;
    if (!t.current)
      return;
    let i = this.getTrackTime(e);
    if (isFinite(i)) {
      let r = e.offsetX - t.current.offsetWidth / 2;
      t.current.style.left = r + "px", t.current.innerHTML = wn(i);
    }
  }
  /**
   * Event handler for mousedown event on the track scrubber. This sets the
   * progress percentage within track scrubber and update the player's current time
   * when user clicks on a point within the track scrubber.
   * @param {Event} e pointer event for user interaction
   */
  handleSetProgress(e) {
    const {
      currentTrackRef: t,
      player: i
    } = this;
    if (!t.current)
      return;
    let r = this.getTrackTime(e);
    if (r != null) {
      let a = Math.min(100, Math.max(0, 100 * (r / t.current.duration)));
      this.setTrackScrubberValue(a, r);
      const s = i?.srcIndex > 0 ? r : r + t.current.time;
      i.currentTime(s);
    }
  }
  /**
   * Set the elapsed time percentage and time as aria-now in the 
   * progress bar of track scrubber
   * @param {Number} trackpercent 
   * @param {Number} trackoffset 
   */
  setTrackScrubberValue = (e, t) => {
    document.documentElement.style.setProperty("--range-scrubber", `calc(${e}%)`);
    const {
      trackScrubberRef: i
    } = this.options;
    if (i.current && i.current.children) {
      let [r, a, s] = i.current.children;
      a.setAttribute("aria-valuenow", t);
    }
  };
  /**
   * Convert pointer position on track scrubber to a time value
   * @param {Event} e pointer event for user interaction
   * @returns {Number} time corresponding to the pointer position
   */
  getTrackTime(e) {
    const {
      currentTrackRef: t
    } = this;
    if (!t.current)
      return;
    let i = e.offsetX;
    if (i && i != null)
      return i / e.target.clientWidth * t.current.duration;
  }
}
ke.registerComponent("VideoJSTrackScrubber", U7);
require("@silvermine/videojs-quality-selector")(ke);
function Y3({
  enableFileDownload: n,
  enableTitleLink: e,
  isVideo: t,
  options: i,
  placeholderText: r,
  scrubberTooltipRef: a,
  tracks: s,
  trackScrubberRef: o,
  videoJSLangMap: u,
  withCredentials: c
}) {
  const l = Wg(), h = Vg(), f = zr(), d = fo(), {
    canvasDuration: y,
    canvasLink: m,
    hasMultiItems: b,
    targets: p,
    autoAdvance: g,
    structures: v,
    canvasSegments: _
  } = f, {
    hasStructure: x,
    structItems: T
  } = v, {
    clickedUrl: E,
    isEnded: U,
    isPlaying: D,
    currentTime: L
  } = l, [j, C] = Eu("startVolume", 1), [k, I] = Eu("startMuted", !1), [$, W] = Eu("startCaptioned", !0), [B, z] = Eu("startQuality", null), q = He(null), Y = He(), H = He(), {
    canvasIndex: K,
    canvasIsEmpty: ie,
    lastCanvasIndex: ge
  } = xo(), {
    isPlaylist: pe,
    renderingFiles: ce,
    srcIndex: oe,
    switchPlayer: De
  } = z3({
    enableFileDownload: n,
    withCredentials: c,
    lastCanvasIndex: ge
  }), {
    messageTime: Re
  } = a7({
    lastCanvasIndex: ge
  }), Me = He();
  Me.current = Je(() => ie, [ie]);
  const F = He();
  F.current = Je(() => U, [U]);
  const P = He();
  P.current = Je(() => D, [D]);
  const ne = He();
  ne.current = Je(() => g, [g]);
  const S = He();
  S.current = Je(() => oe, [oe]);
  const he = He();
  he.current = Je(() => L, [L]);
  const ae = He();
  ae.current = Je(() => s, [s]);
  const te = He();
  te.current = Je(() => E, [E]);
  const ee = (G) => {
    G.on("ready", function() {
      console.log("Player ready"), ve(G), (ei || js) && G.controlBar.addClass("vjs-mobile-visible"), G.error() ? G.trigger("error") : (G.muted(k), G.volume(j), G.canvasIndex = N.current, G.duration(y), G.srcIndex = oe, G.targets = p, e && (G.canvasLink = m), G.getChild("controlBar").qualitySelector.setIcon("cog"));
    }), G.on("emptied", () => {
      if (ae.current?.length > 0 && t && G.textTracks()?.length <= ae.current?.length) {
        if (Qi) {
          let J = G.remoteTextTracks(), fe = J.length;
          for (; fe--; )
            G.removeRemoteTextTrack(J[fe]);
        }
        ae.current.forEach(function(J) {
          J.label == H.current?.label ? J.mode = "showing" : J.mode = "disabled", G.addRemoteTextTrack(J, !1);
        });
      }
    }), G.on("canplay", () => {
      h({
        isEnded: !1,
        type: "setIsEnded"
      });
    }), G.on("play", () => {
      h({
        isPlaying: !0,
        type: "setPlayingStatus"
      });
    }), G.on("timeupdate", () => {
      je();
    }), G.on("resize", () => {
      ve(G);
    }), G.on("ended", () => {
      setTimeout(() => {
        ye.current && P.current && (h({
          isEnded: !0,
          type: "setIsEnded"
        }), G.pause(), Me.current || Ie());
      }, 100);
    }), G.on("volumechange", () => {
      I(G.muted()), C(G.volume());
    }), G.on("loadeddata", function() {
      M(!0), je();
    }), G.on("qualityRequested", (J, fe) => {
      z(fe.label);
    }), G.on("seeked", (J) => {
      G.hasClass("vjs-disabled") && G.removeClass("vjs-disabled"), G.readyState() != 4 && G.currentTime() == 0 && G.currentTime() != he.current && G.currentTime(he.current), setTimeout(() => {
        h({
          type: "setCurrentTime",
          currentTime: G.currentTime()
        });
      }, 0);
    }), G.on("error", (J) => {
      const fe = G.error();
      let Ce = "Something went wrong. Please try again later or contact support for help.";
      switch (fe.code) {
        case 1:
          console.error("MEDIA_ERR_ABORTED: The fetching process for the media resource was aborted by the user agent             at the users request.");
          break;
        case 2:
          Ce = "The media could not be loaded due to a network error. Please try again later.", console.error("MEDIA_ERR_NETWORK: A network error caused the user agent to stop fetching the media resource,             after the resource was established to be usable.");
          break;
        case 3:
          Ce = "Media is corrupt or has features not supported by the browser.           Please try a different media or contact support for help.", console.error("MEDIA_ERR_DECODE: An error occurred while decoding the media resource, after             the resource was established to be usable.");
          break;
        case 4:
          Ce = "Media could not be loaded.  Network error or media format is not supported.", console.error("MEDIA_ERR_SRC_NOT_SUPPORTED: The media resource indicated by the src attribute was not suitable.");
          break;
        default:
          console.error("An unknown error occurred.");
          break;
      }
      var Ne = G.getChild("ErrorDisplay");
      Ne && (Ne.contentEl().innerText = Ce, Ne.removeClass("vjs-hidden"), G.removeClass("vjs-error"), G.removeClass("vjs-disabled")), J.stopPropagation();
    }), Se(G);
  }, ve = (G) => {
    const fe = G.currentWidth() - 24;
    G.controlBar.width(`${fe}px`);
  }, Ee = (G) => {
    G.duration(y), G.src(i.sources), G.poster(i.poster), G.canvasIndex = N.current, G.canvasIsEmpty = Me.current, G.srcIndex = oe, G.targets = p, e && (G.canvasLink = m);
    for (var J = G.remoteTextTracks(), fe = J.length; fe--; )
      G.removeRemoteTextTrack(J[fe]);
    if (s?.length > 0 && t && s.forEach(function(Ce) {
      G.addRemoteTextTrack(Ce, !1);
    }), G.getChild("controlBar") != null && !ie) {
      const Ce = G.getChild("controlBar"), Ne = ei ? Ce.children().findIndex((Ve) => Ve.name_ == "MuteToggle") : Ce.children().findIndex((Ve) => Ve.name_ == "VolumePanel");
      if (x || pe ? Ce.getChild("videoJSTrackScrubber") || Ce.addChild("videoJSTrackScrubber", {
        trackScrubberRef: o,
        timeToolRef: a
      }, Ne + 1) : Ce.removeChild("videoJSTrackScrubber"), ei || (Ce.removeChild("volumePanel"), Ce.addChild("volumePanel", {
        inline: !t
      }, Ne), G.trigger("volumechange")), s?.length > 0 && t && !Ce.getChild("subsCapsButton") && Ce.addChild("subsCapsButton", {}, Ne + 1).children_[0].addClass("captions-on"), t ? (G.audioOnlyMode(!1), G.removeClass("vjs-audio"), G.aspectRatio("16:9"), G.addChild("bigPlayButton")) : (G.audioOnlyMode(!0), G.addClass("vjs-audio"), G.height(G.controlBar.height()), G.removeChild("bigPlayButton")), n) {
        const Ve = Ce.children().findIndex((mt) => mt.name_ == "FullscreenToggle");
        let ut = Ce.children().findIndex((mt) => mt.name_ == "VideoJSFileDownload");
        if (ut = ut < 0 ? Ve : ut, Ce.removeChild("videoJSFileDownload"), ce?.length > 0) {
          const mt = {
            title: "Download Files",
            controlText: "Alternate resource download",
            files: ce
          };
          Ce.addChild("videoJSFileDownload", {
            ...mt
          }, ut);
        }
      }
    }
    G.structStart = he.current, Se(G);
  }, Se = (G) => {
    G.one("loadedmetadata", () => {
      console.log("Player loadedmetadata");
      const J = F.current ? 0 : Math.max(he.current, G.currentTime());
      if (G.currentTime(J), ve(G), G.duration(y), (Qi || Fm) && G.readyState() != 4 && G.load(), F.current || P.current) {
        var fe = G.play();
        fe !== void 0 && fe.then((Ne) => {
          G.currentTime(he.current);
        }).catch((Ne) => {
        });
      }
      t && de(G);
      const Ce = rr(G.src(), y);
      Ce != null ? (G.playableDuration = Ce.end - Ce.start, G.altStart = Ce.start) : (G.playableDuration = y, G.altStart = p[oe].altStart), G.canvasIndex = N.current, Qi && je();
    });
  }, {
    activeId: xe,
    fragmentMarker: le,
    isReadyRef: ye,
    playerRef: we,
    setActiveId: Ue,
    setFragmentMarker: Q,
    setIsReady: M
  } = r7({
    options: i,
    playerInitSetup: ee,
    updatePlayer: Ee,
    startQuality: B,
    tracks: s,
    videoJSRef: q,
    videoJSLangMap: u
  });
  let N = He();
  N.current = Je(() => K, [K]);
  const Z = He();
  Z.current = Je(() => xe, [xe]);
  const de = (G) => {
    let J = G.textTracks();
    if (ei && !Ui && J.on("addtrack", () => {
      for (let fe = 0; fe < J.length; fe++)
        J[fe].language === "" && J[fe].label === "" && G.textTracks().removeTrack(J[fe]), $ && H.current && (J.tracks_.filter((Ce) => Ce.label === H.current.label && Ce.language === H.current.language)[0].mode = "showing");
    }), J.tracks_?.length > 0) {
      let fe = null, Ce = !1;
      for (let Ne = 0; Ne < J.tracks_.length; Ne++) {
        let Ve = J.tracks_[Ne];
        (Ve.kind === "subtitles" || Ve.kind === "captions") && Ve.language != "" && Ve.label != "" && (Ve.mode = "disabled", Ce || (fe = Ve), Ce = !0);
      }
      fe && $ && (fe.mode = "showing", H.current = fe, Te(!0));
    }
    J.on("change", () => {
      let fe = [];
      for (let Ne = 0; Ne < J.tracks_.length; Ne++) {
        const {
          mode: Ve,
          label: ut,
          kind: mt
        } = J[Ne];
        fe.push(J[Ne].mode), Ve === "showing" && ut != "" && (mt === "subtitles" || mt === "captions") && (H.current = J[Ne]);
      }
      const Ce = !!fe.includes("showing");
      Te(Ce), W(Ce);
    });
  }, Te = (G) => {
    const fe = we.current.controlBar.getChild("subsCapsButton");
    fe == null || !fe || !fe?.children_ || (G ? (fe.children_[0].addClass("captions-on"), Y.current = !0) : (fe.children_[0].removeClass("captions-on"), Y.current = !1, H.current = null));
  }, Ie = Je(() => Ac(() => {
    const G = N.current === ge;
    if (!((!ne.current || G) && !b)) {
      if (we.current && we.current.markers && (we.current.pause(), Q(null), we.current.markers.removeAll()), b)
        if (oe + 1 < p.length)
          d({
            srcIndex: oe + 1,
            type: "setSrcIndex"
          }), h({
            currentTime: 0,
            type: "setCurrentTime"
          }), we.current.play();
        else
          return;
      else if (T?.length > 0) {
        const J = T[N.current + 1];
        if (J) {
          d({
            canvasIndex: N.current + 1,
            type: "switchCanvas"
          }), h({
            startTime: 0,
            type: "setTimeFragment"
          }), h({
            currentTime: 0,
            type: "setCurrentTime"
          });
          let fe = _.filter((Ve) => Ve.canvasIndex === J.canvasIndex && Ve.itemIndex === 1), Ce = J.id != null ? J : fe[0], Ne = 0;
          Ce != null && Ce.id != null && (Ne = Ce.times.start), Ne === 0 ? d({
            item: Ce,
            type: "switchItem"
          }) : Ce.isEmpty && (d({
            item: Ce,
            type: "switchItem"
          }), we.current.currentTime(Ne), J.isEmpty || we.current.play());
        }
      }
    }
  }), [N.current]), je = Je(() => Ac(() => {
    const G = we.current;
    if (G && ye.current) {
      let J = G.currentTime() ?? he.current;
      b && S.current > 0 && (J = J + p[S.current].altStart);
      const fe = Bi(J);
      if (Z.current !== fe?.id)
        if (!fe)
          d({
            item: null,
            type: "switchItem"
          }), Ue(null), Q(null);
        else if (d({
          item: fe,
          type: "switchItem"
        }), Ue(fe.id), !pe && G.markers) {
          const {
            start: Ce,
            end: Ne
          } = fe.times;
          if (h({
            endTime: Ne,
            startTime: Ce,
            type: "setTimeFragment"
          }), Ce !== Ne) {
            let Ve = Ne > fe.canvasDuration ? fe.canvasDuration : Ne;
            Q({
              time: Ce,
              duration: Ve - Ce,
              text: Ce,
              class: "ramp--track-marker--fragment"
            });
          } else
            Q(null);
        } else le !== null && Q(null);
      te.current && !G.paused() && (h({
        type: "clearClickedUrl"
      }), G.structStart = G?.targets[0]?.start ?? 0);
    }
  }, 10), []), Ze = (G) => {
    const J = we.current;
    G.changedTouches[0].clientX == Qe && G.changedTouches[0].clientY == ot && (J.paused() ? J.play() : J.pause());
  };
  let Qe = null, ot = null;
  const rt = (G) => {
    Qe = G.touches[0].clientX, ot = G.touches[0].clientY;
  }, Bi = (G) => {
    if (pe)
      return _[N.current];
    {
      const J = tc(G);
      let fe = _.filter((Ce) => {
        if (Jp(Ce.times, Ce.canvasDuration) && J >= Ce.times.start && J < Ce.times.end)
          return Ce;
      });
      if (te.current) {
        const Ce = fe.filter((Ne) => Ne.id === te.current);
        fe = Ce?.length > 0 ? Ce : fe;
      }
      for (let Ce of fe) {
        const {
          isCanvas: Ne,
          canvasDuration: Ve,
          canvasIndex: ut,
          times: mt
        } = Ce;
        if (ut == N.current + 1) {
          if (Ne)
            return Ce;
          const Jt = Jp(mt, Ve);
          if (J >= mt.start && J < mt.end && Jt)
            return Ce;
        }
      }
      return null;
    }
  }, oi = (G) => {
    De(G, !0);
  }, ui = (G, J, fe) => {
    (G.which === 32 || G.which === 13) && De(J, !0, fe);
  };
  return /* @__PURE__ */ se.jsxs("div", { children: [
    /* @__PURE__ */ se.jsxs("div", { "data-vjs-player": !0, "data-canvasindex": N.current, children: [
      Me.current && /* @__PURE__ */ se.jsxs(
        "div",
        {
          "data-testid": "inaccessible-message-display",
          style: {
            position: we.current ? "absolute" : "relative",
            top: 0,
            left: 0,
            right: 0,
            bottom: 0,
            display: "flex",
            flexDirection: "column",
            justifyContent: "center",
            alignItems: "center",
            fontSize: "medium",
            textAlign: "center",
            color: "#fff",
            backgroundColor: "black",
            zIndex: 101,
            aspectRatio: we.current ? "" : "16/9"
          },
          children: [
            /* @__PURE__ */ se.jsx("p", { className: "ramp--media-player_inaccessible-message-content", "data-testid": "inaccessible-message-content", dangerouslySetInnerHTML: {
              __html: r
            } }),
            ge > 0 && /* @__PURE__ */ se.jsxs("div", { className: "ramp--media-player_inaccessible-message-buttons", "data-testid": "inaccessible-message-buttons", children: [
              K >= 1 && /* @__PURE__ */ se.jsxs("button", { "aria-label": "Go back to previous item", onClick: () => oi(K - 1), onKeyDown: (G) => ui(G, K - 1, "previousBtn"), "data-testid": "inaccessible-previous-button", children: [
                /* @__PURE__ */ se.jsx(xT, { flip: !0 }),
                " Previous"
              ] }),
              K != ge && /* @__PURE__ */ se.jsxs("button", { "aria-label": "Go to next item", onClick: () => oi(K + 1), onKeyDown: (G) => ui(G, K + 1, "nextBtn"), "data-testid": "inaccessible-next-button", children: [
                "Next ",
                /* @__PURE__ */ se.jsx(xT, {})
              ] })
            ] }),
            K != ge && ge > 0 && /* @__PURE__ */ se.jsx("p", { "data-testid": "inaccessible-message-timer", className: cn("ramp--media-player_inaccessible-message-timer", ne.current ? "" : "hidden"), children: `Next item in ${Re} second${Re === 1 ? "" : "s"}` })
          ]
        }
      ),
      /* @__PURE__ */ se.jsx("video", { "data-testid": `videojs-${t ? "video" : "audio"}-element`, "data-canvasindex": N.current, ref: q, className: cn("video-js vjs-big-play-centered vjs-theme-ramp vjs-disabled", Ui ? "is-mobile" : ""), onTouchStart: rt, onTouchEnd: Ze, style: {
        display: `${Me.current ? "none" : ""}`
      } })
    ] }),
    (x || pe) && /* @__PURE__ */ se.jsxs("div", { className: "vjs-track-scrubber-container hidden", ref: o, id: "track_scrubber", children: [
      /* @__PURE__ */ se.jsx("p", { className: "vjs-time track-currenttime", role: "presentation" }),
      /* @__PURE__ */ se.jsx("span", { type: "range", "aria-label": "Track scrubber", role: "slider", tabIndex: 0, className: "vjs-track-scrubber", style: {
        width: "100%"
      }, children: !ti && /* @__PURE__ */ se.jsx("span", { className: "tooltiptext", ref: a, "aria-hidden": !0, role: "presentation" }) }),
      /* @__PURE__ */ se.jsx("p", { className: "vjs-time track-duration", role: "presentation" })
    ] })
  ] });
}
Y3.propTypes = {
  enableFileDownload: Le.bool,
  enableTitleLink: Le.bool,
  isVideo: Le.bool,
  options: Le.object,
  placeholderText: Le.string,
  scrubberTooltipRef: Le.object,
  tracks: Le.array,
  trackScrubberRef: Le.object,
  videoJSLangMap: Le.string,
  withCredentials: Le.bool
};
const R7 = "Play", O7 = "Pause", L7 = "Replay", P7 = "Duration", F7 = "LIVE", N7 = "Loaded", M7 = "Progress", B7 = "Fullscreen", j7 = "Mute", q7 = "Unmute", W7 = "Subtitles", V7 = "Captions", H7 = "Chapters", z7 = "Descriptions", $7 = "Close", G7 = "Text", X7 = "White", K7 = "Black", Y7 = "Red", Q7 = "Green", Z7 = "Blue", J7 = "Yellow", eF = "Magenta", tF = "Cyan", nF = "Background", iF = "Window", rF = "Transparent", aF = "Opaque", sF = "None", oF = "Raised", uF = "Depressed", cF = "Uniform", lF = "Casual", dF = "Script", fF = "Reset", hF = "Done", pF = "Color", mF = "Opacity", Cs = {
  "Audio Player": "Audio Player",
  "Video Player": "Video Player",
  Play: R7,
  Pause: O7,
  Replay: L7,
  "Current Time": "Current Time",
  Duration: P7,
  "Remaining Time": "Remaining Time",
  "Stream Type": "Stream Type",
  LIVE: F7,
  "Seek to live, currently behind live": "Seek to live, currently behind live",
  "Seek to live, currently playing live": "Seek to live, currently playing live",
  Loaded: N7,
  Progress: M7,
  "Progress Bar": "Progress Bar",
  "progress bar timing: currentTime={1} duration={2}": "{1} of {2}",
  Fullscreen: B7,
  "Exit Fullscreen": "Exit Fullscreen",
  Mute: j7,
  Unmute: q7,
  "Playback Rate": "Playback Rate",
  Subtitles: W7,
  "subtitles off": "subtitles off",
  Captions: V7,
  "captions off": "captions off",
  Chapters: H7,
  Descriptions: z7,
  "descriptions off": "descriptions off",
  "Audio Track": "Audio Track",
  "Volume Level": "Volume Level",
  "You aborted the media playback": "You aborted the media playback",
  "A network error caused the media download to fail part-way.": "A network error caused the media download to fail part-way.",
  "The media could not be loaded, either because the server or network failed or because the format is not supported.": "The media could not be loaded, either because the server or network failed or because the format is not supported.",
  "The media playback was aborted due to a corruption problem or because the media used features your browser did not support.": "The media playback was aborted due to a corruption problem or because the media used features your browser did not support.",
  "No compatible source was found for this media.": "No compatible source was found for this media.",
  "The media is encrypted and we do not have the keys to decrypt it.": "The media is encrypted and we do not have the keys to decrypt it.",
  "Play Video": "Play Video",
  Close: $7,
  "Close Modal Dialog": "Close Modal Dialog",
  "Modal Window": "Modal Window",
  "This is a modal window": "This is a modal window",
  "This modal can be closed by pressing the Escape key or activating the close button.": "This modal can be closed by pressing the Escape key or activating the close button.",
  ", opens captions settings dialog": ", opens captions settings dialog",
  ", opens subtitles settings dialog": ", opens subtitles settings dialog",
  ", opens descriptions settings dialog": ", opens descriptions settings dialog",
  ", selected": ", selected",
  "captions settings": "captions settings",
  "subtitles settings": "subtitles settings",
  "descriptions settings": "descriptions settings",
  Text: G7,
  White: X7,
  Black: K7,
  Red: Y7,
  Green: Q7,
  Blue: Z7,
  Yellow: J7,
  Magenta: eF,
  Cyan: tF,
  Background: nF,
  Window: iF,
  Transparent: rF,
  "Semi-Transparent": "Semi-Transparent",
  Opaque: aF,
  "Font Size": "Font Size",
  "Text Edge Style": "Text Edge Style",
  None: sF,
  Raised: oF,
  Depressed: uF,
  Uniform: cF,
  "Drop shadow": "Drop shadow",
  "Font Family": "Font Family",
  "Proportional Sans-Serif": "Proportional Sans-Serif",
  "Monospace Sans-Serif": "Monospace Sans-Serif",
  "Proportional Serif": "Proportional Serif",
  "Monospace Serif": "Monospace Serif",
  Casual: lF,
  Script: dF,
  "Small Caps": "Small Caps",
  Reset: fF,
  "restore all settings to the default values": "restore all settings to the default values",
  Done: hF,
  "Caption Settings Dialog": "Caption Settings Dialog",
  "Beginning of dialog window. Escape will cancel and close the window.": "Beginning of dialog window. Escape will cancel and close the window.",
  "End of dialog window.": "End of dialog window.",
  "{1} is loading.": "{1} is loading.",
  "Exit Picture-in-Picture": "Exit Picture-in-Picture",
  "Picture-in-Picture": "Picture-in-Picture",
  "No content": "No content",
  Color: pF,
  Opacity: mF,
  "Text Background": "Text Background",
  "Caption Area Background": "Caption Area Background",
  "Playing in Picture-in-Picture": "Playing in Picture-in-Picture",
  "Skip backward {1} seconds": "Skip backward {1} seconds",
  "Skip forward {1} seconds": "Skip forward {1} seconds"
}, As = /* @__PURE__ */ new Map();
As.set("en", Cs);
const gF = !1;
async function bF(n) {
  if (!n)
    return Cs;
  const e = n.toLowerCase();
  if (As.has(e))
    return As.get(e);
  try {
    let t = null;
    const i = [e, n];
    if (e.includes("-")) {
      const [r, a] = e.split("-");
      i.push(r), i.push(`${r}-${a.toUpperCase()}`);
    }
    for (const r of i)
      try {
        if (!gF) {
          const a = await import(
            /* @vite-ignore */
            `video.js/dist/lang/${r}.json`
          );
          t = a.default || a;
          break;
        }
      } catch {
        continue;
      }
    return t || (console.warn(`Video.js language '${n}' not found, falling back to English`), t = Cs), As.set(e, t), t;
  } catch (t) {
    return console.warn(`Failed to load Video.js language '${n}':`, t.message), console.warn("Falling back to English"), As.set(e, Cs), Cs;
  }
}
const yF = "iiif-media-player", vF = ({
  enableFileDownload: n = !1,
  enablePIP: e = !1,
  enablePlaybackRate: t = !1,
  enableTitleLink: i = !1,
  withCredentials: r = !1,
  language: a = "en"
}) => {
  const s = zr(), o = Wg(), {
    showBoundary: u
  } = ho(), {
    srcIndex: c,
    playlist: l,
    structures: h
  } = s, {
    isPlaylist: f
  } = l, {
    hasStructure: d
  } = h, {
    currentTime: y
  } = o, m = He(), b = He();
  let p = He("{}");
  const [g, v] = $e(!1), {
    canvasIsEmpty: _,
    canvasIndex: x,
    isMultiCanvased: T,
    lastCanvasIndex: E
  } = xo(), {
    isMultiSourced: U,
    isVideo: D,
    playerConfig: L,
    ready: j,
    renderingFiles: C,
    nextItemClicked: k,
    switchPlayer: I
  } = z3({
    enableFileDownload: n,
    lastCanvasIndex: E,
    withCredentials: r
  }), {
    error: $,
    poster: W,
    sources: B,
    targets: z,
    tracks: q
  } = L, Y = Je(() => async () => {
    try {
      const ie = await bF(a);
      p.current = JSON.stringify(ie), v(!0);
    } catch (ie) {
      u(ie);
    }
  }, [a]);
  et(() => {
    (async () => {
      try {
        await Y();
      } catch (ge) {
        u(ge);
      }
    })();
  }, [a]);
  const H = Je(() => ({
    autoplay: !1,
    id: yF,
    playbackRates: t ? [0.5, 0.75, 1, 1.5, 2] : [],
    experimentalSvgIcons: !0,
    controls: !0,
    fluid: !0,
    language: a,
    // Setting inactivity timeout to zero in mobile and tablet devices translates to
    // user is always active. And the control bar is not hidden when user is active.
    // With this user can always use the controls when the media is playing.
    inactivityTimeout: ei || ti ? 0 : 2e3,
    // In iOS devices the player uses native iOS player either by default or on fullscreen-mode.
    // For instance where iOS player is used for playback, native text track functionality
    // needs to be turned ON for captions to work properly between VideoJS player and
    // iOS player. 
    // Therefore, turn on 'nativeTextTracks' option for browser and OS combinations
    // where the native iOS player is used by default or on fullscreen-mode.
    // i.e. Both Safari and Chrome on iPhones, only Chrome on iPads.
    html5: {
      nativeTextTracks: !Ui && (js && !Qi || Ss)
    },
    // Make error display modal dismissable
    errorDisplay: {
      uncloseable: !1
    },
    /* 
      Setting this option helps to override VideoJS's default 'keydown' event handler, whenever
      the focus is on a native VideoJS control icon (e.g. play toggle).
      E.g. click event on 'playtoggle' sets the focus on the play/pause button,
      which has VideoJS's 'handleKeydown' event handler attached to it. Therefore, as long as the
      focus is on the play/pause button the 'keydown' event will pass through VideoJS's default
      'keydown' event handler, without ever reaching the 'keydown' handler setup on the document
      in Ramp code.
      When this option is setup VideoJS's 'handleKeydown' event handler passes the event to the
      function setup under the 'hotkeys' option when the native player controls are focused.
      In Safari, this works without using 'hotkeys' option, therefore only set this in other browsers.
    */
    userActions: {
      hotkeys: Qi ? void 0 : function(ie) {
        nm(ie, this);
      }
    },
    videoJSTitleLink: i,
    sources: []
  }), [a, t, i]), K = Je(() => _ ? {
    ...H,
    sources: []
  } : {
    ...H,
    aspectRatio: D ? "16:9" : "1:0",
    audioOnlyMode: !D,
    bigPlayButton: D,
    poster: D ? W : null,
    controlBar: {
      // Define and order control bar controls
      // See https://docs.videojs.com/tutorial-components.html for options of what
      // seem to be supported controls
      children: [
        T ? "videoJSPreviousButton" : "",
        "playToggle",
        T ? "videoJSNextButton" : "",
        "videoJSProgress",
        "videoJSCurrentTime",
        "timeDivider",
        "durationDisplay",
        "customControlSpacer",
        // Spacer element from VideoJS
        ei ? "muteToggle" : "volumePanel",
        q.length > 0 && D ? "subsCapsButton" : "",
        d || f ? "videoJSTrackScrubber" : "",
        "qualitySelector",
        t ? "playbackRateMenuButton" : "",
        e ? "pictureInPictureToggle" : "",
        n ? "videoJSFileDownload" : "",
        "fullscreenToggle"
        // 'vjsYo',             custom component
      ],
      videoJSProgress: {
        nextItemClicked: k
      },
      // Make the volume slider horizontal for audio in non-mobile browsers
      volumePanel: !ei && {
        inline: !D
      },
      videoJSCurrentTime: {
        srcIndex: c,
        targets: z,
        currentTime: y || 0
      },
      videoJSFileDownload: n && {
        title: "Download Files",
        controlText: "Alternate resource download",
        files: C
      },
      videoJSPreviousButton: T && {
        canvasIndex: x,
        switchPlayer: I
      },
      videoJSNextButton: T && {
        canvasIndex: x,
        lastCanvasIndex: E,
        switchPlayer: I
      },
      videoJSTrackScrubber: (d || f) && {
        trackScrubberRef: m,
        timeToolRef: b,
        isPlaylist: f
      }
    },
    sources: U ? [B[c]] : B,
    errorDisplay: {
      // Show the close button for the error modal, if more than one source OR multiple 
      // canvases are available
      uncloseable: !(B?.length > 1 || T)
    }
  }, [D, L, c]);
  return j && K != null && g || _ ? /* @__PURE__ */ se.jsx("div", { "data-testid": "media-player", className: "ramp--media_player", role: "complementary", "aria-label": "media player", children: /* @__PURE__ */ se.jsx(Y3, { enableFileDownload: n, enableTitleLink: i, isVideo: D, options: K, placeholderText: $, scrubberTooltipRef: b, tracks: q, trackScrubberRef: m, videoJSLangMap: p.current, withCredentials: r }) }) : null;
};
vF.propTypes = {
  enableFileDownload: Le.bool,
  enablePIP: Le.bool,
  enablePlaybackRate: Le.bool,
  enableTitleLink: Le.bool,
  withCredentials: Le.bool,
  language: Le.string
};
const xF = (n) => {
  const e = Et.c(14), {
    numberOfSections: t
  } = n;
  let i;
  e[0] === Symbol.for("react.memo_cache_sentinel") ? (i = {}, e[0] = i) : i = e[0];
  const {
    collapseExpandAll: r,
    isCollapsed: a
  } = $3();
  let s;
  e[1] !== r ? (s = () => {
    r();
  }, e[1] = r, e[2] = s) : s = e[2];
  const o = s;
  let u;
  e[3] !== o || e[4] !== a ? (u = (m) => {
    m.keyCode === 13 && (m.preventDefault(), o()), a && m.keyCode === 39 && o(), !a && m.keyCode === 37 && o();
  }, e[3] = o, e[4] = a, e[5] = u) : u = e[5];
  const c = u, l = a ? "Expand" : "Close", h = t > 1 ? " Sections" : " Section", f = `arrow ${a ? "down" : "up"}`;
  let d;
  e[6] !== f ? (d = /* @__PURE__ */ se.jsx("i", { className: f }), e[6] = f, e[7] = d) : d = e[7];
  let y;
  return e[8] !== o || e[9] !== c || e[10] !== l || e[11] !== h || e[12] !== d ? (y = /* @__PURE__ */ se.jsxs("button", { className: "ramp--structured-nav__collapse-all-btn", "data-testid": "collapse-expand-all-btn", onClick: o, onKeyDown: c, role: "button", children: [
    l,
    h,
    d
  ] }), e[8] = o, e[9] = c, e[10] = l, e[11] = h, e[12] = d, e[13] = y) : y = e[13], y;
}, k0 = (n) => {
  const e = Et.c(102), {
    canvasDuration: t,
    canvasIndex: i,
    duration: r,
    id: a,
    isTitle: s,
    isCanvas: o,
    isClickable: u,
    isEmpty: c,
    label: l,
    summary: h,
    homepage: f,
    isRoot: d,
    items: y,
    itemIndex: m,
    rangeId: b,
    sectionCount: p,
    sectionRef: g,
    structureContainerRef: v,
    times: _,
    setFocusedItem: x
  } = n, T = He(null), {
    isCollapsed: E,
    updateSectionStatus: U
  } = $3(), [D, L] = $e(!d);
  let j;
  e[0] !== t || e[1] !== a || e[2] !== o || e[3] !== c || e[4] !== m || e[5] !== g || e[6] !== v || e[7] !== _ ? (j = {
    itemId: a,
    itemIndex: m,
    liRef: T,
    sectionRef: g,
    structureContainerRef: v,
    isCanvas: o,
    isEmpty: c,
    canvasDuration: t,
    setSectionIsCollapsed: L,
    times: _
  }, e[0] = t, e[1] = a, e[2] = o, e[3] = c, e[4] = m, e[5] = g, e[6] = v, e[7] = _, e[8] = j) : j = e[8];
  const {
    currentNavItem: C,
    handleClick: k,
    isActiveLi: I,
    isActiveSection: $,
    isPlaylist: W,
    screenReaderTime: B
  } = s7(j), z = o && !W, q = y?.length > 0;
  let Y;
  e[9] !== C?.id || e[10] !== a || e[11] !== s || e[12] !== v ? (Y = () => {
    T.current && C?.id == a && T.current.isClicked != null && !T.current.isClicked && v.current.isScrolling != null && !v.current.isScrolling && !s && Pn(T.current, v), T.current && (T.current.isClicked = !1);
  }, e[9] = C?.id, e[10] = a, e[11] = s, e[12] = v, e[13] = Y) : Y = e[13];
  let H;
  e[14] !== C ? (H = [C], e[14] = C, e[15] = H) : H = e[15], et(Y, H);
  let K;
  e[16] !== E || e[17] !== d || e[18] !== D ? (K = () => {
    !d && E != D && L(E);
  }, e[16] = E, e[17] = d, e[18] = D, e[19] = K) : K = e[19];
  let ie;
  e[20] !== E ? (ie = [E], e[20] = E, e[21] = ie) : ie = e[21], et(K, ie);
  let ge;
  e[22] !== i || e[23] !== z || e[24] !== m || e[25] !== g || e[26] !== v ? (ge = () => {
    i + 1 === m && g.current && g.current.isClicked != null && !g.current.isClicked && v.current.isScrolling != null && !v.current.isScrolling && z && Pn(g.current, v), g.current && (g.current.isClicked = !1);
  }, e[22] = i, e[23] = z, e[24] = m, e[25] = g, e[26] = v, e[27] = ge) : ge = e[27];
  let pe;
  e[28] !== i || e[29] !== z ? (pe = [i, z], e[28] = i, e[29] = z, e[30] = pe) : pe = e[30], et(ge, pe);
  let ce;
  e[31] !== $ || e[32] !== z || e[33] !== g || e[34] !== v ? (ce = () => {
    $ && z && Pn(g.current, v);
  }, e[31] = $, e[32] = z, e[33] = g, e[34] = v, e[35] = ce) : ce = e[35];
  let oe;
  e[36] !== $ || e[37] !== z ? (oe = [$, z], e[36] = $, e[37] = z, e[38] = oe) : oe = e[38], et(ce, oe);
  let De;
  W ? De = c ? `Restricted playlist item ${m}${l} starts a ${Us / 1e3} 
          second timer to auto-advance to next playlist item` : `Playlist item ${m}${l} ${r} starting at ${B}` : z ? De = a != null ? `Load media for Canvas ${m},${l},${r}` : d ? `Table of contents for ${l},${r}` : `Section for Canvas ${m}${l},${r}` : De = `Structure item with label ${m}${l} ${r} starting at ${B} in Canvas ${i}`;
  const Re = De;
  let Me;
  e[39] !== m || e[40] !== D || e[41] !== U ? (Me = () => {
    L(!D), U(m - 1, !D);
  }, e[39] = m, e[40] = D, e[41] = U, e[42] = Me) : Me = e[42];
  const F = Me;
  let P;
  e[43] !== k || e[44] !== $ || e[45] !== F ? (P = (Se) => {
    k(Se), $ && F();
  }, e[43] = k, e[44] = $, e[45] = F, e[46] = P) : P = e[46];
  const ne = P;
  let S;
  e[47] !== k || e[48] !== a || e[49] !== D || e[50] !== x || e[51] !== F ? (S = (Se) => {
    if ((Se.keyCode === 13 || Se.keyCode === 32) && (a != null && k(Se), D && F()), Se.keyCode == 39 && D && F(), Se.keyCode === 37 && !D && (F(), x(Se.target)), Se.keyCode === 39 && !D && T.current) {
      const xe = T.current.querySelectorAll("a.ramp--structured-nav__item-link");
      xe?.length > 0 && (xe[0].focus(), x(xe[0])), Se.stopPropagation();
    }
  }, e[47] = k, e[48] = a, e[49] = D, e[50] = x, e[51] = F, e[52] = S) : S = e[52];
  const he = S;
  let ae;
  e[53] !== k || e[54] !== g || e[55] !== x ? (ae = (Se) => {
    Se.keyCode === 39 && Se.stopPropagation(), Se.keyCode === 37 && g.current && (g.current.focus(), x(g.current)), Se.keyCode === 32 && k(Se);
  }, e[53] = k, e[54] = g, e[55] = x, e[56] = ae) : ae = e[56];
  const te = ae;
  let ee;
  e[57] !== l || e[58] !== D || e[59] !== F ? (ee = () => /* @__PURE__ */ se.jsx("span", { className: "collapse-expand-button", tabIndex: -1, role: "button", "aria-expanded": D ? "false" : "true", "aria-label": `${D ? "Expand" : "Collapse"} ${l} section`, "data-testid": "section-collapse-icon", onClick: F, children: /* @__PURE__ */ se.jsx("i", { className: cn("arrow", D ? "down" : "up") }) }), e[57] = l, e[58] = D, e[59] = F, e[60] = ee) : ee = e[60];
  const ve = ee;
  let Ee;
  if (e[61] !== Re || e[62] !== ve || e[63] !== r || e[64] !== k || e[65] !== te || e[66] !== ne || e[67] !== he || e[68] !== q || e[69] !== f || e[70] !== a || e[71] !== I || e[72] !== $ || e[73] !== u || e[74] !== c || e[75] !== W || e[76] !== d || e[77] !== z || e[78] !== s || e[79] !== m || e[80] !== y || e[81] !== l || e[82] !== b || e[83] !== p || e[84] !== D || e[85] !== g || e[86] !== x || e[87] !== v || e[88] !== h) {
    Ee = Symbol.for("react.early_return_sentinel");
    e: {
      const Se = () => /* @__PURE__ */ se.jsx(Qu, { children: z ? /* @__PURE__ */ se.jsxs("div", { className: cn("ramp--structured-nav__section", "ramp--structured-nav__section-head-buttons", $ ? "active" : ""), "data-testid": "treeitem-section", "data-mediafrag": a ?? "", tabIndex: -1, children: [
        /* @__PURE__ */ se.jsx("button", { "data-testid": a == null ? "treeitem-section-span" : "treeitem-section-button", ref: g, onClick: a != null ? ne : null, onKeyDown: he, "aria-label": Re, role: "button", className: cn("ramp--structured-nav__section-title", a == null && "not-clickable", $ ? "active" : ""), tabIndex: -1, children: /* @__PURE__ */ se.jsxs("span", { className: "ramp--structured-nav__title", "aria-label": l, children: [
          d ? "" : `${m}.`,
          /* @__PURE__ */ se.jsx("span", { className: "ramp--structured-nav__section-label", children: l }),
          r != "" && /* @__PURE__ */ se.jsx("span", { className: "ramp--structured-nav__section-duration", children: r })
        ] }) }),
        q && !d && ve()
      ] }) : /* @__PURE__ */ se.jsx(se.Fragment, { children: s ? /* @__PURE__ */ se.jsx("span", { className: "ramp--structured-nav__item-title", children: l }) : /* @__PURE__ */ se.jsxs(Qu, { children: [
        /* @__PURE__ */ se.jsx("div", { className: "tracker" }),
        u ? /* @__PURE__ */ se.jsxs("a", { role: "button", className: "ramp--structured-nav__item-link", href: f && f != "" ? f : a, "aria-label": Re, onClick: k, onKeyDown: te, tabIndex: -1, children: [
          c && /* @__PURE__ */ se.jsx(t7, {}),
          `${m}.`,
          /* @__PURE__ */ se.jsxs("span", { className: "structured-nav__item-label", "aria-label": l, children: [
            l,
            " ",
            r.length > 0 ? ` (${r})` : ""
          ] })
        ] }) : /* @__PURE__ */ se.jsx("span", { "aria-label": l, children: l })
      ] }, a) }) }, b);
      if (l != "") {
        const xe = z ? "section-tree-item" : "", le = I ? "active" : "";
        let ye;
        e[90] !== xe || e[91] !== le ? (ye = cn("ramp--structured-nav__tree-item", xe, le), e[90] = xe, e[91] = le, e[92] = ye) : ye = e[92];
        let we;
        e[93] !== q || e[94] !== W || e[95] !== y || e[96] !== p || e[97] !== D || e[98] !== g || e[99] !== x || e[100] !== v ? (we = !D && q && /* @__PURE__ */ se.jsx("ul", { className: "ramp--structured-nav__tree", role: "group", "data-testid": "tree-group", children: y.map((Ue, Q) => {
          const M = Ue.isCanvas && !W ? Zn() : g;
          return /* @__PURE__ */ Yu(k0, { ...Ue, key: Q, sectionCount: p, sectionRef: M, structureContainerRef: v, setFocusedItem: x });
        }) }), e[93] = q, e[94] = W, e[95] = y, e[96] = p, e[97] = D, e[98] = g, e[99] = x, e[100] = v, e[101] = we) : we = e[101], Ee = /* @__PURE__ */ se.jsxs("li", { "data-testid": "tree-item", ref: T, role: "treeitem", className: ye, "data-label": l, "data-summary": h, "aria-expanded": y?.length > 0 ? "true" : void 0, "aria-posinset": W ? m : null, children: [
          Se(),
          we
        ] });
        break e;
      }
    }
    e[61] = Re, e[62] = ve, e[63] = r, e[64] = k, e[65] = te, e[66] = ne, e[67] = he, e[68] = q, e[69] = f, e[70] = a, e[71] = I, e[72] = $, e[73] = u, e[74] = c, e[75] = W, e[76] = d, e[77] = z, e[78] = s, e[79] = m, e[80] = y, e[81] = l, e[82] = b, e[83] = p, e[84] = D, e[85] = g, e[86] = x, e[87] = v, e[88] = h, e[89] = Ee;
  } else
    Ee = e[89];
  if (Ee !== Symbol.for("react.early_return_sentinel"))
    return Ee;
};
k0.propTypes = {
  canvasDuration: Le.number.isRequired,
  canvasIndex: Le.number.isRequired,
  duration: Le.string.isRequired,
  id: Le.string,
  isTitle: Le.bool.isRequired,
  isCanvas: Le.bool.isRequired,
  isClickable: Le.bool.isRequired,
  isEmpty: Le.bool.isRequired,
  label: Le.string.isRequired,
  summary: Le.string,
  homepage: Le.string,
  isRoot: Le.bool.isRequired,
  items: Le.array.isRequired,
  itemIndex: Le.number,
  rangeId: Le.string.isRequired,
  sectionCount: Le.number.isRequired,
  sectionRef: Le.object.isRequired,
  structureContainerRef: Le.object.isRequired,
  times: Le.object.isRequired,
  setFocusedItem: Le.func
};
const _F = ({
  showAllSectionsButton: n = !1,
  sectionsHeading: e = "Sections"
}) => {
  const t = fo(), i = Vg(), {
    clickedUrl: r,
    isClicked: a,
    isPlaying: s,
    player: o
  } = Wg(), {
    allCanvases: u,
    canvasDuration: c,
    canvasIndex: l,
    hasMultiItems: h,
    targets: f,
    manifest: d,
    playlist: y,
    canvasIsEmpty: m,
    canvasSegments: b
  } = zr(), {
    showBoundary: p
  } = ho();
  let g = He(), v = He(), _ = He(m), x = He(!1);
  const T = He(), E = He();
  let U = He(!1);
  const D = He(null), L = (q) => {
    D.current = q;
  }, j = He(-1), C = (q) => {
    j.current = q;
  }, k = He(null);
  et(() => {
    if (d)
      try {
        let {
          structures: q,
          timespans: Y,
          markRoot: H,
          hasCollapsibleStructure: K
        } = g6(d, u, y.isPlaylist);
        v.current = q, g.current = q, x.current = H, U.current = K && n && !y.isPlaylist, q?.length > 0 && q[0].isRoot && (g.current = q[0].items), t({
          structures: g.current,
          type: "setStructures"
        }), t({
          timespans: Y,
          type: "setCanvasSegments"
        }), T.current.isScrolling = !1;
      } catch (q) {
        p(q);
      }
  }, [d]), et(() => {
    m && y.isPlaylist && t({
      item: b[l],
      type: "switchItem"
    });
  }, [m, l]), et(() => {
    if (a) {
      const q = b.filter((ie) => ie.id === r);
      if (q?.length > 0) {
        const {
          isCanvas: ie,
          items: ge
        } = q[0];
        (!ie || ge.length == 0 && ie) && t({
          item: q[0],
          type: "switchItem"
        });
      }
      const Y = u.findIndex((ie) => ie.canvasURL === Nc(r)), H = rr(r, c);
      if (!H || H == null) {
        console.error("StructuredNavigation -> invalid media fragment in structure item -> ", H);
        return;
      }
      let K = H.start;
      if (h) {
        const {
          srcIndex: ie,
          fragmentStart: ge
        } = i6(f, H, c);
        K = ge, t({
          srcIndex: ie,
          type: "setSrcIndex"
        });
      } else
        l != Y && Y > -1 && (t({
          canvasIndex: Y,
          type: "switchCanvas"
        }), _.current = g.current[Y].isEmpty);
      o && !_.current ? (o.currentTime(K), i({
        startTime: H.start,
        endTime: H.end,
        type: "setTimeFragment"
      }), o.structStart = K, i({
        currentTime: K,
        type: "setCurrentTime"
      }), s && o.userActive(!0)) : _.current && i({
        type: "resetClick"
      });
    }
  }, [a, o]), et(() => {
    if (T.current) {
      const q = T.current, Y = T.current.parentElement, H = Math.abs(q.scrollHeight - (q.scrollTop + q.clientHeight)) <= 1;
      E.current = !H, Y && $.observe(Y);
    }
  }, [o]);
  const I = (q) => {
    let Y = q.target;
    Y.classList.contains("ramp--structured-nav__border") && (Y = Y.firstChild);
    const H = Y.nextSibling, K = Math.abs(Y.scrollHeight - (Y.scrollTop + Y.clientHeight)) <= 1;
    Y && K && Y.classList.contains("scrollable") ? Y.classList.remove("scrollable") : Y && !K && !Y.classList.contains("scrollable") && Y.classList.add("scrollable"), H && K && H.classList.contains("scrollable") ? H.classList.remove("scrollable") : H && !K && !H.classList.contains("scrollable") && H.classList.add("scrollable");
  }, $ = new ResizeObserver((q) => {
    for (let Y of q)
      I(Y);
  }), W = (q) => {
    T.current.isScrolling = q;
  }, B = (q) => {
    const Y = T.current.querySelectorAll("button.ramp--structured-nav__section-title, a.ramp--structured-nav__item-link");
    if (Y?.length > 0) {
      if (D.current) {
        const K = Array.prototype.indexOf.call(Y, D.current);
        C(K), L(null);
      }
      let H = j.current;
      if (q.key === "ArrowDown")
        H = (j.current + 1) % Y.length, q.preventDefault();
      else if (q.key === "ArrowUp")
        H = (j.current - 1 + Y.length) % Y.length, q.preventDefault();
      else if (q.key === "Tab" && q.shiftKey) {
        T.current.parentElement.parentElement && H < 0 ? T.current.parentElement.parentElement.focus() : (q.preventDefault(), T.current.parentElement.focus());
        return;
      }
      H > -1 && H < Y.length && (Y[j.current] && (Y[j.current].tabIndex = -1), Y[H].tabIndex = 0, Y[H].focus(), C(H));
    }
  }, z = Je(() => v.current?.length || 0, [v.current]);
  return d ? /* @__PURE__ */ se.jsxs("div", { className: cn("ramp--structured-nav", n && !y.isPlaylist ? " display" : ""), role: "complementary", "aria-label": "structured navigation", children: [
    n && !y.isPlaylist && /* @__PURE__ */ se.jsxs("div", { className: "ramp--structured-nav__sections", children: [
      /* @__PURE__ */ se.jsx("span", { "data-testid": "sections-heading-text", className: cn(
        "ramp--structured-nav__sections-text",
        x.current && "hidden"
        // hide 'Sections' text when a root Range exists
      ), children: z > 1 ? `${z} ${e}` : e }),
      U.current && /* @__PURE__ */ se.jsx(xF, { numberOfSections: z })
    ] }),
    /* @__PURE__ */ se.jsxs("div", { className: "ramp--structured-nav__border", tabIndex: -1, children: [
      /* @__PURE__ */ se.jsxs("div", { "data-testid": "structured-nav", className: cn("ramp--structured-nav__content", E.current && "scrollable", y?.isPlaylist && "playlist-items", x.current && "ramp--structured-nav__content-with_root"), ref: T, onScroll: I, onMouseLeave: () => W(!1), onMouseOver: () => W(!0), tabIndex: 0, onKeyDown: B, children: [
        z > 0 ? /* @__PURE__ */ se.jsx("ul", { className: "ramp--structured-nav__tree", role: "tree", "data-testid": "nested-tree", "aria-label": "nested structure tree content", ref: k, children: v.current.map((q, Y) => /* @__PURE__ */ Yu(k0, { ...q, key: Y, sectionCount: z, sectionRef: Zn(), structureContainerRef: T, setFocusedItem: L })) }) : /* @__PURE__ */ se.jsx("p", { className: "ramp--no-structure", children: "There are no structures in the manifest" }),
        /* @__PURE__ */ se.jsx("div", { "aria-live": "assertive", className: "ramp--structured-nav__sr-only" })
      ] }),
      /* @__PURE__ */ se.jsx("span", { className: cn(E.current && "scrollable"), children: "Scroll to see more" })
    ] })
  ] }) : /* @__PURE__ */ se.jsx("p", { children: "No manifest - Please provide a valid manifest." });
};
_F.propTypes = {};
const Q3 = (n) => {
  const e = Et.c(8), {
    fileUrl: t,
    fileName: i,
    machineGenerated: r,
    fileExt: a
  } = n;
  let s;
  e[0] !== a || e[1] !== i || e[2] !== t || e[3] !== r ? (s = (l) => {
    l.preventDefault(), KT(t, i, a, r);
  }, e[0] = a, e[1] = i, e[2] = t, e[3] = r, e[4] = s) : s = e[4];
  const o = s;
  let u;
  e[5] === Symbol.for("react.memo_cache_sentinel") ? (u = /* @__PURE__ */ se.jsx(n7, {}), e[5] = u) : u = e[5];
  let c;
  return e[6] !== o ? (c = /* @__PURE__ */ se.jsx("button", { className: "ramp--transcript_menu_button ramp--transcript_downloader", "data-testid": "transcript-downloader", onClick: o, href: "#", "aria-label": "Transcript download button", children: u }), e[6] = o, e[7] = c) : c = e[7], c;
};
Q3.propTypes = {
  fileUrl: Le.string,
  fileName: Le.string,
  machineGenerated: Le.bool,
  fileExt: Le.string
};
const Z3 = (n) => {
  const e = Et.c(17), {
    selectTranscript: t,
    transcriptData: i,
    transcriptInfo: r,
    noTranscript: a
  } = n, {
    filename: s,
    id: o,
    tUrl: u,
    tFileExt: c,
    isMachineGen: l
  } = r;
  let h;
  e[0] !== t ? (h = (d) => {
    t(d.target.value);
  }, e[0] = t, e[1] = h) : h = e[1];
  const f = h;
  if (i) {
    const d = o || "";
    let y;
    e[2] !== i ? (y = i.map(TF), e[2] = i, e[3] = y) : y = e[3];
    let m;
    e[4] !== f || e[5] !== d || e[6] !== y ? (m = /* @__PURE__ */ se.jsx("select", { "data-testid": "transcript-select-option", value: d, onChange: f, "aria-label": "Select transcripts", "aria-expanded": !1, "aria-haspopup": "true", children: y }), e[4] = f, e[5] = d, e[6] = y, e[7] = m) : m = e[7];
    let b;
    e[8] !== s || e[9] !== l || e[10] !== a || e[11] !== c || e[12] !== u ? (b = !a && /* @__PURE__ */ se.jsx(Q3, { fileUrl: u, fileName: s, fileExt: c, machineGenerated: l }, "transcript-downloader"), e[8] = s, e[9] = l, e[10] = a, e[11] = c, e[12] = u, e[13] = b) : b = e[13];
    let p;
    return e[14] !== m || e[15] !== b ? (p = [/* @__PURE__ */ se.jsxs("div", { "data-testid": "transcript-selector", className: "ramp--transcript_selector", children: [
      m,
      b
    ] }, "transcript-selector")], e[14] = m, e[15] = b, e[16] = p) : p = e[16], p;
  } else
    return null;
};
Z3.propTypes = {
  selectTranscript: Le.func.isRequired,
  transcriptData: Le.array.isRequired,
  transcriptInfo: Le.shape({
    title: Le.string,
    id: Le.string,
    tUrl: Le.string,
    tFileExt: Le.string,
    isMachineGen: Le.bool
  }).isRequired,
  noTranscript: Le.bool.isRequired
};
const J3 = jm(Z3);
function TF(n, e) {
  return /* @__PURE__ */ se.jsx("option", { value: n.id, label: `${n.title}${n.numberOfHits ? " (" + n.numberOfHits + ")" : ""}`, children: `${n.title}${n.numberOfHits ? " (" + n.numberOfHits + ")" : ""}` }, e);
}
const eC = ({
  searchResults: n,
  searchQuery: e = null,
  focusedMatchIndex: t,
  setFocusedMatchIndex: i,
  setSearchQuery: r
}) => {
  const a = He(null);
  et(() => {
    a.current && e && (a.current.value = e);
  }, [!!a.current]);
  const s = Je(() => X3((c) => {
    r(c.target.value);
  }, 100), []), o = e === null || e.replace(/\s/g, "") === "";
  let u = null;
  return o || (n.matchingIds.length === 0 ? u = /* @__PURE__ */ se.jsx("div", { className: "ramp--transcript_search_navigator", children: /* @__PURE__ */ se.jsx("span", { "data-testid": "transcript-search-count", className: "ramp--transcript_search_count", children: "no results found in this transcript" }) }) : t !== null && (u = /* @__PURE__ */ se.jsxs("div", { className: "ramp--transcript_search_navigator", children: [
    /* @__PURE__ */ se.jsx("button", { type: "button", "data-testid": "transcript-search-prev", className: "ramp--transcript_menu_button ramp--transcript_search_prev", disabled: t === 0, title: "Previous Search Result", onClick: (c) => {
      c.preventDefault(), c.stopPropagation(), t > 0 && i(t - 1);
    }, children: /* @__PURE__ */ se.jsx(_T, { flip: !0 }) }),
    /* @__PURE__ */ se.jsxs("span", { className: "ramp--transcript_search_count", "data-testid": "transcript-search-count", children: [
      t + 1,
      " of ",
      n.matchingIds.length,
      " results"
    ] }),
    /* @__PURE__ */ se.jsx("button", { className: "ramp--transcript_menu_button ramp--transcript_search_next", type: "button", "data-testid": "transcript-search-next", disabled: t >= n.matchingIds.length - 1, title: "Next Search Result", onClick: (c) => {
      c.preventDefault(), c.stopPropagation(), t < n.matchingIds.length - 1 && i(t + 1);
    }, children: /* @__PURE__ */ se.jsx(_T, {}) })
  ] }))), /* @__PURE__ */ se.jsxs(se.Fragment, { children: [
    /* @__PURE__ */ se.jsxs("div", { className: "ramp--transcript_search_input", children: [
      /* @__PURE__ */ se.jsx("input", { type: "text", ref: a, "data-testid": "transcript-search-input", "aria-label": "Search the transcript", placeholder: "Search Transcript...", onChange: (c) => {
        c.target.value.trim() == "" ? r(null) : s(c);
      } }),
      !o && /* @__PURE__ */ se.jsx("button", { type: "button", "aria-label": "Clear search query!", "data-testid": "transcript-search-clear", className: "ramp--transcript_menu_button ramp--transcript_search_clear", onClick: () => {
        r(null), a.current && (a.current.value = ""), a.current.focus();
      }, children: /* @__PURE__ */ se.jsx("span", {}) })
    ] }),
    u
  ] });
};
eC.propTypes = {
  setSearchQuery: Le.func.isRequired,
  focusedMatchIndex: Le.number,
  setFocusedMatchIndex: Le.func.isRequired,
  searchQuery: Le.string,
  searchResults: Le.any
};
const wF = "Machine-generated transcript may contain errors.", Bm = (n) => {
  const e = Et.c(33);
  let t, i, r, a, s, o, u, c, l;
  e[0] !== n ? ({
    showSearch: c,
    setAutoScrollEnabled: s,
    autoScrollEnabled: t,
    searchQuery: l,
    setSearchQuery: u,
    searchResults: r,
    focusedMatchIndex: i,
    setFocusedMatchIndex: o,
    ...a
  } = n, e[0] = n, e[1] = t, e[2] = i, e[3] = r, e[4] = a, e[5] = s, e[6] = o, e[7] = u, e[8] = c, e[9] = l) : (t = e[1], i = e[2], r = e[3], a = e[4], s = e[5], o = e[6], u = e[7], c = e[8], l = e[9]);
  const h = l === void 0 ? null : l, {
    transcriptInfo: f
  } = a, {
    tType: d,
    isMachineGen: y
  } = f;
  let m;
  e[10] !== i || e[11] !== h || e[12] !== r || e[13] !== o || e[14] !== u || e[15] !== c ? (m = c && /* @__PURE__ */ se.jsx(eC, { searchResults: r, searchQuery: h, setSearchQuery: u, focusedMatchIndex: i, setFocusedMatchIndex: o }), e[10] = i, e[11] = h, e[12] = r, e[13] = o, e[14] = u, e[15] = c, e[16] = m) : m = e[16];
  let b;
  e[17] !== a ? (b = /* @__PURE__ */ se.jsx(J3, { ...a }), e[17] = a, e[18] = b) : b = e[18];
  let p;
  e[19] !== y ? (p = y && /* @__PURE__ */ se.jsx("p", { className: "ramp--transcript_machine_generated", "data-testid": "transcript-machinegen-msg", children: wF }, "machine-gen-msg"), e[19] = y, e[20] = p) : p = e[20];
  let g;
  e[21] !== t || e[22] !== h || e[23] !== s || e[24] !== d ? (g = d === ct.timedText && /* @__PURE__ */ se.jsxs("div", { className: "ramp--transcript_auto_scroll_check", "data-testid": "transcript-auto-scroll-check", children: [
    /* @__PURE__ */ se.jsx("input", { type: "checkbox", id: "auto-scroll-check", name: "autoscrollcheck", "aria-checked": t, title: h !== null ? "Auto-scroll is disabled when searching" : "", checked: t, disabled: h !== null, onChange: () => {
      s(!t);
    } }),
    /* @__PURE__ */ se.jsx("label", { htmlFor: "auto-scroll-check", title: h !== null ? "Auto-scroll is disabled when searching" : "", children: "Auto-scroll with media" })
  ] }), e[21] = t, e[22] = h, e[23] = s, e[24] = d, e[25] = g) : g = e[25];
  let v;
  e[26] !== p || e[27] !== g ? (v = /* @__PURE__ */ se.jsxs("div", { className: "ramp--transcript_menu-info", children: [
    p,
    g
  ] }), e[26] = p, e[27] = g, e[28] = v) : v = e[28];
  let _;
  return e[29] !== m || e[30] !== b || e[31] !== v ? (_ = /* @__PURE__ */ se.jsxs("div", { className: "ramp--transcript_menu", children: [
    m,
    b,
    v
  ] }), e[29] = m, e[30] = b, e[31] = v, e[32] = _) : _ = e[32], _;
};
Bm.propTypes = {
  showSearch: Le.bool,
  autoScrollEnabled: Le.bool.isRequired,
  setAutoScrollEnabled: Le.func.isRequired,
  ...J3.propTypes,
  ...Bm.propTypes
};
const EF = (n, e, t, i, r) => {
  if (!n || n === void 0) return [];
  let a = [], s = [];
  n.items?.length > 0 && n.items.map((f) => {
    const d = new Ws(f);
    if (d.getMotivation() != tr) return;
    const y = d.getTarget(), m = Nc(y), b = d.getBody()[0].getProperty("value"), p = I0(b, e)?.length;
    s.push({
      target: y,
      targetURI: m,
      value: b,
      hitCount: p
    });
  });
  const o = s6(s, "targetURI"), u = [...Sr.webvtt, ...Sr.srt];
  for (const [h, f] of Object.entries(o)) {
    const d = r.filter((b) => b.url == h)[0].format, y = u.includes(d);
    let m = f;
    y && (m = f.filter((b) => b.target != b.targetURI)), a.push({
      transcriptURL: h,
      numberOfHits: m.reduce((b, p) => b + p.hitCount, 0)
    });
  }
  let c = o[i.url];
  return i.isTimed && c != null && (c = c.filter((h) => h.target != h.targetURI)), {
    matchedTranscriptLines: DF(c, e, t),
    hitCounts: a,
    allSearchHits: o
  };
}, DF = (n, e, t) => {
  const i = e.trim().toLocaleLowerCase();
  let r = [];
  if (n === void 0) return;
  let a = [];
  return n.map((s) => {
    let {
      target: o,
      value: u,
      hitCount: c
    } = s;
    const l = rr(o), h = u.replace(/<\/?[^>]+>/gi, "");
    let f = 0, d = 0, y;
    if (l != null) {
      f = l.start, d = l.end, y = t.findIndex((p) => p.begin == f && p.end == d);
      const m = i.match(/[a-zA-Z]+/gi) ? i.match(/[a-zA-Z]+/gi)[0] : i;
      if (h.toLocaleLowerCase().indexOf(m) !== -1 && y != -1) {
        const p = tC(u, t[y].text, e);
        r.push({
          tag: vt.timedCue,
          begin: f,
          end: d,
          id: y,
          match: p,
          matchCount: c,
          text: t[y].text
        });
      }
    } else {
      const m = SF(t, u, e, a);
      r = [...r, ...m];
    }
  }), r;
}, SF = (n, e, t, i) => {
  const r = qs(e), a = I0(e, t);
  let s = 0, o = [];
  if (n?.length == 1) {
    const {
      id: c,
      text: l,
      textDisplayed: h
    } = n[0], f = h || l;
    if (qs(f).includes(r))
      return i.push(c), [{
        tag: vt.nonTimedLine,
        begin: void 0,
        end: void 0,
        id: c,
        match: tC(e, f, t),
        matchCount: a.length,
        text: f
      }];
  }
  let u = i[i.length - 1] + 1 || 0;
  for (let c = u; c < n.length; c++) {
    const {
      id: l,
      text: h,
      textDisplayed: f
    } = n[c], d = f || h, y = d.length, m = r.indexOf(qs(d), s);
    if (m === -1)
      continue;
    const b = m + y, p = a.filter((v) => v.start < b && v.end > m).map((v) => ({
      start: Math.max(0, v.start - m),
      end: Math.min(y, v.end - m),
      content: v.content
    })), g = iC(d, p);
    i.push(l), o.push({
      tag: vt.nonTimedLine,
      begin: void 0,
      end: void 0,
      id: l,
      match: g,
      matchCount: p.length,
      text: d
    }), s = b;
  }
  return o;
}, tC = (n, e, t) => {
  const i = I0(n, t);
  return iC(e, i);
}, qs = (n) => n.replace(/<[^>]*>/g, ""), I0 = (n, e) => {
  const t = [], i = /<em>(.*?)<\/em>/g;
  let r;
  const a = e.replace(/[^\w']/g, "").toLowerCase(), s = [];
  for (; (r = i.exec(n)) !== null; )
    s.push({
      content: r[1],
      index: r.index,
      fullMatch: r[0]
    });
  if (s.length === 0) return t;
  const o = qs(n);
  let u = 0, c = 0;
  for (const f of s) {
    const d = qs(n.substring(c, f.index)), y = u + d.length, m = y + f.content.length;
    t.push({
      start: y,
      end: m,
      content: f.content
    }), u = m, c = f.index + f.fullMatch.length;
  }
  if (t.length <= 1) return t;
  const l = [];
  let h = 0;
  for (; h < t.length; ) {
    let f = t[h], d = h + 1;
    for (; d < t.length && t[d].start <= f.end + 2 && f.content.replace(/[^\w']/g, "").toLowerCase() != a; ) {
      const y = o.substring(f.end, t[d].start);
      f = {
        start: f.start,
        end: t[d].end,
        content: f.content + y + t[d].content
      }, d++;
    }
    l.push(f), h = d;
  }
  return l;
}, nC = (n) => {
  if (n.nodeType === Node.TEXT_NODE) return n.nodeValue;
  if (n.nodeType === Node.ELEMENT_NODE) {
    let e = "";
    for (let t = n.firstChild; t; t = t.nextSibling)
      e += nC(t);
    return e;
  }
  return "";
}, iC = (n, e) => {
  if (e.length === 0) return n;
  const t = typeof document < "u" ? document.createElement("div") : null;
  t.innerHTML = n;
  function i(r, a, s = 0) {
    if (a.length === 0) return s;
    if (r.nodeType === Node.TEXT_NODE) {
      let o = r.nodeValue, u = [], c = 0, l = a.filter((h) => h.start < s + o.length && h.end > s);
      if (l.length === 0) return s + o.length;
      for (let h = 0; h < l.length; h++) {
        const f = l[h], d = Math.max(0, f.start - s), y = Math.min(o.length, f.end - s);
        c < d && u.push(document.createTextNode(o.slice(c, d)));
        const m = document.createElement("span");
        m.className = "ramp--transcript_highlight", m.textContent = o.slice(d, y), u.push(m), c = y;
      }
      c < o.length && u.push(document.createTextNode(o.slice(c)));
      for (let h of u.reverse())
        r.after(h);
      return r.remove(), s + o.length;
    } else if (r.nodeType === Node.ELEMENT_NODE) {
      const o = nC(r);
      for (const l of a)
        if (o === l.content) {
          const h = document.createElement("span");
          for (h.className = "ramp--transcript_highlight"; r.firstChild; )
            h.appendChild(r.firstChild);
          return r.appendChild(h), s + o.length;
        }
      let u = r.firstChild, c = s;
      for (; u; ) {
        const l = u.nextSibling;
        c = i(u, a, c), u = l;
      }
      return c;
    } else
      return s;
  }
  return i(t, e), t.innerHTML;
}, CF = (n) => {
  const e = n.map((t) => t.text.toLocaleLowerCase());
  return (t, i) => {
    const r = new RegExp(String.raw`${t}`, "i"), a = t.trim().toLocaleLowerCase();
    return {
      matchedTranscriptLines: e.reduce((o, u, c) => {
        const l = u.search(r);
        if (l !== -1) {
          const h = n[c], f = 1, [d, y, m] = [h.text.slice(0, l), h.text.slice(l, l + a.length), h.text.slice(l + a.length)], b = `${d}<span class="ramp--transcript_highlight">${y}</span>${m}`;
          return [...o, {
            ...h,
            score: c,
            match: b,
            matchCount: f
          }];
        } else
          return o;
      }, []),
      hitCounts: [],
      allSearchHits: null
    };
  };
}, AF = (n, e, t, i) => async (r, a) => {
  try {
    var s = new Headers();
    s.append("pragma", "no-cache"), s.append("cache-control", "no-cache");
    const u = await (await fetch(`${n}?q=${r}`, {
      signal: a.signal,
      headers: s
    })).json();
    return u.items?.length > 0 ? EF(u, r, e, t, i) : {
      matchedTranscriptLines: [],
      hitCounts: [],
      allSearchHits: null
    };
  } catch (o) {
    return o.name !== "AbortError" && console.error(o), {
      matchedTranscriptLines: [],
      hitCounts: [],
      allSearchHits: null
    };
  }
}, kF = (n) => n.sort((e, t) => e.id - t.id), aa = {
  initialSearchQuery: null,
  showMarkers: !0,
  matcherFactory: CF,
  sorter: kF,
  matchesOnly: !1
}, IF = (n) => n && n.isSearchable ? {
  ...aa,
  ...n,
  enabled: !0
} : {
  ...aa,
  enabled: !1
};
function UF({
  query: n,
  sorter: e = aa.sorter,
  enabled: t = !0,
  transcripts: i,
  canvasIndex: r,
  selectedTranscript: a,
  canvasTranscripts: s,
  showMarkers: o = aa.showMarkers,
  matchesOnly: u = aa.matchesOnly,
  matcherFactory: c = aa.matcherFactory
}) {
  const [l, h] = $e({
    results: {},
    ids: [],
    matchingIds: [],
    counts: []
  }), [f, d] = $e(), [y, m] = $e(null), [b, p] = $e([]), g = He(null), v = He(0), {
    matcher: _,
    itemsWithIds: x,
    itemsIndexed: T
  } = Je(() => {
    const C = (i || []).map(($, W) => typeof $ == "string" ? {
      text: $,
      id: W
    } : {
      id: W,
      ...$
    }), k = C.reduce(($, W) => ({
      ...$,
      [W.id]: W
    }), {});
    let I = c(C);
    return f != null && f != null && (I = AF(f, C, a, s)), {
      matcher: I,
      itemsWithIds: C,
      itemsIndexed: k
    };
  }, [i, c, a?.url]), E = pt(La), U = pt(Cn);
  et(() => {
    if (U && r >= 0) {
      const {
        manifest: j,
        allCanvases: C
      } = U;
      let k = null;
      C?.length ? k = C[r].searchService : j && (k = rm(j)), d(k);
    }
    m(null);
  }, [r]), et(() => {
    g.current && g.current.abort(), n && D();
  }, [n]), et(() => {
    if (x.length) {
      if (!t || !n) {
        E && E({
          type: "setSearchMarkers",
          payload: []
        });
        const C = e([...x]).map((k) => k.id);
        h({
          ...l,
          results: T,
          matchingIds: [],
          ids: C
        }), n || m(null);
        return;
      }
    } else {
      E && E({
        type: "setSearchMarkers",
        payload: []
      }), h({
        ...l,
        results: {},
        matchingIds: [],
        ids: []
      });
      return;
    }
    const j = b.length > 0 && b.filter((C) => C.url == a.url).length > 0;
    if (y != null && j) {
      const C = b.filter((k) => k.url == a.url)[0];
      L(C.markedSearchHits, l?.counts, y);
    } else
      D();
  }, [_, n, t, e, u, o, E, a]);
  const D = () => {
    v.current || clearTimeout(v.current);
    const j = new AbortController();
    g.current = j, v.current = setTimeout(() => {
      Promise.resolve(_(n, g.current)).then(({
        matchedTranscriptLines: C,
        hitCounts: k,
        allSearchHits: I
      }) => {
        j.signal.aborted || L(C, k, I);
      }).catch((C) => {
        console.error("Search failed: ", n);
      });
    });
  }, L = (j, C = [], k = null) => {
    m(k), p({
      url: a.url,
      markedSearchHits: j
    });
    let I = {
      results: x,
      matchingIds: [],
      ids: e([...x]).map((z) => z.id),
      counts: C?.length > 0 ? C : []
    };
    if (j === void 0) {
      h({
        ...I
      });
      return;
    }
    const $ = j.reduce((z, q) => ({
      ...z,
      [q.id]: q
    }), {}), W = e([...j], !0);
    let B = [];
    if (W.map((z) => {
      if (z.matchCount != null) {
        let q = 0;
        for (; q < z.matchCount; )
          B.push(z.id), q++;
      }
    }), u)
      h({
        ...I,
        results: $,
        ids: B,
        matchingIds: B
      });
    else {
      const z = {
        ...T,
        ...$
      }, q = e(Object.values(z), !1).map((Y) => Y.id);
      if (I = {
        ...I,
        results: z,
        ids: q,
        matchingIds: B
      }, h(I), E)
        if (o) {
          let Y = [];
          (I.matchingIds.length < 25 || n?.length >= 4 && I.matchingIds.length < 45) && (Y = I.matchingIds.map((H) => ({
            time: I.results[H].begin,
            text: "",
            class: "ramp--track-marker--search"
          }))), E({
            type: "setSearchMarkers",
            payload: Y
          });
        } else
          E({
            type: "setSearchMarkers",
            payload: []
          });
    }
  };
  return l;
}
const RF = ({
  searchResults: n,
  canvasTranscripts: e,
  searchQuery: t
}) => {
  if (!n?.counts || e?.length === 0 || t === null)
    return e;
  const i = n.counts;
  let r = [];
  return e.map((a) => {
    const s = i.find((o) => o.transcriptURL === a.url)?.numberOfHits || 0;
    r.push({
      ...a,
      numberOfHits: s
    });
  }), r;
}, OF = (n) => {
  const e = Et.c(17), {
    searchResults: t
  } = n, [i, r] = $e(null), a = i === null ? null : t.matchingIds[i];
  let s;
  e[0] !== t.matchingIds ? (s = (d) => {
    const y = t.matchingIds.indexOf(d);
    r(y !== -1 ? y : null);
  }, e[0] = t.matchingIds, e[1] = s) : s = e[1];
  const o = s;
  let u;
  e[2] !== i || e[3] !== t.matchingIds.length ? (u = () => {
    !t.matchingIds.length && i !== null ? r(null) : t.matchingIds.length && i === null ? r(0) : i !== null && i >= t.matchingIds.length && r(t.matchingIds.length - 1);
  }, e[2] = i, e[3] = t.matchingIds.length, e[4] = u) : u = e[4];
  let c;
  e[5] !== i || e[6] !== t.matchingIds ? (c = [t.matchingIds, i], e[5] = i, e[6] = t.matchingIds, e[7] = c) : c = e[7], et(u, c);
  let l;
  e[8] !== i || e[9] !== t.matchingIds.length ? (l = () => {
    t.matchingIds.length && i > 0 && r(null);
  }, e[8] = i, e[9] = t.matchingIds.length, e[10] = l) : l = e[10];
  let h;
  e[11] !== t.matchingIds ? (h = [t.matchingIds], e[11] = t.matchingIds, e[12] = h) : h = e[12], et(l, h);
  let f;
  return e[13] !== a || e[14] !== i || e[15] !== o ? (f = {
    focusedMatchId: a,
    setFocusedMatchId: o,
    focusedMatchIndex: i,
    setFocusedMatchIndex: r
  }, e[13] = a, e[14] = i, e[15] = o, e[16] = f) : f = e[16], f;
}, LF = (n, e = !1) => {
  let t = e ? n.textDisplayed : n.text;
  return n.match && (t = n.match), n.speaker ? `<u>${n.speaker}:</u> ${t}` : t;
}, PF = jm(({
  item: n,
  goToItem: e,
  isActive: t,
  isFirstItem: i,
  focusedMatchId: r,
  setFocusedMatchId: a,
  autoScrollEnabled: s,
  showMoreSettings: o,
  showNotes: u,
  transcriptContainerRef: c,
  focusedMatchIndex: l
}) => {
  const h = He(null), f = n.id === r, d = He(f), y = He(t), m = He(-1), b = He(-1), p = He(0), g = He(null), v = He(null), {
    textLineLimit: _
  } = o, x = o.enableShowMore && n.tag === vt.timedCue && n.match == null, T = He(!0), E = (q) => T.current = q;
  et(() => {
    let q = !1;
    const Y = b.current;
    t && !y.current ? s && (y.current = !0, q = !0) : y.current = !1, f && !d.current ? (d.current = !0, q = !0) : d.current = !1, q && h.current && Pn(h.current, c, !0), Y < r || Y < 0 || !Y ? p.current = -1 : p.current = n.matchCount, b.current = r;
  }, [s, t, f, h.current]), et(() => {
    if (h.current && f) {
      const q = h.current.querySelectorAll(".ramp--transcript_highlight");
      q.forEach((H) => H.classList.remove("current-hit"));
      const Y = m.current;
      if (p.current = l > Y ? p.current + 1 : p.current <= 0 ? 0 : p.current - 1, p.current > -1) {
        const H = q[p.current];
        H != null && (H.classList.add("current-hit"), Pn(H, c, !0));
      }
      m.current = l;
    }
  }, [l]);
  const U = (q) => {
    if (q.preventDefault(), q.stopPropagation(), q.target.tagName == "A") {
      const Y = /https?:\/\/[^\s/$.?#].[^\s]*/gi, H = q.target.getAttribute("href");
      if (!H?.match(Y))
        q.preventDefault();
      else {
        window.open(H, "_self");
        return;
      }
    }
    n.match && r !== n.id ? a(n.id) : r !== null && n.tag === vt.timedCue && Pn(h.current, c, !0), e(n);
  }, D = Je(() => LF(n, n.tag === vt.nonTimedLine), [n]), {
    handleKeyDown: L,
    handleLinkClicks: j,
    handleLinkKeyDown: C,
    handleShowMoreLessClick: k,
    handleShowMoreLessKeydown: I,
    hasLongerText: $,
    textToShow: W
  } = G3({
    autoScrollEnabled: s,
    enableShowMore: x,
    MAX_LINES: _,
    refs: {
      annotationRef: h,
      annotationTagsRef: null,
      annotationTextsRef: g,
      annotationTimesRef: v,
      containerRef: c
    },
    setIsShowMoreRef: E,
    setIsActive: a,
    texts: D
  }), B = Je(() => /* @__PURE__ */ se.jsxs("div", { className: "ramp--transcript_cue-texts", ref: g, children: [
    W?.length > 0 && /* @__PURE__ */ se.jsx("p", { "data-testid": "transcript_timed_text", className: "ramp--transcript_text", onClick: j, onKeyDown: C, dangerouslySetInnerHTML: {
      __html: W
    } }, `cue-text_${n.id}`),
    $ && x && /* @__PURE__ */ se.jsx("button", { role: "button", "aria-label": T.current ? "show more" : "show less", "aria-pressed": T.current ? "false" : "true", className: "ramp--transcript__show-more-less", "data-testid": `transcript-cue-show-more-${n.id}`, onClick: () => k(T.current, E), onKeyDown: (q) => I(q, T.current, E), children: T.current ? "Show more" : "Show less" }, `cue-show-more_${n.id}`)
  ] }, `cue_${n.id}`), [x, W, $, u]), z = Je(() => {
    switch (n.tag) {
      case vt.note:
        return "transcript_note";
      case vt.metadata:
        return "transcript_metadata";
      case vt.timedCue:
        return "transcript_item";
      case vt.nonTimedLine:
        return "transcript_untimed_text";
      default:
        return null;
    }
  }, [n.tag, u]);
  return n.tag ? /* @__PURE__ */ se.jsxs(
    "span",
    {
      ref: h,
      className: cn("ramp--transcript_item", t && "active", f && "focused", n.tag === vt.nonTimedLine && "untimed", n.tag === vt.metadata && "metadata-block"),
      "data-testid": z,
      tabIndex: i && n.begin == null ? 0 : -1,
      onClick: n.begin == null ? U : null,
      "aria-label": n.begin == null && Zp(D),
      children: [
        n.tag === vt.timedCue && typeof n.begin == "number" && /* @__PURE__ */ se.jsxs("span", { className: "ramp--transcript_time", "data-testid": "transcript_time", role: "button", ref: v, onClick: U, onKeyDown: (q) => L(q, U), tabIndex: i ? 0 : -1, "aria-label": `${wn(n.begin, !0)}, ${Zp(D)}`, children: [
          "[",
          wn(n.begin, !0),
          "]"
        ] }),
        B
      ]
    }
  ) : null;
}), FF = jm(({
  seekPlayer: n,
  currentTime: e,
  searchResults: t,
  focusedMatchId: i,
  transcriptInfo: r,
  setFocusedMatchId: a,
  autoScrollEnabled: s,
  showMoreSettings: o,
  showNotes: u,
  transcriptContainerRef: c,
  focusedMatchIndex: l
}) => {
  const [h, f] = $e(null), d = $t((_) => {
    typeof _.begin == "number" ? (n(_.begin), f(null)) : f(_.id);
  }, [n]), y = Object.keys(ct).find((_) => ct[_] === r.tType), m = He(null), b = Je(() => {
    if (t?.results && Object.values(t.results).length > 0) {
      const _ = Object.values(t.results).find((x) => x.tag != vt.metadata && x.tag != vt.note);
      if (_)
        return _.id;
    }
    return null;
  }, [t]), p = He(0), g = (_) => p.current = _, v = (_) => {
    const x = m.current.querySelectorAll(".ramp--transcript_time"), T = Array.from(m.current.children).filter((U) => U.textContent?.length > 0), E = x?.length || T?.length || 0;
    if (E > 0) {
      let U = p.current;
      _.key === "ArrowDown" ? (U = (p.current + 1) % E, _.preventDefault()) : _.key === "ArrowUp" && (U = (p.current - 1 + E) % E, _.preventDefault()), U !== p.current && (x?.length > 0 ? (x[p.current].tabIndex = -1, x[U].tabIndex = 0, x[U].focus(), Pn(x[U], c)) : T?.length > 0 && (T[p.current].tabIndex = -1, T[U].tabIndex = 0, T[U].focus(), Pn(T[U], c, !0)), g(U));
    }
  };
  return r.tError ? /* @__PURE__ */ se.jsx("p", { id: "no-transcript", "data-testid": "no-transcript", role: "listitem", children: r.tError }, "no-transcript") : !t.results || t.results.length === 0 ? /* @__PURE__ */ se.jsx(ul, {}) : /* @__PURE__ */ se.jsx("div", { "data-testid": `transcript_${y}`, onKeyDown: v, ref: m, "aria-label": "Scrollable transcript cues", children: t.ids.map((_) => /* @__PURE__ */ se.jsx(PF, { goToItem: d, focusedMatchId: i, isActive: h === _ || typeof t.results[_].begin == "number" && t.results[_].tag !== vt.note && t.results[_].tag !== vt.metadata && t.results[_].begin <= e && e <= t.results[_].end, item: t.results[_], isFirstItem: b === _, autoScrollEnabled: s, setFocusedMatchId: a, showNotes: u, showMoreSettings: o, transcriptContainerRef: c, focusedMatchIndex: l }, _)) });
}), NF = ({
  playerID: n,
  manifestUrl: e,
  showMetadata: t = !1,
  showNotes: i = !1,
  showMoreSettings: r = {},
  search: a = {},
  transcripts: s = []
}) => {
  const [o, u] = $e(-1), c = Je(() => Ac(u, 50), []);
  r = {
    ...{
      enableShowMore: !1,
      textLineLimit: 6
    },
    ...r
  };
  const {
    canvasIndexRef: h,
    canvasTranscripts: f,
    isEmpty: d,
    isLoading: y,
    NO_SUPPORT_MSG: m,
    playerRef: b,
    selectedTranscript: p,
    selectTranscript: g,
    transcript: v,
    transcriptInfo: _
  } = o7({
    manifestUrl: e,
    playerID: n,
    setCurrentTime: c,
    showMetadata: t,
    showNotes: i,
    transcripts: s
  }), {
    initialSearchQuery: x,
    ...T
  } = IF({
    ...a,
    isSearchable: _.tType === ct.timedText || _.tType === ct.docx || _.tType === ct.plainText,
    showMarkers: _.tType === ct.timedText
  }), [E, U] = $e(x), D = UF({
    ...T,
    query: E,
    transcripts: v,
    canvasIndex: h.current,
    selectedTranscript: p,
    canvasTranscripts: f
  }), {
    focusedMatchId: L,
    setFocusedMatchId: j,
    focusedMatchIndex: C,
    setFocusedMatchIndex: k
  } = OF({
    searchResults: D
  }), I = RF({
    searchResults: D,
    canvasTranscripts: f,
    searchQuery: E
  }), [$, W] = $e(!0), B = He($), z = (H) => {
    B.current = H, W(H);
  }, q = He(), Y = $t((H) => {
    c(H), b.current && b.current.currentTime(H);
  }, []);
  return y ? /* @__PURE__ */ se.jsx(ul, {}) : /* @__PURE__ */ se.jsxs("div", { className: "ramp--transcript_nav", "data-testid": "transcript_nav", role: "complementary", "aria-label": "transcript display", children: [
    !d && /* @__PURE__ */ se.jsx(Bm, { showSearch: T.enabled, selectTranscript: g, transcriptData: I, transcriptInfo: _, noTranscript: _.tError?.length > 0 && _.tError != m, setAutoScrollEnabled: z, setFocusedMatchIndex: k, focusedMatchIndex: C, autoScrollEnabled: B.current, searchResults: D, searchQuery: E, setSearchQuery: U }),
    /* @__PURE__ */ se.jsx("div", { className: cn("transcript_content", v ? "" : "static"), "data-testid": `transcript_content_${_.tType}`, "aria-label": "Attached Transcript content", ref: q, tabIndex: -1, children: /* @__PURE__ */ se.jsx(FF, { currentTime: o, seekPlayer: Y, searchResults: D, focusedMatchId: L, transcriptInfo: _, setFocusedMatchId: j, autoScrollEnabled: B.current && E === null, showMoreSettings: r, showNotes: i, transcriptContainerRef: q, focusedMatchIndex: C }) })
  ] }, _.title);
};
NF.propTypes = {
  /** `id` attribute of the media player in the DOM */
  playerID: Le.string.isRequired,
  /** URL of the manifest */
  manifestUrl: Le.string,
  showSearch: Le.bool,
  showMetadata: Le.bool,
  showNotes: Le.bool,
  showMoreSettings: Le.shape({
    enableShowMore: Le.bool,
    textLineLimit: Le.number
  }),
  search: Le.oneOf([Le.bool, Le.shape({
    initialSearchQuery: Le.string,
    showMarkers: Le.bool,
    matcherFactory: Le.func,
    sorter: Le.func,
    matchesOnly: Le.bool
  })]),
  /** A list of transcripts for respective canvases in the manifest */
  transcripts: Le.arrayOf(Le.shape({
    /** Index of the canvas in manifest, starts with zero */
    canvasId: Le.number.isRequired,
    /** List of title and URI key value pairs for each individual transcript resource */
    items: Le.arrayOf(Le.shape({
      title: Le.string,
      url: Le.string
    }))
  }))
};
const MF = ({
  displayOnlyCanvasMetadata: n = !1,
  displayAllMetadata: e = !1,
  displayTitle: t = !0,
  showHeading: i = !0,
  itemHeading: r = "Item Details",
  sectionHeaading: a = "Section Details"
}) => {
  const {
    manifest: s,
    canvasIndex: o
  } = zr(), [u, c] = $e(), [l, h] = $e(), [f, d] = $e(), [y, m] = $e(), [b, p] = $e(), [g, v] = $e(), [_, x] = $e(), [T, E] = $e(!1);
  let U = He();
  const D = (I) => {
    h(I), U.current = I;
  };
  et(() => {
    if (s) {
      const I = n || e;
      p(I);
      const $ = !n || e;
      m($);
      const W = p6(s, I);
      if (I && (D(W.canvasMetadata), L()), $) {
        let B = W.manifestMetadata;
        t || (B = B.filter((z) => z.label.toLowerCase() != "title")), c(B), E(B?.length > 0);
      }
      W.rights?.length > 0 && v(W.rights);
    }
  }, [s]), et(() => {
    o >= 0 && b && L();
  }, [o]);
  const L = () => {
    const I = U.current.filter(($) => $.canvasindex === o)[0];
    if (I != null) {
      let {
        metadata: $,
        rights: W
      } = I;
      !t && $ != null && ($ = $.filter((B) => B.label.toLowerCase() != "title")), d($), E($?.length > 0), W != null && W?.length > 0 && x(W);
    }
  }, j = (I) => {
    let $ = [];
    return I?.length > 0 && I.map((W, B) => {
      $.push(/* @__PURE__ */ se.jsxs(Qu, { children: [
        /* @__PURE__ */ se.jsx("dt", { children: W.label }),
        /* @__PURE__ */ se.jsx("dd", { dangerouslySetInnerHTML: {
          __html: W.value
        } })
      ] }, B));
    }), /* @__PURE__ */ se.jsx("dl", { children: $ });
  }, C = Je(() => {
    if (y && u?.length > 0)
      return /* @__PURE__ */ se.jsxs(se.Fragment, { children: [
        e && /* @__PURE__ */ se.jsx("span", { children: r }),
        j(u),
        g?.length > 0 && /* @__PURE__ */ se.jsx("span", { className: "ramp--metadata-rights-heading", "data-testid": "manifest-rights", children: "Rights" }),
        j(g)
      ] });
  }, [u]), k = Je(() => {
    if (b && f?.length > 0)
      return /* @__PURE__ */ se.jsxs(se.Fragment, { children: [
        e && /* @__PURE__ */ se.jsx("span", { children: a }),
        j(f),
        _?.length > 0 && /* @__PURE__ */ se.jsx("span", { className: "ramp--metadata-rights-heading", "data-testid": "canvas-rights", children: "Rights" }),
        j(_)
      ] });
  }, [f]);
  return /* @__PURE__ */ se.jsxs("div", { "data-testid": "metadata-display", className: "ramp--metadata-display", role: "complementary", "aria-label": "metadata display", children: [
    i && /* @__PURE__ */ se.jsx("div", { className: "ramp--metadata-display-title", "data-testid": "metadata-display-title", children: /* @__PURE__ */ se.jsx("h4", { children: "Details" }) }),
    T ? /* @__PURE__ */ se.jsxs("div", { className: "ramp--metadata-display-content", children: [
      C,
      k
    ] }) : /* @__PURE__ */ se.jsx("div", { "data-testid": "metadata-display-message", className: "ramp--metadata-display-message", children: /* @__PURE__ */ se.jsx("p", { children: "No valid Metadata is in the Manifest/Canvas(es)" }) })
  ] });
};
MF.propTypes = {
  displayOnlyCanvasMetadata: Le.bool,
  displayAllMetadata: Le.bool,
  displayTitle: Le.bool,
  showHeading: Le.bool,
  itemHeading: Le.string,
  sectionHeaading: Le.string
};
const KF = ({
  itemHeading: n = "Item files",
  sectionHeading: e = "Section files",
  showHeading: t = !0
}) => {
  const {
    renderings: i
  } = zr(), [r, a] = $e(), [s, o] = $e(), [u, c] = $e(!1), [l, h] = $e(!1), {
    showBoundary: f
  } = ho();
  et(() => {
    try {
      a(i?.manifest);
      let y = i?.canvas, m = 0;
      y && (o(y), m = y.reduce((b, p) => b + p.files.length, 0), c(m > 0)), m > 0 || i?.manifest?.length > 0 ? h(!0) : h(!1);
    } catch (y) {
      f(y);
    }
  }, [i]);
  const d = Je(() => /* @__PURE__ */ se.jsxs(se.Fragment, { children: [
    l && /* @__PURE__ */ se.jsxs("div", { className: "ramp--supplemental-files-display-content", "data-testid": "supplemental-files-display-content", children: [
      Array.isArray(r) && r.length > 0 && /* @__PURE__ */ se.jsxs(se.Fragment, { children: [
        /* @__PURE__ */ se.jsx("h4", { children: n }),
        /* @__PURE__ */ se.jsx("dl", { children: r.map((y, m) => /* @__PURE__ */ se.jsx(Qu, { children: /* @__PURE__ */ se.jsx("dd", { children: /* @__PURE__ */ se.jsx("a", { href: y.id, children: y.label }, m) }, `item-file-${m}`) }, m)) }, "item-files")
      ] }),
      Array.isArray(s) && u && /* @__PURE__ */ se.jsxs(se.Fragment, { children: [
        /* @__PURE__ */ se.jsx("h4", { children: e }),
        s.map((y, m) => {
          let b = y.files;
          return b.length > 0 && /* @__PURE__ */ se.jsxs("dl", { children: [
            /* @__PURE__ */ se.jsx("dt", { children: y.label }, y.label),
            b.map((p, g) => /* @__PURE__ */ se.jsx("dd", { children: /* @__PURE__ */ se.jsx("a", { href: p.id, children: p.label }, g) }, `section-${m}-file-${g}`))
          ] }, `section-${m}-label`);
        })
      ] })
    ] }),
    !l && /* @__PURE__ */ se.jsx("div", { "data-testid": "supplemental-files-empty", className: "ramp--supplemental-files-empty", children: /* @__PURE__ */ se.jsx("p", { children: "No Supplemental file(s) in Manifest" }) })
  ] }), [l, u]);
  return /* @__PURE__ */ se.jsxs("div", { "data-testid": "supplemental-files", className: "ramp--supplemental-files", role: "complementary", "aria-label": "supplemental files", children: [
    t && /* @__PURE__ */ se.jsx("div", { className: "ramp--supplemental-files-heading", "data-testid": "supplemental-files-heading", children: /* @__PURE__ */ se.jsx("h4", { children: "Files" }) }),
    d
  ] });
}, BF = (n) => {
  const e = Et.c(14), {
    label: t,
    showLabel: i
  } = n, r = t === void 0 ? "Autoplay" : t, a = i === void 0 ? !0 : i, {
    autoAdvance: s
  } = zr(), o = fo();
  let u;
  e[0] !== s || e[1] !== o ? (u = (b) => {
    b.target.setAttribute("aria-checked", String(!s)), o({
      autoAdvance: !s,
      type: "setAutoAdvance"
    });
  }, e[0] = s, e[1] = o, e[2] = u) : u = e[2];
  const c = u;
  let l;
  e[3] !== c ? (l = (b) => {
    (b.key === "Enter" || b.key === " ") && (b.preventDefault(), c(b));
  }, e[3] = c, e[4] = l) : l = e[4];
  const h = l, f = String(s);
  let d;
  e[5] !== r || e[6] !== a ? (d = a && /* @__PURE__ */ se.jsx("span", { className: "ramp--auto-advance-label", "data-testid": "auto-advance-label", children: r }), e[5] = r, e[6] = a, e[7] = d) : d = e[7];
  let y;
  e[8] === Symbol.for("react.memo_cache_sentinel") ? (y = /* @__PURE__ */ se.jsx("span", { className: "slider", children: /* @__PURE__ */ se.jsx("span", { "data-testid": "auto-advance-toggle" }) }), e[8] = y) : y = e[8];
  let m;
  return e[9] !== c || e[10] !== h || e[11] !== f || e[12] !== d ? (m = /* @__PURE__ */ se.jsxs("div", { role: "switch", onClick: c, onKeyDown: h, "aria-checked": f, tabIndex: 0, "data-testid": "auto-advance", className: "ramp--auto-advance", children: [
    d,
    y
  ] }), e[9] = c, e[10] = h, e[11] = f, e[12] = d, e[13] = m) : m = e[13], m;
};
BF.propTypes = {
  label: Le.string,
  showLabel: Le.bool
};
const rC = ({
  newMarkerEndpoint: n,
  canvasId: e,
  handleCreate: t,
  csrfToken: i
}) => {
  const [r, a] = $e(!1), [s, o] = $e(!1), [u, c] = $e(!1), [l, h] = $e(""), [f, d] = $e();
  let y;
  const {
    getCurrentTime: m
  } = xo();
  et(() => (a(!1), () => {
    y?.abort();
  }), [e]);
  const b = () => {
    const _ = wn(m(), !0, !0);
    v(_), a(!0);
  }, p = $t((_) => {
    _.preventDefault();
    const x = _.target, T = new FormData(x), {
      label: E,
      time: U
    } = Object.fromEntries(T.entries()), D = {
      type: "Annotation",
      motivation: "highlighting",
      body: {
        type: "TextualBody",
        format: "text/html",
        value: E
      },
      target: `${e}#t=${Ri(U)}`
    }, L = {
      method: "POST",
      /** NOTE: In avalon try this option */
      credentials: "same-origin",
      headers: {
        Accept: "application/json"
        // 'Avalon-Api-Key': '',
      },
      body: JSON.stringify(D)
    };
    i !== void 0 && (L.headers["X-CSRF-Token"] = i), y = new AbortController(), fetch(n, L, {
      signal: y.signal
    }).then((j) => {
      if (j.status != 201)
        throw new Error();
      return j.json();
    }).then((j) => {
      const C = gI(j);
      C && t(C), a(!1);
    }).catch((j) => {
      console.error("CreateMarker -> handleCreateMarker() -> failed to create annotation; ", j), c(!0), h("Marker creation failed.");
    });
  }, [e]), g = $t(() => {
    a(!1), o(!1), h(""), c(!1);
  }), v = (_) => {
    let x = _?.target?.value ?? _;
    d(x);
    let T = YT(x);
    o(T);
  };
  return /* @__PURE__ */ se.jsxs("div", { className: "ramp-markers-display__new-marker", "data-testid": "create-new-marker", children: [
    /* @__PURE__ */ se.jsx("button", { type: "submit", onClick: b, className: "ramp--markers-display__edit-button", "data-testid": "create-new-marker-button", children: "Add New Marker" }),
    r && /* @__PURE__ */ se.jsx("form", { className: "ramp--markers-display__new-marker-form", method: "post", onSubmit: p, "data-testid": "create-new-marker-form", children: /* @__PURE__ */ se.jsx("table", { className: "create-marker-form-table", children: /* @__PURE__ */ se.jsx("tbody", { children: /* @__PURE__ */ se.jsxs("tr", { children: [
      /* @__PURE__ */ se.jsxs("td", { children: [
        /* @__PURE__ */ se.jsx("label", { htmlFor: "new-marker-title", children: "Title:" }),
        /* @__PURE__ */ se.jsx("input", { id: "new-marker-title", "data-testid": "create-marker-title", type: "text", className: "ramp--markers-display__create-marker", name: "label" })
      ] }),
      /* @__PURE__ */ se.jsxs("td", { children: [
        /* @__PURE__ */ se.jsx("label", { htmlFor: "new-marker-time", children: "Time:" }),
        /* @__PURE__ */ se.jsx("input", { id: "new-marker-time", "data-testid": "create-marker-timestamp", type: "text", className: cn("ramp--markers-display__create-marker", s ? "time-valid" : "time-invalid"), name: "time", value: f, onChange: v })
      ] }),
      /* @__PURE__ */ se.jsx("td", { children: /* @__PURE__ */ se.jsxs("div", { className: "marker-actions", children: [
        u && /* @__PURE__ */ se.jsx("p", { className: "ramp--markers-display__error-message", children: l }),
        /* @__PURE__ */ se.jsxs("button", { type: "submit", className: "ramp--markers-display__edit-button", "data-testid": "edit-save-button", disabled: !s, children: [
          /* @__PURE__ */ se.jsx(Nm, {}),
          " Save"
        ] }),
        /* @__PURE__ */ se.jsxs("button", { className: "ramp--markers-display__edit-button-danger", "data-testid": "edit-cancel-button", onClick: g, children: [
          /* @__PURE__ */ se.jsx(Mm, {}),
          " Cancel"
        ] })
      ] }) })
    ] }) }) }) })
  ] });
};
rC.propTypes = {
  newMarkerEndpoint: Le.string.isRequired,
  canvasId: Le.string,
  handleCreate: Le.func.isRequired,
  csrfToken: Le.string
};
const aC = ({
  marker: n,
  handleSubmit: e,
  handleDelete: t,
  toggleIsEditing: i,
  csrfToken: r
}) => {
  const [a, s] = $e(!1), [o, u] = $e(!0), [c, l] = $e(), [h, f] = $e(!1), [d, y] = $e(!1), [m, b] = $e("");
  let p;
  const {
    hasAnnotationService: g,
    isDisabled: v
  } = i7(), {
    player: _
  } = xo();
  et(() => () => {
    p?.abort();
  }, []), et(() => {
    T(n.value), D(n.timeStr);
  }, [n]);
  let x = He(n.value);
  const T = (q) => {
    x.current = q;
  };
  let E = He(Ri(n.timeStr)), U = He(n.timeStr);
  const D = (q) => {
    U.current = q, E.current = Ri(q);
  }, L = () => {
    l({
      time: U.current,
      label: x.current
    }), s(!0), i(!0);
  }, j = () => {
    D(c.time), T(c.label), l({}), W(), B();
  }, C = () => {
    const q = {
      type: "Annotation",
      motivation: "highlighting",
      body: {
        type: "TextualBody",
        format: "text/html",
        value: x.current
      },
      id: n.id,
      target: `${n.canvasId}#t=${Ri(U.current)}`
    }, Y = {
      method: "PUT",
      /** NOTE: In avalon try this option */
      credentials: "same-origin",
      headers: {
        Accept: "application/json"
        // 'Avalon-Api-Key': '',
      },
      body: JSON.stringify(q)
    };
    r !== void 0 && (Y.headers["X-CSRF-Token"] = r), p = new AbortController(), fetch(n.id, Y, {
      signal: p.signal
    }).then((H) => {
      if (H.status != 201)
        throw new Error();
      e(x.current, U.current, n.id), W(), B();
    }).catch((H) => {
      console.error("MarkerRow -> handleEditSubmit -> failed to update annotation; ", H), y(!0), b("Marker update failed");
    });
  }, k = (q) => {
    let Y = YT(q);
    u(Y), D(q);
  }, I = () => {
    f(!0), i(!0);
  }, $ = () => {
    const q = {
      method: "DELETE",
      /** NOTE: In avalon try this option */
      credentials: "same-origin",
      headers: {
        Accept: "application/json"
        // 'Avalon-Api-Key': '',
      }
    };
    r !== void 0 && (q.headers["X-CSRF-Token"] = r), p = new AbortController(), fetch(n.id, q, {
      signal: p.signal
    }).then((Y) => {
      if (Y.status != 200)
        throw new Error();
      t(n.id), W(), B();
    }).catch((Y) => {
      console.error("MarkerRow -> submitDelete() -> failed to delete annotation; ", Y), B(), y(!0), b("Marker delete failed."), setTimeout(() => {
        W();
      }, 1500);
    });
  }, W = () => {
    y(!1), b("");
  }, B = () => {
    f(!1), s(!1), i(!1);
  }, z = $t((q) => {
    q.preventDefault();
    const Y = parseFloat(q.target.dataset.offset);
    if (_) {
      const {
        start: H,
        end: K
      } = _.targets[0];
      switch (!0) {
        case (Y >= H && Y <= K):
          _.currentTime(Y);
          break;
        case Y < H:
          _.currentTime(H);
          break;
        case Y > K:
          _.currentTime(K);
          break;
      }
    }
  }, [_]);
  return a ? /* @__PURE__ */ se.jsxs("tr", { children: [
    /* @__PURE__ */ se.jsx("td", { children: /* @__PURE__ */ se.jsx("input", { id: "marker-edit-label", "data-testid": "edit-label", defaultValue: x.current, type: "text", className: "ramp--markers-display__edit-marker", onChange: (q) => T(q.target.value), name: "label" }) }),
    /* @__PURE__ */ se.jsx("td", { children: /* @__PURE__ */ se.jsx("input", { className: cn("ramp--markers-display__edit-marker", o ? "time-valid" : "time-invalid"), id: "marker-edit-time", "data-testid": "edit-timestamp", defaultValue: U.current, type: "text", onChange: (q) => k(q.target.value), name: "time" }) }),
    /* @__PURE__ */ se.jsx("td", { children: /* @__PURE__ */ se.jsxs("div", { className: "marker-actions", children: [
      d && /* @__PURE__ */ se.jsx("p", { className: "ramp--markers-display__error-message", children: m }),
      /* @__PURE__ */ se.jsxs("button", { type: "submit", onClick: C, disabled: !o, className: "ramp--markers-display__edit-button", "data-testid": "edit-save-button", children: [
        /* @__PURE__ */ se.jsx(Nm, {}),
        " Save"
      ] }),
      /* @__PURE__ */ se.jsxs("button", { className: "ramp--markers-display__edit-button-danger", "data-testid": "edit-cancel-button", onClick: j, children: [
        /* @__PURE__ */ se.jsx(Mm, {}),
        " Cancel"
      ] })
    ] }) })
  ] }) : h ? /* @__PURE__ */ se.jsxs("tr", { children: [
    /* @__PURE__ */ se.jsx("td", { children: /* @__PURE__ */ se.jsx("a", { href: `${n.canvasId}#t=${E.current},`, onClick: (q) => z(q), "data-offset": E.current, children: x.current }) }),
    /* @__PURE__ */ se.jsx("td", { children: U.current }),
    /* @__PURE__ */ se.jsx("td", { children: /* @__PURE__ */ se.jsxs("div", { className: "marker-actions", children: [
      /* @__PURE__ */ se.jsx("p", { children: "Are you sure?" }),
      /* @__PURE__ */ se.jsxs("button", { type: "submit", className: "ramp--markers-display__edit-button-danger", "data-testid": "delete-confirm-button", onClick: $, children: [
        /* @__PURE__ */ se.jsx(Nm, {}),
        " Yes"
      ] }),
      /* @__PURE__ */ se.jsxs("button", { className: "ramp--markers-display__edit-button", "data-testid": "delete-cancel-button", onClick: B, children: [
        /* @__PURE__ */ se.jsx(Mm, {}),
        " Cancel"
      ] })
    ] }) })
  ] }) : /* @__PURE__ */ se.jsxs("tr", { children: [
    /* @__PURE__ */ se.jsx("td", { children: /* @__PURE__ */ se.jsx("a", { href: `${n.canvasId}#t=${E.current},`, onClick: (q) => z(q), "data-offset": E.current, children: x.current }) }),
    /* @__PURE__ */ se.jsx("td", { children: U.current }),
    g && /* @__PURE__ */ se.jsx("td", { children: /* @__PURE__ */ se.jsxs("div", { className: "marker-actions", children: [
      d && /* @__PURE__ */ se.jsx("p", { className: "ramp--markers-display__error-message", children: m }),
      /* @__PURE__ */ se.jsxs("button", { onClick: L, className: "ramp--markers-display__edit-button", "data-testid": "edit-button", disabled: v, children: [
        /* @__PURE__ */ se.jsx(JP, {}),
        " Edit"
      ] }),
      /* @__PURE__ */ se.jsxs("button", { className: "ramp--markers-display__edit-button-danger", "data-testid": "delete-button", disabled: v, onClick: I, children: [
        /* @__PURE__ */ se.jsx(e7, {}),
        " Delete"
      ] })
    ] }) })
  ] });
};
aC.propTypes = {
  marker: Le.object.isRequired,
  handleSubmit: Le.func.isRequired,
  handleDelete: Le.func.isRequired,
  toggleIsEditing: Le.func.isRequired,
  csrfToken: Le.string
};
const sC = ({
  canvasAnnotationSets: n = [],
  duration: e = 0,
  setDisplayedAnnotationSets: t,
  setAutoScrollEnabled: i,
  autoScrollEnabled: r
}) => {
  const [a, s] = $e([]), [o, u] = $e(!1), [c, l] = $e([]), h = He(null), f = He(null), d = He(null), [y, m] = $e(!1), b = He(!1), p = (W) => {
    b.current = W, m(W);
  }, g = () => p(!b.current), v = He(0), _ = (W) => v.current = W;
  et(() => {
    if (s([]), t([]), u(!1), p(!1), n?.length > 0) {
      const W = n.sort((B, z) => B.label.localeCompare(z.label));
      l(W), T(W[0]);
    } else
      l([]);
    return document.addEventListener("click", j), () => {
      document.removeEventListener("click", j);
    };
  }, [n]);
  const x = $t((W) => a.includes(W.label), [a]), T = async (W) => {
    let B = W.items;
    if (!x(W)) {
      if (W.url && !W.items)
        if (W?.linkedResource)
          B = await lI(W);
        else {
          let z = await aI(W.url, e);
          B = z?.length > 0 ? z[0].items : [];
        }
      U(W, B);
    }
  }, E = (W) => {
    s((B) => B.filter((z) => z !== W.label)), t((B) => B.filter((z) => z.label != W.label));
  }, U = (W, B) => {
    B != null && (W.items = B, s((z) => [...z, W.label]), t((z) => [...z, W]));
  }, D = async (W) => {
    const B = !o;
    u(B), B ? await Promise.all(c.map((z) => {
      T(z);
    })) : (s([]), t([])), W.stopPropagation(), g();
  }, L = async (W) => {
    T(W), x(W) && E(W);
  }, j = (W) => {
    !h?.current?.contains(W.target) && b.current && p(!1);
  }, C = (W) => {
    const B = () => {
      if (b.current && d.current) {
        const z = d.current.children;
        (W.key === "Home" || W.key === "PageUp") && z?.length > 0 && (z[0].focus(), _(0)), (W.key === "End" || W.key === "PageDown") && z?.length > 0 && (z[z.length - 1].focus(), _(z.length - 1));
      }
    };
    switch (W.key) {
      case "Enter":
      case " ":
        W.preventDefault(), g();
        break;
      case "ArrowDown":
      case "ArrowUp":
        b.current || p(!0);
        const z = document.querySelector(".annotations-dropdown-item");
        z && (W.preventDefault(), z.focus(), _(0));
        break;
      case "Home":
      case "PageUp":
      case "End":
      case "PageDown":
        B();
        break;
      case "Escape":
        W.preventDefault(), b.current && g();
        break;
      default:
        if (W.ctrlKey || W.altKey || W.metaKey || W.shiftKey || W.key.length > 1)
          return;
        b.current || p(!0), I(W);
        break;
    }
  }, k = (W) => {
    const B = d.current.children;
    let z = v.current;
    switch (W.key) {
      case "Enter":
      case " ":
        W.preventDefault();
        const q = c.filter((Y) => W.target.id == Y.label)[0];
        q != null ? L(q) : D(W);
        break;
      case "ArrowDown":
        W.preventDefault(), z = (v.current + 1) % B.length;
        break;
      case "ArrowUp":
        W.preventDefault(), z = (v.current - 1 + B.length) % B.length;
        break;
      case "Home":
      case "PageUp":
        W.preventDefault(), z = 0;
        break;
      case "End":
      case "PageDown":
        W.preventDefault(), z = B.length - 1;
        break;
      case "Escape":
        W.preventDefault(), g(), f.current.focus();
        break;
      case "Tab":
        g();
        break;
      default:
        I(W);
        break;
    }
    z !== v.current && (B[z].focus(), B[z].scrollIntoView(), _(z));
  }, I = (W) => {
    const B = W.key, z = B.length === 1 && B.match(/\S/);
    setTimeout(() => {
      if (z && d.current) {
        const q = d.current.children, Y = q.length > 1;
        for (let H in q)
          if (!(Y && H == 0) && q[H].textContent?.trim()[0].toLowerCase() === B) {
            q[H].focus(), _(H);
            break;
          }
      }
    }, 0);
  }, $ = (W) => {
    (W.key == " " || W.key == "Enter") && (W.preventDefault(), i((B) => !B));
  };
  return c?.length > 0 ? /* @__PURE__ */ se.jsxs("div", { className: "ramp--annotations__select", children: [
    /* @__PURE__ */ se.jsx("label", { children: "Annotation sets: " }),
    /* @__PURE__ */ se.jsxs("div", { className: "ramp--annotations__multi-select", "data-testid": "annotation-multi-select", ref: h, children: [
      /* @__PURE__ */ se.jsxs("span", { className: "ramp--annotations__multi-select-header", onClick: g, onKeyDown: C, "aria-haspopup": !0, "aria-expanded": y, "aria-controls": "annotations-dropdown-menu", id: "dropdown-button", role: "button", tabIndex: 0, ref: f, children: [
        a.length > 0 ? `${a.length} of ${c.length} sets selected` : "Select Annotation set(s)",
        /* @__PURE__ */ se.jsx("span", { className: `annotations-dropdown-arrow ${y ? "open" : ""}`, children: "" })
      ] }),
      y && /* @__PURE__ */ se.jsxs("ul", {
        className: "annotations-dropdown-menu",
        role: "listbox",
        "aria-labelledby": "dropdown-button",
        "aria-multiselectable": !0,
        tabIndex: -1,
        ref: d,
        // Only show select all option when there's more than one annotation set
        children: [
          c?.length > 1 && /* @__PURE__ */ se.jsx("li", { className: "annotations-dropdown-item", role: "option", tabIndex: 0, "aria-selected": o, onKeyDown: k, id: "select-all-annotation-sets", children: /* @__PURE__ */ se.jsxs("label", { children: [
            /* @__PURE__ */ se.jsx("input", { type: "checkbox", "aria-checked": o, checked: o, onChange: D, tabIndex: 0, role: "checkbox" }),
            "Show all Annotation sets"
          ] }) }, "select-all"),
          c.map((W, B) => /* @__PURE__ */ se.jsx("li", { className: "annotations-dropdown-item", role: "option", tabIndex: 0, "aria-selected": x(W), onKeyDown: k, id: W.label, children: /* @__PURE__ */ se.jsxs("label", { children: [
            /* @__PURE__ */ se.jsx("input", { type: "checkbox", "aria-checked": x(W), checked: x(W), onChange: () => L(W), tabIndex: 0, role: "checkbox" }),
            W.label
          ] }) }, `annotaion-set-${B}`))
        ]
      }),
      /* @__PURE__ */ se.jsxs("div", { className: "ramp--annotations__scroll", "data-testid": "annotations-scroll", children: [
        /* @__PURE__ */ se.jsx("input", { type: "checkbox", id: "scroll-check", name: "scrollcheck", "aria-checked": r, title: "Auto-scroll with media", checked: r, onChange: () => {
          i(!r);
        }, onKeyDown: $ }),
        /* @__PURE__ */ se.jsx("label", { htmlFor: "scroll-check", title: "Auto-scroll with media", children: "Auto-scroll with media" })
      ] })
    ] })
  ] }) : null;
};
sC.propTypes = {
  canvasAnnotationSets: Le.array.isRequired,
  duration: Le.number.isRequired,
  setDisplayedAnnotationSets: Le.func.isRequired,
  setAutoScrollEnabled: Le.func.isRequired,
  autoScrollEnabled: Le.bool.isRequired
};
const oC = ({
  annotation: n,
  autoScrollEnabled: e,
  containerRef: t,
  displayedAnnotations: i,
  displayMotivations: r,
  index: a,
  showMoreSettings: s
}) => {
  const {
    canvasId: o,
    motivation: u,
    time: c,
    value: l
  } = n, {
    enableShowMore: h,
    textLineLimit: f
  } = s, [d, y] = $e(!1), {
    player: m,
    currentTime: b
  } = xo(), {
    checkCanvas: p,
    inPlayerRange: g
  } = u7({
    canvasId: o,
    annotationId: n.id,
    startTime: c?.start,
    endTime: c?.end,
    currentTime: b,
    displayedAnnotations: i
  }), v = He(null), _ = He(null), x = He(null), T = He(null), E = He(null), U = He(!0), D = (oe) => U.current = oe, L = Je(() => l.filter((oe) => oe.purpose.includes("tagging")), [l]), j = Je(() => {
    const oe = l.filter((De) => oc.some((Re) => De.purpose.includes(Re)));
    return oe?.length > 0 ? oe.map((Re) => Re.value).join("<br>") : "";
  }, [l]), C = Je(() => r?.length > 0 ? r.some((oe) => u.includes(oe)) : !0, [n, r]), {
    handleKeyDown: k,
    handleLinkClicks: I,
    handleLinkKeyDown: $,
    handleShowMoreLessClick: W,
    handleShowMoreLessKeydown: B,
    hasLongerTags: z,
    hasLongerText: q,
    setShowMoreTags: Y,
    showMoreTags: H,
    textToShow: K,
    toggleTagsView: ie
  } = G3({
    autoScrollEnabled: e,
    enableShowMore: h,
    inPlayerRange: g,
    MAX_LINES: f,
    refs: {
      annotationRef: v,
      annotationTagsRef: _,
      annotationTextsRef: T,
      annotationTimesRef: x,
      containerRef: t,
      moreTagsButtonRef: E
    },
    setIsShowMoreRef: D,
    setIsActive: y,
    tags: L,
    texts: j
  }), ge = $t((oe) => {
    oe.preventDefault(), p(n);
    const De = c?.start;
    if (m && m?.targets?.length > 0) {
      const {
        start: Re,
        end: Me
      } = m.targets[0];
      switch (!0) {
        case (De >= Re && De <= Me):
          m.currentTime(De);
          break;
        case De < Re:
          m.currentTime(Re);
          break;
        case De > Me:
          m.currentTime(Me);
          break;
      }
    }
  }, [n, m]), pe = () => {
    const oe = !H;
    ie(oe), Y(oe), oe && Pn(v.current, t, !0);
  }, ce = (oe) => {
    (oe.key === " " || oe.key === "Enter") && (oe.preventDefault(), pe());
  };
  return C ? /* @__PURE__ */ se.jsxs("div", { ref: v, "data-testid": "annotation-row", className: cn("ramp--annotations__annotation-row", d && "active"), "aria-label": Zp(K), children: [
    /* @__PURE__ */ se.jsxs("div", { role: "button", tabIndex: a === 0 ? 0 : -1, onClick: ge, onKeyDown: (oe) => k(oe, ge), "data-testid": "annotation-row-button", className: "ramp--annotations__annotation-row-time-tags", children: [
      /* @__PURE__ */ se.jsxs("div", { className: "ramp--annotations__annotation-times", ref: x, children: [
        c?.start != null && /* @__PURE__ */ se.jsx("span", { className: "ramp--annotations__annotation-start-time", "data-testid": "annotation-start-time", children: wn(c?.start, !0, !0) }),
        c?.end != null && /* @__PURE__ */ se.jsx("span", { className: "ramp--annotations__annotation-end-time", "data-testid": "annotation-end-time", children: ` - ${wn(c?.end, !0, !0)}` })
      ] }, `times_${a}`),
      /* @__PURE__ */ se.jsxs("div", { className: "ramp--annotations__annotation-tags", "data-testid": `annotation-tags-${a}`, ref: _, children: [
        L?.length > 0 && L.map((oe, De) => /* @__PURE__ */ se.jsx("p", { className: "ramp--annotations__annotation-tag", "data-testid": `annotation-tag-${De}`, style: {
          backgroundColor: oe.tagColor
        }, children: oe.value }, `tag_${De}`)),
        z && /* @__PURE__ */ se.jsx("button", { role: "button", "aria-label": H ? "Show hidden tags" : "Hide overflowing tags", "aria-pressed": H ? "false" : "true", className: "ramp--annotations__show-more-tags", "data-testid": `show-more-annotation-tags-${a}`, onClick: pe, onKeyDown: ce, ref: E, children: /* @__PURE__ */ se.jsx("i", { className: `arrow ${H ? "right" : "left"}` }) }, `show-more-tags_${a}`)
      ] }, `tags_${a}`)
    ] }, `row_${a}`),
    /* @__PURE__ */ se.jsxs("div", { className: "ramp--annotations__annotation-texts", ref: T, children: [
      K?.length > 0 && /* @__PURE__ */ se.jsx("p", { "data-testid": `annotation-text-${a}`, className: "ramp--annotations__annotation-text", onClick: I, onKeyDown: $, dangerouslySetInnerHTML: {
        __html: K
      } }, `text_${a}`),
      q && h && /* @__PURE__ */ se.jsx("button", { role: "button", "aria-label": U.current ? "show more" : "show less", "aria-pressed": U.current ? "false" : "true", className: "ramp--annotations__show-more-less", "data-testid": `annotation-show-more-${a}`, onClick: () => W(U.current, D), onKeyDown: (oe) => B(oe, U.current, D), children: U.current ? "Show more" : "Show less" }, `show-more_${a}`)
    ] }, `text_${a}`)
  ] }, `li_${a}`) : null;
};
oC.propTypes = {
  annotation: Le.object.isRequired,
  autoScrollEnabled: Le.bool.isRequired,
  containerRef: Le.object.isRequired,
  displayedAnnotations: Le.array,
  displayMotivations: Le.array.isRequired,
  index: Le.number,
  showMoreSettings: Le.object.isRequired
};
const uC = ({
  annotations: n,
  canvasIndex: e,
  duration: t,
  displayMotivations: i,
  showMoreSettings: r
}) => {
  const [a, s] = $e([]), [o, u] = $e([]), [c, l] = $e(!0), [h, f] = $e(!0), d = He(null), y = He(null), m = He(0), b = (U) => m.current = U;
  et(() => {
    if (f(!0), n?.length > 0) {
      const {
        _: U,
        annotationSets: D
      } = n.filter((L) => L.canvasIndex === e)[0];
      D?.length > 0 && s(D.filter((L) => L.timed));
    }
  }, [n, e]);
  const p = Je(() => o?.length > 0 ? QT(o.map((U) => U.items).flat()) : [], [o]), g = Je(() => o?.length > 0 ? o.map((U) => U.linkedResource).reduce((U, D) => U || D, !1) : !1, [o]), v = (U, D, L) => {
    if (L?.aborted)
      return;
    const j = setTimeout(() => {
      L?.aborted || U();
    }, D);
    L?.addEventListener("abort", () => {
      clearTimeout(j);
    });
  }, _ = Je(() => {
    let U;
    if (p?.length > 0 && p[0] != null) {
      U?.abort(), f(!1);
      const D = p.map((L) => L.motivation);
      return i?.length > 0 ? i.some((L) => D.flat().includes(L)) : oc.some((L) => D.flat().includes(L));
    } else
      return U?.abort(), U = new AbortController(), g && v(() => {
        f(!1);
      }, 500, U.signal), !1;
  }, [p]), x = Je(() => /* @__PURE__ */ se.jsx(sC, { canvasAnnotationSets: a, duration: t, setDisplayedAnnotationSets: u, setAutoScrollEnabled: l, autoScrollEnabled: c }, e), [c, a]), T = (U) => {
    const D = y.current.querySelectorAll(".ramp--annotations__annotation-row-time-tags");
    if (D?.length > 0) {
      let L = m.current;
      U.key === "ArrowDown" ? (L = (m.current + 1) % D.length, U.preventDefault()) : U.key === "ArrowUp" && (L = (m.current - 1 + D.length) % D.length, U.preventDefault()), L !== m.current && (D[m.current].tabIndex = -1, D[L].tabIndex = 0, D[L].focus(), Pn(D[L], d, !0), b(L));
    }
  }, E = Je(() => h ? /* @__PURE__ */ se.jsx(ul, {}) : _ && p?.length > 0 ? /* @__PURE__ */ se.jsx("div", { onKeyDown: T, ref: y, "aria-label": "Scrollable time-synced annotations list", children: p.map((U, D) => /* @__PURE__ */ se.jsx(oC, { annotation: U, displayMotivations: i, autoScrollEnabled: c, containerRef: d, displayedAnnotations: p, showMoreSettings: r, index: D }, D)) }) : /* @__PURE__ */ se.jsx("p", { "data-testid": "no-annotations-message", children: i?.length > 0 ? `No Annotations were found with ${i.join("/")} motivation.` : "No Annotations were found for the selected set(s)." }), [_, p, h, c]);
  return a?.length > 0 ? /* @__PURE__ */ se.jsxs("div", { className: "ramp--annotations__list", "data-testid": "annotations-list", children: [
    x,
    /* @__PURE__ */ se.jsx("div", { className: "ramp--annotations__content", "data-testid": "annotations-content", tabIndex: -1, ref: d, children: E })
  ] }) : /* @__PURE__ */ se.jsx("p", { "data-testid": "no-annotation-sets-message", children: "No Annotations sets were found for the Canvas." });
};
uC.propTypes = {
  annotations: Le.array.isRequired,
  canvasIndex: Le.number.isRequired,
  displayMotivations: Le.array.isRequired,
  duration: Le.number.isRequired,
  showMoreSettings: Le.object.isRequired
};
const jF = ({
  displayMotivations: n = [],
  headingText: e = "Annotations",
  showHeading: t = !0,
  showMoreSettings: i
}) => {
  i = {
    ...{
      enableShowMore: !1,
      textLineLimit: 6
    },
    ...i
  };
  const {
    allCanvases: a,
    annotations: s,
    canvasDuration: o,
    canvasIndex: u,
    playlist: c
  } = zr(), l = fo();
  c7();
  const {
    annotationServiceId: h,
    hasAnnotationService: f,
    isPlaylist: d,
    markers: y
  } = c, [m, b] = $e([]), {
    showBoundary: p
  } = ho(), g = He();
  let v = He([]);
  const _ = (C) => {
    b(...C), v.current = C;
  }, x = document.getElementsByName("csrf-token")[0]?.content;
  et(() => {
    try {
      if (d && y?.length > 0) {
        const C = y.filter((k) => k.canvasIndex === u);
        C?.length > 0 ? _(C[0].canvasMarkers) : _([]);
      }
      a != null && a?.length > 0 && (g.current = a[u].canvasId);
    } catch (C) {
      p(C);
    }
  }, [d, u, y]);
  const T = $t((C, k, I) => {
    let $ = v.current.map((W) => (W.id === I && (W.value = C, W.timeStr = k, W.time = Ri(k)), W));
    _($), l({
      updatedMarkers: $,
      type: "setPlaylistMarkers"
    });
  }), E = $t((C) => {
    let k = v.current.filter((I) => I.id != C);
    _(k), l({
      updatedMarkers: k,
      type: "setPlaylistMarkers"
    });
  }), U = $t((C) => {
    _([...v.current, C]), l({
      updatedMarkers: v.current,
      type: "setPlaylistMarkers"
    });
  }), D = $t((C) => {
    l({
      isEditing: C,
      type: "setIsEditing"
    });
  }), L = Je(() => {
    if (f)
      return /* @__PURE__ */ se.jsx(rC, { newMarkerEndpoint: h, canvasId: g.current, handleCreate: U, csrfToken: x });
  }, [f, g.current, x]), j = Je(() => {
    if (v.current.length > 0)
      return /* @__PURE__ */ se.jsxs("table", { className: "ramp--markers-display_table", "data-testid": "markers-display-table", children: [
        /* @__PURE__ */ se.jsx("thead", { children: /* @__PURE__ */ se.jsxs("tr", { children: [
          /* @__PURE__ */ se.jsx("th", { children: /* @__PURE__ */ se.jsx("label", { htmlFor: "marker-edit-label", children: "Name" }) }),
          /* @__PURE__ */ se.jsx("th", { children: /* @__PURE__ */ se.jsx("label", { htmlFor: "marker-edit-time", children: "Time" }) }),
          f && /* @__PURE__ */ se.jsx("th", { children: "Actions" })
        ] }) }),
        /* @__PURE__ */ se.jsx("tbody", { children: v.current.map((C, k) => /* @__PURE__ */ se.jsx(aC, { marker: C, handleSubmit: T, handleDelete: E, toggleIsEditing: D, csrfToken: x }, k)) })
      ] });
  }, [v.current]);
  return /* @__PURE__ */ se.jsxs("div", { className: "ramp--annotations-display", "data-testid": "annotations-display", role: "complementary", "aria-label": "annotations display", children: [
    t && /* @__PURE__ */ se.jsx("div", { className: "ramp--annotations__title", "data-testid": "annotations-display-title", children: /* @__PURE__ */ se.jsx("h4", { children: e }) }),
    d && /* @__PURE__ */ se.jsxs(se.Fragment, { children: [
      L,
      j
    ] }),
    s?.length > 0 && !d && /* @__PURE__ */ se.jsx(uC, { annotations: s, canvasIndex: u, displayMotivations: n, duration: o, showMoreSettings: i })
  ] });
};
jF.propTypes = {
  displayMotivations: Le.array,
  headingText: Le.string,
  showHeading: Le.bool,
  showMoreSettings: Le.object
};
export {
  jF as Annotations,
  BF as AutoAdvanceToggle,
  UI as IIIFPlayer,
  vF as MediaPlayer,
  MF as MetadataDisplay,
  _F as StructuredNavigation,
  KF as SupplementalFiles,
  NF as Transcript
};
